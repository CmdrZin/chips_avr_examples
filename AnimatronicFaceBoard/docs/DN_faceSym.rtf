{\rtf1\ansi\ansicpg1252\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fswiss\fprq2\fcharset0 Arial;}{\f2\fnil\fprq2\fcharset0 Tahoma;}{\f3\fnil\fcharset0 Courier;}{\f4\fnil\fcharset0 Courier New;}}
{\*\generator Riched20 10.0.16299}\viewkind4\uc1 
\pard\sl240\slmult1\f0\fs22\lang9 DN_faceSym.rtf\par
12sep16 ndp\par
09jan18\par
\par
Design Notes for Animatronics Face Board (I2C Master)\par
\par
ref1: C:\\Data\\EmbeddedSystems\\Demo Boards\\SlaveADC - Hardware\par
ref2: C:\\Data\\EmbeddedSystems\\Robotics\\Animatronics\\FaceBoard - Software I2C Master\par
ref3: C:\\Data\\EmbeddedSystems\\Robotics\\Animatronics\\I2CADCSlave - Software I2C ADC Slave\par
ref3: DN_MultiServoCtrl.rtf\par
ref4: LCD_16100_CP - Shortcut to LCD display board\par
\par
TODO:\par
\strike Change sysTimer.c,.h to use millis() function.\par
\strike0 Serial support\par
\strike I2C 16 servo controller support\par
\strike0 MOD: Build a Master with an ATmega1284. 16k bytes of RAM since I fogot to add and I2C EEPROM on board!\par
Could use the LCD one though. Use ATmega164P for now.\par
\tab ATMEGA1284-PU-ND\tab IC MCU 8BIT 128KB FLASH 40DIP\tab 5.250\par
MOD: Use \f1\fs20 18.4320 MHz crystal for exact baud 115.2k.\f2\par
\f0\fs22\par
\par
The Face Board allows programming sequences for a 16 servo facial animation demonstration.\par
It uses 10 sliding pots and 6 rotating pot to control 10 linear servos and 6 ratational servo respectively.\par
An 8 channel ADC I2C Slave board and an 8 channel ADC I2C Master board  are used to read the pots. \par
The I2C master provides USB serial to the host computer. It also controls the 16 channel servo controller \par
board and LCD plus buttons and LEDs display board.\par
\par
Using Atmel Studio 7.0\par
Target: ATmega164P @ 20 MHz\par
\par
SYSTEM CONTROL\par
IDLE\tab\tab - Banner and other setups\par
RUN\tab\tab - Run animation sequence\par
MANUAL\tab - Tie Servos to Pots\par
MENU\tab\tab - Run Options Setting menu\par
\par
\par
Data Storage\par
typedef servoData enum \{\par
\tab uint32_t timeStamp;\tab\tab // 20ms steps. Maximum update rate. THIS can be 16bit.\par
\tab uint8_t\tab servo[16];\par
\} SERVO_DATA;\par
SERVO_DATA\tab servoPos[64];\tab\tab // 20 bytes per entry -> 1280 bytes.\par
\par
Initial Program [state = PRGM]\par
Display "READY" and light Yellow LED.\par
Continually sample ADC and Slave ADC and request Buttons.\par
When Yellow is pressed, record current positions to array with timesstamp = lasttimestamp+1000\par
Repeat until Red is pressed. Display number of frames. Turn OFF Yellow LED. Light Green LED.\par
When Green is pressed, play through frames showing the frame number updating.\par
At the end, display "READY" and repeat loop.\par
\par
Menu mode [state = MENU]\par
\f3\tab " <   MANUAL   > "\par
\f0 GREEN: <\par
YELLOW: >\par
RED: Select <MODE name>\par
Servos are idle in Menu Mode.\par
\par
MODEs:\par
MANUAL: Pots directly control servos\par
\f3\tab "      EXIT      "\par
\f0 PROGRAM: Enter programing mode to generate Key Frames.\par
\f3\tab "REC   EXIT  #:XX"\par
\f0\tab GREEN: Record\tab\tab RED: Exit\tab\par
RUN: Run stored sequence generated by Program mode. In LOOP, one second pause after run.\par
\f3\tab "ONCE  EXIT  LOOP"\par
\f0\tab GREEN: Once\tab\tab RED: Exit\tab YELLOW: Loop\par
ERASE: Erase stored sequence.\par
\f3\tab "DONE  EXIT      "\par
\f0\tab\tab\tab\tab RED: Exit\par
STEP: Step throught stored sequence.\par
\f3\tab "STEP  EXIT      "\par
\f0\tab GREEN: Step\tab\tab RED: Exit\par
FRAME TIME: Set delay between Key Frames. 30ms to 1000ms. RED:Exit\par
\f3\tab "INC  0000ms  DEC"\par
\f0\tab GREEN: Inc by 1ms\tab RED: Save.Exit\tab YELLOW: Dec by 1ms\par
\tab Inc/Dec run faster if held down.\par
ZERO: Set all servos to CENTER position.\par
\tab Has no menu.\par
\par
PROGRAM Process\par
static uint8_t x\par
if Button & GREEN == GREEN and x < MAX_FRAMES\par
  Record adc_data[0:15] into servoPos[x].servo[0:15] when GREEN pressed and inc x and display.\par
if Button & RED == RED then EXIT to MENU_INIT.\par
\par
RUN Process\par
MAX_FRAMES  8\tab // size of arrary or as a variable set during PROGRAM process\par
servoPos[] has an entry for each Frame: servoPos[0:N].timeStamp and servoPos[0:N].servo[0:15]\par
\par
RUN.Init\par
Set runIndex = 0\par
Set runStartTime = millis()\par
print("\f4 ONCE  EXIT  LOOP\f0 ", index, 16)\par
RUN Menu service\par
\tab if getButton() == GREEN then runLoop = false. mss_state = MSS_RUN\par
\tab if getButton() == YELLOW then runLoop = true. mss_state = MSS_RUN\par
\tab if getButton() == RED then runLoop = false. mss_state = MSS_MENU\par
\par
RUN.service\par
frameTime = millis() - runStartTime\par
if(frameTime => servoPos[runIndex].timeStamp )\tab\tab // are we there yet?\par
\tab // Update servos\par
\tab for(int i=0; i<16; i++)\par
\tab\tab send servoPos[index].servo[i] to servo i\par
\tab print("\f4 FRAME: %2d      \f0 ", runIndex, 16)\par
NOTE: When building the servoPos array, the timeStamp starts at 0 and F-Time is added to each step.\par
if Button != 0 then mss_state = MSS_MENU and EXIT\tab\tab // Press ANY button to STOP.\par
if(++index > MAX_FRAMES)\par
\tab if(runLoop = true)\par
\tab\tab mss_state = MSS_RUN_INIT\par
\tab\tab Set runIndex = 0\par
\tab\tab Set runStartTime = millis()\par
CAUTION: Large movements can occur if LAST and FIRST frames are not similar.\par
\tab else\par
\tab\tab mss_State = MSS_MENU\par
\par
SERIAL API (I2C MASTER)\par
I2C Slave ADC:  0x32\par
The Slave ADC is used as a DAC for the slider pots.\par
Optional DIO and external LED control are not active.\par
I2C Slave API\par
SDA_W N\tab\tab\tab N = 0x00 -> 0x07\par
\tab Read ADC channel N.\par
SDA_R\tab DataN\par
\par
SDA_W\tab 0x08\par
\tab Read all ADC channels.\par
SDA_R\tab CH0 CH1 ... CH7\par
\par
SDA_W\tab 0xF8\par
\tab Read build date\par
SDA_R\tab 11 bytes of data\par
\par
SDA_W\tab 0xF9\par
\tab Read build time\par
SDA_R\tab 8 bytes of data\par
\par
SDA_W\tab 0xFA\par
\tab Read build version\par
SDA_R\tab 4 bytes of data\par
\par
I2C Slave LCD:  0x5E\par
The LCD Display board provides an 16x1 LCD display, three push buttons, and three LEDs (RGY).\par
The CAPTURE button (RED) will record the current settings of all the pots and add this snap-shot \par
to the current list. The PLAY button will cycle through the current list of snap-shots.\par
A MENU button (YELLOW) brings up a menu to set timing, transistion modes, and other sequence \par
parameters. In MENU MODE (YELLOW LED ON), the GREEN button is SELECT and the RED is SCROLL.\par
The START button (GREEN) will Start/Stop the selected animation sequence.\par

\pard\sl240\slmult1\tx540 I2C Slave LCD API\par
SDA_R\tab\par
\tab Reads last register selected or default status register 0x00 on start up.\par
\tab Last register seleced will remain selected until another SDA_W occurs.\par
\par
SDA_W 0x00 DATA\par
\tab Write DATA to control register 0x00. Select register 0x00 to read.\par
\par
SDA_W 0x01\par
\tab Select register 0x01 (Buttons) to read. 00000YRG.\par
\tab SDA_R returns the history of the buttons. 1:Has been pressed since last read, else 0. Reset to 0 after read.\par
\par
SDA_W 0x02\par
\tab Select register 0x02 (Raw Button States) to read. Captures the state of the button at this time.  00000YRG.\par
\tab SDA_R returns the captured state of the buttons. 1:Was pressed at the time, else 0.\par
\par
SDA_W 0x03\par
\tab Select the last ADC capture. ADC is in auto-sample at 15kHz. Data is 8bit unipolar left shifted.\par
\par
SDA_W 0x10 LEN D[0] ... D[N]\par
\tab Write LEN characters to line starting at left most position P[0]. N < 16.\par
\par
SDA_W 0x11 LEN POS D[0] ... D[N]\par
\tab Write LEN characters to line starting at P[POS] where p[0] is the left most position. N < (16-POS).\par
\par
SDA_W 0x20 STATE\par
\tab Write STATE (OFF:0, ON:1) to GREEN LED control.\par
\par
SDA_W 0x21 STATE\par
\tab Write STATE (OFF:0, ON:1) to RED LED control.\par
\par
SDA_W 0x22 STATE\par
\tab Write STATE (OFF:0, ON:1) to YELLOW LED control.\par

\pard\sl240\slmult1\par
\par
I2C Servo Controller: 0x40\par
I2C Servo Controller API\par
SDA_W 6+(CHAN<<2)      DOnL\tab\tab CHAN: 0:15\par
SDA_W 6+(CHAN<<2)+1 DOnH\par
SDA_W 6+(CHAN<<2)+2 DOffL\par
SDA_W 6+(CHAN<<2)+3 DOffH\par
\par
\par
Audio API (mod_audio.h)\par
PWM is 8-bit @ 12.8us [78.125kHz] (20MHz/256)\par
\f4 ma_tone( uint16_t freq, uint16_t duration );\tab // play sin wave tone.\par
\f0 freq from table or defines (use f * 0.8) ..duration in ms..\par
\par
\par
LCD API (mod_stdio.h)\par
(see DN_LCD_16100_CP.rtf)\par
\par
Data Handling Redux\par
Store raw ADC data as uint8_t.\par
\tab data = 0 : 255\par
When moved to currentADC[], save as uint8_t.\par
\tab char currentADC[x] = rawADC;\par
To send to servo, convert to uint16_t.\par
\tab CENTER = 0x0133\par
\tab uint16_t servo = (uint16_t)((int)CENTER + (int)currentADC[x]) - 128\par
\par
\par
\par
\par
}
 
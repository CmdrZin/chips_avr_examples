LN_BootloaderSlave.txt
22jan17 ndp
17mar17

ref1: Atmel AVR112: TWI Bootloader for devices without boot section
ref2: I2C_Bootloader_Layout.pdf - Diagram of test connections. (see[1]Fig 1-1)
ref3: AVR911_AVR OS Programmer.pdf - PC AVROSP app note.
ref4: ATtiny25-45-85_Datasheet.pdf
ref5: LN_BootloaderMaster.txt

Plan 0: Straight port to AS 7.0 with minor clean up to build.
Slave Target is ATtiny85, which code supports.

Slave I2C Address: 0x58 (0xb0)


Set up Atmel Studio 7.0 TWI_Slave_7_0 project in
	\Bootloader\PortOrgAVR112\TWI_Slave_7_0
..ok..set Device to ATtiny85..
Add docs folder..ok..save this doc there..
Copy files from AV112.zip archive TWI_Slave:
TWI_Slave.c
USI_TWI_Slave.c,.h
Common_Define.h
Add to project and remove (not delete) main.c file..
MOD: TWI_Slave.c
Replace
	#include <inavr.h>
with
#include <avr/io.h>
Comment out extra headers
//#include "stdint.h"
//#include <inavr.h>
Slave address is SDA_R+0x30 = 0xb0..ok.
ADD: delay_cycles( uint16_t delay ) function to replace __delay_cycles()..
MOD: main()..replace void with int..
Replace
//__no_init uint8_t pageBuffer[PAGE_SIZE];
uint8_t pageBuffer[PAGE_SIZE] __attribute__ ((section (".noinit")));
Move into TWI_Slave.c..hmm..try adding
#include <avr/io.h>
to Common_Defines.h..
MOD: Common_Defines.h
Replace __ATTINY with __AVR_ATtiny
Replace __ATMEGA with __AVR_ATmega
better..SELFPROGEN..hmm..check ATtiny85 datasheet for SPM register..
hmm..no status bit..
[4]Section 20.3.1
ATtiny85 signature bytes: 0x1E 0x93 0x0B
oops, missed a TINY to tiny replace..fix..ok now..
flash access issues..
MOD: TWI_Slave - add
#include <avr/pgmspace.h>
replace __load_program_memory() with pgm_read_byte()
MOD: Common)Defines.h - comment out _BV..ok..
MOD: USI_TWI_Slave.h
Replace __ATTINY with __AVR_ATtiny
EECR has no EEWE flag..hmm..check[4]..[4]5.3.5 uses EEPE to test..fix..
MOD: TWI_Slave.c
Replace __ATTINY with __AVR_ATtiny
Replace __ATMEGA with __AVR_ATmega
MOD: USI_TWI_Slave
move bufferPtr and Value into USI_TWI_SLAVE_Process_Overflow_Condition()..
Add extern uint8_t pageBuffer[PAGE_SIZE] __attribute__ ((section (".noinit")));
Comment out used variables..
Add #include <avr/interrupt.h>
MOD: TWI_Slave.c
Replace USI_OVF_vect with USI_OVF_vect_num..
_SPM_ERASE()..replace with spm_erase()[4]Section 19.1 ..ok..
Comment out data write of 0s..ok..
__SPM_FILLTEMP()..replace with spm_filltemp()..ok..
__SPM_PAGEWRITE()..replace with spm_pagewrite()..
NOTE: "The temporary buffer will auto-erase after a Page Write operation or by
 * writing the CTPB bit in SPMCSR."..so DataToR0ByteToSPMCR_SPM() not needed..ok..
add the do_spm()..ok..build..woot..now try it..
Program ATtiny85..install on Slave protoboard..hook up board to board wires..
CD to AVROSP.exe directory..change port to COM5, 38400, 8N1
>mode com5 baud=38400 parity=n data=8
>avrosp -s -cCOM5
returns : 0x1e 0x98 0x01 the signature bytes in the Master..com is up.
>avrosp -dATtiny85 -pf -vf -ifDemoApp1.hex -cCOM5
hmm..can't find XML file..not generated by build..after an hour or so..
http://www.avrfreaks.net/forum/xml-files-studio-7..says they are in
  \Atmel\Studio\7.0\packs\atmel\ATtiny_DFP\1.0.79\atdf\ATtiny85.atdf
rename to .xml and save to aavrops.exe directory..hmm..AVRPART not found..
d/l Atmel Studio 4.19 and install..may have files in correct format..
got farther..sig bytes not matched..change SIGBYTES in Master to 
ATtiny85 signature bytes: 0x1E 0x93 0x0B
and recompile Master..try again..hmm..almost working. COM port time out part 
way through..try increasing baud to 115k on master..oops. redo.
>mode com5 baud=115200 parity=n data=8
hmm..time out again..
Error Message:
Found AVRBOOT on COM5!
Entering programming mode...
Parsing XML file for device parameters...
Parsing '.\ATtiny85.xml'...
#######
Saving cached XML parameters...
Signature matches device!
Reading HEX input file for flash operations...
##########
Programming Flash contents...
Using block mode...
#
An error occurred:
  [Timeout during COM-port read operation!]
oh well..time to debug..check I2C lines for lock-up..
SDA never goes high, SCL starts low. Both should be high..
MOD: InitTWI - comment out IO set up..nope..
MOD:TWMI_Master.c - use my TWI settings for 20 MHz..blah..call send to 
test I2C..hmm..
ADD: mod_led.c,.h for debugging..DOH..no pullups on I2C..FIX..lots now, but all 
SDA_R actions..SCL at 100kHz..ok. Hung up is request for Slave status..
Slave may not be programmed right..
First off, need to set text Origin at 0x1800..size is 1094 bytes. need 2k.
Toolchain > AVR/GNU Linker > Memory Settngs > Flash segment add
--section-start=.text=0x1800
build and check map and .hex files..hmm..try 0x1000..also
Toolchain > AVR/GNU Linker > General .. (-Wl, -s)..hmm..remove and check 
map and .hex files..at 0x0000..try FLASH: .text=0x1800 ..hmm..link cmd clue..
try FLASH segment: .text=0x0c00..ah, builds now in right place..review code.
looks ok..program it..still NAK on SDA_R read..time for LED debug on Slave..
23jan17
Wire up AT84_85_2313 demo board as I2C Slave. No RESET or BOOT_EN connections.
Add mod_led.c,h to TWI_Slave project for debug on demo board.
MOD: mod_led.h - Set LED to PB1.
Add a toggle function. mod_toggle(uint8_t val).
MOD: USI_TWI_Slave.h - fix defines for ATtiny85.
try loader..still timeout..
Side track: Make an ATtiny85 demo .hex file..DemoApp1_ATtiny85.hex
>mode com5 baud=115200 parity=n data=8
>avrosp -dATtiny85 -pf -vf -ifDemoApp1_ATtiny85.hex -cCOM5
blah..need RESET and BOOT_EN..move back to protoboard..
hmm..0x0000 reset vector not set to jump to 0x1800 (0x0C00)..

From: http://stackoverflow.com/questions/13055866/attiny-and-linux-avr-gcc-interrupt-reset-vector-in-linker/13075026
-Wl,--section-start=.bootreset=0x00
uint16_t boot_reset __attribute__((section(".bootreset"))) = 0xC000U + 0x1800 / 2 - 1;
To have this custom sections added on the hex, just -j .bootreset on avr-objcopy.

From: https://web.stanford.edu/class/ee281/materials/references/avr-lib-beta.pdf
The reset vector is set to jump to location _init_. _init_ is defined to be a
“weak” symbol, which means that if the application doesn’t define it, the linker 
will use the value from the library (or module). The start-up module defines
_init_ to be the same location as _real_init_. If you want to add some custom 
code that gets executed right out of a reset, name your routine _init_. Just 
make sure you jump to _real_init_ at the end of your custom code.

void _real_init_(void);
void _init_(void) __attribute__((naked));
void _init_(void)
{
  /* This must be the last line of the function. */
  asm ( "rjmp _real_init_" );
}

From: http://www.nongnu.org/avr-libc/user-manual/FAQ.html#faq_reloc_code - Notes.
#define BOOTLOADER_SECTION    __attribute__ ((section (".bootloader")))

So,
MOD: Toolchain > ... > FLASH segment .. .bootloader=0x0C00
ADD: sysdefs.h - add def
#define BOOTLOADER_SECTION    __attribute__ ((section (".bootloader")))
add to top files..change all prototypes to use BOOTLOADER_SECTION attrib.
MOD: TWI_Slave.c - mskr prototypes for all functions and add B_S attrib..
not going to work..vectors don't move..back to .text=0x0c00..
Idea: add a .s file with ORG 0 and DB BL, BH addesses..
FLASH segment:
.bootvec=0x0000
.text=0x0C00
ADD: bootvec.s file
 .segment .bootvec
	.word		INTVECT_PAGE_ADDRESS
builds..hex looks right..try it..ignores .S file..back to square one..

Other finds:
http://msoe.us/taylor/tutorial/ce2810/candasm - some C + ASM tutorials
https://sourceware.org/binutils/docs-2.27/as/index.html - ASM in C manual
http://www.embedded-creations.com/projects/attiny85-usb-bootloader-overview/
d/l code for usb boot for ref..ok.
https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_mono/ld.html - -e flag..try it.
-e __vectors

>cd C:\Data\EmbeddedSystems\I2C_Slave_Boards\Bootloader\PortOrgAVR112\Support
>mode com5 baud=115200 parity=n data=8
>avrosp -dATtiny85 -pf -vf -ifDemoApp1_ATtiny85.hex -cCOM5
HAH..runs code now. Doesn't work yet, but it resets to 0x1800 code area..
it's a start.
24jan17
well, sort of. Seems its just running through the NOPs to get to 0x1800..
need to effectively put :0200000016CC1C in the HEX or get FLASH address 0x0000 set to 0x16CC.
IDEA: The first thing the Bootloader does is write FLASH 0x0000 with 0x16CC, 
but save the rest of the 0 Page code.
In main(), Read Page 0, alter bytes 0 & 1, Write Page 0.
try it..hmm..try setting SELFPRGEN fuse..YES. Flash readback shows changes..
minor problem..MSB is 00..hmm..ah..C call messing up R1..do spm's in ASM..
hmm..have to use STS/LDS instead of OUT/IN for some registers..
build..FIXed it..0000: is now FF CB ..ok.. try it..
hmm..so now, why no ACK?..tweak boot pin chk to force run..ok..getting there..
still NAK..
MOD: USI_TWI_Slave.c - address compare bug?..don't see how this USI ever worked..
Save as snapshot..rev 167..
Now, for a big rewrite to get USI_TWI working.
1. Remove all TWI ref code. Any device with TWI is big enough to support BOOT.
25jan17
Make a simple tester..ok.sends SDA_R every 5ms..
NOTE: SDA_W (0)	SDA_R (1)	check this..yup. backwards..fix..add mod_led.c,.h 
to usiTwiSlaveNI for testing..
30jan17
NOTE: TODO - For verify, save 0x0000 RESET Vector bytes. Insert when Page 0 is read.

NOTE: ATtiny85 on Demo board is programmed with usiTwiSlaveNI code.
\EmbeddedSystems\USI_I2C_Slave_NonIntr\usiTwiSlaveNI

12mar17
Should be able to use I2C from Master to Slave now since usiTwiSlaveNI used..ok.
First things first. [5]Get master to send SDA_R and get an ACK and return a byte..works.
13mar17
TODO	Use usiTwiSlaveNI[6] code to replace crap from AN112 code.
Remove _TWI_ code since never used and enable _USI_ since always used..sheesh..
all processing if USI moved to USI_TWI_Slave..blah..and remove Boot Enable code..
builds..ok..add usiTwi code files..builds..ok..commit..rev 209.
14mar17
review flow..link main() to usiTwi code..blah..create a new main.c..
NEW: main.c - start from scratch to replace TWI_Slave.c ..
ADD: polled timer support..copy support utilities..add initial command 
processing..build..ok..commit rev 210.
try it..NAK on I2C read after Block recieved on Serial..fix LED bug..fix time bug..ok.
might help to call uts_init()..doh..ok, getting a 0x00 on first SLA_R read..
So, PC -> A 0000 B 0040 F [64]bytes and Master does one SLA_R, 
then PC -> A 0020 B 0020 F [32]bytes (rest of the hex file) then b and waits.
Back to the Master..fixed..sending both pages to Slave now and PC asking for readback..
TODO Master: Implement 'g' command.
Sort of working..commit rev 211
15mar17
ADD: commands.h file
16mar16
Address is now WORD address..check Read data..fix logic..ok..still 00..DOH..
misread RxFifo..fix..try..hmm..W 03 40 R then..cmd but not rest of it..ah, missing break; 
..fix..ok..getting programmed page 0 AND retains BootReset..
back to Master..ok..need to restore App reset bytes..convert to byte address..
WOOT..verified to 0x40..fix..TA DA!!!!..programmed and verified..commit rev 212
TODO: Jump to App after programming.
17mar17
EXTRAS TODO: Put I2C address in EEPROM and highjack an AVROSP command to set it.
Code cleanup..
main.c - remove led toggles..
TWI_Slave.c - remove
USI_TWI_Slave.c,.h - remove
build..1358 bytes..reprogram and test..ok..passes..commit after Master code cleanup..
rev 214
14apr17
MOD: main.c - added 'jump to app' if no comms within 10 sec after reset and 
there is an app loaded.
test it..open terminal CLI..
>cd C:\Data\EmbeddedSystems\I2C_Slave_Boards\Bootloader\PortOrgAVR112\Support
>mode com5 baud=115200 parity=n data=8
>avrosp -dATtiny85 -pf -vf -ifDemoApp2_I2C_AT85.hex -cCOM5
hmm..reset vector bytes not matching..Set SELFPRGEN fuse..no errors..check 
image..YES..try Arduino as master, wait 10 seconds, then run..hmm..seems to 
stay in bootloader...put in some flashing LED code..3:call app, 5:in boot..
hmm..check start location of app..blew out mkII..not polling in wait??..DOH..
fix..can't program though..no ISP..
29apr17
Get latest..build Slave..program. Use Bootloader to load App2.
>cd C:\Data\EmbeddedSystems\I2C_Slave_Boards\Bootloader\PortOrgAVR112\Support
>mode com3 baud=115200 parity=n data=8
>avrosp -dATtiny85 -pf -vf -ifDemoApp2_I2C_AT85.hex -cCOM3
Need to run CLI as Admin if on Windows 10..ok..works. 20 sec LED, then off.
Try with Arduino. Slave=0x40. hmm. Try direct programming of Slave with App2.
hmm..set up Saleae pod..fix app2..tested..still not leaving bootloader..
put blinks in to debug..if any I2C comm (0x58) exit Boot, try this before 
reprogramming..Chg Arduino to use 0x58 one write only..nope..change logic to 
1. Run App if no I2C comm in 20sec AND there is an App.
2. If Bootloader is address during the 20sec window, Bootloader is entered OR if 
no App code.
reprogram..blink(5) after 20sec..ok..try to load App2a..
cd C:\Data\EmbeddedSystems\I2C_Slave_Boards\Bootloader\PortOrgAVR112\Support
mode com3 baud=115200 parity=n data=8
avrosp -dATtiny85 -pf -vf -ifDemoApp2a_I2C_AT85.hex -cCOM3
ok, got 3 blinks..try Arduino..hmm, not the right jump point?..going to 001E, 
check App2a code..looks like 000F is the place..try that..nothin now..check 
images in Flash..hmm, Bootjump is 0000, no written..add a resetBootReset just 
before App jump..reprog..d/l App2a..try Arduino test..WOOT, Up and running.
Commit..











<?xml version="1.0"?>
<AVRPART>
  <MODULE_LIST>[ADMIN:CORE:INTERRUPT_VECTOR:MEMORY:PACKAGE:FUSE:LOCKBIT:PROGRAMMING:IO_MODULE:ICE_SETTINGS]</MODULE_LIST>
  <ADMIN>
    <PART_NAME>ATtiny26</PART_NAME>
    <SPEED>16MHZ</SPEED>
    <BUILD>257</BUILD>
    <RELEASE_STATUS>RELEASED</RELEASE_STATUS>
    <SIGNATURE>
      <ADDR000>$1E</ADDR000>
      <ADDR001>$91</ADDR001>
      <ADDR002>$09</ADDR002>
    </SIGNATURE>
  </ADMIN>
  <CORE>
    <CORE_VERSION>V1</CORE_VERSION>
    <ID>AVRSimCoreV1.SimCoreV1</ID>
    <NEW_INSTRUCTIONS>[lpm rd,z]</NEW_INSTRUCTIONS>
    <INSTRUCTIONS_NOT_SUPPORTED>[]</INSTRUCTIONS_NOT_SUPPORTED>
    <RAMP_REGISTERS>[0x0023:0x0034:0x0054]</RAMP_REGISTERS>
    <GP_REG_FILE>
      <NMB_REG>32</NMB_REG>
      <START_ADDR>$00</START_ADDR>
      <X_REG_HIGH>$1B</X_REG_HIGH>
      <X_REG_LOW>$1A</X_REG_LOW>
      <Y_REG_HIGH>$1D</Y_REG_HIGH>
      <Y_REG_LOW>$1C</Y_REG_LOW>
      <Z_REG_HIGH>$1F</Z_REG_HIGH>
      <Z_REG_LOW>$1E</Z_REG_LOW>
    </GP_REG_FILE>
  </CORE>
  <INTERRUPT_VECTOR>
    <NMB_VECTORS>12</NMB_VECTORS>
    <VECTOR1>
      <PROGRAM_ADDRESS>$000</PROGRAM_ADDRESS>
      <SOURCE>RESET</SOURCE>
      <DEFINITION>External Reset, Power-on Reset and Watchdog Reset</DEFINITION>
    </VECTOR1>
    <VECTOR2>
      <PROGRAM_ADDRESS>$001</PROGRAM_ADDRESS>
      <SOURCE>INT0</SOURCE>
      <DEFINITION>External Interrupt 0</DEFINITION>
    </VECTOR2>
    <VECTOR3>
      <PROGRAM_ADDRESS>$002</PROGRAM_ADDRESS>
      <SOURCE>I/O_PINS</SOURCE>
      <DEFINITION>External Interrupt Request 0</DEFINITION>
    </VECTOR3>
    <VECTOR4>
      <PROGRAM_ADDRESS>$003</PROGRAM_ADDRESS>
      <SOURCE>TIMER1,CMPA</SOURCE>
      <DEFINITION>Timer/Counter1 Compare Match 1A</DEFINITION>
    </VECTOR4>
    <VECTOR5>
      <PROGRAM_ADDRESS>$004</PROGRAM_ADDRESS>
      <SOURCE>TIMER1,CMPB</SOURCE>
      <DEFINITION>Timer/Counter1 Compare Match 1B</DEFINITION>
    </VECTOR5>
    <VECTOR6>
      <PROGRAM_ADDRESS>$005</PROGRAM_ADDRESS>
      <SOURCE>TIMER1,OVF1</SOURCE>
      <DEFINITION>Timer/Counter1 Overflow</DEFINITION>
    </VECTOR6>
    <VECTOR7>
      <PROGRAM_ADDRESS>$006</PROGRAM_ADDRESS>
      <SOURCE>TIMER0,OVF0</SOURCE>
      <DEFINITION>Timer/Counter0 Overflow</DEFINITION>
    </VECTOR7>
    <VECTOR8>
      <PROGRAM_ADDRESS>$007</PROGRAM_ADDRESS>
      <SOURCE>USI_STRT</SOURCE>
      <DEFINITION>USI Start</DEFINITION>
    </VECTOR8>
    <VECTOR9>
      <PROGRAM_ADDRESS>$008</PROGRAM_ADDRESS>
      <SOURCE>USI_OVF</SOURCE>
      <DEFINITION>USI Overflow</DEFINITION>
    </VECTOR9>
    <VECTOR10>
      <PROGRAM_ADDRESS>$009</PROGRAM_ADDRESS>
      <SOURCE>EE_RDY</SOURCE>
      <DEFINITION>EEPROM Ready</DEFINITION>
    </VECTOR10>
    <VECTOR11>
      <PROGRAM_ADDRESS>$00A</PROGRAM_ADDRESS>
      <SOURCE>ANA_COMP</SOURCE>
      <DEFINITION>Analog Comparator</DEFINITION>
    </VECTOR11>
    <VECTOR12>
      <PROGRAM_ADDRESS>$00B</PROGRAM_ADDRESS>
      <SOURCE>ADC</SOURCE>
      <DEFINITION>ADC Conversion Complete</DEFINITION>
    </VECTOR12>
  </INTERRUPT_VECTOR>
  <MEMORY>
    <ID>AVRSimMemory8bit.SimMemory8bit</ID>
    <PROG_FLASH>2048</PROG_FLASH>
    <EEPROM>128</EEPROM>
    <INT_SRAM>
      <SIZE>128</SIZE>
      <START_ADDR>$60</START_ADDR>
    </INT_SRAM>
    <EXT_SRAM>
      <SIZE>0</SIZE>
      <START_ADDR>NA</START_ADDR>
    </EXT_SRAM>
    <IO_MEMORY>
      <IO_START_ADDR>$00</IO_START_ADDR>
      <IO_STOP_ADDR>$3F</IO_STOP_ADDR>
      <EXT_IO_START_ADDR>NA</EXT_IO_START_ADDR>
      <EXT_IO_STOP_ADDR>NA</EXT_IO_STOP_ADDR>
      <MEM_START_ADDR>$20</MEM_START_ADDR>
      <MEM_STOP_ADDR>$5F</MEM_STOP_ADDR>
      <SREG>
        <IO_ADDR>$3F</IO_ADDR>
        <MEM_ADDR>$5F</MEM_ADDR>
        <C_MASK>0x01</C_MASK>
        <Z_MASK>0x02</Z_MASK>
        <N_MASK>0x04</N_MASK>
        <V_MASK>0x08</V_MASK>
        <S_MASK>0x10</S_MASK>
        <H_MASK>0x20</H_MASK>
        <T_MASK>0x40</T_MASK>
        <I_MASK>0x80</I_MASK>
      </SREG>
      <SP>
        <IO_ADDR>$3D</IO_ADDR>
        <MEM_ADDR>$5D</MEM_ADDR>
        <SP0_MASK>0x01</SP0_MASK>
        <SP1_MASK>0x02</SP1_MASK>
        <SP2_MASK>0x04</SP2_MASK>
        <SP3_MASK>0x08</SP3_MASK>
        <SP4_MASK>0x10</SP4_MASK>
        <SP5_MASK>0x20</SP5_MASK>
        <SP6_MASK>0x40</SP6_MASK>
        <SP7_MASK>0x80</SP7_MASK>
      </SP>
      <GIMSK>
        <IO_ADDR>$3B</IO_ADDR>
        <MEM_ADDR>$5B</MEM_ADDR>
        <PCIE0_MASK>0x10</PCIE0_MASK>
        <PCIE1_MASK>0x20</PCIE1_MASK>
        <INT0_MASK>0x40</INT0_MASK>
      </GIMSK>
      <GIFR>
        <IO_ADDR>$3A</IO_ADDR>
        <MEM_ADDR>$5A</MEM_ADDR>
        <PCIF_MASK>0x20</PCIF_MASK>
        <INTF0_MASK>0x40</INTF0_MASK>
      </GIFR>
      <TIMSK>
        <IO_ADDR>$39</IO_ADDR>
        <MEM_ADDR>$59</MEM_ADDR>
        <TOIE0_MASK>0x02</TOIE0_MASK>
        <TOIE1_MASK>0x04</TOIE1_MASK>
        <OCIE1B_MASK>0x20</OCIE1B_MASK>
        <OCIE1A_MASK>0x40</OCIE1A_MASK>
      </TIMSK>
      <TIFR>
        <IO_ADDR>$38</IO_ADDR>
        <MEM_ADDR>$58</MEM_ADDR>
        <TOV0_MASK>0x02</TOV0_MASK>
        <TOV1_MASK>0x04</TOV1_MASK>
        <OCF1B_MASK>0x20</OCF1B_MASK>
        <OCF1A_MASK>0x40</OCF1A_MASK>
      </TIFR>
      <MCUCR>
        <IO_ADDR>$35</IO_ADDR>
        <MEM_ADDR>$55</MEM_ADDR>
        <ISC00_MASK>0x01</ISC00_MASK>
        <ISC01_MASK>0x02</ISC01_MASK>
        <SM0_MASK>0x08</SM0_MASK>
        <SM1_MASK>0x10</SM1_MASK>
        <SE_MASK>0x20</SE_MASK>
        <PUD_MASK>0x40</PUD_MASK>
      </MCUCR>
      <MCUSR>
        <IO_ADDR>$34</IO_ADDR>
        <MEM_ADDR>$54</MEM_ADDR>
        <PORF_MASK>0x01</PORF_MASK>
        <EXTRF_MASK>0x02</EXTRF_MASK>
        <BORF_MASK>0x04</BORF_MASK>
        <WDRF_MASK>0x08</WDRF_MASK>
      </MCUSR>
      <TCCR0>
        <IO_ADDR>$33</IO_ADDR>
        <MEM_ADDR>$53</MEM_ADDR>
        <CS00_MASK>0x01</CS00_MASK>
        <CS01_MASK>0x02</CS01_MASK>
        <CS02_MASK>0x04</CS02_MASK>
        <PSR0_MASK>0x08</PSR0_MASK>
      </TCCR0>
      <TCNT0>
        <IO_ADDR>$32</IO_ADDR>
        <MEM_ADDR>$52</MEM_ADDR>
        <TCNT00_MASK>0x01</TCNT00_MASK>
        <TCNT01_MASK>0x02</TCNT01_MASK>
        <TCNT02_MASK>0x04</TCNT02_MASK>
        <TCNT03_MASK>0x08</TCNT03_MASK>
        <TCNT04_MASK>0x10</TCNT04_MASK>
        <TCNT05_MASK>0x20</TCNT05_MASK>
        <TCNT06_MASK>0x40</TCNT06_MASK>
        <TCNT07_MASK>0x80</TCNT07_MASK>
      </TCNT0>
      <OSCCAL>
        <IO_ADDR>$31</IO_ADDR>
        <MEM_ADDR>$51</MEM_ADDR>
        <CAL0_MASK>0x01</CAL0_MASK>
        <CAL1_MASK>0x02</CAL1_MASK>
        <CAL2_MASK>0x04</CAL2_MASK>
        <CAL3_MASK>0x08</CAL3_MASK>
        <CAL4_MASK>0x10</CAL4_MASK>
        <CAL5_MASK>0x20</CAL5_MASK>
        <CAL6_MASK>0x40</CAL6_MASK>
        <CAL7_MASK>0x80</CAL7_MASK>
      </OSCCAL>
      <TCCR1A>
        <IO_ADDR>$30</IO_ADDR>
        <MEM_ADDR>$50</MEM_ADDR>
        <PWM1B_MASK>0x01</PWM1B_MASK>
        <PWM1A_MASK>0x02</PWM1A_MASK>
        <FOC1B_MASK>0x04</FOC1B_MASK>
        <FOC1A_MASK>0x08</FOC1A_MASK>
        <COM1B0_MASK>0x10</COM1B0_MASK>
        <COM1B1_MASK>0x20</COM1B1_MASK>
        <COM1A0_MASK>0x40</COM1A0_MASK>
        <COM1A1_MASK>0x80</COM1A1_MASK>
      </TCCR1A>
      <TCCR1B>
        <IO_ADDR>$2F</IO_ADDR>
        <MEM_ADDR>$4F</MEM_ADDR>
        <CS10_MASK>0x01</CS10_MASK>
        <CS11_MASK>0x02</CS11_MASK>
        <CS12_MASK>0x04</CS12_MASK>
        <CS13_MASK>0x08</CS13_MASK>
        <PSR1_MASK>0x40</PSR1_MASK>
        <CTC1_MASK>0x80</CTC1_MASK>
      </TCCR1B>
      <TCNT1>
        <IO_ADDR>$2E</IO_ADDR>
        <MEM_ADDR>$4E</MEM_ADDR>
        <TCNT1_0_MASK>0x01</TCNT1_0_MASK>
        <TCNT1_1_MASK>0x02</TCNT1_1_MASK>
        <TCNT1_2_MASK>0x04</TCNT1_2_MASK>
        <TCNT1_3_MASK>0x08</TCNT1_3_MASK>
        <TCNT1_4_MASK>0x10</TCNT1_4_MASK>
        <TCNT1_5_MASK>0x20</TCNT1_5_MASK>
        <TCNT1_6_MASK>0x40</TCNT1_6_MASK>
        <TCNT1_7_MASK>0x80</TCNT1_7_MASK>
      </TCNT1>
      <OCR1A>
        <IO_ADDR>$2D</IO_ADDR>
        <MEM_ADDR>$4D</MEM_ADDR>
        <OCR1A0_MASK>0x01</OCR1A0_MASK>
        <OCR1A1_MASK>0x02</OCR1A1_MASK>
        <OCR1A2_MASK>0x04</OCR1A2_MASK>
        <OCR1A3_MASK>0x08</OCR1A3_MASK>
        <OCR1A4_MASK>0x10</OCR1A4_MASK>
        <OCR1A5_MASK>0x20</OCR1A5_MASK>
        <OCR1A6_MASK>0x40</OCR1A6_MASK>
        <OCR1A7_MASK>0x80</OCR1A7_MASK>
      </OCR1A>
      <OCR1B>
        <IO_ADDR>$2C</IO_ADDR>
        <MEM_ADDR>$4C</MEM_ADDR>
        <OCR1B0_MASK>0x01</OCR1B0_MASK>
        <OCR1B1_MASK>0x02</OCR1B1_MASK>
        <OCR1B2_MASK>0x04</OCR1B2_MASK>
        <OCR1B3_MASK>0x08</OCR1B3_MASK>
        <OCR1B4_MASK>0x10</OCR1B4_MASK>
        <OCR1B5_MASK>0x20</OCR1B5_MASK>
        <OCR1B6_MASK>0x40</OCR1B6_MASK>
        <OCR1B7_MASK>0x80</OCR1B7_MASK>
      </OCR1B>
      <OCR1C>
        <IO_ADDR>$2B</IO_ADDR>
        <MEM_ADDR>$4B</MEM_ADDR>
        <OCR1C0_MASK>0x01</OCR1C0_MASK>
        <OCR1C1_MASK>0x02</OCR1C1_MASK>
        <OCR1C2_MASK>0x04</OCR1C2_MASK>
        <OCR1C3_MASK>0x08</OCR1C3_MASK>
        <OCR1C4_MASK>0x10</OCR1C4_MASK>
        <OCR1C5_MASK>0x20</OCR1C5_MASK>
        <OCR1C6_MASK>0x40</OCR1C6_MASK>
        <OCR1C7_MASK>0x80</OCR1C7_MASK>
      </OCR1C>
      <PLLCSR>
        <IO_ADDR>$29</IO_ADDR>
        <MEM_ADDR>$49</MEM_ADDR>
        <PLOCK_MASK>0x01</PLOCK_MASK>
        <PLLE_MASK>0x02</PLLE_MASK>
        <PCKE_MASK>0x04</PCKE_MASK>
      </PLLCSR>
      <WDTCR>
        <IO_ADDR>$21</IO_ADDR>
        <MEM_ADDR>$41</MEM_ADDR>
        <WDP0_MASK>0x01</WDP0_MASK>
        <WDP1_MASK>0x02</WDP1_MASK>
        <WDP2_MASK>0x04</WDP2_MASK>
        <WDE_MASK>0x08</WDE_MASK>
        <WDCE_MASK>0x10</WDCE_MASK>
      </WDTCR>
      <EEAR>
        <IO_ADDR>$1E</IO_ADDR>
        <MEM_ADDR>$3E</MEM_ADDR>
        <EEAR0_MASK>0x01</EEAR0_MASK>
        <EEAR1_MASK>0x02</EEAR1_MASK>
        <EEAR2_MASK>0x04</EEAR2_MASK>
        <EEAR3_MASK>0x08</EEAR3_MASK>
        <EEAR4_MASK>0x10</EEAR4_MASK>
        <EEAR5_MASK>0x20</EEAR5_MASK>
        <EEAR6_MASK>0x40</EEAR6_MASK>
      </EEAR>
      <EEDR>
        <IO_ADDR>$1D</IO_ADDR>
        <MEM_ADDR>$3D</MEM_ADDR>
        <EEDR0_MASK>0x01</EEDR0_MASK>
        <EEDR1_MASK>0x02</EEDR1_MASK>
        <EEDR2_MASK>0x04</EEDR2_MASK>
        <EEDR3_MASK>0x08</EEDR3_MASK>
        <EEDR4_MASK>0x10</EEDR4_MASK>
        <EEDR5_MASK>0x20</EEDR5_MASK>
        <EEDR6_MASK>0x40</EEDR6_MASK>
        <EEDR7_MASK>0x80</EEDR7_MASK>
      </EEDR>
      <EECR>
        <IO_ADDR>$1C</IO_ADDR>
        <MEM_ADDR>$3C</MEM_ADDR>
        <EERE_MASK>0x01</EERE_MASK>
        <EEWE_MASK>0x02</EEWE_MASK>
        <EEMWE_MASK>0x04</EEMWE_MASK>
        <EERIE_MASK>0x08</EERIE_MASK>
      </EECR>
      <PORTA>
        <IO_ADDR>$1B</IO_ADDR>
        <MEM_ADDR>$3B</MEM_ADDR>
        <PORTA0_MASK>0x01</PORTA0_MASK>
        <PORTA1_MASK>0x02</PORTA1_MASK>
        <PORTA2_MASK>0x04</PORTA2_MASK>
        <PORTA3_MASK>0x08</PORTA3_MASK>
        <PORTA4_MASK>0x10</PORTA4_MASK>
        <PORTA5_MASK>0x20</PORTA5_MASK>
        <PORTA6_MASK>0x40</PORTA6_MASK>
        <PORTA7_MASK>0x80</PORTA7_MASK>
      </PORTA>
      <DDRA>
        <IO_ADDR>$1A</IO_ADDR>
        <MEM_ADDR>$3A</MEM_ADDR>
        <DDA0_MASK>0x01</DDA0_MASK>
        <DDA1_MASK>0x02</DDA1_MASK>
        <DDA2_MASK>0x04</DDA2_MASK>
        <DDA3_MASK>0x08</DDA3_MASK>
        <DDA4_MASK>0x10</DDA4_MASK>
        <DDA5_MASK>0x20</DDA5_MASK>
        <DDA6_MASK>0x40</DDA6_MASK>
        <DDA7_MASK>0x80</DDA7_MASK>
      </DDRA>
      <PINA>
        <IO_ADDR>$19</IO_ADDR>
        <MEM_ADDR>$39</MEM_ADDR>
        <PINA0_MASK>0x01</PINA0_MASK>
        <PINA1_MASK>0x02</PINA1_MASK>
        <PINA2_MASK>0x04</PINA2_MASK>
        <PINA3_MASK>0x08</PINA3_MASK>
        <PINA4_MASK>0x10</PINA4_MASK>
        <PINA5_MASK>0x20</PINA5_MASK>
        <PINA6_MASK>0x40</PINA6_MASK>
        <PINA7_MASK>0x80</PINA7_MASK>
      </PINA>
      <PORTB>
        <IO_ADDR>$18</IO_ADDR>
        <MEM_ADDR>$38</MEM_ADDR>
        <PORTB0_MASK>0x01</PORTB0_MASK>
        <PORTB1_MASK>0x02</PORTB1_MASK>
        <PORTB2_MASK>0x04</PORTB2_MASK>
        <PORTB3_MASK>0x08</PORTB3_MASK>
        <PORTB4_MASK>0x10</PORTB4_MASK>
        <PORTB5_MASK>0x20</PORTB5_MASK>
        <PORTB6_MASK>0x40</PORTB6_MASK>
        <PORTB7_MASK>0x80</PORTB7_MASK>
      </PORTB>
      <DDRB>
        <IO_ADDR>$17</IO_ADDR>
        <MEM_ADDR>$37</MEM_ADDR>
        <DDB0_MASK>0x01</DDB0_MASK>
        <DDB1_MASK>0x02</DDB1_MASK>
        <DDB2_MASK>0x04</DDB2_MASK>
        <DDB3_MASK>0x08</DDB3_MASK>
        <DDB4_MASK>0x10</DDB4_MASK>
        <DDB5_MASK>0x20</DDB5_MASK>
        <DDB6_MASK>0x40</DDB6_MASK>
        <DDB7_MASK>0x80</DDB7_MASK>
      </DDRB>
      <PINB>
        <IO_ADDR>$16</IO_ADDR>
        <MEM_ADDR>$36</MEM_ADDR>
        <PINB0_MASK>0x01</PINB0_MASK>
        <PINB1_MASK>0x02</PINB1_MASK>
        <PINB2_MASK>0x04</PINB2_MASK>
        <PINB3_MASK>0x08</PINB3_MASK>
        <PINB4_MASK>0x10</PINB4_MASK>
        <PINB5_MASK>0x20</PINB5_MASK>
        <PINB6_MASK>0x40</PINB6_MASK>
        <PINB7_MASK>0x80</PINB7_MASK>
      </PINB>
      <USIDR>
        <IO_ADDR>$0F</IO_ADDR>
        <MEM_ADDR>$2F</MEM_ADDR>
        <USIDR0_MASK>0x01</USIDR0_MASK>
        <USIDR1_MASK>0x02</USIDR1_MASK>
        <USIDR2_MASK>0x04</USIDR2_MASK>
        <USIDR3_MASK>0x08</USIDR3_MASK>
        <USIDR4_MASK>0x10</USIDR4_MASK>
        <USIDR5_MASK>0x20</USIDR5_MASK>
        <USIDR6_MASK>0x40</USIDR6_MASK>
        <USIDR7_MASK>0x80</USIDR7_MASK>
      </USIDR>
      <USISR>
        <IO_ADDR>$0E</IO_ADDR>
        <MEM_ADDR>$2E</MEM_ADDR>
        <USICNT0_MASK>0x01</USICNT0_MASK>
        <USICNT1_MASK>0x02</USICNT1_MASK>
        <USICNT2_MASK>0x04</USICNT2_MASK>
        <USICNT3_MASK>0x08</USICNT3_MASK>
        <USIDC_MASK>0x10</USIDC_MASK>
        <USIPF_MASK>0x20</USIPF_MASK>
        <USIOIF_MASK>0x40</USIOIF_MASK>
        <USISIF_MASK>0x80</USISIF_MASK>
      </USISR>
      <USICR>
        <IO_ADDR>$0D</IO_ADDR>
        <MEM_ADDR>$2D</MEM_ADDR>
        <USITC_MASK>0x01</USITC_MASK>
        <USICLK_MASK>0x02</USICLK_MASK>
        <USICS0_MASK>0x04</USICS0_MASK>
        <USICS1_MASK>0x08</USICS1_MASK>
        <USIWM0_MASK>0x10</USIWM0_MASK>
        <USIWM1_MASK>0x20</USIWM1_MASK>
        <USIOIE_MASK>0x40</USIOIE_MASK>
        <USISIE_MASK>0x80</USISIE_MASK>
      </USICR>
      <ACSR>
        <IO_ADDR>$08</IO_ADDR>
        <MEM_ADDR>$28</MEM_ADDR>
        <ACIS0_MASK>0x01</ACIS0_MASK>
        <ACIS1_MASK>0x02</ACIS1_MASK>
        <ACME_MASK>0x04</ACME_MASK>
        <ACIE_MASK>0x08</ACIE_MASK>
        <ACI_MASK>0x10</ACI_MASK>
        <ACO_MASK>0x20</ACO_MASK>
        <ACBG_MASK>0x40</ACBG_MASK>
        <ACD_MASK>0x80</ACD_MASK>
      </ACSR>
      <ADMUX>
        <IO_ADDR>$07</IO_ADDR>
        <MEM_ADDR>$27</MEM_ADDR>
        <MUX0_MASK>0x01</MUX0_MASK>
        <MUX1_MASK>0x02</MUX1_MASK>
        <MUX2_MASK>0x04</MUX2_MASK>
        <MUX3_MASK>0x08</MUX3_MASK>
        <MUX4_MASK>0x10</MUX4_MASK>
        <ADLAR_MASK>0x20</ADLAR_MASK>
        <REFS0_MASK>0x40</REFS0_MASK>
        <REFS1_MASK>0x80</REFS1_MASK>
      </ADMUX>
      <ADCSR>
        <IO_ADDR>$06</IO_ADDR>
        <MEM_ADDR>$26</MEM_ADDR>
        <ADPS0_MASK>0x01</ADPS0_MASK>
        <ADPS1_MASK>0x02</ADPS1_MASK>
        <ADPS2_MASK>0x04</ADPS2_MASK>
        <ADIE_MASK>0x08</ADIE_MASK>
        <ADIF_MASK>0x10</ADIF_MASK>
        <ADFR_MASK>0x20</ADFR_MASK>
        <ADSC_MASK>0x40</ADSC_MASK>
        <ADEN_MASK>0x80</ADEN_MASK>
      </ADCSR>
      <ADCH>
        <IO_ADDR>$05</IO_ADDR>
        <MEM_ADDR>$25</MEM_ADDR>
        <ADCH0_MASK>0x01</ADCH0_MASK>
        <ADCH1_MASK>0x02</ADCH1_MASK>
        <ADCH2_MASK>0x04</ADCH2_MASK>
        <ADCH3_MASK>0x08</ADCH3_MASK>
        <ADCH4_MASK>0x10</ADCH4_MASK>
        <ADCH5_MASK>0x20</ADCH5_MASK>
        <ADCH6_MASK>0x40</ADCH6_MASK>
        <ADCH7_MASK>0x80</ADCH7_MASK>
      </ADCH>
      <ADCL>
        <IO_ADDR>$04</IO_ADDR>
        <MEM_ADDR>$24</MEM_ADDR>
        <ADCL0_MASK>0x01</ADCL0_MASK>
        <ADCL1_MASK>0x02</ADCL1_MASK>
        <ADCL2_MASK>0x04</ADCL2_MASK>
        <ADCL3_MASK>0x08</ADCL3_MASK>
        <ADCL4_MASK>0x10</ADCL4_MASK>
        <ADCL5_MASK>0x20</ADCL5_MASK>
        <ADCL6_MASK>0x40</ADCL6_MASK>
        <ADCL7_MASK>0x80</ADCL7_MASK>
      </ADCL>
    </IO_MEMORY>
  </MEMORY>
  <PACKAGE>
    <PACKAGES>[PDIP:SOIC]</PACKAGES>
    <PDIP>
      <NMB_PIN>20</NMB_PIN>
      <PIN1>
        <NAME>[MOSI:DI:SDA:'OC1A:PCINT0:PB0]</NAME>
        <TEXT>DI: Data input in USI 3-wire mode. USI 3-wire mode does not override normal port functions., so pin must be configure as an input. SDA: Serial data in USI 2-wire mode. Serial data pin is bi-directional and uses open-col-lector output. The SDA pin is enabled by setting the pin as an output. The pin is pulled low when the PORTB0 or USI shiftregister is zero when DDB0 is set (one). Pull-up is disabled in USI 2-wire mode. OC1A: Inverted Timer/Counter1 PWM Output A: The PB0 pin can serve as an Inverted output for the PWM mode if not used in programming or USI. The PB0 pin has to be configured as an output (DDB0 set (one)) to serve this function. For further reading on PCINT0 please refer to the manual</TEXT>
      </PIN1>
      <PIN2>
        <NAME>[MISO:DO:OC1A:PCINT0:PB1]</NAME>
        <TEXT>DO: Data output in USI 3-wire mode. Data output (DO) overrides PORTB1 value and it is driven to the port when the data direction bit DDB1 is set (one). However the PORTB1 bit still controls the pullup, enabling pullup if direction is input and PORTB1 is set(one). OC1A: Output compare match output: The PB1 pin can serve as an output for the Timer/Counter1 compare match A. The PB1 pin has to be configured as an output (DDB3 set (one)) to serve this function. The OC1B pin is also the output pin for the PWM mode timer function if not used in programming or USI. PCINT0: Pin Change Interrupt 0 pin. Pin change interrupt is enabled on pin when global interrupt is enabled, pin change interrupt is enabled and the alternate functions do not mask the interrupt. The masking alternate functions are the output compare match out-put OC1A and data output DO in USI 3-wire mode. Digital input is enabled on pin PB4 also in SLEEP modes, if the pin change interrupt is enabled and not masked by the alternate function</TEXT>
      </PIN2>
      <PIN3>
        <NAME>[SCK:SCL:'OC1B:PCINT0:PB2]</NAME>
        <TEXT>SCK: Clock input or output in USI 3-wire mode. When the SPI is enabled this pin is con-figured</TEXT>
      </PIN3>
      <PIN4>
        <NAME>[OC1B:PCINT0:PB3]</NAME>
        <TEXT>OC1B: Output compare match output: The PB3 pin can serve as an output for the Timer/Counter1 compare match B. The PB3 pin has to be configured as an output (DDB3 set (one)) to serve this function. The OC1B pin is also the output pin for the PWM mode. PCINT0: Pin Change Interrupt 0 pin. Pin change interrupt is enabled on pin when global interrupt is enabled, pin change interrupt is enabled and the alternate functions do not mask the interrupt. The masking alternate function is the output compare match output OC1B. Digital input is enabled on pin PB3 also in SLEEP modes, if the pin change interrupt is enabled and not masked by the alternate function</TEXT>
      </PIN4>
      <PIN5>
        <NAME>[VCC]</NAME>
        <TEXT/>
      </PIN5>
      <PIN6>
        <NAME>[GND]</NAME>
        <TEXT/>
      </PIN6>
      <PIN7>
        <NAME>[ADC7:XTAL1:PCINT1:PB4]</NAME>
        <TEXT>ADC7: ADC input channel 7. Configure the port pins as inputs with the internal pull-ups switched off to avoid the digital port function from interfering with the function of the ana-log to digital converter. XTAL1: Chip clock oscillator pin 1. Used for all chip clock sources except internal cali-brateble RC oscillator and PLL clock. When used as a clock pin, the pin can not be used as an I/O pin. When using internal calibratable RC oscillator or PLL clock as chip clock sources, PB4 serves as an ordinary I/O pin. PCINT1: Pin Change Interrupt 1 pin. Pin change interrupt is enabled on pin when global interrupt is enabled, pin change interrupt is enabled and the alternate functions do not mask the interrupt. The masking alternate functions are the XTAL1 inputs. Digital input is enabled on pin PB4 also in SLEEP modes, if the pin change interrupt is enabled and not masked by the alternate functions</TEXT>
      </PIN7>
      <PIN8>
        <NAME>[ADC8:XTAL2:PCINT1:PB5]</NAME>
        <TEXT>ADC8: ADC input channel 8. Configure the port pins as inputs with the internal pull-ups switched off to avoid the digital port function from interfering with the function of the ana-log to digital converter. XTAL2: Chip clock oscillator pin 2. Used as clock pin for all chip clock sources except internal calibrateble RC oscillator, external clock and PLL clock. When used as a clock pin, the pin can not be used as an I/O pin. When using internal calibratable RC oscillator, external clock or PLL clock as chip clock sources, PB5 serves as an ordinary I/O pin. PCINT1: Pin Change Interrupt 1 pin. Pin change interrupt is enabled on pin when global interrupt is enabled, pin change interrupt is enabled and the alternate functions do not mask the interrupt. The masking alternate functions are the XTAL2 outputs. Digital input is enabled on pin PB5 also in SLEEP modes, if the pin change interrupt is enabled and not masked by the alternate function</TEXT>
      </PIN8>
      <PIN9>
        <NAME>[ADC9:INT0:T0:PCINT1:PB6]</NAME>
        <TEXT>ADC9: ADC input channel 9. Configure the port pins as inputs with the internal pull-ups switched off to avoid the digital port function from interfering with the function of the analog to digital converter. INT0: External Interrupt source 0: The PB6 pin can serve as an external interrupt source enabled by setting (one) the bit INT0 in the general input mask register (GIMSK). T0: Timer/Counter0 External Counter Clock Input is enabled by setting (one) the bits CS02 and CS01 in the Timer/Counter0 control register (TCCR0). PCINT1: Pin Change Interrupt 1 pin. Pin change interrupt is enabled on pin when global interrupt is enabled, pin change interrupt is enabled and the alternate functions do not mask the interrupt. The masking alternate functions are the external low level Interrupt source 0 (INT0) and the Timer/Counter0 external counter clock input (T0). Digital input is enabled on pin PB6 also in SLEEP modes, if the pin change interrupt is enabled and not masked by the alternate functio</TEXT>
      </PIN9>
      <PIN10>
        <NAME>[ADC10:'RESET:PCINT1:PB7]</NAME>
        <TEXT>ADC10: ADC input channel 10. Configure the port pins as inputs with the internal pull-ups switched off to avoid the digital port function from interfering with the function of the analog to digital converter. RESET: External Reset Input is active low and enabled by unprogramming (&#x201C;1&#x201D;) the RSTDISBL fuse. Pullup is activated and output driver and digital input are deactivated when the pin is used as the RESET pin. PCINT1: Pin Change Interrupt 1 pin. Pin change interrupt is enabled on pin when global interrupt is enabled, pin change interrupt is enabled and the alternate function do not mask the interrupt. The masking alternate function is the pin usage as RESET. Digital input is enabled on pin PB7 also in SLEEP modes, if the pin change interrupt is enabled and not masked by the alternate functi</TEXT>
      </PIN10>
      <PIN11>
        <NAME>[ADC6:AIN1:PA7]</NAME>
        <TEXT>AIN1: Analog Comparator Negative Input and ADC6: ADC input channel 6. Configure the port pin as input with the internal pull-up switched off to avoid the digital port function from interfering with the function of the analog comparator or analog to digital converter. PCINT1: Pin Change Interrupt 1 pin. Pin change interrupt is enabled on pin when global interrupt is enabled, pin change interrupt is enabled and the alternate function do not mask the interrupt. The masking alternate function is the analog comparator.Digital input is enabled on pin PA7 also in SLEEP modes, if the pin change interrupt is enabled and not masked by the alternate functio</TEXT>
      </PIN11>
      <PIN12>
        <NAME>[ADC5:AIN0:PA6]</NAME>
        <TEXT>AIN0: Analog Comparator Positive Input and ADC5: ADC input channel 5. Configure the port pin as input with the internal pull-up switched off to avoid the digital port function from interfering with the function of the analog comparator or analog to digital converter. PCINT1: Pin Change Interrupt 1 pin. Pin change interrupt is enabled on pin when global interrupt is enabled, pin change interrupt is enabled and the alternate function do not mask the interrupt. The masking alternate function is the analog comparator.Digital input is enabled on pin PA6 also in SLEEP modes, if the pin change interrupt is enabled and not masked by the alternate functio</TEXT>
      </PIN12>
      <PIN13>
        <NAME>[ADC4:PA5]</NAME>
        <TEXT>ADC4/ADC3: ADC input channel 4 and 3. Configure the port pins as inputs with the internal pull-ups switched off to avoid the digital port function from interfering with the function of the analog to digital converter.</TEXT>
      </PIN13>
      <PIN14>
        <NAME>[ADC3:PA4]</NAME>
        <TEXT>ADC4/ADC3: ADC input channel 4 and 3. Configure the port pins as inputs with the internal pull-ups switched off to avoid the digital port function from interfering with the function of the analog to digital converter.</TEXT>
      </PIN14>
      <PIN15>
        <NAME>[AVCC]</NAME>
        <TEXT/>
      </PIN15>
      <PIN16>
        <NAME>[AGND]</NAME>
        <TEXT/>
      </PIN16>
      <PIN17>
        <NAME>[AREF:PA3]</NAME>
        <TEXT>AREF: External reference for ADC. Pullup and output driver are disabled on PA3 when the pin is used as an external reference or Internal Voltage Reference (2.56V) with external capacitor at the AREF pin by setting (one) the bit REFS0 in the ADC Multiplexer Selection Register (ADMUX). PCINT1: Pin Change Interrupt 1 pin. Pin change interrupt is enabled on pin when global interrupt is enabled, pin change interrupt is enabled and the alternate function do not mask the interrupt. The masking alternate function is the pin usage as an analog refer-ence for the ADC. Digital input is enabled on pin PA3 also in SLEEP modes, if the pin change interrupt is enabled and not masked by the alternate function. Please refer to the manual for further details</TEXT>
      </PIN17>
      <PIN18>
        <NAME>[ADC2:PA2]</NAME>
        <TEXT/>
      </PIN18>
      <PIN19>
        <NAME>[ADC1:PA1]</NAME>
        <TEXT/>
      </PIN19>
      <PIN20>
        <NAME>[ADC0:PA0]</NAME>
        <TEXT/>
      </PIN20>
    </PDIP>
  </PACKAGE>
  <FUSE>
    <LIST>[LOW:HIGH]</LIST>
    <ID/>
    <ICON/>
    <TEXT/>
    <LOW>
      <NMB_FUSE_BITS>8</NMB_FUSE_BITS>
      <FUSE7>
        <NAME>PLLCK</NAME>
        <TEXT>Use PLL for internal clock</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE7>
      <FUSE6>
        <NAME>CKOPT</NAME>
        <TEXT>Oscillator options</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE6>
      <FUSE5>
        <NAME>SUT1</NAME>
        <TEXT>Select start-up time</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE5>
      <FUSE4>
        <NAME>SUT0</NAME>
        <TEXT>Select start-up time</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE4>
      <FUSE3>
        <NAME>CKSEL3</NAME>
        <TEXT>Select Clock Source</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE3>
      <FUSE2>
        <NAME>CKSEL2</NAME>
        <TEXT>Select Clock Source</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE2>
      <FUSE1>
        <NAME>CKSEL1</NAME>
        <TEXT>Select Clock Source</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE1>
      <FUSE0>
        <NAME>CKSEL0</NAME>
        <TEXT>Select Clock Source</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE0>
      <NMB_TEXT>63</NMB_TEXT>
      <TEXT1>
        <MASK>0x40</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>CKOPT fuse (operation dependent of CKSEL fuses); [CKOPT=0]</TEXT>
      </TEXT1>
      <TEXT2>
        <MASK>0xBF</MASK>
        <VALUE>0x01</VALUE>
        <TEXT>PLL Clock; Start-up time: 1K CK + 0 ms; [CKSEL=0001 SUT=00]</TEXT>
      </TEXT2>
      <TEXT3>
        <MASK>0xBF</MASK>
        <VALUE>0x11</VALUE>
        <TEXT>PLL Clock; Start-up time: 1K CK + 4 ms; [CKSEL=0001 SUT=01]</TEXT>
      </TEXT3>
      <TEXT4>
        <MASK>0xBF</MASK>
        <VALUE>0x21</VALUE>
        <TEXT>PLL Clock; Start-up time: 1K CK + 64 ms; [CKSEL=0001 SUT=10]</TEXT>
      </TEXT4>
      <TEXT5>
        <MASK>0xBF</MASK>
        <VALUE>0x31</VALUE>
        <TEXT>PLL Clock; Start-up time: 16K CK + 64 ms; [CKSEL=0001 SUT=11]</TEXT>
      </TEXT5>
      <TEXT6>
        <MASK>0xBF</MASK>
        <VALUE>0x80</VALUE>
        <TEXT>Ext. Clock; Start-up time: 6 CK + 0 ms; [CKSEL=0000 SUT=00]</TEXT>
      </TEXT6>
      <TEXT7>
        <MASK>0xBF</MASK>
        <VALUE>0x90</VALUE>
        <TEXT>Ext. Clock; Start-up time: 6 CK + 4 ms; [CKSEL=0000 SUT=01]</TEXT>
      </TEXT7>
      <TEXT8>
        <MASK>0xBF</MASK>
        <VALUE>0xA0</VALUE>
        <TEXT>Ext. Clock; Start-up time: 6 CK + 64 ms; [CKSEL=0000 SUT=10]</TEXT>
      </TEXT8>
      <TEXT9>
        <MASK>0xBF</MASK>
        <VALUE>0x81</VALUE>
        <TEXT>Int. RC Osc. 1 MHz; Start-up time: 6 CK + 0 ms; [CKSEL=0001 SUT=00]</TEXT>
      </TEXT9>
      <TEXT10>
        <MASK>0xBF</MASK>
        <VALUE>0x91</VALUE>
        <TEXT>Int. RC Osc. 1 MHz; Start-up time: 6 CK + 4 ms; [CKSEL=0001 SUT=01]</TEXT>
      </TEXT10>
      <TEXT11>
        <MASK>0xBF</MASK>
        <VALUE>0xA1</VALUE>
        <TEXT>Int. RC Osc. 1 MHz; Start-up time: 6 CK + 64 ms; [CKSEL=0001 SUT=10]; default value</TEXT>
      </TEXT11>
      <TEXT12>
        <MASK>0xBF</MASK>
        <VALUE>0x82</VALUE>
        <TEXT>Int. RC Osc. 2 MHz; Start-up time: 6 CK + 0 ms; [CKSEL=0010 SUT=00]</TEXT>
      </TEXT12>
      <TEXT13>
        <MASK>0xBF</MASK>
        <VALUE>0x92</VALUE>
        <TEXT>Int. RC Osc. 2 MHz; Start-up time: 6 CK + 4 ms; [CKSEL=0010 SUT=01]</TEXT>
      </TEXT13>
      <TEXT14>
        <MASK>0xBF</MASK>
        <VALUE>0xA2</VALUE>
        <TEXT>Int. RC Osc. 2 MHz; Start-up time: 6 CK + 64 ms; [CKSEL=0010 SUT=10]</TEXT>
      </TEXT14>
      <TEXT15>
        <MASK>0xBF</MASK>
        <VALUE>0x83</VALUE>
        <TEXT>Int. RC Osc. 4 MHz; Start-up time: 6 CK + 0 ms; [CKSEL=0011 SUT=00]</TEXT>
      </TEXT15>
      <TEXT16>
        <MASK>0xBF</MASK>
        <VALUE>0x93</VALUE>
        <TEXT>Int. RC Osc. 4 MHz; Start-up time: 6 CK + 4 ms; [CKSEL=0011 SUT=01]</TEXT>
      </TEXT16>
      <TEXT17>
        <MASK>0xBF</MASK>
        <VALUE>0xA3</VALUE>
        <TEXT>Int. RC Osc. 4 MHz; Start-up time: 6 CK + 64 ms; [CKSEL=0011 SUT=10]</TEXT>
      </TEXT17>
      <TEXT18>
        <MASK>0xBF</MASK>
        <VALUE>0x84</VALUE>
        <TEXT>Int. RC Osc. 8 MHz; Start-up time: 6 CK + 0 ms; [CKSEL=0100 SUT=00]</TEXT>
      </TEXT18>
      <TEXT19>
        <MASK>0xBF</MASK>
        <VALUE>0x94</VALUE>
        <TEXT>Int. RC Osc. 8 MHz; Start-up time: 6 CK + 4 ms; [CKSEL=0100 SUT=01]</TEXT>
      </TEXT19>
      <TEXT20>
        <MASK>0xBF</MASK>
        <VALUE>0xA4</VALUE>
        <TEXT>Int. RC Osc. 8 MHz; Start-up time: 6 CK + 64 ms; [CKSEL=0100 SUT=10]</TEXT>
      </TEXT20>
      <TEXT21>
        <MASK>0xBF</MASK>
        <VALUE>0x85</VALUE>
        <TEXT>Ext. RC Osc.         -  0.9 MHz; Start-up time: 18 CK + 0 ms; [CKSEL=0101 SUT=00]</TEXT>
      </TEXT21>
      <TEXT22>
        <MASK>0xBF</MASK>
        <VALUE>0x95</VALUE>
        <TEXT>Ext. RC Osc.         -  0.9 MHz; Start-up time: 18 CK + 4 ms; [CKSEL=0101 SUT=01]</TEXT>
      </TEXT22>
      <TEXT23>
        <MASK>0xBF</MASK>
        <VALUE>0xA5</VALUE>
        <TEXT>Ext. RC Osc.         -  0.9 MHz; Start-up time: 18 CK + 64 ms; [CKSEL=0101 SUT=10]</TEXT>
      </TEXT23>
      <TEXT24>
        <MASK>0xBF</MASK>
        <VALUE>0xB5</VALUE>
        <TEXT>Ext. RC Osc.         -  0.9 MHz; Start-up time: 6 CK + 4 ms; [CKSEL=0101 SUT=11]</TEXT>
      </TEXT24>
      <TEXT25>
        <MASK>0xBF</MASK>
        <VALUE>0x86</VALUE>
        <TEXT>Ext. RC Osc. 0.9 MHz -  3.0 MHz; Start-up time: 18 CK + 0 ms; [CKSEL=0110 SUT=00]</TEXT>
      </TEXT25>
      <TEXT26>
        <MASK>0xBF</MASK>
        <VALUE>0x96</VALUE>
        <TEXT>Ext. RC Osc. 0.9 MHz -  3.0 MHz; Start-up time: 18 CK + 4 ms; [CKSEL=0110 SUT=01]</TEXT>
      </TEXT26>
      <TEXT27>
        <MASK>0xBF</MASK>
        <VALUE>0xA6</VALUE>
        <TEXT>Ext. RC Osc. 0.9 MHz -  3.0 MHz; Start-up time: 18 CK + 64 ms; [CKSEL=0110 SUT=10]</TEXT>
      </TEXT27>
      <TEXT28>
        <MASK>0xBF</MASK>
        <VALUE>0xB6</VALUE>
        <TEXT>Ext. RC Osc. 0.9 MHz -  3.0 MHz; Start-up time: 6 CK + 4 ms; [CKSEL=0110 SUT=11]</TEXT>
      </TEXT28>
      <TEXT29>
        <MASK>0xBF</MASK>
        <VALUE>0x87</VALUE>
        <TEXT>Ext. RC Osc. 3.0 MHz -  8.0 MHz; Start-up time: 18 CK + 0 ms; [CKSEL=0111 SUT=00]</TEXT>
      </TEXT29>
      <TEXT30>
        <MASK>0xBF</MASK>
        <VALUE>0x97</VALUE>
        <TEXT>Ext. RC Osc. 3.0 MHz -  8.0 MHz; Start-up time: 18 CK + 4 ms; [CKSEL=0111 SUT=01]</TEXT>
      </TEXT30>
      <TEXT31>
        <MASK>0xBF</MASK>
        <VALUE>0xA7</VALUE>
        <TEXT>Ext. RC Osc. 3.0 MHz -  8.0 MHz; Start-up time: 18 CK + 64 ms; [CKSEL=0111 SUT=10]</TEXT>
      </TEXT31>
      <TEXT32>
        <MASK>0xBF</MASK>
        <VALUE>0xB7</VALUE>
        <TEXT>Ext. RC Osc. 3.0 MHz -  8.0 MHz; Start-up time: 6 CK + 4 ms; [CKSEL=0111 SUT=11]</TEXT>
      </TEXT32>
      <TEXT33>
        <MASK>0xBF</MASK>
        <VALUE>0x88</VALUE>
        <TEXT>Ext. RC Osc. 8.0 MHz - 12.0 MHz; Start-up time: 18 CK + 0 ms; [CKSEL=1000 SUT=00]</TEXT>
      </TEXT33>
      <TEXT34>
        <MASK>0xBF</MASK>
        <VALUE>0x98</VALUE>
        <TEXT>Ext. RC Osc. 8.0 MHz - 12.0 MHz; Start-up time: 18 CK + 4 ms; [CKSEL=1000 SUT=01]</TEXT>
      </TEXT34>
      <TEXT35>
        <MASK>0xBF</MASK>
        <VALUE>0xA8</VALUE>
        <TEXT>Ext. RC Osc. 8.0 MHz - 12.0 MHz; Start-up time: 18 CK + 64 ms; [CKSEL=1000 SUT=10]</TEXT>
      </TEXT35>
      <TEXT36>
        <MASK>0xBF</MASK>
        <VALUE>0xB8</VALUE>
        <TEXT>Ext. RC Osc. 8.0 MHz - 12.0 MHz; Start-up time: 6 CK + 4 ms; [CKSEL=1000 SUT=11]</TEXT>
      </TEXT36>
      <TEXT37>
        <MASK>0xBF</MASK>
        <VALUE>0x89</VALUE>
        <TEXT>Ext. Low-Freq. Crystal; Start-up time: 1K CK + 4 ms; [CKSEL=1001 SUT=00]</TEXT>
      </TEXT37>
      <TEXT38>
        <MASK>0xBF</MASK>
        <VALUE>0x99</VALUE>
        <TEXT>Ext. Low-Freq. Crystal; Start-up time: 1K CK + 64 ms; [CKSEL=1001 SUT=01]</TEXT>
      </TEXT38>
      <TEXT39>
        <MASK>0xBF</MASK>
        <VALUE>0xA9</VALUE>
        <TEXT>Ext. Low-Freq. Crystal; Start-up time: 32K CK + 64 ms; [CKSEL=1001 SUT=10]</TEXT>
      </TEXT39>
      <TEXT40>
        <MASK>0xBF</MASK>
        <VALUE>0x8A</VALUE>
        <TEXT>Ext. Crystal/Resonator Low Freq.; Start-up time: 258 CK + 4 ms; [CKSEL=1010 SUT=00]</TEXT>
      </TEXT40>
      <TEXT41>
        <MASK>0xBF</MASK>
        <VALUE>0x9A</VALUE>
        <TEXT>Ext. Crystal/Resonator Low Freq.; Start-up time: 258 CK + 64 ms; [CKSEL=1010 SUT=01]</TEXT>
      </TEXT41>
      <TEXT42>
        <MASK>0xBF</MASK>
        <VALUE>0xAA</VALUE>
        <TEXT>Ext. Crystal/Resonator Low Freq.; Start-up time: 1K CK + 0 ms; [CKSEL=1010 SUT=10]</TEXT>
      </TEXT42>
      <TEXT43>
        <MASK>0xBF</MASK>
        <VALUE>0xBA</VALUE>
        <TEXT>Ext. Crystal/Resonator Low Freq.; Start-up time: 1K CK + 4 ms; [CKSEL=1010 SUT=11]</TEXT>
      </TEXT43>
      <TEXT44>
        <MASK>0xBF</MASK>
        <VALUE>0x8B</VALUE>
        <TEXT>Ext. Crystal/Resonator Low Freq.; Start-up time: 1K CK + 64 ms; [CKSEL=1011 SUT=00]</TEXT>
      </TEXT44>
      <TEXT45>
        <MASK>0xBF</MASK>
        <VALUE>0x9B</VALUE>
        <TEXT>Ext. Crystal/Resonator Low Freq.; Start-up time: 16K CK + 0 ms; [CKSEL=1011 SUT=01]</TEXT>
      </TEXT45>
      <TEXT46>
        <MASK>0xBF</MASK>
        <VALUE>0xAB</VALUE>
        <TEXT>Ext. Crystal/Resonator Low Freq.; Start-up time: 16K CK + 4 ms; [CKSEL=1011 SUT=10]</TEXT>
      </TEXT46>
      <TEXT47>
        <MASK>0xBF</MASK>
        <VALUE>0xBB</VALUE>
        <TEXT>Ext. Crystal/Resonator Low Freq.; Start-up time: 16K CK + 64 ms; [CKSEL=1011 SUT=11]</TEXT>
      </TEXT47>
      <TEXT48>
        <MASK>0xBF</MASK>
        <VALUE>0x8C</VALUE>
        <TEXT>Ext. Crystal/Resonator Medium Freq.; Start-up time: 258 CK + 4 ms; [CKSEL=1100 SUT=00]</TEXT>
      </TEXT48>
      <TEXT49>
        <MASK>0xBF</MASK>
        <VALUE>0x9C</VALUE>
        <TEXT>Ext. Crystal/Resonator Medium Freq.; Start-up time: 258 CK + 64 ms; [CKSEL=1100 SUT=01]</TEXT>
      </TEXT49>
      <TEXT50>
        <MASK>0xBF</MASK>
        <VALUE>0xAC</VALUE>
        <TEXT>Ext. Crystal/Resonator Medium Freq.; Start-up time: 1K CK + 0 ms; [CKSEL=1100 SUT=10]</TEXT>
      </TEXT50>
      <TEXT51>
        <MASK>0xBF</MASK>
        <VALUE>0xBC</VALUE>
        <TEXT>Ext. Crystal/Resonator Medium Freq.; Start-up time: 1K CK + 4 ms; [CKSEL=1100 SUT=11]</TEXT>
      </TEXT51>
      <TEXT52>
        <MASK>0xBF</MASK>
        <VALUE>0x8D</VALUE>
        <TEXT>Ext. Crystal/Resonator Medium Freq.; Start-up time: 1K CK + 64 ms; [CKSEL=1101 SUT=00]</TEXT>
      </TEXT52>
      <TEXT53>
        <MASK>0xBF</MASK>
        <VALUE>0x9D</VALUE>
        <TEXT>Ext. Crystal/Resonator Medium Freq.; Start-up time: 16K CK + 0 ms; [CKSEL=1101 SUT=01]</TEXT>
      </TEXT53>
      <TEXT54>
        <MASK>0xBF</MASK>
        <VALUE>0xAD</VALUE>
        <TEXT>Ext. Crystal/Resonator Medium Freq.; Start-up time: 16K CK + 4 ms; [CKSEL=1101 SUT=10]</TEXT>
      </TEXT54>
      <TEXT55>
        <MASK>0xBF</MASK>
        <VALUE>0xBD</VALUE>
        <TEXT>Ext. Crystal/Resonator Medium Freq.; Start-up time: 16K CK + 64 ms; [CKSEL=1101 SUT=11]</TEXT>
      </TEXT55>
      <TEXT56>
        <MASK>0xBF</MASK>
        <VALUE>0x8E</VALUE>
        <TEXT>Ext. Crystal/Resonator High Freq.; Start-up time: 258 CK + 4 ms; [CKSEL=1110 SUT=00]</TEXT>
      </TEXT56>
      <TEXT57>
        <MASK>0xBF</MASK>
        <VALUE>0x9E</VALUE>
        <TEXT>Ext. Crystal/Resonator High Freq.; Start-up time: 258 CK + 64 ms; [CKSEL=1110 SUT=01]</TEXT>
      </TEXT57>
      <TEXT58>
        <MASK>0xBF</MASK>
        <VALUE>0xAE</VALUE>
        <TEXT>Ext. Crystal/Resonator High Freq.; Start-up time: 1K CK + 0 ms; [CKSEL=1110 SUT=10]</TEXT>
      </TEXT58>
      <TEXT59>
        <MASK>0xBF</MASK>
        <VALUE>0xBE</VALUE>
        <TEXT>Ext. Crystal/Resonator High Freq.; Start-up time: 1K CK + 4 ms; [CKSEL=1110 SUT=11]</TEXT>
      </TEXT59>
      <TEXT60>
        <MASK>0xBF</MASK>
        <VALUE>0x8F</VALUE>
        <TEXT>Ext. Crystal/Resonator High Freq.; Start-up time: 1K CK + 64 ms; [CKSEL=1111 SUT=00]</TEXT>
      </TEXT60>
      <TEXT61>
        <MASK>0xBF</MASK>
        <VALUE>0x9F</VALUE>
        <TEXT>Ext. Crystal/Resonator High Freq.; Start-up time: 16K CK + 0 ms; [CKSEL=1111 SUT=01]</TEXT>
      </TEXT61>
      <TEXT62>
        <MASK>0xBF</MASK>
        <VALUE>0xAF</VALUE>
        <TEXT>Ext. Crystal/Resonator High Freq.; Start-up time: 16K CK + 4 ms; [CKSEL=1111 SUT=10]</TEXT>
      </TEXT62>
      <TEXT63>
        <MASK>0xBF</MASK>
        <VALUE>0xBF</VALUE>
        <TEXT>Ext. Crystal/Resonator High Freq.; Start-up time: 16K CK + 64 ms; [CKSEL=1111 SUT=11]</TEXT>
      </TEXT63>
    </LOW>
    <HIGH>
      <NMB_FUSE_BITS>5</NMB_FUSE_BITS>
      <FUSE4>
        <NAME>RSTDISBL</NAME>
        <TEXT>Select if PB/ is I/O pin or RESET pin</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE4>
      <FUSE3>
        <NAME>SPIEN</NAME>
        <TEXT>Enable Serial Program and Data Downloading</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE3>
      <FUSE2>
        <NAME>EESAVE</NAME>
        <TEXT>EEPROM memory is preserved through the Chip Erase</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE2>
      <FUSE1>
        <NAME>BODLEVEL</NAME>
        <TEXT>Brown out detector trigger level</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE1>
      <FUSE0>
        <NAME>BODEN</NAME>
        <TEXT>Brown out detector enable</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE0>
      <NMB_TEXT>6</NMB_TEXT>
      <TEXT1>
        <MASK>0x10</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Reset Disabled (Enable PB7 as i/o pin); [RSTDISBL=0]</TEXT>
      </TEXT1>
      <TEXT2>
        <MASK>0x08</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Serial program downloading (SPI) enabled; [SPIEN=0]</TEXT>
      </TEXT2>
      <TEXT3>
        <MASK>0x04</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Preserve EEPROM memory through the Chip Erase cycle; [EESAVE=0]</TEXT>
      </TEXT3>
      <TEXT4>
        <MASK>0x02</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Brown-out detection level at VCC=4.0 V; [BODLEVEL=0]</TEXT>
      </TEXT4>
      <TEXT5>
        <MASK>0x02</MASK>
        <VALUE>0x02</VALUE>
        <TEXT>Brown-out detection level at VCC=2.7 V; [BODLEVEL=1]</TEXT>
      </TEXT5>
      <TEXT6>
        <MASK>0x01</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Brown-out detection enabled; [BODEN=0]</TEXT>
      </TEXT6>
    </HIGH>
  </FUSE>
  <LOCKBIT>
    <ICON/>
    <ID/>
    <TEXT>[LB1 = 1 :  LB2 = 1] No memory lock features enabled. [LB1 = 0 :  LB2 = 1] Further programming of Flash and EEPROM is enabled. [LB1 = 0 :  LB2 = 0] Same as previous, but verify is also disabled</TEXT>
    <NMB_TEXT>3</NMB_TEXT>
    <NMB_LOCK_BITS>2</NMB_LOCK_BITS>
    <TEXT1>
      <MASK>0x03</MASK>
      <VALUE>0x03</VALUE>
      <TEXT>Mode 1: No memory lock features enabled</TEXT>
    </TEXT1>
    <TEXT2>
      <MASK>0x03</MASK>
      <VALUE>0x02</VALUE>
      <TEXT>Mode 2: Further programming disabled</TEXT>
    </TEXT2>
    <TEXT3>
      <MASK>0x03</MASK>
      <VALUE>0x00</VALUE>
      <TEXT>Mode 3: Further programming and verification disabled</TEXT>
    </TEXT3>
    <LOCKBIT0>
      <NAME>LB1</NAME>
      <TEXT>Lockbit</TEXT>
    </LOCKBIT0>
    <LOCKBIT1>
      <NAME>LB2</NAME>
      <TEXT>Lockbit</TEXT>
    </LOCKBIT1>
  </LOCKBIT>
  <PROGRAMMING>
    <ISPInterface>
      <FuseProgMask>0xff,0xf7</FuseProgMask>
      <FuseWarning>1,0x08,0x08,WARNING! These fuse settings will disable the ISP interface!</FuseWarning>
      <FuseWarning>1,0x10,0x00,WARNING! Disabling external reset will make the ISP interface inaccessible!</FuseWarning>
    </ISPInterface>
    <HVInterface>
      <FuseWarning>1,0x08,0x08,WARNING! These fuse settings will disable the ISP interface!</FuseWarning>
      <FuseWarning>1,0x10,0x00,WARNING! Disabling external reset will make the ISP interface inaccessible!</FuseWarning>
    </HVInterface>
    <OscCal>
      <OCEntry>0x00,1.0 MHz</OCEntry>
      <OCEntry>0x01,2.0 MHz</OCEntry>
      <OCEntry>0x02,4.0 MHz</OCEntry>
      <OCEntry>0x03,8.0 MHz</OCEntry>
    </OscCal>
    <FlashPageSize>32</FlashPageSize>
    <EepromPageSize>4</EepromPageSize>
  </PROGRAMMING>
  <IO_MODULE>
    <MODULE_LIST>[AD_CONVERTER:ANALOG_COMPARATOR:USI:PORTA:PORTB:EEPROM:WATCHDOG:CPU:TIMER_COUNTER_0:TIMER_COUNTER_1:EXTERNAL_INTERRUPT]</MODULE_LIST>
    <AD_CONVERTER>
      <LIST>[ADMUX:ADCSR:ADCH:ADCL]</LIST>
      <LINK/>
      <RULES>((IF ADMUX.ADLAR = 1) LINK [ADCH(1:0):ADCL(7:0)]); (IF ADMUX.ADLAR = 0) LINK [ADCH(7:0):ADCL(7:6)]);</RULES>
      <ICON>io_analo.bmp</ICON>
      <ID/>
      <TEXT>AD Converter Feature list: 10-bit Resolution. 0.5 LSB Integral Non-Linearity. +-2 LSB Absolute Accuracy. TBD - 260 &#xB5;s Conversion Time. Up to TBD kSPS at maximum resolution. 8 Multiplexed Single Ended Input Channels. 7 Differential input channels (TQFP package only).  2 Differential input channels with optional gain of 10x and 200x (TQFP package only). Optional left adjustment for ADC result readout. 0 - VCC ADC Input Voltage Range. Selectable 2.56 V ADC reference voltage. Free Running or Single Conversion Mode. Interrupt on ADC Conversion Complete. Sleep Mode Noise</TEXT>
      <ADMUX>
        <NAME>ADMUX</NAME>
        <DESCRIPTION>The ADC multiplexer Selection Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$07</IO_ADDR>
        <MEM_ADDR>$27</MEM_ADDR>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>REFS1</NAME>
          <DESCRIPTION>Reference Selection Bit 1</DESCRIPTION>
          <TEXT>These bits select the voltage reference for the ADC, as shown in Table 91. If these bits are changed during a conversion, the change will not go in effect until this conversion is complete (ADIF in ADCSR is set). If differential channels are used, the selected reference should not be closer to AV CC than indicated in Table 94 on page 200. The internal voltage reference options may not be used if an external reference voltage is being applied to the AREF pin.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>REFS0</NAME>
          <DESCRIPTION>Reference Selection Bit 0</DESCRIPTION>
          <TEXT>These bits select the voltage reference for the ADC, as shown in Table 91. If these bits are changed during a conversion, the change will not go in effect until this conversion is complete (ADIF in ADCSR is set). If differential channels are used, the selected reference should not be closer to AV CC than indicated in Table 94 on page 200. The internal voltage reference options may not be used if an external reference voltage is being applied to the AREF pin.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>ANALOG_ADC_V_REF</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ADLAR</NAME>
          <DESCRIPTION>Left Adjust Result</DESCRIPTION>
          <TEXT>The ADLAR bit affects the presentation of the ADC conversion result in the ADC data register. If ADLAR is cleared, the result is right adjusted. If ADLAR is set, the result is left adjusted. Changing the ADLAR bit will affect the ADC data register immediately, regardless of any ongoing conversions. For a complete description of this bit, see &#x201C;The ADC Data Register -ADCL and ADCH&#x201D; on page 198. </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>MUX4</NAME>
          <DESCRIPTION>Analog Channel and Gain Selection Bits</DESCRIPTION>
          <TEXT>The value of these bits selects which combination of analog inputs are connected to the ADC. These bits also select the gain for the differential channels. See Table 92 for details. If these bits are changed during a conversion, the change will not go in effect until this conversion is complete (ADIF in ADCSR is set).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>MUX3</NAME>
          <DESCRIPTION>Analog Channel and Gain Selection Bits</DESCRIPTION>
          <TEXT>The value of these bits selects which combination of analog inputs are connected to the ADC. These bits also select the gain for the differential channels. See Table 92 for details. If these bits are changed during a conversion, the change will not go in effect until this conversion is complete (ADIF in ADCSR is set).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>MUX2</NAME>
          <DESCRIPTION>Analog Channel and Gain Selection Bits</DESCRIPTION>
          <TEXT>The value of these bits selects which combination of analog inputs are connected to the ADC. These bits also select the gain for the differential channels. See Table 92 for details. If these bits are changed during a conversion, the change will not go in effect until this conversion is complete (ADIF in ADCSR is set).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>MUX1</NAME>
          <DESCRIPTION>Analog Channel and Gain Selection Bits</DESCRIPTION>
          <TEXT>The value of these bits selects which combination of analog inputs are connected to the ADC. These bits also select the gain for the differential channels. See Table 92 for details. If these bits are changed during a conversion, the change will not go in effect until this conversion is complete (ADIF in ADCSR is set).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>MUX0</NAME>
          <DESCRIPTION>Analog Channel and Gain Selection Bits</DESCRIPTION>
          <TEXT>The value of these bits selects which combination of analog inputs are connected to the ADC. These bits also select the gain for the differential channels. See Table 92 for details. If these bits are changed during a conversion, the change will not go in effect until this conversion is complete (ADIF in ADCSR is set).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ADMUX>
      <ADCSR>
        <NAME>ADCSR</NAME>
        <ALIAS>ADCSRA</ALIAS>
        <DESCRIPTION>The ADC Control and Status register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$06</IO_ADDR>
        <MEM_ADDR>$26</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>ADEN</NAME>
          <DESCRIPTION>ADC Enable</DESCRIPTION>
          <TEXT>Writing a logical &#x2018;1&#x2019; to this bit enables the ADC. By clearing this bit to zero, the ADC is turned off. Turning the ADC off while a conversion is in progress, will terminate this conversion.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ADSC</NAME>
          <DESCRIPTION>ADC Start Conversion</DESCRIPTION>
          <TEXT>In Single Conversion Mode, a logical &#x2018;1&#x2019; must be written to this bit to start each conversion. In Free Running Mode, a logical &#x2018;1&#x2019; must be written to this bit to start the first conversion. The first time ADSC has been written after the ADC has been enabled, or if ADSC is written at the same time as the ADC is enabled, an extended conversion will result. This extended conversion performs initialization of the ADC. ADSC will read as one as long as a conversion is in progress. When the conversion is complete, it returns to zero. When a dummy conversion precedes a real conversion, ADSC will stay high until the real conversion completes. Writing a 0 to this bit has no effect</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ADFR</NAME>
          <DESCRIPTION>ADC  Free Running Select</DESCRIPTION>
          <TEXT>When this bit is set (one) the ADC operates in Free Running Mode. In this mode, the ADC samples and updates the data registers continuously. Clearing this bit (zero) will terminate Free Running Mode.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ADIF</NAME>
          <DESCRIPTION>ADC Interrupt Flag</DESCRIPTION>
          <TEXT>This bit is set (one) when an ADC conversion completes and the data registers are updated. The ADC Conversion Complete Interrupt is executed if the ADIE bit and the I-bit in SREG are set (one). ADIF is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, ADIF is cleared by writing a logical one to the flag. Beware that if doing a read-modify-write on ADCSR, a pending interrupt can be disabled. This also applies if the SBI and CBI instructions are used.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ADIE</NAME>
          <DESCRIPTION>ADC Interrupt Enable</DESCRIPTION>
          <TEXT>When this bit is set (one) and the I-bit in SREG is set (one), the ADC Conversion Complete Interrupt is activated.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ADPS2</NAME>
          <DESCRIPTION>ADC  Prescaler Select Bits</DESCRIPTION>
          <TEXT>These bits determine the division factor between the XTAL frequency and the input clock to the ADC.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ADPS1</NAME>
          <DESCRIPTION>ADC  Prescaler Select Bits</DESCRIPTION>
          <TEXT>These bits determine the division factor between the XTAL frequency and the input clock to the ADC.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ADPS0</NAME>
          <DESCRIPTION>ADC  Prescaler Select Bits</DESCRIPTION>
          <TEXT>These bits determine the division factor between the XTAL frequency and the input clock to the ADC.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>ANALIG_ADC_PRESCALER</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ADCSR>
      <ADCH>
        <NAME>ADCH</NAME>
        <DESCRIPTION>ADC Data Register High Byte</DESCRIPTION>
        <TEXT>When an ADC conversion is complete, the result is found in these two registers. If differential channels are used, the result is presented in two&#x2019;s complement form. The selected channel is differential if MUX4..0 are between &#x2018;01000&#x2019; and &#x2018;11101&#x2019;, otherwise the selected channel is single ended. When ADCL is read, the ADC Data Register is not updated until ADCH is read. Consequently, if the result is left adjusted and no more than 8 bit precision (7 bit + sign bit for differential input channels) is required, it is sufficient to read ADCH. Otherwise, ADCL must be read first, then ADCH. The ADLAR bit in ADMUX, and the MUX4..0 bits in ADMUX affect the way the result is read from the registers. If ADLAR is set, the result is left adjusted. If ADLAR is cleared (default), the result is right adju</TEXT>
        <IO_ADDR>$05</IO_ADDR>
        <MEM_ADDR>$25</MEM_ADDR>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>ADCH7</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ADCH6</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ADCH5</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ADCH4</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ADCH3</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ADCH2</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ADCH1</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ADCH0</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ADCH>
      <ADCL>
        <NAME>ADCL</NAME>
        <DESCRIPTION>ADC Data Register Low Byte</DESCRIPTION>
        <TEXT>When an ADC conversion is complete, the result is found in these two registers. If differential channels are used, the result is presented in two&#x2019;s complement form. The selected channel is differential if MUX4..0 are between &#x2018;01000&#x2019; and &#x2018;11101&#x2019;, otherwise the selected channel is single ended. When ADCL is read, the ADC Data Register is not updated until ADCH is read. Consequently, if the result is left adjusted and no more than 8 bit precision (7 bit + sign bit for differential input channels) is required, it is sufficient to read ADCH. Otherwise, ADCL must be read first, then ADCH. The ADLAR bit in ADMUX, and the MUX4..0 bits in ADMUX affect the way the result is read from the registers. If ADLAR is set, the result is left adjusted. If ADLAR is cleared (default), the result is right ad</TEXT>
        <IO_ADDR>$04</IO_ADDR>
        <MEM_ADDR>$24</MEM_ADDR>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>ADCL7</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ADCL6</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ADCL5</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ADCL4</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ADCL3</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ADCL2</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ADCL1</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ADCL0</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ADCL>
    </AD_CONVERTER>
    <ANALOG_COMPARATOR>
      <LIST>[ACSR]</LIST>
      <LINK/>
      <ICON>io_analo.bmp</ICON>
      <ID>AlgComp_06</ID>
      <TEXT/>
      <ACSR>
        <NAME>ACSR</NAME>
        <DESCRIPTION>Analog Comparator Control And Status Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$08</IO_ADDR>
        <MEM_ADDR>$28</MEM_ADDR>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>ACD</NAME>
          <DESCRIPTION>Analog Comparator Disable</DESCRIPTION>
          <TEXT>When this bit is written logic one, the power to the analog comparator is switched off. This bit can be set at any time to turn off the analog comparator. This will reduce power consumption in active and idle mode. When changing the ACD bit, the Analog Comparator Interrupt must be disabled by clearing the ACIE bit in ACSR. Otherwise an interrupt can occur when the bit is changed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ACBG</NAME>
          <DESCRIPTION>Analog Comparator Bandgap Select</DESCRIPTION>
          <TEXT>When this bit is set, a fixed bandgap reference voltage replaces the positive input to the Analog Comparator. When this bit is cleared, AIN0 is applied to the positive input of the Analog Comparator. See &#x201C;Internal Voltage Reference&#x201D; on page 42.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ACO</NAME>
          <DESCRIPTION>Analog Compare Output</DESCRIPTION>
          <TEXT>The output of the analog comparator is synchronized and then directly connected to ACO. The synchronization introduces a delay of 1-2 clock cycles.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>NA</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ACI</NAME>
          <DESCRIPTION>Analog Comparator Interrupt Flag</DESCRIPTION>
          <TEXT>This bit is set by hardware when a comparator output event triggers the interrupt mode defined by ACIS1 and ACIS0. The Analog Comparator Interrupt routine is executed if the ACIE bit is set and the I-bit in SREG is set. ACI is cleared by hard-ware when executing the corresponding interrupt handling vector. Alternatively, ACI is cleared by writing a logic one to the flag.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ACIE</NAME>
          <DESCRIPTION>Analog Comparator Interrupt Enable</DESCRIPTION>
          <TEXT>When the ACIE bit is written logic one and the I-bit in the Status Register is set, the analog comparator interrupt is acti-vated. When written logic zero, the interrupt is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ACME</NAME>
          <DESCRIPTION>Analog Comparator Multiplexer Enable</DESCRIPTION>
          <TEXT>When the ACME bit is set (one) and the ADC is switched off (ADEN in ADCSR is zero), MUX3...0 in ADMUX select the input pin to replace the negative input to the Analog Comparator, as shown in the table in the datasheet. If ACME is cleared (zero) or ADEN is set (one), PA7(AIN1) is applied to the negative input to the Analog Comparator.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ACIS1</NAME>
          <DESCRIPTION>Analog Comparator Interrupt Mode Select bit 1</DESCRIPTION>
          <TEXT>These bits determine which comparator events that trigger the Analog Comparator interrupt.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ACIS0</NAME>
          <DESCRIPTION>Analog Comparator Interrupt Mode Select bit 0</DESCRIPTION>
          <TEXT>These bits determine which comparator events that trigger the Analog Comparator interrupt.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>ANALOG_COMP_INTERRUPT</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ACSR>
    </ANALOG_COMPARATOR>
    <USI>
      <LIST>[USIDR:USISR:USICR]</LIST>
      <LINK/>
      <ICON>io_com.bmp</ICON>
      <ID/>
      <TEXT>Universal Serial Interface</TEXT>
      <USIDR>
        <NAME>USIDR</NAME>
        <DESCRIPTION>USI Data Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$0F</IO_ADDR>
        <MEM_ADDR>$2F</MEM_ADDR>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>USIDR7</NAME>
          <DESCRIPTION>USI Data Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>USIDR6</NAME>
          <DESCRIPTION>USI Data Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>USIDR5</NAME>
          <DESCRIPTION>USI Data Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>USIDR4</NAME>
          <DESCRIPTION>USI Data Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>USIDR3</NAME>
          <DESCRIPTION>USI Data Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>USIDR2</NAME>
          <DESCRIPTION>USI Data Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>USIDR1</NAME>
          <DESCRIPTION>USI Data Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>USIDR0</NAME>
          <DESCRIPTION>USI Data Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </USIDR>
      <USISR>
        <NAME>USISR</NAME>
        <DESCRIPTION>USI Status Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$0E</IO_ADDR>
        <MEM_ADDR>$2E</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>USISIF</NAME>
          <DESCRIPTION>Start Condition Interrupt Flag</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>USIOIF</NAME>
          <DESCRIPTION>Counter Overflow Interrupt Flag</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>USIPF</NAME>
          <DESCRIPTION>Stop Condition Flag</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>USIDC</NAME>
          <DESCRIPTION>Data Output Collision</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>USICNT3</NAME>
          <DESCRIPTION>USI Counter Value Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>USICNT2</NAME>
          <DESCRIPTION>USI Counter Value Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>USICNT1</NAME>
          <DESCRIPTION>USI Counter Value Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>USICNT0</NAME>
          <DESCRIPTION>USI Counter Value Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </USISR>
      <USICR>
        <NAME>USICR</NAME>
        <DESCRIPTION>USI Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$0D</IO_ADDR>
        <MEM_ADDR>$2D</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>USISIE</NAME>
          <DESCRIPTION>Start Condition Interrupt Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>USIOIE</NAME>
          <DESCRIPTION>Counter Overflow Interrupt Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>USIWM1</NAME>
          <DESCRIPTION>USI Wire Mode Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>USIWM0</NAME>
          <DESCRIPTION>USI Wire Mode Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <ENUM>COMM_USI_OP</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>USICS1</NAME>
          <DESCRIPTION>USI Clock Source Select Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>USICS0</NAME>
          <DESCRIPTION>USI Clock Source Select Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>USICLK</NAME>
          <DESCRIPTION>Clock Strobe</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>USITC</NAME>
          <DESCRIPTION>Toggle Clock Port Pin</DESCRIPTION>
          <TEXT/>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </USICR>
    </USI>
    <PORTA>
      <LIST>[PORTA:DDRA:PINA]</LIST>
      <LINK/>
      <ICON>io_port.bmp</ICON>
      <ID>AVRSimIOPort.SimIOPort</ID>
      <TEXT/>
      <PORTA>
        <NAME>PORTA</NAME>
        <DESCRIPTION>Port A Data Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$1B</IO_ADDR>
        <MEM_ADDR>$3B</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PORTA7</NAME>
          <DESCRIPTION>Port A Data Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PORTA6</NAME>
          <DESCRIPTION>Port A Data Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PORTA5</NAME>
          <DESCRIPTION>Port A Data Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PORTA4</NAME>
          <DESCRIPTION>Port A Data Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PORTA3</NAME>
          <DESCRIPTION>Port A Data Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PORTA2</NAME>
          <DESCRIPTION>Port A Data Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PORTA1</NAME>
          <DESCRIPTION>Port A Data Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PORTA0</NAME>
          <DESCRIPTION>Port A Data Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PORTA>
      <DDRA>
        <NAME>DDRA</NAME>
        <DESCRIPTION>Port A Data Direction Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$1A</IO_ADDR>
        <MEM_ADDR>$3A</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>DDA7</NAME>
          <DESCRIPTION>Data Direction Register, Port A, bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>DDA6</NAME>
          <DESCRIPTION>Data Direction Register, Port A, bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>DDA5</NAME>
          <DESCRIPTION>Data Direction Register, Port A, bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>DDA4</NAME>
          <DESCRIPTION>Data Direction Register, Port A, bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>DDA3</NAME>
          <DESCRIPTION>Data Direction Register, Port A, bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>DDA2</NAME>
          <DESCRIPTION>Data Direction Register, Port A, bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>DDA1</NAME>
          <DESCRIPTION>Data Direction Register, Port A, bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>DDA0</NAME>
          <DESCRIPTION>Data Direction Register, Port A, bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </DDRA>
      <PINA>
        <NAME>PINA</NAME>
        <DESCRIPTION>Port A Input Pins</DESCRIPTION>
        <TEXT>The Port A Input Pins address - PINA - is not a register, and this address enables access to the physical value on each Port A pin. When reading PORTA the Port A Data Latch is read, and when reading PINA, the logical values present on the pins are read.</TEXT>
        <IO_ADDR>$19</IO_ADDR>
        <MEM_ADDR>$39</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PINA7</NAME>
          <DESCRIPTION>Input Pins, Port A bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>Hi-Z</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PINA6</NAME>
          <DESCRIPTION>Input Pins, Port A bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>Hi-Z</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PINA5</NAME>
          <DESCRIPTION>Input Pins, Port A bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>Hi-Z</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PINA4</NAME>
          <DESCRIPTION>Input Pins, Port A bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>Hi-Z</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PINA3</NAME>
          <DESCRIPTION>Input Pins, Port A bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>Hi-Z</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PINA2</NAME>
          <DESCRIPTION>Input Pins, Port A bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>Hi-Z</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PINA1</NAME>
          <DESCRIPTION>Input Pins, Port A bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>Hi-Z</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PINA0</NAME>
          <DESCRIPTION>Input Pins, Port A bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>Hi-Z</INIT_VAL>
        </BIT0>
      </PINA>
    </PORTA>
    <PORTB>
      <LIST>[PORTB:DDRB:PINB]</LIST>
      <LINK/>
      <ICON>io_port.bmp</ICON>
      <ID>AVRSimIOPort.SimIOPort</ID>
      <TEXT/>
      <PORTB>
        <NAME>PORTB</NAME>
        <DESCRIPTION>Port B Data Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$18</IO_ADDR>
        <MEM_ADDR>$38</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PORTB7</NAME>
          <DESCRIPTION>Port B Data Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PORTB6</NAME>
          <DESCRIPTION>Port B Data Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PORTB5</NAME>
          <DESCRIPTION>Port B Data Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PORTB4</NAME>
          <DESCRIPTION>Port B Data Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PORTB3</NAME>
          <DESCRIPTION>Port B Data Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PORTB2</NAME>
          <DESCRIPTION>Port B Data Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PORTB1</NAME>
          <DESCRIPTION>Port B Data Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PORTB0</NAME>
          <DESCRIPTION>Port B Data Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PORTB>
      <DDRB>
        <NAME>DDRB</NAME>
        <DESCRIPTION>Port B Data Direction Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$17</IO_ADDR>
        <MEM_ADDR>$37</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>DDB7</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>DDB6</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>DDB5</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>DDB4</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>DDB3</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>DDB2</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>DDB1</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>DDB0</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </DDRB>
      <PINB>
        <NAME>PINB</NAME>
        <DESCRIPTION>Port B Input Pins</DESCRIPTION>
        <TEXT>The Port B Input Pins address - PINB - is not a register, and this address enables access to the physical value on each Port B pin. When reading PORTB, the Port B Data Latch is read, and when reading PINB, the logical values present on the pins are read.</TEXT>
        <IO_ADDR>$16</IO_ADDR>
        <MEM_ADDR>$36</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PINB7</NAME>
          <DESCRIPTION>Port B Input Pins bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PINB6</NAME>
          <DESCRIPTION>Port B Input Pins bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PINB5</NAME>
          <DESCRIPTION>Port B Input Pins bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PINB4</NAME>
          <DESCRIPTION>Port B Input Pins bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PINB3</NAME>
          <DESCRIPTION>Port B Input Pins bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PINB2</NAME>
          <DESCRIPTION>Port B Input Pins bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PINB1</NAME>
          <DESCRIPTION>Port B Input Pins bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PINB0</NAME>
          <DESCRIPTION>Port B Input Pins bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PINB>
    </PORTB>
    <EEPROM>
      <LIST>[EEAR:EEDR:EECR]</LIST>
      <LINK/>
      <ICON>io_cpu.bmp</ICON>
      <ID>EEPROM_02.xml</ID>
      <TEXT/>
      <EEAR>
        <NAME>EEAR</NAME>
        <DESCRIPTION>EEPROM Read/Write Access</DESCRIPTION>
        <TEXT>The EEPROM access register is accessible in the I/O space. The write access time is in the range of 2.5 - 4ms, depending on the V CC voltages. A self-timing function, however, lets the user software detect when the next byte can be written. If the user code contains code that writes the EEPROM, some pre-caution must be taken. In heavily filtered power supplies, V CC is likely to rise or fall slowly on power-up/down. This causes the device for some period of time to run at a voltage lower than specified as minimum for the clock frequency used. CPU operation under these conditions is likely cause the program counter to perform unintentional jumps and eventually execute the EEPROM write code. To secure EEPROM integrity, the user is advised to use an external under-voltage reset circuit in this case. In order to prevent unintentional EEPROM writes, a specific write procedure must be followed. Refer to the description of the EEPROM Control Register for details on this. When the EEPROM is written, the CPU is halted for two clock cycles before the next instruction is executed. When the EEPROM is read, the CPU is halted for four clock cycles before the next instruction</TEXT>
        <IO_ADDR>$1E</IO_ADDR>
        <MEM_ADDR>$3E</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT6>
          <NAME>EEAR6</NAME>
          <DESCRIPTION>EEPROM Read/Write Access bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>EEAR5</NAME>
          <DESCRIPTION>EEPROM Read/Write Access bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>EEAR4</NAME>
          <DESCRIPTION>EEPROM Read/Write Access bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>EEAR3</NAME>
          <DESCRIPTION>EEPROM Read/Write Access bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>EEAR2</NAME>
          <DESCRIPTION>EEPROM Read/Write Access bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>EEAR1</NAME>
          <DESCRIPTION>EEPROM Read/Write Access bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>EEAR0</NAME>
          <DESCRIPTION>EEPROM Read/Write Access bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </EEAR>
      <EEDR>
        <NAME>EEDR</NAME>
        <DESCRIPTION>EEPROM Data Register</DESCRIPTION>
        <TEXT>For the EEPROM write operation, the EEDR register contains the data to be written to the EEPROM in the address given by the EEAR register. For the EEPROM read operation, the EEDR contains the data read out from the EEPROM at the address given by EEAR.</TEXT>
        <IO_ADDR>$1D</IO_ADDR>
        <MEM_ADDR>$3D</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>EEDR7</NAME>
          <DESCRIPTION>EEPROM Data Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>EEDR6</NAME>
          <DESCRIPTION>EEPROM Data Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>EEDR5</NAME>
          <DESCRIPTION>EEPROM Data Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>EEDR4</NAME>
          <DESCRIPTION>EEPROM Data Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>EEDR3</NAME>
          <DESCRIPTION>EEPROM Data Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>EEDR2</NAME>
          <DESCRIPTION>EEPROM Data Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>EEDR1</NAME>
          <DESCRIPTION>EEPROM Data Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>EEDR0</NAME>
          <DESCRIPTION>EEPROM Data Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </EEDR>
      <EECR>
        <NAME>EECR</NAME>
        <DESCRIPTION>EEPROM Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$1C</IO_ADDR>
        <MEM_ADDR>$3C</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT3>
          <NAME>EERIE</NAME>
          <DESCRIPTION>EEProm Ready Interrupt Enable</DESCRIPTION>
          <TEXT>When the I-bit in SREG and EERIE are set (one), the EEPROM Ready Interrupt is enabled. When cleared (zero), the interrupt is disabled. The EEPROM Ready Interrupt generates a constant interrupt when EEWE is cleared (zero).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>EEMWE</NAME>
          <DESCRIPTION>EEPROM Master Write Enable</DESCRIPTION>
          <TEXT>The EEMWE bit determines whether setting EEWE to one causes the EEPROM to be written. When EEMWE is set(one) setting EEWE will write data to the EEPROM at the selected address If EEMWE is zero, setting EEWE will have no effect. When EEMWE has been set (one) by software, hardware clears the bit to zero after four clock cycles. See the description of the EEWE bit for a EEPROM write procedure.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>EEWE</NAME>
          <DESCRIPTION>EEPROM Write Enable</DESCRIPTION>
          <TEXT>The EEPROM Write Enable Signal EEWE is the write strobe to the EEPROM. When address and data are correctly set up, the EEWE bit must be set to write the value into the EEPROM. The EEMWE bit must be set when the logical one is written to EEWE, otherwise no EEPROM write takes place. The following procedure should be followed when writing the EEPROM (the order of steps 2 and 3 is unessential): 1. Wait until EEWE becomes zero. 2. Write new EEPROM address to EEARL and EEARH (optional). 3. Write new EEPROM data to EEDR (optional). 4. Write a logical one to the EEMWE bit in EECR (to be able to write a logical one to the EEMWE bit, the EEWE bit mustbewritten to zero in thesamecycle). 5. Within four clock cycles after setting EEMWE, write a logical one to EEWE. When the write access time (typically 2.5 ms at V CC =5Vor 4msatV CC = 2.7V) has elapsed, the EEWE bit is cleared (zero) by hardware. The user software can poll this bit and wait for a zero before writing the next byte. When EEWE has been set, the CPU is halted or two cycles before the next instruction is executed. Caution: An interrupt between step 4 and step 5 will make the write cycle fail, since the EEPROM Master Write Enable will time-out. If an interrupt routine accessing the EEPROM is interrupting another EEPROM access, the EEAR or EEDR regis-ter will be modified, causing the interrupted EEPROM access to fail. It is recommended to have the global interrupt flag cleared during the 4 last steps to avoid these problems.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>EERE</NAME>
          <DESCRIPTION>EEPROM Read Enable</DESCRIPTION>
          <TEXT>The EEPROM Read Enable Signal EERE is the read strobe to the EEPROM. When the correct address is set up in the EEAR register, the EERE bit must be set. When the EERE bit is cleared (zero) by hardware, requested data is found in the EEDR register. The EEPROM read access takes one instruction and there is no need to poll the EERE bit. When EERE has been set, the CPU is halted for four cycles before the next instruction is executed. The user should poll the EEWE bit before starting the read operation. If a write operation is in progress when new data or address is written to the EEPROM I/O registers, the write operation will be interrupted, and the result is undefined.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </EECR>
    </EEPROM>
    <WATCHDOG>
      <LIST>[WDTCR]</LIST>
      <LINK/>
      <ICON>io_watch.bmp</ICON>
      <ID/>
      <TEXT/>
      <WDTCR>
        <NAME>WDTCR</NAME>
        <ALIAS>WDTCSR</ALIAS>
        <DESCRIPTION>Watchdog Timer Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$21</IO_ADDR>
        <MEM_ADDR>$41</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT4>
          <NAME>WDCE</NAME>
          <ALIAS>WDTOE</ALIAS>
          <DESCRIPTION>Watchdog Change Enable</DESCRIPTION>
          <TEXT>This bit must be set when the WDE bit is written to logic zero.Otherwise,the watchdog will not be disabled.Once written to one,hardware will clear this bit after four clock cycles.Refer to the description of the WDE bit for a watchdog disable procedure.This bit must also be set when changing the prescaler bits.     </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>WDE</NAME>
          <DESCRIPTION>Watch Dog Enable</DESCRIPTION>
          <TEXT>When the WDE is set (one) the Watchdog Timer is enabled, and if the WDE is cleared (zero) the Watchdog Timer function is disabled. WDE can only be cleared if the WDTOE bit is set(one). To disable an enabled watchdog timer, the following procedure must be followed: 1. In the same operation, write a logical one to WDTOE and WDE. A logical one must be written to WDE even though it is set to one before the disable operation starts. 2. Within the next four clock cycles, write a logical 0 to WDE. This disables the watchdog</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>WDP2</NAME>
          <DESCRIPTION>Watch Dog Timer Prescaler bit 2</DESCRIPTION>
          <TEXT>The WDP2,WDP1,and WDP0 bits determine the Watchdog Timer prescaling when the Watchdog Timer is enabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>WDOG_TIMER_PRESCALE_3BITS</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>WDP1</NAME>
          <DESCRIPTION>Watch Dog Timer Prescaler bit 1</DESCRIPTION>
          <TEXT>The WDP2,WDP1,and WDP0 bits determine the Watchdog Timer prescaling when the Watchdog Timer is enabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>WDP0</NAME>
          <DESCRIPTION>Watch Dog Timer Prescaler bit 0</DESCRIPTION>
          <TEXT>The WDP2,WDP1,and WDP0 bits determine the Watchdog Timer prescaling when the Watchdog Timer is enabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </WDTCR>
    </WATCHDOG>
    <CPU>
      <LIST>[SREG:SP:MCUCR:MCUSR:OSCCAL]</LIST>
      <LINK/>
      <ICON>io_cpu.com</ICON>
      <ID/>
      <TEXT/>
      <SREG>
        <NAME>SREG</NAME>
        <DESCRIPTION>Status Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$3F</IO_ADDR>
        <MEM_ADDR>$5F</MEM_ADDR>
        <ICON>io_sreg.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>I</NAME>
          <DESCRIPTION>Global Interrupt Enable</DESCRIPTION>
          <TEXT>The global interrupt enable bit must be set (one) for the interrupts to be enabled. The individual interrupt enable control is then performed in separate control registers. If the global interrupt enable bit is cleared (zero), none of the interrupts are enabled independent of the individual interrupt enable settings. The I-bit is cleared by hardware after an interrupt has occurred, and is set by the RETI instruction to enable subsequent interrupts.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>T</NAME>
          <DESCRIPTION>Bit Copy Storage</DESCRIPTION>
          <TEXT>The bit copy instructions BLD (Bit LoaD) and BST (Bit STore) use the T bit as source and destination for the operated bit. A bit from a register in the register file can be copied into T by the BST instruction, and a bit in T can be copied into a bit in a register in the register file by the BLD instruction.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>H</NAME>
          <DESCRIPTION>Half Carry Flag</DESCRIPTION>
          <TEXT>The half carry flag H indicates a half carry in some arithmetic operations. See the Instruction Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>S</NAME>
          <DESCRIPTION>Sign Bit</DESCRIPTION>
          <TEXT>The S-bit is always an exclusive or between the negative flag N and the two&#x2019;s complement overflow flag V. See the Instruc-tion Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>V</NAME>
          <DESCRIPTION>Two's Complement Overflow Flag</DESCRIPTION>
          <TEXT>The two&#x2019;s complement overflow flag V supports two&#x2019;s complement arithmetics. See the Instruction Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>N</NAME>
          <DESCRIPTION>Negative Flag</DESCRIPTION>
          <TEXT>The negative flag N indicates a negative result after the different arithmetic and logic operations. See the Instruction Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>Z</NAME>
          <DESCRIPTION>Zero Flag</DESCRIPTION>
          <TEXT>The zero flag Z indicates a zero result after the different arithmetic and logic operations. See the Instruction Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>C</NAME>
          <DESCRIPTION>Carry Flag</DESCRIPTION>
          <TEXT>The carry flag C indicates a carry in an arithmetic or logic operation. See the Instruction Set Description for detailed information. Note that the status register is not automatically stored when entering an interrupt routine and restored when returning from an interrupt routine. This must be handled by software.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SREG>
      <SP>
        <NAME>SP</NAME>
        <DESCRIPTION>Stack Pointer</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$3D</IO_ADDR>
        <MEM_ADDR>$5D</MEM_ADDR>
        <ICON>io_sreg.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>SP7</NAME>
          <DESCRIPTION>Stack Pointer Bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SP6</NAME>
          <DESCRIPTION>Stack Pointer Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SP5</NAME>
          <DESCRIPTION>Stack Pointer Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SP4</NAME>
          <DESCRIPTION>Stack Pointer Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SP3</NAME>
          <DESCRIPTION>Stack Pointer Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SP2</NAME>
          <DESCRIPTION>Stack Pointer Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SP1</NAME>
          <DESCRIPTION>Stack Pointer Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SP0</NAME>
          <DESCRIPTION>Stack Pointer Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SP>
      <MCUCR>
        <NAME>MCUCR</NAME>
        <DESCRIPTION>MCU Control Register</DESCRIPTION>
        <TEXT>The MCU Control Register contains control bits for general MCU functions.</TEXT>
        <IO_ADDR>$35</IO_ADDR>
        <MEM_ADDR>$55</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT6>
          <NAME>PUD</NAME>
          <DESCRIPTION>Pull-up Disable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SE</NAME>
          <DESCRIPTION>Sleep Enable</DESCRIPTION>
          <TEXT>The SE bit must be set (one) to make the MCU enter the sleep mode when the SLEEP instruction is executed. To avoid the MCU entering the sleep mode unless it is the programmers purpose, it is recommended to set the Sleep Enable SE bit just before the execution of the SLEEP instruction.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SM1</NAME>
          <DESCRIPTION>Sleep Mode Select Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SM0</NAME>
          <DESCRIPTION>Sleep Mode Select Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <ENUM>CPU_SLEEP_MODE</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT1>
          <NAME>ISC01</NAME>
          <DESCRIPTION>Interrupt Sense Control 0 bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ISC00</NAME>
          <DESCRIPTION>Interrupt Sense Control 0 bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <ENUM>INTERRUPT_SENSE_CONTROL2</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </MCUCR>
      <MCUSR>
        <NAME>MCUSR</NAME>
        <DESCRIPTION>MCU Status register</DESCRIPTION>
        <TEXT>The MCU Status Registerprovides information on which reset source caused a MCU reset.</TEXT>
        <IO_ADDR>$34</IO_ADDR>
        <MEM_ADDR>$54</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT3>
          <NAME>WDRF</NAME>
          <DESCRIPTION>Watchdog Reset Flag</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>BORF</NAME>
          <DESCRIPTION>Brown-out Reset Flag</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>EXTRF</NAME>
          <DESCRIPTION>External Reset Flag</DESCRIPTION>
          <TEXT>After a power-on reset, this bit is undefined (X). It will be set by an external reset. A watchdog reset will leave this bit unchanged.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PORF</NAME>
          <DESCRIPTION>Power-On Reset Flag</DESCRIPTION>
          <TEXT>This bit is set by a power-on reset. A watchdog reset or an external reset will leave this bit unchanged</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </MCUSR>
      <OSCCAL>
        <NAME>OSCCAL</NAME>
        <DESCRIPTION>Status Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$31</IO_ADDR>
        <MEM_ADDR>$51</MEM_ADDR>
        <ICON>io_sreg.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>CAL7</NAME>
          <DESCRIPTION>Oscillator Calibration Value Bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>CAL6</NAME>
          <DESCRIPTION>Oscillator Calibration Value Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>CAL5</NAME>
          <DESCRIPTION>Oscillator Calibration Value Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>CAL4</NAME>
          <ALIAS>OSCCAL4</ALIAS>
          <DESCRIPTION>Oscillator Calibration Value Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>CAL3</NAME>
          <ALIAS>OSCCAL3</ALIAS>
          <DESCRIPTION>Oscillator Calibration Value Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CAL2</NAME>
          <ALIAS>OSCCAL2</ALIAS>
          <DESCRIPTION>Oscillator Calibration Value Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CAL1</NAME>
          <ALIAS>OSCCAL1</ALIAS>
          <DESCRIPTION>Oscillator Calibration Value Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CAL0</NAME>
          <ALIAS>OSCCAL0</ALIAS>
          <DESCRIPTION>Oscillator Calibration Value Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OSCCAL>
    </CPU>
    <TIMER_COUNTER_0>
      <LIST>[TIMSK:TIFR:TCCR0:TCNT0]</LIST>
      <LINK/>
      <ICON>io_timer.bmp</ICON>
      <ID>t81</ID>
      <TEXT>The 8-bit Timer/Counter0 can select clock source from CK, prescaled CK, or an external pin. In addition it can be stopped as described in &#x201C;Timer/Counter0 Control Register - TCCR0&#x201D; on page 35. The overflow status flag is found in &#x201C;The Timer/Counter Interrupt Flag Register - TIFR&#x201D; on page 29. Control signals are found in the Timer/Counter0 Control Register - TCCR0. The interrupt enable/disable settings for Timer/Counter0 are found in &#x201C;The Timer/Counter Interrupt Mask Regis-ter - TIMSK&#x201D; on page 28. When Timer/Counter0 is externally clocked, the external signal is synchronized with the oscillator frequency of the CPU. To assure proper sampling of the external clock, the minimum time between two external clock transitions must be at least one internal CPU clock period. The external clock signal is sampled on the rising edge of the internal CPU clock. The 8-bit Timer/Counter0 features both a high resolution and a high accuracy usage with the lower prescaling opportuni-ties. Similarly, the high prescaling opportuni ties make the Timer/Counter0 useful for lower speed functions or exact timing functions with infrequent actions</TEXT>
      <TIMSK>
        <NAME>TIMSK</NAME>
        <DESCRIPTION>Timer/Counter Interrupt Mask Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$39</IO_ADDR>
        <MEM_ADDR>$59</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT1>
          <NAME>TOIE0</NAME>
          <DESCRIPTION>Timer/Counter0 Overflow Interrupt Enable</DESCRIPTION>
          <TEXT>When the TOIE0 bit is set (one) and the I-bit in the Status Register is set (one), the Timer/Counter0 Overflow interrupt is enabled. The corresponding interrupt  is executed if an overflow in Timer/Counter0 occurs, i.e., when the TOV0 bit is set in the Timer/Counter Interrupt Flag Register - TIFR.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
      </TIMSK>
      <TIFR>
        <NAME>TIFR</NAME>
        <DESCRIPTION>Timer/Counter Interrupt Flag register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$38</IO_ADDR>
        <MEM_ADDR>$58</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT1>
          <NAME>TOV0</NAME>
          <DESCRIPTION>Timer/Counter0 Overflow Flag</DESCRIPTION>
          <TEXT>The bit TOV0 is set (one) when an overflow occurs in Timer/Counter0. TOV0 is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, TOV0 is cleared by writing a logic one to the flag. When the SREG I-bit, and TOIE0 (Timer/Counter0 Overflow Interrupt Enable), and TOV0 are set (one), the Timer/Counter0 Overflow interrupt is executed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
      </TIFR>
      <TCCR0>
        <NAME>TCCR0</NAME>
        <DESCRIPTION>Timer/Counter0 Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$33</IO_ADDR>
        <MEM_ADDR>$53</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT3>
          <NAME>PSR0</NAME>
          <DESCRIPTION>Prescaler Reset Timer/Counter0</DESCRIPTION>
          <TEXT>When this bit is set (one), the prescaler of the Timer/Counter0 will be reset. The bit will be cleared by hardware after the operation is performed. Writing a zero to this bit will have no effect. This bit will always be read as zero.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CS02</NAME>
          <DESCRIPTION>Clock Select0 bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CS01</NAME>
          <DESCRIPTION>Clock Select0 bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CS00</NAME>
          <DESCRIPTION>Clock Select0 bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <ENUM>CLK_SEL_3BIT_EXT</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCCR0>
      <TCNT0>
        <NAME>TCNT0</NAME>
        <DESCRIPTION>Timer Counter 0</DESCRIPTION>
        <TEXT>The Timer/Counter0 is realized as an up-counter with read and write access. If the Timer/Counter0 is written and a clock source is present, the Timer/Counter0 continues counting in the clock cycle following the write operation.</TEXT>
        <IO_ADDR>$32</IO_ADDR>
        <MEM_ADDR>$52</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TCNT07</NAME>
          <DESCRIPTION>Timer Counter 0 bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TCNT06</NAME>
          <DESCRIPTION>Timer Counter 0 bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TCNT05</NAME>
          <DESCRIPTION>Timer Counter 0 bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TCNT04</NAME>
          <DESCRIPTION>Timer Counter 0 bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TCNT03</NAME>
          <DESCRIPTION>Timer Counter 0 bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TCNT02</NAME>
          <DESCRIPTION>Timer Counter 0 bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TCNT01</NAME>
          <DESCRIPTION>Timer Counter 0 bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TCNT00</NAME>
          <DESCRIPTION>Timer Counter 0 bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCNT0>
    </TIMER_COUNTER_0>
    <TIMER_COUNTER_1>
      <LIST>[TCCR1A:TCCR1B:TCNT1:OCR1A:OCR1B:OCR1C:TIMSK:TIFR:PLLCSR]</LIST>
      <LINK/>
      <ICON>io_timer.bmp</ICON>
      <ID>t8pwm1_00</ID>
      <TEXT/>
      <TCCR1A>
        <NAME>TCCR1A</NAME>
        <DESCRIPTION>Timer/Counter Control Register A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$30</IO_ADDR>
        <MEM_ADDR>$50</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>COM1A1</NAME>
          <DESCRIPTION>Comparator A Output Mode Bit 1</DESCRIPTION>
          <TEXT>The COM1A1 and COM1A0 control bits determine any output pin action following a compare match with compare register A in Timer/Counter1. Output pin actions affect pin PB1 (OC1A). Since this is an alternative function to an I/O port, the corresponding direction control bit must be set (one) in order to control an output pin. Note that OC1A is not connected in normal mode.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>COM1A0</NAME>
          <DESCRIPTION>Comparator A Output Mode Bit 0</DESCRIPTION>
          <TEXT>The COM1A1 and COM1A0 control bits determine any output pin action following a compare match with compare register A in Timer/Counter1. Output pin actions affect pin PB1 (OC1A). Since this is an alternative function to an I/O port, the corresponding direction control bit must be set (one) in order to control an output pin. Note that OC1A is not connected in normal mode.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>CLK_COMP_MATCH_OUT_MODE</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>COM1B1</NAME>
          <DESCRIPTION>Comparator B Output Mode Bit 1</DESCRIPTION>
          <TEXT>The COM1B1 and COM1B0 control bits determine any output pin action following a compare match with compare register B in Timer/Counter1. Output pin actions affect pin PB3 (OC1B). Since this is an alternative function to an I/O port, the corresponding direction control bit must be set (one) in order to control an output pin. Note that OC1B is not connected in normal mode.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>COM1B0</NAME>
          <DESCRIPTION>Comparator B Output Mode Bit 0</DESCRIPTION>
          <TEXT>The COM1B1 and COM1B0 control bits determine any output pin action following a compare match with compare register B in Timer/Counter1. Output pin actions affect pin PB3 (OC1B). Since this is an alternative function to an I/O port, the corresponding direction control bit must be set (one) in order to control an output pin. Note that OC1B is not connected in normal mode.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>CLK_COMP_MATCH_OUT_MODE</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>FOC1A</NAME>
          <DESCRIPTION>Force Output Compare Match 1A</DESCRIPTION>
          <TEXT>Writing a logical one to this bit forces a change in the compare match output pin PB1 (OC1A) according to the values already set in COM1A1 and COM1A0. If COM1A1 and COM1A0 written in the same cycle as FOC1A, the new settings will be used. The Force Output Compare bit can be used to change the output pin value regardless of the timer value. The automatic action programmed in COM1A1 and COM1A0 takes place as if a compare match had occurred, but no interrupt is generated. The FOC1A bit always reads as zero. FOC1A is not in use if PWM1A bit is</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>FOC1B</NAME>
          <DESCRIPTION>Force Output Compare Match 1B</DESCRIPTION>
          <TEXT>Writing a logical one to this bit forces a change in the compare match output pin PB3 (OC1B) according to the values already set in COM1B1 and COM1B0. If COM1B1 and COM1B0 written in the same cycle as FOC1B, the new settings will be used. The Force Output Compare bit can be used to change the output pin value regardless of the timer value. The automatic action programmed in COM1B1 and COM1B0 takes place as if a compare match had occurred, but no interrupt is generated. The FOC1B bit always reads as zero. FOC1B is not in use if PWM1B bit is set</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PWM1A</NAME>
          <DESCRIPTION>Pulse Width Modulator A Enable</DESCRIPTION>
          <TEXT>When set (one) this bit enables PWM mode based on comparator OCR1A in Timer/Counter1 and the counter value is reset to $00 in the CPU clock cycle after a compare match with OCR1C register value.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PWM1B</NAME>
          <DESCRIPTION>Pulse Width Modulator B Enable</DESCRIPTION>
          <TEXT>When set (one) this bit enables PWM mode based on comparator OCR1B in Timer/Counter1 and the counter value is reset to $00 in the CPU clock cycle after a compare match with OCR1C register value.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCCR1A>
      <TCCR1B>
        <NAME>TCCR1B</NAME>
        <DESCRIPTION>Timer/Counter Control Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$2F</IO_ADDR>
        <MEM_ADDR>$4F</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>CTC1</NAME>
          <DESCRIPTION>Clear Timer/Counter on Compare Match</DESCRIPTION>
          <TEXT>When the CTC1 control bit is set (one), Timer/Counter1 is reset to $00 in the CPU clock cycle after a compare match with OCR1C register value. If the control bit is cleared, Timer/Counter1 continues counting and is unaffected by a compare match.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PSR1</NAME>
          <DESCRIPTION>Prescaler Reset Timer/Counter1</DESCRIPTION>
          <TEXT>When this bit is set (one), the Timer/Counter prescaler will be reset. The bit will be cleared by hardware after the operation is performed. Writing a zero to this bit will have no effect. This bit will always read as zero.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT3>
          <NAME>CS13</NAME>
          <DESCRIPTION>Clock Select Bits</DESCRIPTION>
          <TEXT>The Clock Select bits 3, 2, 1, and 0 define the prescaling source of Timer/Counter1.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CS12</NAME>
          <DESCRIPTION>Clock Select Bits</DESCRIPTION>
          <TEXT>The Clock Select bits 3, 2, 1, and 0 define the prescaling source of Timer/Counter1.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CS11</NAME>
          <DESCRIPTION>Clock Select Bits</DESCRIPTION>
          <TEXT>The Clock Select bits 3, 2, 1, and 0 define the prescaling source of Timer/Counter1.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CS10</NAME>
          <DESCRIPTION>Clock Select Bits</DESCRIPTION>
          <TEXT>The Clock Select bits 3, 2, 1, and 0 define the prescaling source of Timer/Counter1.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>CLK_SEL_4BIT</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCCR1B>
      <TCNT1>
        <NAME>TCNT1</NAME>
        <DESCRIPTION>Timer/Counter Register</DESCRIPTION>
        <TEXT>The Timer/Counter Register gives direct access, both for read and write operations, to the Timer/Counter unit 8-bit counter. Writing to the TCNT1 register blocks (removes) the compare match on the following timer clock. Modifying the counter (TCNT1) while the counter is running, introduces a risk of missing a compare match between TCNT1 the OCR2 register. </TEXT>
        <IO_ADDR>$2E</IO_ADDR>
        <MEM_ADDR>$4E</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TCNT1_7</NAME>
          <DESCRIPTION>Timer/Counter Register Bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TCNT1_6</NAME>
          <DESCRIPTION>Timer/Counter Register Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TCNT1_5</NAME>
          <DESCRIPTION>Timer/Counter Register Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TCNT1_4</NAME>
          <DESCRIPTION>Timer/Counter Register Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TCNT1_3</NAME>
          <DESCRIPTION>Timer/Counter Register Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TCNT1_2</NAME>
          <DESCRIPTION>Timer/Counter Register Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TCNT1_1</NAME>
          <DESCRIPTION>Timer/Counter Register Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TCNT1_0</NAME>
          <DESCRIPTION>Timer/Counter Register Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCNT1>
      <OCR1A>
        <NAME>OCR1A</NAME>
        <DESCRIPTION>Output Compare Register</DESCRIPTION>
        <TEXT>The Output Compare Register contains an 8-bit value that is continuously compared with the counter value (TCNT1). A match can be used to generate an output compare interrupt, or to generate a waveform output on the OC2 pin.</TEXT>
        <IO_ADDR>$2D</IO_ADDR>
        <MEM_ADDR>$4D</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR1A7</NAME>
          <DESCRIPTION>Output Compare Register A Bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR1A6</NAME>
          <DESCRIPTION>Output Compare Register A Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR1A5</NAME>
          <DESCRIPTION>Output Compare Register A Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR1A4</NAME>
          <DESCRIPTION>Output Compare Register A Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR1A3</NAME>
          <DESCRIPTION>Output Compare Register A Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR1A2</NAME>
          <DESCRIPTION>Output Compare Register A Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR1A1</NAME>
          <DESCRIPTION>Output Compare Register A Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR1A0</NAME>
          <DESCRIPTION>Output Compare Register A Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCR1A>
      <OCR1B>
        <NAME>OCR1B</NAME>
        <DESCRIPTION>Output Compare Register</DESCRIPTION>
        <TEXT>The Output Compare Register contains an 8-bit value that is continuously compared with the counter value (TCNT1). A match can be used to generate an output compare interrupt, or to generate a waveform output on the OC2 pin.</TEXT>
        <IO_ADDR>$2C</IO_ADDR>
        <MEM_ADDR>$4C</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR1B7</NAME>
          <DESCRIPTION>Output Compare Register B Bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR1B6</NAME>
          <DESCRIPTION>Output Compare Register B Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR1B5</NAME>
          <DESCRIPTION>Output Compare Register B Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR1B4</NAME>
          <DESCRIPTION>Output Compare Register B Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR1B3</NAME>
          <DESCRIPTION>Output Compare Register B Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR1B2</NAME>
          <DESCRIPTION>Output Compare Register B Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR1B1</NAME>
          <DESCRIPTION>Output Compare Register B Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR1B0</NAME>
          <DESCRIPTION>Output Compare Register B Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCR1B>
      <OCR1C>
        <NAME>OCR1C</NAME>
        <DESCRIPTION>Output Compare Register</DESCRIPTION>
        <TEXT>The Output Compare Register contains an 8-bit value that is continuously compared with the counter value (TCNT1). A match can be used to generate an output compare interrupt, or to generate a waveform output on the OC2 pin.</TEXT>
        <IO_ADDR>$2B</IO_ADDR>
        <MEM_ADDR>$4B</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR1C7</NAME>
          <DESCRIPTION>Output Compare Register C Bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR1C6</NAME>
          <DESCRIPTION>Output Compare Register C Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR1C5</NAME>
          <DESCRIPTION>Output Compare Register C Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR1C4</NAME>
          <DESCRIPTION>Output Compare Register C Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR1C3</NAME>
          <DESCRIPTION>Output Compare Register C Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR1C2</NAME>
          <DESCRIPTION>Output Compare Register C Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR1C1</NAME>
          <DESCRIPTION>Output Compare Register C Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR1C0</NAME>
          <DESCRIPTION>Output Compare Register C Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCR1C>
      <TIMSK>
        <NAME>TIMSK</NAME>
        <DESCRIPTION>Timer/Counter Interrupt Mask Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$39</IO_ADDR>
        <MEM_ADDR>$59</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT6>
          <NAME>OCIE1A</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Interrupt Enable</DESCRIPTION>
          <TEXT>When the OCIE1A bit is set (one) and the I-bit in the Status Register is set (one), the Timer/Counter1 Compare MatchA, interrupt is enabled. The corresponding interrupt at vector $003 is executed if a compare matchA occurs. The Compare Flag in Timer/Counter1 is set (one) in the Timer/Counter Interrupt Flag Register.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCIE1B</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Interrupt Enable</DESCRIPTION>
          <TEXT>When the OCIE1B bit is set (one) and the I-bit in the Status Register is set (one), the Timer/Counter1 Compare MatchB, interrupt is enabled. The corresponding interrupt at vector $004 is executed if a compare matchB occurs. The Compare Flag in Timer/Counter1 is set (one) in the Timer/Counter Interrupt Flag Register.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT2>
          <NAME>TOIE1</NAME>
          <DESCRIPTION>Timer/Counter1 Overflow Interrupt Enable</DESCRIPTION>
          <TEXT>When the TOIE1 bit is set (one) and the I-bit in the Status Register is set (one), the Timer/Counter1 Overflow interrupt is enabled. The corresponding interrupt (at vector $004) is executed if an overflow in Timer/Counter1 occurs (i.e., when the TOV1 bit is set in the Timer/Counter Interrupt Flag Register [TIFR]).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
      </TIMSK>
      <TIFR>
        <NAME>TIFR</NAME>
        <DESCRIPTION>Timer/Counter Interrupt Flag Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$38</IO_ADDR>
        <MEM_ADDR>$58</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT6>
          <NAME>OCF1A</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Flag 1A</DESCRIPTION>
          <TEXT>The OCF1A bit is set (one) when compare match occurs between Timer/Counter1 and the data value in OCR1A (Output Compare Register 1A). OCF1A is cleared by hard-ware when executing the corresponding interrupt handling vector. Alternatively, OCF1A is cleared by writing a logical &#x201C;1&#x201D; to the flag. When the I-bit in SREG, OCIE1A, and OCF1A are set (one), the Timer/Counter1 compare match A interrupt is executed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCF1B</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Flag 1B</DESCRIPTION>
          <TEXT>The OCF1B bit is set (one) when compare match occurs between Timer/Counter1 and the data value in OCR1B &#x2013; Output Compare Register 1A. OCF1B is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, OCF1B is cleared, after synchronization clock cycle, by writing a logic one to the flag. When the I-bit in SREG, OCIE1B, and OCF1B are set (one), the Timer/Counter1 B compare match interrupt is executed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT2>
          <NAME>TOV1</NAME>
          <DESCRIPTION>Timer/Counter1 Overflow Flag</DESCRIPTION>
          <TEXT>The bit TOV1 is set (one) when an overflow occurs in Timer/Counter1. TOV1 is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, TOV1 is cleared by writing a logical &#x201C;1&#x201D; to the flag. When the SREG I-bit, TOIE1 (Timer/Counter1 Overf low Interrupt Enable) and TOV1 are set (one), the Timer/Counter1 Overflow interrupt is executed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
      </TIFR>
      <PLLCSR>
        <NAME>PLLCSR</NAME>
        <DESCRIPTION>PLL Control and Status Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$29</IO_ADDR>
        <MEM_ADDR>$49</MEM_ADDR>
        <ICON>io_sreg.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT2>
          <NAME>PCKE</NAME>
          <DESCRIPTION>PCK Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PLLE</NAME>
          <DESCRIPTION>PLL Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PLOCK</NAME>
          <DESCRIPTION>PLL Lock Detector</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PLLCSR>
    </TIMER_COUNTER_1>
    <EXTERNAL_INTERRUPT>
      <LIST>[GIMSK:GIFR]</LIST>
      <LINK/>
      <ICON>io_ext.bmp</ICON>
      <ID/>
      <TEXT/>
      <GIMSK>
        <NAME>GIMSK</NAME>
        <DESCRIPTION>General Interrupt Mask Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$3B</IO_ADDR>
        <MEM_ADDR>$5B</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT6>
          <NAME>INT0</NAME>
          <DESCRIPTION>External Interrupt Request 0 Enable</DESCRIPTION>
          <TEXT>When the INT0 bit is set (one) and the I-bit in the Status Register (SREG) is set (one), the external pin interrupt is enabled. The Interrupt Sense Control0 bits 1/0 (ISC01 and ISC00) in the MCU general Control Register (MCUCR) defines whether the external interrupt is activated on rising or falling edge of the INT0 pin or level sensed. Activity on the pin will cause an interrupt request even if INT0 is configured as an output. The corresponding interrupt of External Interrupt Request 0 is executed from program memory address $001. See also &#x201C;External Interrupts.&#x201D; &#x2022; Bits 5..0 - Res: Reserved bits</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PCIE1</NAME>
          <DESCRIPTION>Pin Change Interrupt Enable 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PCIE0</NAME>
          <DESCRIPTION>Pin Change Interrupt Enable 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
      </GIMSK>
      <GIFR>
        <NAME>GIFR</NAME>
        <DESCRIPTION>General Interrupt Flag register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$3A</IO_ADDR>
        <MEM_ADDR>$5A</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT6>
          <NAME>INTF0</NAME>
          <DESCRIPTION>External Interrupt Flag 0</DESCRIPTION>
          <TEXT>When an event on the INT0 pin triggers an interrupt request, INTF0 becomes set (one). If the I-bit in SREG and the INT0 bit in GIMSK are set (one), the MCU will jump to the interrupt vector at address $001. The flag is cleared when the interrupt routine is executed. Alternatively, the flag can be cleared by writing a logical one to it. </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PCIF</NAME>
          <DESCRIPTION>Pin Change Interrupt Flag</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
      </GIFR>
    </EXTERNAL_INTERRUPT>
  </IO_MODULE>
  <ICE_SETTINGS>
    <MODULE_LIST>[ICE50:SIMULATOR:STK500:STK500_2:AVRISPmkII:AVRDragon:STK600:SIMULATOR2]</MODULE_LIST>
    <ICE50>
      <MMU_ACCESS>
        <MemTypeSram8Bit>0x05</MemTypeSram8Bit>
        <MemTypeSram16Bit>0x0F</MemTypeSram16Bit>
        <MemTypeSramShdw8Bit>0x0F</MemTypeSramShdw8Bit>
        <MemTypeSramShdw16Bit>0x0F</MemTypeSramShdw16Bit>
        <MemTypeEeprom>0x05</MemTypeEeprom>
        <MemTypeProgram>0x05</MemTypeProgram>
        <MemTypePrgEventBreak>0x05</MemTypePrgEventBreak>
        <MemTypePrgEventTrigOut>0x05</MemTypePrgEventTrigOut>
        <MemTypePrgEventTraceCtrl>0x05</MemTypePrgEventTraceCtrl>
        <MemTypePrgEventComplex>0x05</MemTypePrgEventComplex>
        <MemTypeSramEventLow>0x05</MemTypeSramEventLow>
        <MemTypeSramEventHigh>0x05</MemTypeSramEventHigh>
        <MemTypeEepromEvent>0x05</MemTypeEepromEvent>
        <MemTypeRegisterEvent>0x0F</MemTypeRegisterEvent>
        <MemTypeIoEvent>0x0F</MemTypeIoEvent>
        <MemTypePreTrace>0x0F</MemTypePreTrace>
        <MemTypeTrace>0x15</MemTypeTrace>
        <MemTypeCoreShdw>0x14</MemTypeCoreShdw>
        <MemTypeCoreMem>0x14</MemTypeCoreMem>
      </MMU_ACCESS>
      <MMU_NOXRAM>
        <MemTypeSram8Bit>0x000000DF</MemTypeSram8Bit>
        <MemTypeSram16Bit>0x00000000</MemTypeSram16Bit>
        <MemTypeSramShdw8Bit>0x00000000</MemTypeSramShdw8Bit>
        <MemTypeSramShdw16Bit>0x00000000</MemTypeSramShdw16Bit>
        <MemTypeEeprom>0x0000007F</MemTypeEeprom>
        <MemTypeProgram>0x000007FF</MemTypeProgram>
        <MemTypePrgEventBreak>0x000003FF</MemTypePrgEventBreak>
        <MemTypePrgEventTrigOut>0x000003FF</MemTypePrgEventTrigOut>
        <MemTypePrgEventTraceCtrl>0x000003FF</MemTypePrgEventTraceCtrl>
        <MemTypePrgEventComplex>0x000003FF</MemTypePrgEventComplex>
        <MemTypeSramEventLow>0x000000DF</MemTypeSramEventLow>
        <MemTypeSramEventHigh>0x0000FFFF</MemTypeSramEventHigh>
        <MemTypeEepromEvent>0x0000007F</MemTypeEepromEvent>
        <MemTypeRegisterEvent>0x00000000</MemTypeRegisterEvent>
        <MemTypeIoEvent>0x00000000</MemTypeIoEvent>
        <MemTypePreTrace>0x00000000</MemTypePreTrace>
        <MemTypeTrace>0x0023FFFF</MemTypeTrace>
        <MemTypeCoreShdw>0x00000FFF</MemTypeCoreShdw>
        <MemTypeCoreMem>0x00000060</MemTypeCoreMem>
      </MMU_NOXRAM>
      <MMU_EMULATED>
        <MemTypeSram8Bit>0x00000000</MemTypeSram8Bit>
        <MemTypeSram16Bit>0x00000000</MemTypeSram16Bit>
        <MemTypeSramShdw8Bit>0x00000000</MemTypeSramShdw8Bit>
        <MemTypeSramShdw16Bit>0x00000000</MemTypeSramShdw16Bit>
        <MemTypeEeprom>0x0000007F</MemTypeEeprom>
        <MemTypeProgram>0x000007FF</MemTypeProgram>
        <MemTypePrgEventBreak>0x000003FF</MemTypePrgEventBreak>
        <MemTypePrgEventTrigOut>0x000003FF</MemTypePrgEventTrigOut>
        <MemTypePrgEventTraceCtrl>0x000003FF</MemTypePrgEventTraceCtrl>
        <MemTypePrgEventComplex>0x000003FF</MemTypePrgEventComplex>
        <MemTypeSramEventLow>0x000000DF</MemTypeSramEventLow>
        <MemTypeSramEventHigh>0x0000FFFF</MemTypeSramEventHigh>
        <MemTypeEepromEvent>0x0000007F</MemTypeEepromEvent>
        <MemTypeRegisterEvent>0x00000000</MemTypeRegisterEvent>
        <MemTypeIoEvent>0x00000000</MemTypeIoEvent>
        <MemTypePreTrace>0x00000000</MemTypePreTrace>
        <MemTypeTrace>0x0023FFFF</MemTypeTrace>
        <MemTypeCoreShdw>0x00000FFF</MemTypeCoreShdw>
        <MemTypeCoreMem>0x00000060</MemTypeCoreMem>
      </MMU_EMULATED>
      <MMU_XRAMIF>
        <MemTypeSram8Bit>0x00000000</MemTypeSram8Bit>
        <MemTypeSram16Bit>0x00000000</MemTypeSram16Bit>
        <MemTypeSramShdw8Bit>0x00000000</MemTypeSramShdw8Bit>
        <MemTypeSramShdw16Bit>0x00000000</MemTypeSramShdw16Bit>
        <MemTypeEeprom>0x0000007F</MemTypeEeprom>
        <MemTypeProgram>0x000007FF</MemTypeProgram>
        <MemTypePrgEventBreak>0x000003FF</MemTypePrgEventBreak>
        <MemTypePrgEventTrigOut>0x000003FF</MemTypePrgEventTrigOut>
        <MemTypePrgEventTraceCtrl>0x000003FF</MemTypePrgEventTraceCtrl>
        <MemTypePrgEventComplex>0x000003FF</MemTypePrgEventComplex>
        <MemTypeSramEventLow>0x000000DF</MemTypeSramEventLow>
        <MemTypeSramEventHigh>0x0000FFFF</MemTypeSramEventHigh>
        <MemTypeEepromEvent>0x0000007F</MemTypeEepromEvent>
        <MemTypeRegisterEvent>0x00000000</MemTypeRegisterEvent>
        <MemTypeIoEvent>0x00000000</MemTypeIoEvent>
        <MemTypePreTrace>0x00000000</MemTypePreTrace>
        <MemTypeTrace>0x0023FFFF</MemTypeTrace>
        <MemTypeCoreShdw>0x00000FFF</MemTypeCoreShdw>
        <MemTypeCoreMem>0x000000000</MemTypeCoreMem>
      </MMU_XRAMIF>
      <TABLE_RCOSC>
        <MHZ8>0x00</MHZ8>
        <MHZ4>0x00</MHZ4>
        <MHZ2>0x00</MHZ2>
        <MHZ1>0x00</MHZ1>
      </TABLE_RCOSC>
      <DEFAULT_SETTINGS>
        <HighFuse>0xF7</HighFuse>
        <LowFuse>0xE1</LowFuse>
        <Lockbit>0xff</Lockbit>
        <ADDROSC>0x51</ADDROSC>
        <VALOSC>0xc7</VALOSC>
        <BINFILE>ATtiny26.bin</BINFILE>
        <PARAM_MMU_DMEM_PARTION>0x02</PARAM_MMU_DMEM_PARTION>
        <PARAM_MMU_MEMCFG>0x00</PARAM_MMU_MEMCFG>
        <FREQUENCY>1000000</FREQUENCY>
        <MAXFREQUENCY>40000000</MAXFREQUENCY>
        <MINFREQUENCY>7</MINFREQUENCY>
        <CLOCK>2  ; INTOSC = 1, INTRC=2;EXTCLK=4</CLOCK>
        <TIMEROSC>1    ;NOTUSE = 1, EXTERNAL = 4, INTERNAL = 2 </TIMEROSC>
        <XTAL2SOURCING>1 </XTAL2SOURCING>
        <PARAM_AVR_RMR>0</PARAM_AVR_RMR>
        <XRAMENABLE>0x00</XRAMENABLE>
        <XRAMOTHER>0x01</XRAMOTHER>
        <PARAM_POD_VREFSELCONFIG>0x01</PARAM_POD_VREFSELCONFIG>
        <PARAM_POD_ADMUXCONFIG>0x02</PARAM_POD_ADMUXCONFIG>
        <PARAM_OSC_WD_FREQ>0x80E8</PARAM_OSC_WD_FREQ>
      </DEFAULT_SETTINGS>
      <SETTINGS>
        <CLOCK>
          <STARTUP>
            <INTOSC>
              <OPT1>
                <LFMASK>0x00000031</LFMASK>
                <LFBITS>0x00000000</LFBITS>
                <TEXT>258 CK, 4.1 ms </TEXT>
              </OPT1>
              <OPT2>
                <LFMASK>0x00000031</LFMASK>
                <LFBITS>0x00000010</LFBITS>
                <TEXT>258 CK, 65 ms</TEXT>
              </OPT2>
              <OPT3>
                <LFMASK>0x00000031</LFMASK>
                <LFBITS>0x00000020</LFBITS>
                <TEXT>1K CK</TEXT>
              </OPT3>
              <OPT4>
                <LFMASK>0x00000031</LFMASK>
                <LFBITS>0x00000030</LFBITS>
                <TEXT>1K CK, 4.1 ms</TEXT>
              </OPT4>
              <OPT5>
                <LFMASK>0x00000031</LFMASK>
                <LFBITS>0x00000001</LFBITS>
                <TEXT>1K CK, 65 ms</TEXT>
              </OPT5>
              <OPT6>
                <LFMASK>0x00000031</LFMASK>
                <LFBITS>0x00000011</LFBITS>
                <TEXT>16K CK</TEXT>
              </OPT6>
              <OPT7>
                <LFMASK>0x00000031</LFMASK>
                <LFBITS>0x00000021</LFBITS>
                <TEXT>16K CK, 4.1 ms</TEXT>
              </OPT7>
              <OPT8>
                <LFMASK>0x00000031</LFMASK>
                <LFBITS>0x00000031</LFBITS>
                <TEXT>16K CK, 65 ms</TEXT>
              </OPT8>
            </INTOSC>
            <INTRC>
              <OPT1>
                <LFMASK>0x00000030</LFMASK>
                <LFBITS>0x00000000</LFBITS>
                <TEXT>6 CK</TEXT>
              </OPT1>
              <OPT2>
                <LFMASK>0x00000030</LFMASK>
                <LFBITS>0x00000010</LFBITS>
                <TEXT>6 CK, 4.1 ms</TEXT>
              </OPT2>
              <OPT3>
                <LFMASK>0x00000030</LFMASK>
                <LFBITS>0x00000020</LFBITS>
                <TEXT>6 CK, 65 ms</TEXT>
              </OPT3>
            </INTRC>
            <EXTCLK>
              <OPT1>
                <LFMASK>0x00000030</LFMASK>
                <LFBITS>0x00000000</LFBITS>
                <TEXT>6 CK</TEXT>
              </OPT1>
              <OPT2>
                <LFMASK>0x00000030</LFMASK>
                <LFBITS>0x00000010</LFBITS>
                <TEXT>6 CK, 4.1 ms</TEXT>
              </OPT2>
              <OPT3>
                <LFMASK>0x00000030</LFMASK>
                <LFBITS>0x00000020</LFBITS>
                <TEXT>6 CK, 65 ms</TEXT>
              </OPT3>
            </EXTCLK>
            <PLLCLK>
              <OPT1>
                <LFMASK>0x00000030</LFMASK>
                <LFBITS>0x00000000</LFBITS>
                <TEXT>1K CK</TEXT>
              </OPT1>
              <OPT2>
                <LFMASK>0x00000030</LFMASK>
                <LFBITS>0x00000010</LFBITS>
                <TEXT>1K CK, 4.1 ms</TEXT>
              </OPT2>
              <OPT3>
                <LFMASK>0x00000030</LFMASK>
                <LFBITS>0x00000020</LFBITS>
                <TEXT>1K CK, 65 ms</TEXT>
              </OPT3>
              <OPT4>
                <LFMASK>0x00000030</LFMASK>
                <LFBITS>0x00000030</LFBITS>
                <TEXT>16K CK</TEXT>
              </OPT4>
            </PLLCLK>
          </STARTUP>
          <CLOCK>
            <INTOSC>
              <LFMASK>0x000000ff</LFMASK>
              <LFBITS>0x000000Ab</LFBITS>
            </INTOSC>
            <INTRC>
              <OPT1>
                <LFMASK>0x000000ff</LFMASK>
                <LFBITS>0x000000E1</LFBITS>
                <TEXT>1.0</TEXT>
              </OPT1>
              <OPT2>
                <LFMASK>0x000000ff</LFMASK>
                <LFBITS>0x000000E2</LFBITS>
                <TEXT>2.0</TEXT>
              </OPT2>
              <OPT3>
                <LFMASK>0x000000ff</LFMASK>
                <LFBITS>0x000000E3</LFBITS>
                <TEXT>4.0</TEXT>
              </OPT3>
              <OPT4>
                <LFMASK>0x000000ff</LFMASK>
                <LFBITS>0x000000E4</LFBITS>
                <TEXT>8.0</TEXT>
              </OPT4>
            </INTRC>
            <EXTCLK>
              <LFMASK>0x000000ff</LFMASK>
              <LFBITS>0x000000E0</LFBITS>
            </EXTCLK>
            <PLLCLK>
              <LFMASK>0x000000ff</LFMASK>
              <LFBITS>0x00000020</LFBITS>
            </PLLCLK>
          </CLOCK>
        </CLOCK>
        <RSTDISABLE>
          <TRUE>
            <LFMASK>0x00001000</LFMASK>
            <LFBITS>0x00000000</LFBITS>
            <TEXT>RSTDSBL Fuse </TEXT>
          </TRUE>
          <FALSE>
            <LFMASK>0x00001000</LFMASK>
            <LFBITS>0x00001000</LFBITS>
            <TEXT>RSTDSBL Fuse </TEXT>
          </FALSE>
        </RSTDISABLE>
        <BOD>
          <OPT1>
            <LFMASK>0x00000300</LFMASK>
            <LFBITS>0x00000300</LFBITS>
            <TEXT>BOD disabled</TEXT>
          </OPT1>
          <OPT2>
            <LFMASK>0x00000300</LFMASK>
            <LFBITS>0x00000200</LFBITS>
            <TEXT>BOD enabled, 2.7 V</TEXT>
          </OPT2>
          <OPT3>
            <LFMASK>0x00000300</LFMASK>
            <LFBITS>0x00000000</LFBITS>
            <TEXT>BOD enabled, 4.0 V</TEXT>
          </OPT3>
        </BOD>
      </SETTINGS>
    </ICE50>
    <SIMULATOR>
      <CoreID>AVRSimCoreV2.SimCoreV2</CoreID>
      <MemoryID>AVRSimMemory8bit.SimMemory8bit</MemoryID>
      <InterruptID>AVRSimInterrupt.SimInterrupt</InterruptID>
      <EEINTERRUPT>0x09</EEINTERRUPT>
      <EEAR_EXTRA_BIT>0</EEAR_EXTRA_BIT>
      <NmbIOModules>9</NmbIOModules>
      <PORTA>
        <ID>AVRSimIOPort.SimIOPort</ID>
        <TOGGLE_PIN>N</TOGGLE_PIN>
      </PORTA>
      <PORTB>
        <ID>AVRSimIOPort.SimIOPort</ID>
        <TOGGLE_PIN>N</TOGGLE_PIN>
      </PORTB>
      <EXTINT0>
        <ID>AVRSimIOExtInterrupt.SimIOExtInterrupt</ID>
        <IntVector>0x01</IntVector>
        <EnableIOAdr>0x3B</EnableIOAdr>
        <EnableMask>0x0x40</EnableMask>
        <FlagIOAdr>0x3A</FlagIOAdr>
        <FlagMask>0x40</FlagMask>
        <ExtPinIOAdr>0x16</ExtPinIOAdr>
        <ExtPinMask>0x40</ExtPinMask>
        <SenseIOAdr>0x35</SenseIOAdr>
        <SenseMask>0x03</SenseMask>
      </EXTINT0>
      <PININT0>
        <ID>AVRSimIOPinChangeT26.SimIOPinChangeT26</ID>
        <IntVector>0x02</IntVector>
        <EnableIOAdr>0x3B</EnableIOAdr>
        <EnableMask0>0x10</EnableMask0>
        <EnableMask1>0x20</EnableMask1>
        <FlagIOAdr>0x3A</FlagIOAdr>
        <FlagMask1>0x20</FlagMask1>
        <FlagMask0>0x10</FlagMask0>
        <ExtPinIOAdr10>0x16</ExtPinIOAdr10>
        <ExtPinMask10>0xf0</ExtPinMask10>
        <ExtPinIOAdr11>0x19</ExtPinIOAdr11>
        <ExtPinMask11>0xc8</ExtPinMask11>
        <ExtPinIOAdr0>0x16</ExtPinIOAdr0>
        <ExtPinMask0>0x0f</ExtPinMask0>
      </PININT0>
      <TIMER0>
        <ID>AVRSimIOTimert81.SimIOTimert81</ID>
        <IntVector>0x06</IntVector>
        <ExtPinIOAdr>0x16</ExtPinIOAdr>
        <ExtPinMask>0x40</ExtPinMask>
      </TIMER0>
      <TIMER1>
        <ID>AVRSimIOTimer8pll_OCABC.SimIOTimer8pll_OCABC</ID>
        <CompAVector>0x03</CompAVector>
        <CompBVector>0x04</CompBVector>
        <OvfVector>0x05</OvfVector>
        <OutputAdr>0x16</OutputAdr>
        <DirectionAdr>0x17</DirectionAdr>
        <OutputAMask>0x02</OutputAMask>
        <OutputBMask>0x08</OutputBMask>
        <OutputAMaskNeg>0x01</OutputAMaskNeg>
        <OutputBMaskNeg>0x04</OutputBMaskNeg>
      </TIMER1>
      <ANALOGCOMP>
        <ID>AVRSimAC.SimIOAC</ID>
        <IntVector>0x0A</IntVector>
      </ANALOGCOMP>
      <ADC>
        <ID>AvrSimADC.SimADC</ID>
        <IntVector>0x0B</IntVector>
      </ADC>
      <USI>
        <ID>AvrSimUSI.SimUSI</ID>
        <OvfVector>0x08</OvfVector>
        <StartVector>0x07</StartVector>
      </USI>
      <DEFAULT_SETTINGS>
        <HighFuse>0xff</HighFuse>
        <ExtendedFuse>0xff</ExtendedFuse>
        <LowFuse>0xff</LowFuse>
        <Lockbit>0xff</Lockbit>
      </DEFAULT_SETTINGS>
    </SIMULATOR>
    <STK500>
      <DeviceId>0x21</DeviceId>
      <SelfTimed>1</SelfTimed>
      <FullParallel>1</FullParallel>
      <Polled>1</Polled>
      <FPoll>0xFF</FPoll>
      <EPol1>0xFF</EPol1>
      <EPol2>0xFF</EPol2>
      <ComLockFuseRead>0</ComLockFuseRead>
      <ResetDisable>1</ResetDisable>
    </STK500>
    <STK500_2>
      <IspEnterProgMode>
        <timeout>200</timeout>
        <stabDelay>100</stabDelay>
        <cmdexeDelay>25</cmdexeDelay>
        <synchLoops>32</synchLoops>
        <byteDelay>0</byteDelay>
        <pollIndex>3</pollIndex>
        <pollValue>0x53</pollValue>
      </IspEnterProgMode>
      <IspLeaveProgMode>
        <preDelay>1</preDelay>
        <postDelay>1</postDelay>
      </IspLeaveProgMode>
      <IspChipErase>
        <eraseDelay>20</eraseDelay>
        <pollMethod>0</pollMethod>
      </IspChipErase>
      <IspProgramFlash>
        <mode>0x21</mode>
        <blockSize>16</blockSize>
        <delay>10</delay>
        <cmd1>0x40</cmd1>
        <cmd2>0x4C</cmd2>
        <cmd3>0x20</cmd3>
        <pollVal1>0xFF</pollVal1>
        <pollVal2>0x00</pollVal2>
      </IspProgramFlash>
      <IspProgramEeprom>
        <mode>0x04</mode>
        <blockSize>64</blockSize>
        <delay>20</delay>
        <cmd1>0xC0</cmd1>
        <cmd2>0x00</cmd2>
        <cmd3>0xA0</cmd3>
        <pollVal1>0xFF</pollVal1>
        <pollVal2>0xFF</pollVal2>
      </IspProgramEeprom>
      <IspReadFlash>
        <blockSize>256</blockSize>
      </IspReadFlash>
      <IspReadEeprom>
        <blockSize>256</blockSize>
      </IspReadEeprom>
      <IspReadFuse>
        <pollIndex>4</pollIndex>
      </IspReadFuse>
      <IspReadLock>
        <pollIndex>4</pollIndex>
      </IspReadLock>
      <IspReadSign>
        <pollIndex>4</pollIndex>
      </IspReadSign>
      <IspReadOsccal>
        <pollIndex>4</pollIndex>
      </IspReadOsccal>
      <PPControlStack>0xC4 0xE4 0xC4 0xE4 0xCC 0xEC 0xCC 0xEC 0xD4 0xF4 0xD4 0xF4 0xDC 0xFC 0xDC 0xFC 0xC8 0xE8 0xD8 0xF8 0x4C 0x6C 0x5C 0x7C 0xEC 0xBC 0x00 0x06 0x00 0x00 0x00 0x00</PPControlStack>
      <PpEnterProgMode>
        <stabDelay>100</stabDelay>
        <progModeDelay>0</progModeDelay>
        <latchCycles>5</latchCycles>
        <toggleVtg>1</toggleVtg>
        <powerOffDelay>15</powerOffDelay>
        <resetDelayMs>2</resetDelayMs>
        <resetDelayUs>0</resetDelayUs>
      </PpEnterProgMode>
      <PpLeaveProgMode>
        <stabDelay>15</stabDelay>
        <resetDelay>15</resetDelay>
      </PpLeaveProgMode>
      <PpChipErase>
        <pulseWidth>0</pulseWidth>
        <pollTimeout>20</pollTimeout>
      </PpChipErase>
      <PpProgramFlash>
        <pollTimeout>10</pollTimeout>
        <mode>0x0B</mode>
        <blockSize>256</blockSize>
      </PpProgramFlash>
      <PpReadFlash>
        <blockSize>256</blockSize>
      </PpReadFlash>
      <PpProgramEeprom>
        <pollTimeout>10</pollTimeout>
        <mode>0x05</mode>
        <blockSize>256</blockSize>
      </PpProgramEeprom>
      <PpReadEeprom>
        <blockSize>256</blockSize>
      </PpReadEeprom>
      <PpProgramFuse>
        <pulseWidth>0</pulseWidth>
        <pollTimeout>10</pollTimeout>
      </PpProgramFuse>
      <PpProgramLock>
        <pulseWidth>0</pulseWidth>
        <pollTimeout>10</pollTimeout>
      </PpProgramLock>
    </STK500_2>
    <AVRISPmkII/>
    <AVRDragon/>
    <STK600>
      <IspEnterProgMode>
        <timeout>200</timeout>
        <stabDelay>100</stabDelay>
        <cmdexeDelay>25</cmdexeDelay>
        <synchLoops>32</synchLoops>
        <byteDelay>0</byteDelay>
        <pollIndex>3</pollIndex>
        <pollValue>0x53</pollValue>
      </IspEnterProgMode>
      <IspLeaveProgMode>
        <preDelay>1</preDelay>
        <postDelay>1</postDelay>
      </IspLeaveProgMode>
      <IspChipErase>
        <eraseDelay>20</eraseDelay>
        <pollMethod>0</pollMethod>
      </IspChipErase>
      <IspProgramFlash>
        <mode>0x21</mode>
        <blockSize>16</blockSize>
        <delay>6</delay>
        <cmd1>0x40</cmd1>
        <cmd2>0x4C</cmd2>
        <cmd3>0x20</cmd3>
        <pollVal1>0xFF</pollVal1>
        <pollVal2>0x00</pollVal2>
      </IspProgramFlash>
      <IspProgramEeprom>
        <mode>0x04</mode>
        <blockSize>64</blockSize>
        <delay>10</delay>
        <cmd1>0xC0</cmd1>
        <cmd2>0x00</cmd2>
        <cmd3>0xA0</cmd3>
        <pollVal1>0xFF</pollVal1>
        <pollVal2>0xFF</pollVal2>
      </IspProgramEeprom>
      <IspReadFlash>
        <blockSize>256</blockSize>
      </IspReadFlash>
      <IspReadEeprom>
        <blockSize>256</blockSize>
      </IspReadEeprom>
      <IspReadFuse>
        <pollIndex>4</pollIndex>
      </IspReadFuse>
      <IspReadLock>
        <pollIndex>4</pollIndex>
      </IspReadLock>
      <IspReadSign>
        <pollIndex>4</pollIndex>
      </IspReadSign>
      <IspReadOsccal>
        <pollIndex>4</pollIndex>
      </IspReadOsccal>
      <PPControlStack>0x0E 0x1E 0x0E 0x1E 0x2E 0x3E 0x2E 0x3E 0x4E 0x5E 0x4E 0x5E 0x6E 0x7E 0x6E 0x7E 0x06 0x16 0x46 0x56 0x0A 0x1A 0x4A 0x5A 0x1E 0x7C 0x00 0x01 0x00 0x00 0x00 0x00</PPControlStack>
      <PpEnterProgMode>
        <stabDelay>100</stabDelay>
        <progModeDelay>0</progModeDelay>
        <latchCycles>5</latchCycles>
        <toggleVtg>1</toggleVtg>
        <powerOffDelay>20</powerOffDelay>
        <resetDelayMs>2</resetDelayMs>
        <resetDelayUs>0</resetDelayUs>
      </PpEnterProgMode>
      <PpLeaveProgMode>
        <stabDelay>15</stabDelay>
        <resetDelay>15</resetDelay>
      </PpLeaveProgMode>
      <PpChipErase>
        <pulseWidth>0</pulseWidth>
        <pollTimeout>20</pollTimeout>
      </PpChipErase>
      <PpProgramFlash>
        <pollTimeout>10</pollTimeout>
        <mode>0x0B</mode>
        <blockSize>256</blockSize>
      </PpProgramFlash>
      <PpReadFlash>
        <blockSize>256</blockSize>
      </PpReadFlash>
      <PpProgramEeprom>
        <pollTimeout>10</pollTimeout>
        <mode>0x05</mode>
        <blockSize>256</blockSize>
      </PpProgramEeprom>
      <PpReadEeprom>
        <blockSize>256</blockSize>
      </PpReadEeprom>
      <PpProgramFuse>
        <pulseWidth>0</pulseWidth>
        <pollTimeout>10</pollTimeout>
      </PpProgramFuse>
      <PpProgramLock>
        <pulseWidth>0</pulseWidth>
        <pollTimeout>10</pollTimeout>
      </PpProgramLock>
    </STK600>
    <SIMULATOR2>
      <MODEL>libATtiny1661.dll</MODEL>
    </SIMULATOR2>
  </ICE_SETTINGS>
  <V2>
    <templates>
      <module class="FUSE">
        <registers name="FUSE" memspace="FUSE">
          <reg size="1" name="HIGH" offset="0x01">
            <bitfield name="RSTDISBL" mask="0x10" text="Reset Disabled (Enable PB7 as i/o pin)" icon=""/>
            <bitfield name="SPIEN" mask="0x08" text="Serial program downloading (SPI) enabled" icon=""/>
            <bitfield name="EESAVE" mask="0x04" text="Preserve EEPROM through the Chip Erase cycle" icon=""/>
            <bitfield name="BODLEVEL" mask="0x02" text="Brown out detector trigger level" icon="" enum="ENUM_BODLEVEL"/>
            <bitfield name="BODEN" mask="0x01" text="Brown-out detection enabled" icon=""/>
          </reg>
          <reg size="1" name="LOW" offset="0x00">
            <bitfield name="CKOPT" mask="0x40" text="CKOPT fuse (operation dependent of CKSEL fuses)" icon=""/>
            <bitfield name="PLLCK_SUT_CKSEL" mask="0xBF" text="Select Clock Source" icon="" enum="ENUM_PLLCK_SUT_CKSEL"/>
          </reg>
        </registers>
        <enumerator name="ENUM_PLLCK_SUT_CKSEL">
          <enum val="0x01" text="PLL Clock; Start-up time: 1K CK + 0 ms" constname="PLLCLK_1KCK_0MS"/>
          <enum val="0x11" text="PLL Clock; Start-up time: 1K CK + 4 ms" constname="PLLCLK_1KCK_4MS"/>
          <enum val="0x21" text="PLL Clock; Start-up time: 1K CK + 64 ms" constname="PLLCLK_1KCK_64MS"/>
          <enum val="0x31" text="PLL Clock; Start-up time: 16K CK + 64 ms" constname="PLLCLK_16KCK_64MS"/>
          <enum val="0x40" text="Ext. Clock; Start-up time: 6 CK + 0 ms" constname="EXTCLK_6CK_0MS"/>
          <enum val="0x50" text="Ext. Clock; Start-up time: 6 CK + 4 ms" constname="EXTCLK_6CK_4MS"/>
          <enum val="0x60" text="Ext. Clock; Start-up time: 6 CK + 64 ms" constname="EXTCLK_6CK_64MS"/>
          <enum val="0x41" text="Int. RC Osc. 1 MHz; Start-up time: 6 CK + 0 ms" constname="INTRCOSC_1MHZ_6CK_0MS"/>
          <enum val="0x51" text="Int. RC Osc. 1 MHz; Start-up time: 6 CK + 4 ms" constname="INTRCOSC_1MHZ_6CK_4MS"/>
          <enum val="0x61" text="Int. RC Osc. 1 MHz; Start-up time: 6 CK + 64 ms" constname="INTRCOSC_1MHZ_6CK_64MS"/>
          <enum val="0x42" text="Int. RC Osc. 2 MHz; Start-up time: 6 CK + 0 ms" constname="INTRCOSC_2MHZ_6CK_0MS"/>
          <enum val="0x52" text="Int. RC Osc. 2 MHz; Start-up time: 6 CK + 4 ms" constname="INTRCOSC_2MHZ_6CK_4MS"/>
          <enum val="0x62" text="Int. RC Osc. 2 MHz; Start-up time: 6 CK + 64 ms" constname="INTRCOSC_2MHZ_6CK_64MS"/>
          <enum val="0x83" text="Int. RC Osc. 4 MHz; Start-up time: 6 CK + 0 ms" constname="INTRCOSC_4MHZ_6CK_0MS"/>
          <enum val="0x53" text="Int. RC Osc. 4 MHz; Start-up time: 6 CK + 4 ms" constname="INTRCOSC_4MHZ_6CK_4MS"/>
          <enum val="0x63" text="Int. RC Osc. 4 MHz; Start-up time: 6 CK + 64 ms" constname="INTRCOSC_4MHZ_6CK_64MS"/>
          <enum val="0x44" text="Int. RC Osc. 8 MHz; Start-up time: 6 CK + 0 ms" constname="INTRCOSC_8MHZ_6CK_0MS"/>
          <enum val="0x54" text="Int. RC Osc. 8 MHz; Start-up time: 6 CK + 4 ms" constname="INTRCOSC_8MHZ_6CK_4MS"/>
          <enum val="0x64" text="Int. RC Osc. 8 MHz; Start-up time: 6 CK + 64 ms" constname="INTRCOSC_8MHZ_6CK_64MS"/>
          <enum val="0x45" text="Ext. RC Osc.         -  0.9 MHz; Start-up time: 18 CK + 0 ms" constname="EXTRCOSC_XX_0MHZ9_18CK_0MS"/>
          <enum val="0x55" text="Ext. RC Osc.         -  0.9 MHz; Start-up time: 18 CK + 4 ms" constname="EXTRCOSC_XX_0MHZ9_18CK_4MS"/>
          <enum val="0x65" text="Ext. RC Osc.         -  0.9 MHz; Start-up time: 18 CK + 64 ms" constname="EXTRCOSC_XX_0MHZ9_18CK_64MS"/>
          <enum val="0x75" text="Ext. RC Osc.         -  0.9 MHz; Start-up time: 6 CK + 4 ms" constname="EXTRCOSC_XX_0MHZ9_6CK_4MS"/>
          <enum val="0x46" text="Ext. RC Osc. 0.9 MHz -  3.0 MHz; Start-up time: 18 CK + 0 ms" constname="EXTRCOSC_0MHZ9_3MHZ_18CK_0MS"/>
          <enum val="0x56" text="Ext. RC Osc. 0.9 MHz -  3.0 MHz; Start-up time: 18 CK + 4 ms" constname="EXTRCOSC_0MHZ9_3MHZ_18CK_4MS"/>
          <enum val="0x66" text="Ext. RC Osc. 0.9 MHz -  3.0 MHz; Start-up time: 18 CK + 64 ms" constname="EXTRCOSC_0MHZ9_3MHZ_18CK_64MS"/>
          <enum val="0x76" text="Ext. RC Osc. 0.9 MHz -  3.0 MHz; Start-up time: 6 CK + 4 ms" constname="EXTRCOSC_0MHZ9_3MHZ_6CK_4MS"/>
          <enum val="0x87" text="Ext. RC Osc. 3.0 MHz -  8.0 MHz; Start-up time: 18 CK + 0 ms" constname="EXTRCOSC_3MHZ_8MHZ_18CK_0MS"/>
          <enum val="0x57" text="Ext. RC Osc. 3.0 MHz -  8.0 MHz; Start-up time: 18 CK + 4 ms" constname="EXTRCOSC_3MHZ_8MHZ_18CK_4MS"/>
          <enum val="0x67" text="Ext. RC Osc. 3.0 MHz -  8.0 MHz; Start-up time: 18 CK + 64 ms" constname="EXTRCOSC_3MHZ_8MHZ_18CK_64MS"/>
          <enum val="0x77" text="Ext. RC Osc. 3.0 MHz -  8.0 MHz; Start-up time: 6 CK + 4 ms" constname="EXTRCOSC_3MHZ_8MHZ_6CK_4MS"/>
          <enum val="0x58" text="Ext. RC Osc. 8.0 MHz - 12.0 MHz; Start-up time: 18 CK + 0 ms" constname="EXTRCOSC_8MHZ_12MHZ_18CK_0MS"/>
          <enum val="0x58" text="Ext. RC Osc. 8.0 MHz - 12.0 MHz; Start-up time: 18 CK + 4 ms" constname="EXTRCOSC_8MHZ_12MHZ_18CK_4MS"/>
          <enum val="0x68" text="Ext. RC Osc. 8.0 MHz - 12.0 MHz; Start-up time: 18 CK + 64 ms" constname="EXTRCOSC_8MHZ_12MHZ_18CK_64MS"/>
          <enum val="0x78" text="Ext. RC Osc. 8.0 MHz - 12.0 MHz; Start-up time: 6 CK + 4 ms" constname="EXTRCOSC_8MHZ_12MHZ_6CK_4MS"/>
          <enum val="0x49" text="Ext. Low-Freq. Crystal; Start-up time: 1K CK + 4 ms" constname="EXTLOFXTAL_1KCK_4MS"/>
          <enum val="0x59" text="Ext. Low-Freq. Crystal; Start-up time: 1K CK + 64 ms" constname="EXTLOFXTAL_1KCK_64MS"/>
          <enum val="0x69" text="Ext. Low-Freq. Crystal; Start-up time: 32K CK + 64 ms" constname="EXTLOFXTAL_32KCK_64MS"/>
          <enum val="0x8A" text="Ext. Crystal/Resonator Low Freq.; Start-up time: 258 CK + 4 ms" constname="EXTLOFXTALRES_258CK_4MS"/>
          <enum val="0x5A" text="Ext. Crystal/Resonator Low Freq.; Start-up time: 258 CK + 64 ms" constname="EXTLOFXTALRES_258CK_64MS"/>
          <enum val="0x6A" text="Ext. Crystal/Resonator Low Freq.; Start-up time: 1K CK + 0 ms" constname="EXTLOFXTALRES_1KCK_0MS"/>
          <enum val="0x7A" text="Ext. Crystal/Resonator Low Freq.; Start-up time: 1K CK + 4 ms" constname="EXTLOFXTALRES_1KCK_4MS"/>
          <enum val="0x4B" text="Ext. Crystal/Resonator Low Freq.; Start-up time: 1K CK + 64 ms" constname="EXTLOFXTALRES_1KCK_64MS"/>
          <enum val="0x5B" text="Ext. Crystal/Resonator Low Freq.; Start-up time: 16K CK + 0 ms" constname="EXTLOFXTALRES_16KCK_0MS"/>
          <enum val="0x6B" text="Ext. Crystal/Resonator Low Freq.; Start-up time: 16K CK + 4 ms" constname="EXTLOFXTALRES_16KCK_4MS"/>
          <enum val="0x7B" text="Ext. Crystal/Resonator Low Freq.; Start-up time: 16K CK + 64 ms" constname="EXTLOFXTALRES_16KCK_64MS"/>
          <enum val="0x4C" text="Ext. Crystal/Resonator Medium Freq.; Start-up time: 258 CK + 4 ms" constname="EXTMEDFXTALRES_258CK_4MS"/>
          <enum val="0x5C" text="Ext. Crystal/Resonator Medium Freq.; Start-up time: 258 CK + 64 ms" constname="EXTMEDFXTALRES_258CK_64MS"/>
          <enum val="0x6C" text="Ext. Crystal/Resonator Medium Freq.; Start-up time: 1K CK + 0 ms" constname="EXTMEDFXTALRES_1KCK_0MS"/>
          <enum val="0x7C" text="Ext. Crystal/Resonator Medium Freq.; Start-up time: 1K CK + 4 ms" constname="EXTMEDFXTALRES_1KCK_4MS"/>
          <enum val="0x4D" text="Ext. Crystal/Resonator Medium Freq.; Start-up time: 1K CK + 64 ms" constname="EXTMEDFXTALRES_1KCK_64MS"/>
          <enum val="0x5D" text="Ext. Crystal/Resonator Medium Freq.; Start-up time: 16K CK + 0 ms" constname="EXTMEDFXTALRES_16KCK_0MS"/>
          <enum val="0x6D" text="Ext. Crystal/Resonator Medium Freq.; Start-up time: 16K CK + 4 ms" constname="EXTMEDFXTALRES_16KCK_4MS"/>
          <enum val="0x7D" text="Ext. Crystal/Resonator Medium Freq.; Start-up time: 16K CK + 64 ms" constname="EXTMEDFXTALRES_16KCK_64MS"/>
          <enum val="0x4E" text="Ext. Crystal/Resonator High Freq.; Start-up time: 258 CK + 4 ms" constname="EXTHIFXTALRES_258CK_4MS"/>
          <enum val="0x5E" text="Ext. Crystal/Resonator High Freq.; Start-up time: 258 CK + 64 ms" constname="EXTHIFXTALRES_258CK_64MS"/>
          <enum val="0x6E" text="Ext. Crystal/Resonator High Freq.; Start-up time: 1K CK + 0 ms" constname="EXTHIFXTALRES_1KCK_0MS"/>
          <enum val="0x7E" text="Ext. Crystal/Resonator High Freq.; Start-up time: 1K CK + 4 ms" constname="EXTHIFXTALRES_1KCK_4MS"/>
          <enum val="0x4F" text="Ext. Crystal/Resonator High Freq.; Start-up time: 1K CK + 64 ms" constname="EXTHIFXTALRES_1KCK_64MS"/>
          <enum val="0x5F" text="Ext. Crystal/Resonator High Freq.; Start-up time: 16K CK + 0 ms" constname="EXTHIFXTALRES_16KCK_0MS"/>
          <enum val="0x6F" text="Ext. Crystal/Resonator High Freq.; Start-up time: 16K CK + 4 ms" constname="EXTHIFXTALRES_16KCK_4MS"/>
          <enum val="0x7F" text="Ext. Crystal/Resonator High Freq.; Start-up time: 16K CK + 64 ms" constname="EXTHIFXTALRES_16KCK_64MS"/>
        </enumerator>
        <enumerator name="ENUM_BODLEVEL">
          <enum val="0x00" text="Brown-out detection at VCC=4.0 V" constname="4V0"/>
          <enum val="0x01" text="Brown-out detection at VCC=2.7 V" constname="2V7"/>
        </enumerator>
      </module>
      <module class="LOCKBIT">
        <registers name="LOCKBIT" memspace="LOCKBIT">
          <reg size="1" name="LOCKBIT" offset="0x00">
            <bitfield name="LB" mask="0x03" text="Memory Lock" icon="" enum="ENUM_LB"/>
          </reg>
        </registers>
        <enumerator name="ENUM_LB">
          <enum val="0x00" text="Further programming and verification disabled" constname="PROG_VER_DISABLED"/>
          <enum val="0x02" text="Further programming disabled" constname="PROG_DISABLED"/>
          <enum val="0x03" text="No memory lock features enabled" constname="NO_LOCK"/>
        </enumerator>
      </module>
      <module class="AD_CONVERTER" text="">
        <registers name="AD_CONVERTER" memspace="DATAMEM" text="" icon="io_analo.bmp">
          <reg size="1" name="ADMUX" offset="0x27" text="The ADC multiplexer Selection Register" icon="io_analo.bmp">
            <bitfield name="REFS" mask="0xC0" text="Reference Selection Bits" icon="" enum="ANALOG_ADC_V_REF"/>
            <bitfield name="ADLAR" mask="0x20" text="Left Adjust Result" icon=""/>
            <bitfield name="MUX" mask="0x1F" text="Analog Channel and Gain Selection Bits" icon=""/>
          </reg>
          <reg size="1" name="ADCSR" offset="0x26" text="The ADC Control and Status register" icon="io_flag.bmp">
            <bitfield name="ADEN" mask="0x80" text="ADC Enable" icon=""/>
            <bitfield name="ADSC" mask="0x40" text="ADC Start Conversion" icon=""/>
            <bitfield name="ADFR" mask="0x20" text="ADC  Free Running Select" icon=""/>
            <bitfield name="ADIF" mask="0x10" text="ADC Interrupt Flag" icon=""/>
            <bitfield name="ADIE" mask="0x08" text="ADC Interrupt Enable" icon=""/>
            <bitfield name="ADPS" mask="0x07" text="ADC  Prescaler Select Bits" icon="" enum="ANALIG_ADC_PRESCALER"/>
          </reg>
          <reg size="2" name="ADC" offset="0x24" text="ADC Data Register  Bytes" icon="io_analo.bmp" mask="0xFFFF"/>
        </registers>
        <enumerator name="ANALOG_ADC_V_REF">
          <enum val="0x00" text="AVCC"/>
          <enum val="0x01" text="AREF"/>
          <enum val="0x02" text="Internal Voltage Referance"/>
          <enum val="0x03" text="Internal Voltage Reference With External Capacitor at AREF Pin."/>
        </enumerator>
        <enumerator name="ANALIG_ADC_PRESCALER">
          <enum val="0x00" text="2"/>
          <enum val="0x01" text="2"/>
          <enum val="0x02" text="4"/>
          <enum val="0x03" text="8"/>
          <enum val="0x04" text="16"/>
          <enum val="0x05" text="32"/>
          <enum val="0x06" text="64"/>
          <enum val="0x07" text="128"/>
        </enumerator>
      </module>
      <module class="ANALOG_COMPARATOR" text="">
        <registers name="ANALOG_COMPARATOR" memspace="DATAMEM" text="" icon="io_analo.bmp">
          <reg size="1" name="ACSR" offset="0x28" text="Analog Comparator Control And Status Register" icon="io_analo.bmp">
            <bitfield name="ACD" mask="0x80" text="Analog Comparator Disable" icon=""/>
            <bitfield name="ACBG" mask="0x40" text="Analog Comparator Bandgap Select" icon=""/>
            <bitfield name="ACO" mask="0x20" text="Analog Compare Output" icon=""/>
            <bitfield name="ACI" mask="0x10" text="Analog Comparator Interrupt Flag" icon=""/>
            <bitfield name="ACIE" mask="0x08" text="Analog Comparator Interrupt Enable" icon=""/>
            <bitfield name="ACME" mask="0x04" text="Analog Comparator Multiplexer Enable" icon=""/>
            <bitfield name="ACIS" mask="0x03" text="Analog Comparator Interrupt Mode Select bits" icon="" enum="ANALOG_COMP_INTERRUPT"/>
          </reg>
        </registers>
        <enumerator name="ANALOG_COMP_INTERRUPT">
          <enum val="0x00" text="Interrupt on Toggle"/>
          <enum val="0x01" text="Reserved"/>
          <enum val="0x02" text="Interrupt on Falling Edge"/>
          <enum val="0x03" text="Interrupt on Rising Edge"/>
        </enumerator>
      </module>
      <module class="USI" text="">
        <registers name="USI" memspace="DATAMEM" text="" icon="io_com.bmp">
          <reg size="1" name="USIDR" offset="0x2F" text="USI Data Register" icon="io_com.bmp" mask="0xFF"/>
          <reg size="1" name="USISR" offset="0x2E" text="USI Status Register" icon="io_flag.bmp">
            <bitfield name="USISIF" mask="0x80" text="Start Condition Interrupt Flag" icon=""/>
            <bitfield name="USIOIF" mask="0x40" text="Counter Overflow Interrupt Flag" icon=""/>
            <bitfield name="USIPF" mask="0x20" text="Stop Condition Flag" icon=""/>
            <bitfield name="USIDC" mask="0x10" text="Data Output Collision" icon=""/>
            <bitfield name="USICNT" mask="0x0F" text="USI Counter Value Bits" icon=""/>
          </reg>
          <reg size="1" name="USICR" offset="0x2D" text="USI Control Register" icon="io_flag.bmp">
            <bitfield name="USISIE" mask="0x80" text="Start Condition Interrupt Enable" icon=""/>
            <bitfield name="USIOIE" mask="0x40" text="Counter Overflow Interrupt Enable" icon=""/>
            <bitfield name="USIWM" mask="0x30" text="USI Wire Mode Bits" icon="" enum="COMM_USI_OP"/>
            <bitfield name="USICS" mask="0x0C" text="USI Clock Source Select Bits" icon=""/>
            <bitfield name="USICLK" mask="0x02" text="Clock Strobe" icon=""/>
            <bitfield name="USITC" mask="0x01" text="Toggle Clock Port Pin" icon=""/>
          </reg>
        </registers>
        <enumerator name="COMM_USI_OP">
          <enum val="0x00" text="Normal Operation"/>
          <enum val="0x01" text="Three-Wire Mode"/>
          <enum val="0x02" text="Two-Wire Mode"/>
          <enum val="0x03" text="Two-Wire Mode Held Low"/>
        </enumerator>
      </module>
      <module class="PORTA" text="">
        <registers name="PORTA" memspace="DATAMEM" text="" icon="io_port.bmp">
          <reg size="1" name="PORTA" offset="0x3B" text="Port A Data Register" icon="io_port.bmp" mask="0xFF"/>
          <reg size="1" name="DDRA" offset="0x3A" text="Port A Data Direction Register" icon="io_flag.bmp" mask="0xFF"/>
          <reg size="1" name="PINA" offset="0x39" text="Port A Input Pins" icon="io_port.bmp" mask="0xFF"/>
        </registers>
      </module>
      <module class="PORTB" text="">
        <registers name="PORTB" memspace="DATAMEM" text="" icon="io_port.bmp">
          <reg size="1" name="PORTB" offset="0x38" text="Port B Data Register" icon="io_port.bmp" mask="0xFF"/>
          <reg size="1" name="DDRB" offset="0x37" text="Port B Data Direction Register" icon="io_flag.bmp" mask="0xFF"/>
          <reg size="1" name="PINB" offset="0x36" text="Port B Input Pins" icon="io_port.bmp" mask="0xFF"/>
        </registers>
      </module>
      <module class="EEPROM" text="">
        <registers name="EEPROM" memspace="DATAMEM" text="" icon="io_cpu.bmp">
          <reg size="1" name="EEAR" offset="0x3E" text="EEPROM Read/Write Access" icon="io_cpu.bmp" mask="0x7F"/>
          <reg size="1" name="EEDR" offset="0x3D" text="EEPROM Data Register" icon="io_cpu.bmp" mask="0xFF"/>
          <reg size="1" name="EECR" offset="0x3C" text="EEPROM Control Register" icon="io_flag.bmp">
            <bitfield name="EERIE" mask="0x08" text="EEProm Ready Interrupt Enable" icon=""/>
            <bitfield name="EEMWE" mask="0x04" text="EEPROM Master Write Enable" icon=""/>
            <bitfield name="EEWE" mask="0x02" text="EEPROM Write Enable" icon=""/>
            <bitfield name="EERE" mask="0x01" text="EEPROM Read Enable" icon=""/>
          </reg>
        </registers>
      </module>
      <module class="WATCHDOG" text="">
        <registers name="WATCHDOG" memspace="DATAMEM" text="" icon="io_watch.bmp">
          <reg size="1" name="WDTCR" offset="0x41" text="Watchdog Timer Control Register" icon="io_flag.bmp">
            <bitfield name="WDCE" mask="0x10" text="Watchdog Change Enable" icon=""/>
            <bitfield name="WDE" mask="0x08" text="Watch Dog Enable" icon=""/>
            <bitfield name="WDP" mask="0x07" text="Watch Dog Timer Prescaler bits" icon="" enum="WDOG_TIMER_PRESCALE_3BITS"/>
          </reg>
        </registers>
        <enumerator name="WDOG_TIMER_PRESCALE_3BITS">
          <enum val="0x00" text="Oscillator Cycles 16K"/>
          <enum val="0x01" text="Oscillator Cycles 32K"/>
          <enum val="0x02" text="Oscillator Cycles 64K"/>
          <enum val="0x03" text="Oscillator Cycles 128K"/>
          <enum val="0x04" text="Oscillator Cycles 256K"/>
          <enum val="0x05" text="Oscillator Cycles 512K"/>
          <enum val="0x06" text="Oscillator Cycles 1024K"/>
          <enum val="0x07" text="Oscillator Cycles 2048K"/>
        </enumerator>
      </module>
      <module class="CPU" text="">
        <registers name="CPU" memspace="DATAMEM" text="" icon="io_cpu.com">
          <reg size="1" name="SREG" offset="0x5F" text="Status Register" icon="io_sreg.bmp">
            <bitfield name="I" mask="0x80" text="Global Interrupt Enable" icon=""/>
            <bitfield name="T" mask="0x40" text="Bit Copy Storage" icon=""/>
            <bitfield name="H" mask="0x20" text="Half Carry Flag" icon=""/>
            <bitfield name="S" mask="0x10" text="Sign Bit" icon=""/>
            <bitfield name="V" mask="0x08" text="Two's Complement Overflow Flag" icon=""/>
            <bitfield name="N" mask="0x04" text="Negative Flag" icon=""/>
            <bitfield name="Z" mask="0x02" text="Zero Flag" icon=""/>
            <bitfield name="C" mask="0x01" text="Carry Flag" icon=""/>
          </reg>
          <reg size="1" name="SP" offset="0x5D" text="Stack Pointer" icon="io_sreg.bmp" mask="0xFF"/>
          <reg size="1" name="MCUCR" offset="0x55" text="MCU Control Register" icon="io_cpu.bmp">
            <bitfield name="PUD" mask="0x40" text="Pull-up Disable" icon=""/>
            <bitfield name="SE" mask="0x20" text="Sleep Enable" icon=""/>
            <bitfield name="SM" mask="0x18" text="Sleep Mode Select Bits" icon="" enum="CPU_SLEEP_MODE"/>
            <bitfield name="ISC0" mask="0x03" text="Interrupt Sense Control 0 bits" icon="" enum="INTERRUPT_SENSE_CONTROL2"/>
          </reg>
          <reg size="1" name="MCUSR" offset="0x54" text="MCU Status register" icon="io_cpu.bmp">
            <bitfield name="WDRF" mask="0x08" text="Watchdog Reset Flag" icon=""/>
            <bitfield name="BORF" mask="0x04" text="Brown-out Reset Flag" icon=""/>
            <bitfield name="EXTRF" mask="0x02" text="External Reset Flag" icon=""/>
            <bitfield name="PORF" mask="0x01" text="Power-On Reset Flag" icon=""/>
          </reg>
          <reg size="1" name="OSCCAL" offset="0x51" text="Status Register" icon="io_sreg.bmp" mask="0xFF"/>
        </registers>
        <enumerator name="CPU_SLEEP_MODE">
          <enum val="0x00" text="Idle"/>
          <enum val="0x01" text="ADC Noise Reduction (If Available)"/>
          <enum val="0x02" text="Power Down"/>
          <enum val="0x03" text="Standby"/>
        </enumerator>
        <enumerator name="INTERRUPT_SENSE_CONTROL2">
          <enum val="0x00" text="Low Level of INTX"/>
          <enum val="0x01" text="Any Logical Change in INTX"/>
          <enum val="0x02" text="Falling Edge of INTX"/>
          <enum val="0x03" text="Rising Edge of INTX"/>
        </enumerator>
      </module>
      <module class="TIMER_COUNTER_0" text="">
        <registers name="TIMER_COUNTER_0" memspace="DATAMEM" text="" icon="io_timer.bmp">
          <reg size="1" name="TIMSK" offset="0x59" text="Timer/Counter Interrupt Mask Register" icon="io_flag.bmp">
            <bitfield name="TOIE0" mask="0x02" text="Timer/Counter0 Overflow Interrupt Enable" icon=""/>
          </reg>
          <reg size="1" name="TIFR" offset="0x58" text="Timer/Counter Interrupt Flag register" icon="io_flag.bmp">
            <bitfield name="TOV0" mask="0x02" text="Timer/Counter0 Overflow Flag" icon=""/>
          </reg>
          <reg size="1" name="TCCR0" offset="0x53" text="Timer/Counter0 Control Register" icon="io_flag.bmp">
            <bitfield name="PSR0" mask="0x08" text="Prescaler Reset Timer/Counter0" icon=""/>
            <bitfield name="CS0" mask="0x07" text="Clock Select0 bits" icon="" enum="CLK_SEL_3BIT_EXT"/>
          </reg>
          <reg size="1" name="TCNT0" offset="0x52" text="Timer Counter 0" icon="io_timer.bmp" mask="0xFF"/>
        </registers>
        <enumerator name="CLK_SEL_3BIT_EXT">
          <enum val="0x00" text="No Clock Source (Stopped)"/>
          <enum val="0x01" text="Running, No Prescaling"/>
          <enum val="0x02" text="Running, CLK/8"/>
          <enum val="0x03" text="Running, CLK/64"/>
          <enum val="0x04" text="Running, CLK/256"/>
          <enum val="0x05" text="Running, CLK/1024"/>
          <enum val="0x06" text="Running, ExtClk Tx Falling Edge"/>
          <enum val="0x07" text="Running, ExtClk Tx Rising Edge"/>
        </enumerator>
      </module>
      <module class="TIMER_COUNTER_1" text="">
        <registers name="TIMER_COUNTER_1" memspace="DATAMEM" text="" icon="io_timer.bmp">
          <reg size="1" name="TCCR1A" offset="0x50" text="Timer/Counter Control Register A" icon="io_flag.bmp">
            <bitfield name="COM1A" mask="0xC0" text="Comparator A Output Mode Bits" icon="" enum="CLK_COMP_MATCH_OUT_MODE"/>
            <bitfield name="COM1B" mask="0x30" text="Comparator B Output Mode Bits" icon="" enum="CLK_COMP_MATCH_OUT_MODE"/>
            <bitfield name="FOC1A" mask="0x08" text="Force Output Compare Match 1A" icon=""/>
            <bitfield name="FOC1B" mask="0x04" text="Force Output Compare Match 1B" icon=""/>
            <bitfield name="PWM1A" mask="0x02" text="Pulse Width Modulator A Enable" icon=""/>
            <bitfield name="PWM1B" mask="0x01" text="Pulse Width Modulator B Enable" icon=""/>
          </reg>
          <reg size="1" name="TCCR1B" offset="0x4F" text="Timer/Counter Control Register B" icon="io_flag.bmp">
            <bitfield name="CTC1" mask="0x80" text="Clear Timer/Counter on Compare Match" icon=""/>
            <bitfield name="PSR1" mask="0x40" text="Prescaler Reset Timer/Counter1" icon=""/>
            <bitfield name="CS1" mask="0x0F" text="Clock Select Bits" icon="" enum="CLK_SEL_4BIT"/>
          </reg>
          <reg size="1" name="TCNT1" offset="0x4E" text="Timer/Counter Register" icon="io_timer.bmp" mask="0xFF"/>
          <reg size="1" name="OCR1A" offset="0x4D" text="Output Compare Register" icon="io_timer.bmp" mask="0xFF"/>
          <reg size="1" name="OCR1B" offset="0x4C" text="Output Compare Register" icon="io_timer.bmp" mask="0xFF"/>
          <reg size="1" name="OCR1C" offset="0x4B" text="Output Compare Register" icon="io_timer.bmp" mask="0xFF"/>
          <reg size="1" name="TIMSK" offset="0x59" text="Timer/Counter Interrupt Mask Register" icon="io_flag.bmp">
            <bitfield name="OCIE1A" mask="0x40" text="Timer/Counter1 Output Compare Interrupt Enable" icon=""/>
            <bitfield name="OCIE1B" mask="0x20" text="Timer/Counter1 Output Compare Interrupt Enable" icon=""/>
            <bitfield name="TOIE1" mask="0x04" text="Timer/Counter1 Overflow Interrupt Enable" icon=""/>
          </reg>
          <reg size="1" name="TIFR" offset="0x58" text="Timer/Counter Interrupt Flag Register" icon="io_flag.bmp">
            <bitfield name="OCF1A" mask="0x40" text="Timer/Counter1 Output Compare Flag 1A" icon=""/>
            <bitfield name="OCF1B" mask="0x20" text="Timer/Counter1 Output Compare Flag 1B" icon=""/>
            <bitfield name="TOV1" mask="0x04" text="Timer/Counter1 Overflow Flag" icon=""/>
          </reg>
          <reg size="1" name="PLLCSR" offset="0x49" text="PLL Control and Status Register" icon="io_sreg.bmp">
            <bitfield name="PCKE" mask="0x04" text="PCK Enable" icon=""/>
            <bitfield name="PLLE" mask="0x02" text="PLL Enable" icon=""/>
            <bitfield name="PLOCK" mask="0x01" text="PLL Lock Detector" icon=""/>
          </reg>
        </registers>
        <enumerator name="CLK_COMP_MATCH_OUT_MODE">
          <enum val="0x00" text="Disconnected from OCn/PWMn"/>
          <enum val="0x01" text="Toggle OCn/PWMn output line"/>
          <enum val="0x02" text="Clear OCn/PWMn output line"/>
          <enum val="0x03" text="set OCn/PWMn output line"/>
        </enumerator>
        <enumerator name="CLK_SEL_4BIT">
          <enum val="0x00" text="No Clock Source (Stopped)"/>
          <enum val="0x01" text="Running, No Prescaling"/>
          <enum val="0x02" text="Running, CLK/2"/>
          <enum val="0x03" text="Running, CLK/4"/>
          <enum val="0x04" text="Running, CLK/8"/>
          <enum val="0x05" text="Running, CLK/16"/>
          <enum val="0x06" text="Running, CLK/32"/>
          <enum val="0x07" text="Running, CLK/64"/>
          <enum val="0x08" text="Running, CLK/128"/>
          <enum val="0x09" text="Running, CLK/256"/>
          <enum val="0x0A" text="Running, CLK/512"/>
          <enum val="0x0B" text="Running, CLK/1024"/>
          <enum val="0x0C" text="Running, CLK/2048"/>
          <enum val="0x0D" text="Running, CLK/4096"/>
          <enum val="0x0E" text="Running, CLK/8192"/>
          <enum val="0x0F" text="Running, CLK/16384"/>
        </enumerator>
      </module>
      <module class="EXTERNAL_INTERRUPT" text="">
        <registers name="EXTERNAL_INTERRUPT" memspace="DATAMEM" text="" icon="io_ext.bmp">
          <reg size="1" name="GIMSK" offset="0x5B" text="General Interrupt Mask Register" icon="io_flag.bmp">
            <bitfield name="INT0" mask="0x40" text="External Interrupt Request 0 Enable" icon=""/>
            <bitfield name="PCIE" mask="0x30" text="Pin Change Interrupt Enables" icon=""/>
          </reg>
          <reg size="1" name="GIFR" offset="0x5A" text="General Interrupt Flag register" icon="io_flag.bmp">
            <bitfield name="INTF0" mask="0x40" text="External Interrupt Flag 0" icon=""/>
            <bitfield name="PCIF" mask="0x20" text="Pin Change Interrupt Flag" icon=""/>
          </reg>
        </registers>
      </module>
    </templates>
    <modules>
      <module implements="AD_CONVERTER" name="AD_CONVERTER">
        <registers implements="AD_CONVERTER" name="AD_CONVERTER" offset="0x00" text=""/>
      </module>
      <module implements="ANALOG_COMPARATOR" name="ANALOG_COMPARATOR">
        <registers implements="ANALOG_COMPARATOR" name="ANALOG_COMPARATOR" offset="0x00" text=""/>
      </module>
      <module implements="USI" name="USI">
        <registers implements="USI" name="USI" offset="0x00" text=""/>
      </module>
      <module implements="PORTA" name="PORTA">
        <registers implements="PORTA" name="PORTA" offset="0x00" text=""/>
      </module>
      <module implements="PORTB" name="PORTB">
        <registers implements="PORTB" name="PORTB" offset="0x00" text=""/>
      </module>
      <module implements="EEPROM" name="EEPROM">
        <registers implements="EEPROM" name="EEPROM" offset="0x00" text=""/>
      </module>
      <module implements="WATCHDOG" name="WATCHDOG">
        <registers implements="WATCHDOG" name="WATCHDOG" offset="0x00" text=""/>
      </module>
      <module implements="CPU" name="CPU">
        <registers implements="CPU" name="CPU" offset="0x00" text=""/>
      </module>
      <module implements="TIMER_COUNTER_0" name="TIMER_COUNTER_0">
        <registers implements="TIMER_COUNTER_0" name="TIMER_COUNTER_0" offset="0x00" text=""/>
      </module>
      <module implements="TIMER_COUNTER_1" name="TIMER_COUNTER_1">
        <registers implements="TIMER_COUNTER_1" name="TIMER_COUNTER_1" offset="0x00" text=""/>
      </module>
      <module implements="EXTERNAL_INTERRUPT" name="EXTERNAL_INTERRUPT">
        <registers implements="EXTERNAL_INTERRUPT" name="EXTERNAL_INTERRUPT" offset="0x00" text=""/>
      </module>
    </modules>
    <fuses>
      <fuse implements="FUSE" name="FUSE">
        <registers implements="FUSE" name="FUSE"/>
      </fuse>
    </fuses>
    <lockbits>
      <lockbit implements="LOCKBIT" name="LOCKBIT">
        <registers implements="LOCKBIT" name="LOCKBIT"/>
      </lockbit>
    </lockbits>
  </V2>
</AVRPART>

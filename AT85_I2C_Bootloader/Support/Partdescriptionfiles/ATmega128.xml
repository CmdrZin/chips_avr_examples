<?xml version="1.0"?>
<AVRPART>
  <MODULE_LIST>[ADMIN:CORE:FUSE:INTERRUPT_VECTOR:MEMORY:PACKAGE:POWER:PROGVOLT:LOCKBIT:PROGRAMMING:IO_MODULE:ICE_SETTINGS]</MODULE_LIST>
  <ADMIN>
    <PART_NAME>ATmega128</PART_NAME>
    <SPEED>16MHz</SPEED>
    <BUILD>267</BUILD>
    <RELEASE_STATUS>RELEASED</RELEASE_STATUS>
    <SIGNATURE>
      <ADDR000>$1E</ADDR000>
      <ADDR001>$97</ADDR001>
      <ADDR002>$02</ADDR002>
    </SIGNATURE>
    <COMPATIBILITYMODE>
      <COMPATIBILITYPART>ATmega103comp</COMPATIBILITYPART>
      <NORMAL>ATmega128</NORMAL>
    </COMPATIBILITYMODE>
    <OCD_PARAMETERS>
      <OCD_REVISION>1</OCD_REVISION>
      <OCD_REGISTER_ADDRESS>0x22</OCD_REGISTER_ADDRESS>
      <CACHE_TYPE>0</CACHE_TYPE>
      <USE_JTAGID>1</USE_JTAGID>
      <DW_BASE_PC>0x00</DW_BASE_PC>
    </OCD_PARAMETERS>
  </ADMIN>
  <CORE>
    <CORE_VERSION>V2E</CORE_VERSION>
    <ID>AVRSimCoreV2.SimCoreV2</ID>
    <NEW_INSTRUCTIONS>[]</NEW_INSTRUCTIONS>
    <INSTRUCTIONS_NOT_SUPPORTED>[]</INSTRUCTIONS_NOT_SUPPORTED>
    <RAMP_REGISTERS>[]</RAMP_REGISTERS>
    <GP_REG_FILE>
      <NMB_REG>32</NMB_REG>
      <START_ADDR>$00</START_ADDR>
      <X_REG_HIGH>$1B</X_REG_HIGH>
      <X_REG_LOW>$1A</X_REG_LOW>
      <Y_REG_HIGH>$1D</Y_REG_HIGH>
      <Y_REG_LOW>$1C</Y_REG_LOW>
      <Z_REG_HIGH>$1F</Z_REG_HIGH>
      <Z_REG_LOW>$1E</Z_REG_LOW>
    </GP_REG_FILE>
  </CORE>
  <FUSE>
    <LIST>[LOW:HIGH:EXTENDED]</LIST>
    <ID/>
    <ICON/>
    <TEXT/>
    <LOW>
      <NMB_FUSE_BITS>8</NMB_FUSE_BITS>
      <FUSE7>
        <NAME>BODLEVEL</NAME>
        <TEXT>Brown out detector trigger level</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE7>
      <FUSE6>
        <NAME>BODEN</NAME>
        <TEXT>Brown out detector enable</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE6>
      <FUSE5>
        <NAME>SUT1</NAME>
        <TEXT>Select start-up time</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE5>
      <FUSE4>
        <NAME>SUT0</NAME>
        <TEXT>Select start-up time</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE4>
      <FUSE3>
        <NAME>CKSEL3</NAME>
        <TEXT>Select Clock Source</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE3>
      <FUSE2>
        <NAME>CKSEL2</NAME>
        <TEXT>Select Clock Source</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE2>
      <FUSE1>
        <NAME>CKSEL1</NAME>
        <TEXT>Select Clock Source</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE1>
      <FUSE0>
        <NAME>CKSEL0</NAME>
        <TEXT>Select Clock Source</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE0>
      <NMB_TEXT>61</NMB_TEXT>
      <TEXT1>
        <MASK>0x80</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Brown-out detection level at VCC=4.0 V; [BODLEVEL=0]</TEXT>
      </TEXT1>
      <TEXT2>
        <MASK>0x80</MASK>
        <VALUE>0x80</VALUE>
        <TEXT>Brown-out detection level at VCC=2.7 V; [BODLEVEL=1]</TEXT>
      </TEXT2>
      <TEXT3>
        <MASK>0x40</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Brown-out detection enabled; [BODEN=0]</TEXT>
      </TEXT3>
      <TEXT4>
        <MASK>0x3F</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Ext. Clock; Start-up time: 6 CK + 0 ms; [CKSEL=0000 SUT=00]</TEXT>
      </TEXT4>
      <TEXT5>
        <MASK>0x3F</MASK>
        <VALUE>0x10</VALUE>
        <TEXT>Ext. Clock; Start-up time: 6 CK + 4 ms; [CKSEL=0000 SUT=01]</TEXT>
      </TEXT5>
      <TEXT6>
        <MASK>0x3F</MASK>
        <VALUE>0x20</VALUE>
        <TEXT>Ext. Clock; Start-up time: 6 CK + 64 ms; [CKSEL=0000 SUT=10]</TEXT>
      </TEXT6>
      <TEXT7>
        <MASK>0x3F</MASK>
        <VALUE>0x01</VALUE>
        <TEXT>Int. RC Osc. 1 MHz; Start-up time: 6 CK + 0 ms; [CKSEL=0001 SUT=00]</TEXT>
      </TEXT7>
      <TEXT8>
        <MASK>0x3F</MASK>
        <VALUE>0x11</VALUE>
        <TEXT>Int. RC Osc. 1 MHz; Start-up time: 6 CK + 4 ms; [CKSEL=0001 SUT=01]</TEXT>
      </TEXT8>
      <TEXT9>
        <MASK>0x3F</MASK>
        <VALUE>0x21</VALUE>
        <TEXT>Int. RC Osc. 1 MHz; Start-up time: 6 CK + 64 ms; [CKSEL=0001 SUT=10]; default value</TEXT>
      </TEXT9>
      <TEXT10>
        <MASK>0x3F</MASK>
        <VALUE>0x02</VALUE>
        <TEXT>Int. RC Osc. 2 MHz; Start-up time: 6 CK + 0 ms; [CKSEL=0010 SUT=00]</TEXT>
      </TEXT10>
      <TEXT11>
        <MASK>0x3F</MASK>
        <VALUE>0x12</VALUE>
        <TEXT>Int. RC Osc. 2 MHz; Start-up time: 6 CK + 4 ms; [CKSEL=0010 SUT=01]</TEXT>
      </TEXT11>
      <TEXT12>
        <MASK>0x3F</MASK>
        <VALUE>0x22</VALUE>
        <TEXT>Int. RC Osc. 2 MHz; Start-up time: 6 CK + 64 ms; [CKSEL=0010 SUT=10]</TEXT>
      </TEXT12>
      <TEXT13>
        <MASK>0x3F</MASK>
        <VALUE>0x03</VALUE>
        <TEXT>Int. RC Osc. 4 MHz; Start-up time: 6 CK + 0 ms; [CKSEL=0011 SUT=00]</TEXT>
      </TEXT13>
      <TEXT14>
        <MASK>0x3F</MASK>
        <VALUE>0x13</VALUE>
        <TEXT>Int. RC Osc. 4 MHz; Start-up time: 6 CK + 4 ms; [CKSEL=0011 SUT=01]</TEXT>
      </TEXT14>
      <TEXT15>
        <MASK>0x3F</MASK>
        <VALUE>0x23</VALUE>
        <TEXT>Int. RC Osc. 4 MHz; Start-up time: 6 CK + 64 ms; [CKSEL=0011 SUT=10]</TEXT>
      </TEXT15>
      <TEXT16>
        <MASK>0x3F</MASK>
        <VALUE>0x04</VALUE>
        <TEXT>Int. RC Osc. 8 MHz; Start-up time: 6 CK + 0 ms; [CKSEL=0100 SUT=00]</TEXT>
      </TEXT16>
      <TEXT17>
        <MASK>0x3F</MASK>
        <VALUE>0x14</VALUE>
        <TEXT>Int. RC Osc. 8 MHz; Start-up time: 6 CK + 4 ms; [CKSEL=0100 SUT=01]</TEXT>
      </TEXT17>
      <TEXT18>
        <MASK>0x3F</MASK>
        <VALUE>0x24</VALUE>
        <TEXT>Int. RC Osc. 8 MHz; Start-up time: 6 CK + 64 ms; [CKSEL=0100 SUT=10]</TEXT>
      </TEXT18>
      <TEXT19>
        <MASK>0x3F</MASK>
        <VALUE>0x05</VALUE>
        <TEXT>Ext. RC Osc.         -  0.9 MHz; Start-up time: 18 CK + 0 ms; [CKSEL=0101 SUT=00]</TEXT>
      </TEXT19>
      <TEXT20>
        <MASK>0x3F</MASK>
        <VALUE>0x15</VALUE>
        <TEXT>Ext. RC Osc.         -  0.9 MHz; Start-up time: 18 CK + 4 ms; [CKSEL=0101 SUT=01]</TEXT>
      </TEXT20>
      <TEXT21>
        <MASK>0x3F</MASK>
        <VALUE>0x25</VALUE>
        <TEXT>Ext. RC Osc.         -  0.9 MHz; Start-up time: 18 CK + 64 ms; [CKSEL=0101 SUT=10]</TEXT>
      </TEXT21>
      <TEXT22>
        <MASK>0x3F</MASK>
        <VALUE>0x35</VALUE>
        <TEXT>Ext. RC Osc.         -  0.9 MHz; Start-up time: 6 CK + 4 ms; [CKSEL=0101 SUT=11]</TEXT>
      </TEXT22>
      <TEXT23>
        <MASK>0x3F</MASK>
        <VALUE>0x06</VALUE>
        <TEXT>Ext. RC Osc. 0.9 MHz -  3.0 MHz; Start-up time: 18 CK + 0 ms; [CKSEL=0110 SUT=00]</TEXT>
      </TEXT23>
      <TEXT24>
        <MASK>0x3F</MASK>
        <VALUE>0x16</VALUE>
        <TEXT>Ext. RC Osc. 0.9 MHz -  3.0 MHz; Start-up time: 18 CK + 4 ms; [CKSEL=0110 SUT=01]</TEXT>
      </TEXT24>
      <TEXT25>
        <MASK>0x3F</MASK>
        <VALUE>0x26</VALUE>
        <TEXT>Ext. RC Osc. 0.9 MHz -  3.0 MHz; Start-up time: 18 CK + 64 ms; [CKSEL=0110 SUT=10]</TEXT>
      </TEXT25>
      <TEXT26>
        <MASK>0x3F</MASK>
        <VALUE>0x36</VALUE>
        <TEXT>Ext. RC Osc. 0.9 MHz -  3.0 MHz; Start-up time: 6 CK + 4 ms; [CKSEL=0110 SUT=11]</TEXT>
      </TEXT26>
      <TEXT27>
        <MASK>0x3F</MASK>
        <VALUE>0x07</VALUE>
        <TEXT>Ext. RC Osc. 3.0 MHz -  8.0 MHz; Start-up time: 18 CK + 0 ms; [CKSEL=0111 SUT=00]</TEXT>
      </TEXT27>
      <TEXT28>
        <MASK>0x3F</MASK>
        <VALUE>0x17</VALUE>
        <TEXT>Ext. RC Osc. 3.0 MHz -  8.0 MHz; Start-up time: 18 CK + 4 ms; [CKSEL=0111 SUT=01]</TEXT>
      </TEXT28>
      <TEXT29>
        <MASK>0x3F</MASK>
        <VALUE>0x27</VALUE>
        <TEXT>Ext. RC Osc. 3.0 MHz -  8.0 MHz; Start-up time: 18 CK + 64 ms; [CKSEL=0111 SUT=10]</TEXT>
      </TEXT29>
      <TEXT30>
        <MASK>0x3F</MASK>
        <VALUE>0x37</VALUE>
        <TEXT>Ext. RC Osc. 3.0 MHz -  8.0 MHz; Start-up time: 6 CK + 4 ms; [CKSEL=0111 SUT=11]</TEXT>
      </TEXT30>
      <TEXT31>
        <MASK>0x3F</MASK>
        <VALUE>0x08</VALUE>
        <TEXT>Ext. RC Osc. 8.0 MHz - 12.0 MHz; Start-up time: 18 CK + 0 ms; [CKSEL=1000 SUT=00]</TEXT>
      </TEXT31>
      <TEXT32>
        <MASK>0x3F</MASK>
        <VALUE>0x18</VALUE>
        <TEXT>Ext. RC Osc. 8.0 MHz - 12.0 MHz; Start-up time: 18 CK + 4 ms; [CKSEL=1000 SUT=01]</TEXT>
      </TEXT32>
      <TEXT33>
        <MASK>0x3F</MASK>
        <VALUE>0x28</VALUE>
        <TEXT>Ext. RC Osc. 8.0 MHz - 12.0 MHz; Start-up time: 18 CK + 64 ms; [CKSEL=1000 SUT=10]</TEXT>
      </TEXT33>
      <TEXT34>
        <MASK>0x3F</MASK>
        <VALUE>0x38</VALUE>
        <TEXT>Ext. RC Osc. 8.0 MHz - 12.0 MHz; Start-up time: 6 CK + 4 ms; [CKSEL=1000 SUT=11]</TEXT>
      </TEXT34>
      <TEXT35>
        <MASK>0x3F</MASK>
        <VALUE>0x09</VALUE>
        <TEXT>Ext. Low-Freq. Crystal; Start-up time: 1K CK + 4 ms; [CKSEL=1001 SUT=00]</TEXT>
      </TEXT35>
      <TEXT36>
        <MASK>0x3F</MASK>
        <VALUE>0x19</VALUE>
        <TEXT>Ext. Low-Freq. Crystal; Start-up time: 1K CK + 64 ms; [CKSEL=1001 SUT=01]</TEXT>
      </TEXT36>
      <TEXT37>
        <MASK>0x3F</MASK>
        <VALUE>0x29</VALUE>
        <TEXT>Ext. Low-Freq. Crystal; Start-up time: 32K CK + 64 ms; [CKSEL=1001 SUT=10]</TEXT>
      </TEXT37>
      <TEXT38>
        <MASK>0x3F</MASK>
        <VALUE>0x0A</VALUE>
        <TEXT>Ext. Crystal/Resonator Low Freq.; Start-up time: 258 CK + 4 ms; [CKSEL=1010 SUT=00]</TEXT>
      </TEXT38>
      <TEXT39>
        <MASK>0x3F</MASK>
        <VALUE>0x1A</VALUE>
        <TEXT>Ext. Crystal/Resonator Low Freq.; Start-up time: 258 CK + 64 ms; [CKSEL=1010 SUT=01]</TEXT>
      </TEXT39>
      <TEXT40>
        <MASK>0x3F</MASK>
        <VALUE>0x2A</VALUE>
        <TEXT>Ext. Crystal/Resonator Low Freq.; Start-up time: 1K CK + 0 ms; [CKSEL=1010 SUT=10]</TEXT>
      </TEXT40>
      <TEXT41>
        <MASK>0x3F</MASK>
        <VALUE>0x3A</VALUE>
        <TEXT>Ext. Crystal/Resonator Low Freq.; Start-up time: 1K CK + 4 ms; [CKSEL=1010 SUT=11]</TEXT>
      </TEXT41>
      <TEXT42>
        <MASK>0x3F</MASK>
        <VALUE>0x0B</VALUE>
        <TEXT>Ext. Crystal/Resonator Low Freq.; Start-up time: 1K CK + 64 ms; [CKSEL=1011 SUT=00]</TEXT>
      </TEXT42>
      <TEXT43>
        <MASK>0x3F</MASK>
        <VALUE>0x1B</VALUE>
        <TEXT>Ext. Crystal/Resonator Low Freq.; Start-up time: 16K CK + 0 ms; [CKSEL=1011 SUT=01]</TEXT>
      </TEXT43>
      <TEXT44>
        <MASK>0x3F</MASK>
        <VALUE>0x2B</VALUE>
        <TEXT>Ext. Crystal/Resonator Low Freq.; Start-up time: 16K CK + 4 ms; [CKSEL=1011 SUT=10]</TEXT>
      </TEXT44>
      <TEXT45>
        <MASK>0x3F</MASK>
        <VALUE>0x3B</VALUE>
        <TEXT>Ext. Crystal/Resonator Low Freq.; Start-up time: 16K CK + 64 ms; [CKSEL=1011 SUT=11]</TEXT>
      </TEXT45>
      <TEXT46>
        <MASK>0x3F</MASK>
        <VALUE>0x0C</VALUE>
        <TEXT>Ext. Crystal/Resonator Medium Freq.; Start-up time: 258 CK + 4 ms; [CKSEL=1100 SUT=00]</TEXT>
      </TEXT46>
      <TEXT47>
        <MASK>0x3F</MASK>
        <VALUE>0x1C</VALUE>
        <TEXT>Ext. Crystal/Resonator Medium Freq.; Start-up time: 258 CK + 64 ms; [CKSEL=1100 SUT=01]</TEXT>
      </TEXT47>
      <TEXT48>
        <MASK>0x3F</MASK>
        <VALUE>0x2C</VALUE>
        <TEXT>Ext. Crystal/Resonator Medium Freq.; Start-up time: 1K CK + 0 ms; [CKSEL=1100 SUT=10]</TEXT>
      </TEXT48>
      <TEXT49>
        <MASK>0x3F</MASK>
        <VALUE>0x3C</VALUE>
        <TEXT>Ext. Crystal/Resonator Medium Freq.; Start-up time: 1K CK + 4 ms; [CKSEL=1100 SUT=11]</TEXT>
      </TEXT49>
      <TEXT50>
        <MASK>0x3F</MASK>
        <VALUE>0x0D</VALUE>
        <TEXT>Ext. Crystal/Resonator Medium Freq.; Start-up time: 1K CK + 64 ms; [CKSEL=1101 SUT=00]</TEXT>
      </TEXT50>
      <TEXT51>
        <MASK>0x3F</MASK>
        <VALUE>0x1D</VALUE>
        <TEXT>Ext. Crystal/Resonator Medium Freq.; Start-up time: 16K CK + 0 ms; [CKSEL=1101 SUT=01]</TEXT>
      </TEXT51>
      <TEXT52>
        <MASK>0x3F</MASK>
        <VALUE>0x2D</VALUE>
        <TEXT>Ext. Crystal/Resonator Medium Freq.; Start-up time: 16K CK + 4 ms; [CKSEL=1101 SUT=10]</TEXT>
      </TEXT52>
      <TEXT53>
        <MASK>0x3F</MASK>
        <VALUE>0x3D</VALUE>
        <TEXT>Ext. Crystal/Resonator Medium Freq.; Start-up time: 16K CK + 64 ms; [CKSEL=1101 SUT=11]</TEXT>
      </TEXT53>
      <TEXT54>
        <MASK>0x3F</MASK>
        <VALUE>0x0E</VALUE>
        <TEXT>Ext. Crystal/Resonator High Freq.; Start-up time: 258 CK + 4 ms; [CKSEL=1110 SUT=00]</TEXT>
      </TEXT54>
      <TEXT55>
        <MASK>0x3F</MASK>
        <VALUE>0x1E</VALUE>
        <TEXT>Ext. Crystal/Resonator High Freq.; Start-up time: 258 CK + 64 ms; [CKSEL=1110 SUT=01]</TEXT>
      </TEXT55>
      <TEXT56>
        <MASK>0x3F</MASK>
        <VALUE>0x2E</VALUE>
        <TEXT>Ext. Crystal/Resonator High Freq.; Start-up time: 1K CK + 0 ms; [CKSEL=1110 SUT=10]</TEXT>
      </TEXT56>
      <TEXT57>
        <MASK>0x3F</MASK>
        <VALUE>0x3E</VALUE>
        <TEXT>Ext. Crystal/Resonator High Freq.; Start-up time: 1K CK + 4 ms; [CKSEL=1110 SUT=11]</TEXT>
      </TEXT57>
      <TEXT58>
        <MASK>0x3F</MASK>
        <VALUE>0x0F</VALUE>
        <TEXT>Ext. Crystal/Resonator High Freq.; Start-up time: 1K CK + 64 ms; [CKSEL=1111 SUT=00]</TEXT>
      </TEXT58>
      <TEXT59>
        <MASK>0x3F</MASK>
        <VALUE>0x1F</VALUE>
        <TEXT>Ext. Crystal/Resonator High Freq.; Start-up time: 16K CK + 0 ms; [CKSEL=1111 SUT=01]</TEXT>
      </TEXT59>
      <TEXT60>
        <MASK>0x3F</MASK>
        <VALUE>0x2F</VALUE>
        <TEXT>Ext. Crystal/Resonator High Freq.; Start-up time: 16K CK + 4 ms; [CKSEL=1111 SUT=10]</TEXT>
      </TEXT60>
      <TEXT61>
        <MASK>0x3F</MASK>
        <VALUE>0x3F</VALUE>
        <TEXT>Ext. Crystal/Resonator High Freq.; Start-up time: 16K CK + 64 ms; [CKSEL=1111 SUT=11]</TEXT>
      </TEXT61>
    </LOW>
    <HIGH>
      <NMB_FUSE_BITS>8</NMB_FUSE_BITS>
      <FUSE7>
        <NAME>OCDEN</NAME>
        <TEXT>Enable OCD</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE7>
      <FUSE6>
        <NAME>JTAGEN</NAME>
        <TEXT>Enable JTAG</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE6>
      <FUSE5>
        <NAME>SPIEN</NAME>
        <TEXT>Enable Serial programming and Data Downloading</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE5>
      <FUSE4>
        <NAME>CKOPT</NAME>
        <TEXT>Oscillator Options</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE4>
      <FUSE3>
        <NAME>EESAVE</NAME>
        <TEXT>EEPROM memory is preserved through chip erase</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE3>
      <FUSE2>
        <NAME>BOOTSZ1</NAME>
        <TEXT>Select Boot Size</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE2>
      <FUSE1>
        <NAME>BOOTSZ0</NAME>
        <TEXT>Select Boot Size</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE1>
      <FUSE0>
        <NAME>BOOTRST</NAME>
        <TEXT>Select Reset Vector</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE0>
      <NMB_TEXT>10</NMB_TEXT>
      <TEXT1>
        <MASK>0x80</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>On-Chip Debug Enabled; [OCDEN=0]</TEXT>
      </TEXT1>
      <TEXT2>
        <MASK>0x40</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>JTAG Interface Enabled; [JTAGEN=0]</TEXT>
      </TEXT2>
      <TEXT3>
        <MASK>0x20</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Serial program downloading (SPI) enabled; [SPIEN=0]</TEXT>
      </TEXT3>
      <TEXT4>
        <MASK>0x08</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Preserve EEPROM memory through the Chip Erase cycle; [EESAVE=0]</TEXT>
      </TEXT4>
      <TEXT5>
        <MASK>0x06</MASK>
        <VALUE>0x06</VALUE>
        <TEXT>Boot Flash section size=512 words Boot start address=$FE00; [BOOTSZ=11]</TEXT>
      </TEXT5>
      <TEXT6>
        <MASK>0x06</MASK>
        <VALUE>0x04</VALUE>
        <TEXT>Boot Flash section size=1024 words Boot start address=$FC00; [BOOTSZ=10]</TEXT>
      </TEXT6>
      <TEXT7>
        <MASK>0x06</MASK>
        <VALUE>0x02</VALUE>
        <TEXT>Boot Flash section size=2048 words Boot start address=$F800; [BOOTSZ=01]</TEXT>
      </TEXT7>
      <TEXT8>
        <MASK>0x06</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Boot Flash section size=4096 words Boot start address=$F000; [BOOTSZ=00] ; default value</TEXT>
      </TEXT8>
      <TEXT9>
        <MASK>0x01</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Boot Reset vector Enabled (default address=$0000); [BOOTRST=0]</TEXT>
      </TEXT9>
      <TEXT10>
        <MASK>0x10</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>CKOPT fuse (operation dependent of CKSEL fuses); [CKOPT=0]</TEXT>
      </TEXT10>
    </HIGH>
    <EXTENDED>
      <NMB_FUSE_BITS>2</NMB_FUSE_BITS>
      <FUSE1>
        <NAME>M103C</NAME>
        <TEXT>ATmega103 compatibility mode</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE1>
      <FUSE0>
        <NAME>WDTON</NAME>
        <TEXT>Watchdog timer always on</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE0>
      <NMB_TEXT>2</NMB_TEXT>
      <TEXT1>
        <MASK>0x02</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>ATmega103 Compatibility Mode [M103C=0]</TEXT>
      </TEXT1>
      <TEXT2>
        <MASK>0x01</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Watchdog Timer always on; [WDTON=0]</TEXT>
      </TEXT2>
    </EXTENDED>
  </FUSE>
  <INTERRUPT_VECTOR>
    <NMB_VECTORS>35</NMB_VECTORS>
    <ID>AVRSimInterrupt.SimInterrupt</ID>
    <VECTOR1>
      <PROGRAM_ADDRESS>$0000</PROGRAM_ADDRESS>
      <SOURCE>RESET</SOURCE>
      <DEFINITION>External Pin, Power-on Reset, Brown-out Reset, Watchdog Reset and JTAG AVR Reset</DEFINITION>
    </VECTOR1>
    <VECTOR2>
      <PROGRAM_ADDRESS>$0002</PROGRAM_ADDRESS>
      <SOURCE>INT0</SOURCE>
      <DEFINITION>External Interrupt Request 0</DEFINITION>
    </VECTOR2>
    <VECTOR3>
      <PROGRAM_ADDRESS>$0004</PROGRAM_ADDRESS>
      <SOURCE>INT1</SOURCE>
      <DEFINITION>External Interrupt Request 1</DEFINITION>
    </VECTOR3>
    <VECTOR4>
      <PROGRAM_ADDRESS>$0006</PROGRAM_ADDRESS>
      <SOURCE>INT2</SOURCE>
      <DEFINITION>External Interrupt Request 2</DEFINITION>
    </VECTOR4>
    <VECTOR5>
      <PROGRAM_ADDRESS>$0008</PROGRAM_ADDRESS>
      <SOURCE>INT3</SOURCE>
      <DEFINITION>External Interrupt Request 3</DEFINITION>
    </VECTOR5>
    <VECTOR6>
      <PROGRAM_ADDRESS>$000A</PROGRAM_ADDRESS>
      <SOURCE>INT4</SOURCE>
      <DEFINITION>External Interrupt Request 4</DEFINITION>
    </VECTOR6>
    <VECTOR7>
      <PROGRAM_ADDRESS>$000C</PROGRAM_ADDRESS>
      <SOURCE>INT5</SOURCE>
      <DEFINITION>External Interrupt Request 5</DEFINITION>
    </VECTOR7>
    <VECTOR8>
      <PROGRAM_ADDRESS>$000E</PROGRAM_ADDRESS>
      <SOURCE>INT6</SOURCE>
      <DEFINITION>External Interrupt Request 6</DEFINITION>
    </VECTOR8>
    <VECTOR9>
      <PROGRAM_ADDRESS>$0010</PROGRAM_ADDRESS>
      <SOURCE>INT7</SOURCE>
      <DEFINITION>External Interrupt Request 7</DEFINITION>
    </VECTOR9>
    <VECTOR10>
      <PROGRAM_ADDRESS>$0012</PROGRAM_ADDRESS>
      <SOURCE>TIMER2 COMP</SOURCE>
      <DEFINITION>Timer/Counter2 Compare Match</DEFINITION>
    </VECTOR10>
    <VECTOR11>
      <PROGRAM_ADDRESS>$0014</PROGRAM_ADDRESS>
      <SOURCE>TIMER2 OVF</SOURCE>
      <DEFINITION>Timer/Counter2 Overflow</DEFINITION>
    </VECTOR11>
    <VECTOR12>
      <PROGRAM_ADDRESS>$0016</PROGRAM_ADDRESS>
      <SOURCE>TIMER1 CAPT</SOURCE>
      <DEFINITION>Timer/Counter1 Capture Event</DEFINITION>
    </VECTOR12>
    <VECTOR13>
      <PROGRAM_ADDRESS>$0018</PROGRAM_ADDRESS>
      <SOURCE>TIMER1 COMPA</SOURCE>
      <DEFINITION>Timer/Counter1 Compare Match A</DEFINITION>
    </VECTOR13>
    <VECTOR14>
      <PROGRAM_ADDRESS>$001A</PROGRAM_ADDRESS>
      <SOURCE>TIMER1 COMPB</SOURCE>
      <DEFINITION>Timer/Counter Compare Match B</DEFINITION>
    </VECTOR14>
    <VECTOR15>
      <PROGRAM_ADDRESS>$001C</PROGRAM_ADDRESS>
      <SOURCE>TIMER1 OVF</SOURCE>
      <DEFINITION>Timer/Counter1 Overflow</DEFINITION>
    </VECTOR15>
    <VECTOR16>
      <PROGRAM_ADDRESS>$001E</PROGRAM_ADDRESS>
      <SOURCE>TIMER0 COMP</SOURCE>
      <DEFINITION>Timer/Counter0 Compare Match</DEFINITION>
    </VECTOR16>
    <VECTOR17>
      <PROGRAM_ADDRESS>$0020</PROGRAM_ADDRESS>
      <SOURCE>TIMER0 OVF</SOURCE>
      <DEFINITION>Timer/Counter0 Overflow</DEFINITION>
    </VECTOR17>
    <VECTOR18>
      <PROGRAM_ADDRESS>$0022</PROGRAM_ADDRESS>
      <SOURCE>SPI, STC</SOURCE>
      <DEFINITION>SPI Serial Transfer Complete</DEFINITION>
    </VECTOR18>
    <VECTOR19>
      <PROGRAM_ADDRESS>$0024</PROGRAM_ADDRESS>
      <SOURCE>USART0, RX</SOURCE>
      <DEFINITION>USART0, Rx Complete</DEFINITION>
    </VECTOR19>
    <VECTOR20>
      <PROGRAM_ADDRESS>$0026</PROGRAM_ADDRESS>
      <SOURCE>USART0, UDRE</SOURCE>
      <DEFINITION>USART0 Data Register Empty</DEFINITION>
    </VECTOR20>
    <VECTOR21>
      <PROGRAM_ADDRESS>$0028</PROGRAM_ADDRESS>
      <SOURCE>USART0, TX</SOURCE>
      <DEFINITION>USART0, Tx Complete</DEFINITION>
    </VECTOR21>
    <VECTOR22>
      <PROGRAM_ADDRESS>$002A</PROGRAM_ADDRESS>
      <SOURCE>ADC</SOURCE>
      <DEFINITION>ADC Conversion Complete</DEFINITION>
    </VECTOR22>
    <VECTOR23>
      <PROGRAM_ADDRESS>$002C</PROGRAM_ADDRESS>
      <SOURCE>EE READY</SOURCE>
      <DEFINITION>EEPROM Ready</DEFINITION>
    </VECTOR23>
    <VECTOR24>
      <PROGRAM_ADDRESS>$002E</PROGRAM_ADDRESS>
      <SOURCE>ANALOG COMP</SOURCE>
      <DEFINITION>Analog Comparator</DEFINITION>
    </VECTOR24>
    <VECTOR25>
      <PROGRAM_ADDRESS>$0030</PROGRAM_ADDRESS>
      <SOURCE>TIMER1 COMPC</SOURCE>
      <DEFINITION>Timer/Counter1 Compare Match C</DEFINITION>
    </VECTOR25>
    <VECTOR26>
      <PROGRAM_ADDRESS>$0032</PROGRAM_ADDRESS>
      <SOURCE>TIMER3 CAPT</SOURCE>
      <DEFINITION>Timer/Counter3 Capture Event</DEFINITION>
    </VECTOR26>
    <VECTOR27>
      <PROGRAM_ADDRESS>$0034</PROGRAM_ADDRESS>
      <SOURCE>TIMER3 COMPA</SOURCE>
      <DEFINITION>Timer/Counter3 Compare Match A</DEFINITION>
    </VECTOR27>
    <VECTOR28>
      <PROGRAM_ADDRESS>$0036</PROGRAM_ADDRESS>
      <SOURCE>TIMER3 COMPB</SOURCE>
      <DEFINITION>Timer/Counter3 Compare Match B</DEFINITION>
    </VECTOR28>
    <VECTOR29>
      <PROGRAM_ADDRESS>$0038</PROGRAM_ADDRESS>
      <SOURCE>TIMER3 COMPC</SOURCE>
      <DEFINITION>Timer/Counter3 Compare Match C</DEFINITION>
    </VECTOR29>
    <VECTOR30>
      <PROGRAM_ADDRESS>$003A</PROGRAM_ADDRESS>
      <SOURCE>TIMER3 OVF</SOURCE>
      <DEFINITION>Timer/Counter3 Overflow</DEFINITION>
    </VECTOR30>
    <VECTOR31>
      <PROGRAM_ADDRESS>$003C</PROGRAM_ADDRESS>
      <SOURCE>USART1, RX</SOURCE>
      <DEFINITION>USART1, Rx Complete</DEFINITION>
    </VECTOR31>
    <VECTOR32>
      <PROGRAM_ADDRESS>$003E</PROGRAM_ADDRESS>
      <SOURCE>USART1, UDRE</SOURCE>
      <DEFINITION>USART1, Data Register Empty</DEFINITION>
    </VECTOR32>
    <VECTOR33>
      <PROGRAM_ADDRESS>$0040</PROGRAM_ADDRESS>
      <SOURCE>USART1, TX</SOURCE>
      <DEFINITION>USART1, Tx Complete</DEFINITION>
    </VECTOR33>
    <VECTOR34>
      <PROGRAM_ADDRESS>$0042</PROGRAM_ADDRESS>
      <SOURCE>TWI</SOURCE>
      <DEFINITION>2-wire Serial Interface</DEFINITION>
    </VECTOR34>
    <VECTOR35>
      <PROGRAM_ADDRESS>$0044</PROGRAM_ADDRESS>
      <SOURCE>SPM READY</SOURCE>
      <DEFINITION>Store Program Memory Read</DEFINITION>
    </VECTOR35>
  </INTERRUPT_VECTOR>
  <MEMORY>
    <PROG_FLASH>131072</PROG_FLASH>
    <EEPROM>4096</EEPROM>
    <INT_SRAM>
      <SIZE>4096</SIZE>
      <START_ADDR>$0100</START_ADDR>
      <MEGA_103_MODE>
        <SIZE>4000</SIZE>
        <START_ADDR>$0060</START_ADDR>
      </MEGA_103_MODE>
    </INT_SRAM>
    <EXT_SRAM>
      <SIZE>65536</SIZE>
      <START_ADDR>$1100</START_ADDR>
      <MEGA_103_MODE>
        <SIZE>65536</SIZE>
        <START_ADDR>$1000</START_ADDR>
      </MEGA_103_MODE>
    </EXT_SRAM>
    <IO_MEMORY>
      <IO_START_ADDR>$0000</IO_START_ADDR>
      <IO_STOP_ADDR>$003F</IO_STOP_ADDR>
      <EXT_IO_START_ADDR>$0060</EXT_IO_START_ADDR>
      <EXT_IO_STOP_ADDR>$00FF</EXT_IO_STOP_ADDR>
      <MEM_START_ADDR>$0020</MEM_START_ADDR>
      <MEM_STOP_ADDR>$00FF</MEM_STOP_ADDR>
      <UCSR1C>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x9D</MEM_ADDR>
        <UCPOL1_MASK>0x01</UCPOL1_MASK>
        <UCSZ10_MASK>0x02</UCSZ10_MASK>
        <UCSZ11_MASK>0x04</UCSZ11_MASK>
        <USBS1_MASK>0x08</USBS1_MASK>
        <UPM10_MASK>0x10</UPM10_MASK>
        <UPM11_MASK>0x20</UPM11_MASK>
        <UMSEL1_MASK>0x40</UMSEL1_MASK>
      </UCSR1C>
      <UDR1>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x9C</MEM_ADDR>
        <UDR10_MASK>0x01</UDR10_MASK>
        <UDR11_MASK>0x02</UDR11_MASK>
        <UDR12_MASK>0x04</UDR12_MASK>
        <UDR13_MASK>0x08</UDR13_MASK>
        <UDR14_MASK>0x10</UDR14_MASK>
        <UDR15_MASK>0x20</UDR15_MASK>
        <UDR16_MASK>0x40</UDR16_MASK>
        <UDR17_MASK>0x80</UDR17_MASK>
      </UDR1>
      <UCSR1A>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x9B</MEM_ADDR>
        <MPCM1_MASK>0x01</MPCM1_MASK>
        <U2X1_MASK>0x02</U2X1_MASK>
        <UPE1_MASK>0x04</UPE1_MASK>
        <DOR1_MASK>0x08</DOR1_MASK>
        <FE1_MASK>0x10</FE1_MASK>
        <UDRE1_MASK>0x20</UDRE1_MASK>
        <TXC1_MASK>0x40</TXC1_MASK>
        <RXC1_MASK>0x80</RXC1_MASK>
      </UCSR1A>
      <UCSR1B>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x9A</MEM_ADDR>
        <TXB81_MASK>0x01</TXB81_MASK>
        <RXB81_MASK>0x02</RXB81_MASK>
        <UCSZ12_MASK>0x04</UCSZ12_MASK>
        <TXEN1_MASK>0x08</TXEN1_MASK>
        <RXEN1_MASK>0x10</RXEN1_MASK>
        <UDRIE1_MASK>0x20</UDRIE1_MASK>
        <TXCIE1_MASK>0x40</TXCIE1_MASK>
        <RXCIE1_MASK>0x80</RXCIE1_MASK>
      </UCSR1B>
      <UBRR1L>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x99</MEM_ADDR>
        <UBRR0_MASK>0x01</UBRR0_MASK>
        <UBRR1_MASK>0x02</UBRR1_MASK>
        <UBRR2_MASK>0x04</UBRR2_MASK>
        <UBRR3_MASK>0x08</UBRR3_MASK>
        <UBRR4_MASK>0x10</UBRR4_MASK>
        <UBRR5_MASK>0x20</UBRR5_MASK>
        <UBRR6_MASK>0x40</UBRR6_MASK>
        <UBRR7_MASK>0x80</UBRR7_MASK>
      </UBRR1L>
      <UBRR1H>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x98</MEM_ADDR>
        <UBRR8_MASK>0x01</UBRR8_MASK>
        <UBRR9_MASK>0x02</UBRR9_MASK>
        <UBRR10_MASK>0x04</UBRR10_MASK>
        <UBRR11_MASK>0x08</UBRR11_MASK>
      </UBRR1H>
      <UCSR0C>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x95</MEM_ADDR>
        <UCPOL0_MASK>0x01</UCPOL0_MASK>
        <UCSZ00_MASK>0x02</UCSZ00_MASK>
        <UCSZ01_MASK>0x04</UCSZ01_MASK>
        <USBS0_MASK>0x08</USBS0_MASK>
        <UPM00_MASK>0x10</UPM00_MASK>
        <UPM01_MASK>0x20</UPM01_MASK>
        <UMSEL0_MASK>0x40</UMSEL0_MASK>
      </UCSR0C>
      <UBRR0H>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x90</MEM_ADDR>
        <UBRR8_MASK>0x01</UBRR8_MASK>
        <UBRR9_MASK>0x02</UBRR9_MASK>
        <UBRR10_MASK>0x04</UBRR10_MASK>
        <UBRR11_MASK>0x08</UBRR11_MASK>
      </UBRR0H>
      <TCCR3C>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x8C</MEM_ADDR>
        <FOC3C_MASK>0x20</FOC3C_MASK>
        <FOC3B_MASK>0x40</FOC3B_MASK>
        <FOC3A_MASK>0x80</FOC3A_MASK>
      </TCCR3C>
      <TCCR3A>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x8B</MEM_ADDR>
        <WGM30_MASK>0x01</WGM30_MASK>
        <WGM31_MASK>0x02</WGM31_MASK>
        <COM3C0_MASK>0x04</COM3C0_MASK>
        <COM3C1_MASK>0x08</COM3C1_MASK>
        <COM3B0_MASK>0x10</COM3B0_MASK>
        <COM3B1_MASK>0x20</COM3B1_MASK>
        <COM3A0_MASK>0x40</COM3A0_MASK>
        <COM3A1_MASK>0x80</COM3A1_MASK>
      </TCCR3A>
      <TCCR3B>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x8A</MEM_ADDR>
        <CS30_MASK>0x01</CS30_MASK>
        <CS31_MASK>0x02</CS31_MASK>
        <CS32_MASK>0x04</CS32_MASK>
        <WGM32_MASK>0x08</WGM32_MASK>
        <WGM33_MASK>0x10</WGM33_MASK>
        <ICES3_MASK>0x40</ICES3_MASK>
        <ICNC3_MASK>0x80</ICNC3_MASK>
      </TCCR3B>
      <TCNT3H>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x89</MEM_ADDR>
        <TCNT3H0_MASK>0x01</TCNT3H0_MASK>
        <TCNT3H1_MASK>0x02</TCNT3H1_MASK>
        <TCNT3H2_MASK>0x04</TCNT3H2_MASK>
        <TCNT3H3_MASK>0x08</TCNT3H3_MASK>
        <TCNT3H4_MASK>0x10</TCNT3H4_MASK>
        <TCNT3H5_MASK>0x20</TCNT3H5_MASK>
        <TCNT3H6_MASK>0x40</TCNT3H6_MASK>
        <TCNT3H7_MASK>0x80</TCNT3H7_MASK>
      </TCNT3H>
      <TCNT3L>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x88</MEM_ADDR>
        <TCN3L0_MASK>0x01</TCN3L0_MASK>
        <TCN3L1_MASK>0x02</TCN3L1_MASK>
        <TCN3L2_MASK>0x04</TCN3L2_MASK>
        <TCN3L3_MASK>0x08</TCN3L3_MASK>
        <TCN3L4_MASK>0x10</TCN3L4_MASK>
        <TCN3L5_MASK>0x20</TCN3L5_MASK>
        <TCN3L6_MASK>0x40</TCN3L6_MASK>
        <TCN3L7_MASK>0x80</TCN3L7_MASK>
      </TCNT3L>
      <OCR3AH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x87</MEM_ADDR>
        <OCR3AH0_MASK>0x01</OCR3AH0_MASK>
        <OCR3AH1_MASK>0x02</OCR3AH1_MASK>
        <OCR3AH2_MASK>0x04</OCR3AH2_MASK>
        <OCR3AH3_MASK>0x08</OCR3AH3_MASK>
        <OCR3AH4_MASK>0x10</OCR3AH4_MASK>
        <OCR3AH5_MASK>0x20</OCR3AH5_MASK>
        <OCR3AH6_MASK>0x40</OCR3AH6_MASK>
        <OCR3AH7_MASK>0x80</OCR3AH7_MASK>
      </OCR3AH>
      <OCR3AL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x86</MEM_ADDR>
        <OCR3AL0_MASK>0x01</OCR3AL0_MASK>
        <OCR3AL1_MASK>0x02</OCR3AL1_MASK>
        <OCR3AL2_MASK>0x04</OCR3AL2_MASK>
        <OCR3AL3_MASK>0x08</OCR3AL3_MASK>
        <OCR3AL4_MASK>0x10</OCR3AL4_MASK>
        <OCR3AL5_MASK>0x20</OCR3AL5_MASK>
        <OCR3AL6_MASK>0x40</OCR3AL6_MASK>
        <OCR3AL7_MASK>0x80</OCR3AL7_MASK>
      </OCR3AL>
      <OCR3BH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x85</MEM_ADDR>
        <OCR3BH0_MASK>0x01</OCR3BH0_MASK>
        <OCR3BH1_MASK>0x02</OCR3BH1_MASK>
        <OCR3BH2_MASK>0x04</OCR3BH2_MASK>
        <OCR3BH3_MASK>0x08</OCR3BH3_MASK>
        <OCR3BH4_MASK>0x10</OCR3BH4_MASK>
        <OCR3BH5_MASK>0x20</OCR3BH5_MASK>
        <OCR3BH6_MASK>0x40</OCR3BH6_MASK>
        <OCR3BH7_MASK>0x80</OCR3BH7_MASK>
      </OCR3BH>
      <OCR3BL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x84</MEM_ADDR>
        <OCR3BL0_MASK>0x01</OCR3BL0_MASK>
        <OCR3BL1_MASK>0x02</OCR3BL1_MASK>
        <OCR3BL2_MASK>0x04</OCR3BL2_MASK>
        <OCR3BL3_MASK>0x08</OCR3BL3_MASK>
        <OCR3BL4_MASK>0x10</OCR3BL4_MASK>
        <OCR3BL5_MASK>0x20</OCR3BL5_MASK>
        <OCR3BL6_MASK>0x40</OCR3BL6_MASK>
        <OCR3BL7_MASK>0x80</OCR3BL7_MASK>
      </OCR3BL>
      <OCR3CH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x83</MEM_ADDR>
        <OCR3CH0_MASK>0x01</OCR3CH0_MASK>
        <OCR3CH1_MASK>0x02</OCR3CH1_MASK>
        <OCR3CH2_MASK>0x04</OCR3CH2_MASK>
        <OCR3CH3_MASK>0x08</OCR3CH3_MASK>
        <OCR3CH4_MASK>0x10</OCR3CH4_MASK>
        <OCR3CH5_MASK>0x20</OCR3CH5_MASK>
        <OCR3CH6_MASK>0x40</OCR3CH6_MASK>
        <OCR3CH7_MASK>0x80</OCR3CH7_MASK>
      </OCR3CH>
      <OCR3CL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x82</MEM_ADDR>
        <OCR3CL0_MASK>0x01</OCR3CL0_MASK>
        <OCR3CL1_MASK>0x02</OCR3CL1_MASK>
        <OCR3CL2_MASK>0x04</OCR3CL2_MASK>
        <OCR3CL3_MASK>0x08</OCR3CL3_MASK>
        <OCR3CL4_MASK>0x10</OCR3CL4_MASK>
        <OCR3CL5_MASK>0x20</OCR3CL5_MASK>
        <OCR3CL6_MASK>0x40</OCR3CL6_MASK>
        <OCR3CL7_MASK>0x80</OCR3CL7_MASK>
      </OCR3CL>
      <ICR3H>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x81</MEM_ADDR>
        <ICR3H0_MASK>0x01</ICR3H0_MASK>
        <ICR3H1_MASK>0x02</ICR3H1_MASK>
        <ICR3H2_MASK>0x04</ICR3H2_MASK>
        <ICR3H3_MASK>0x08</ICR3H3_MASK>
        <ICR3H4_MASK>0x10</ICR3H4_MASK>
        <ICR3H5_MASK>0x20</ICR3H5_MASK>
        <ICR3H6_MASK>0x40</ICR3H6_MASK>
        <ICR3H7_MASK>0x80</ICR3H7_MASK>
      </ICR3H>
      <ICR3L>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x80</MEM_ADDR>
        <ICR3L0_MASK>0x01</ICR3L0_MASK>
        <ICR3L1_MASK>0x02</ICR3L1_MASK>
        <ICR3L2_MASK>0x04</ICR3L2_MASK>
        <ICR3L3_MASK>0x08</ICR3L3_MASK>
        <ICR3L4_MASK>0x10</ICR3L4_MASK>
        <ICR3L5_MASK>0x20</ICR3L5_MASK>
        <ICR3L6_MASK>0x40</ICR3L6_MASK>
        <ICR3L7_MASK>0x80</ICR3L7_MASK>
      </ICR3L>
      <ETIMSK>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x7D</MEM_ADDR>
        <OCIE1C_MASK>0x01</OCIE1C_MASK>
        <OCIE3C_MASK>0x02</OCIE3C_MASK>
        <TOIE3_MASK>0x04</TOIE3_MASK>
        <OCIE3B_MASK>0x08</OCIE3B_MASK>
        <OCIE3A_MASK>0x10</OCIE3A_MASK>
        <TICIE3_MASK>0x20</TICIE3_MASK>
      </ETIMSK>
      <ETIFR>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x7C</MEM_ADDR>
        <OCF1C_MASK>0x01</OCF1C_MASK>
        <OCF3C_MASK>0x02</OCF3C_MASK>
        <TOV3_MASK>0x04</TOV3_MASK>
        <OCF3B_MASK>0x08</OCF3B_MASK>
        <OCF3A_MASK>0x10</OCF3A_MASK>
        <ICF3_MASK>0x20</ICF3_MASK>
      </ETIFR>
      <TCCR1C>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x7A</MEM_ADDR>
        <FOC1C_MASK>0x20</FOC1C_MASK>
        <FOC1B_MASK>0x40</FOC1B_MASK>
        <FOC1A_MASK>0x80</FOC1A_MASK>
      </TCCR1C>
      <OCR1CH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x79</MEM_ADDR>
        <OCR1CH0_MASK>0x01</OCR1CH0_MASK>
        <OCR1CH1_MASK>0x02</OCR1CH1_MASK>
        <OCR1CH2_MASK>0x04</OCR1CH2_MASK>
        <OCR1CH3_MASK>0x08</OCR1CH3_MASK>
        <OCR1CH4_MASK>0x10</OCR1CH4_MASK>
        <OCR1CH5_MASK>0x20</OCR1CH5_MASK>
        <OCR1CH6_MASK>0x40</OCR1CH6_MASK>
        <OCR1CH7_MASK>0x80</OCR1CH7_MASK>
      </OCR1CH>
      <OCR1CL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x78</MEM_ADDR>
        <OCR1CL0_MASK>0x01</OCR1CL0_MASK>
        <OCR1CL1_MASK>0x02</OCR1CL1_MASK>
        <OCR1CL2_MASK>0x04</OCR1CL2_MASK>
        <OCR1CL3_MASK>0x08</OCR1CL3_MASK>
        <OCR1CL4_MASK>0x10</OCR1CL4_MASK>
        <OCR1CL5_MASK>0x20</OCR1CL5_MASK>
        <OCR1CL6_MASK>0x40</OCR1CL6_MASK>
        <OCR1CL7_MASK>0x80</OCR1CL7_MASK>
      </OCR1CL>
      <TWCR>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x74</MEM_ADDR>
        <TWIE_MASK>0x01</TWIE_MASK>
        <TWEN_MASK>0x04</TWEN_MASK>
        <TWWC_MASK>0x08</TWWC_MASK>
        <TWSTO_MASK>0x10</TWSTO_MASK>
        <TWSTA_MASK>0x20</TWSTA_MASK>
        <TWEA_MASK>0x40</TWEA_MASK>
        <TWINT_MASK>0x80</TWINT_MASK>
      </TWCR>
      <TWDR>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x73</MEM_ADDR>
        <TWD0_MASK>0x01</TWD0_MASK>
        <TWD1_MASK>0x02</TWD1_MASK>
        <TWD2_MASK>0x04</TWD2_MASK>
        <TWD3_MASK>0x08</TWD3_MASK>
        <TWD4_MASK>0x10</TWD4_MASK>
        <TWD5_MASK>0x20</TWD5_MASK>
        <TWD6_MASK>0x40</TWD6_MASK>
        <TWD7_MASK>0x80</TWD7_MASK>
      </TWDR>
      <TWAR>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x72</MEM_ADDR>
        <TWGCE_MASK>0x01</TWGCE_MASK>
        <TWA0_MASK>0x02</TWA0_MASK>
        <TWA1_MASK>0x04</TWA1_MASK>
        <TWA2_MASK>0x08</TWA2_MASK>
        <TWA3_MASK>0x10</TWA3_MASK>
        <TWA4_MASK>0x20</TWA4_MASK>
        <TWA5_MASK>0x40</TWA5_MASK>
        <TWA6_MASK>0x80</TWA6_MASK>
      </TWAR>
      <TWSR>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x71</MEM_ADDR>
        <TWPS0_MASK>0x01</TWPS0_MASK>
        <TWPS1_MASK>0x02</TWPS1_MASK>
        <TWS3_MASK>0x08</TWS3_MASK>
        <TWS4_MASK>0x10</TWS4_MASK>
        <TWS5_MASK>0x20</TWS5_MASK>
        <TWS6_MASK>0x40</TWS6_MASK>
        <TWS7_MASK>0x80</TWS7_MASK>
      </TWSR>
      <TWBR>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x70</MEM_ADDR>
        <TWBR0_MASK>0x01</TWBR0_MASK>
        <TWBR1_MASK>0x02</TWBR1_MASK>
        <TWBR2_MASK>0x04</TWBR2_MASK>
        <TWBR3_MASK>0x08</TWBR3_MASK>
        <TWBR4_MASK>0x10</TWBR4_MASK>
        <TWBR5_MASK>0x20</TWBR5_MASK>
        <TWBR6_MASK>0x40</TWBR6_MASK>
        <TWBR7_MASK>0x80</TWBR7_MASK>
      </TWBR>
      <OSCCAL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x6F</MEM_ADDR>
        <CAL0_MASK>0x01</CAL0_MASK>
        <CAL1_MASK>0x02</CAL1_MASK>
        <CAL2_MASK>0x04</CAL2_MASK>
        <CAL3_MASK>0x08</CAL3_MASK>
        <CAL4_MASK>0x10</CAL4_MASK>
        <CAL5_MASK>0x20</CAL5_MASK>
        <CAL6_MASK>0x40</CAL6_MASK>
        <CAL7_MASK>0x80</CAL7_MASK>
      </OSCCAL>
      <XMCRA>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x6D</MEM_ADDR>
        <SRW11_MASK>0x02</SRW11_MASK>
        <SRW00_MASK>0x04</SRW00_MASK>
        <SRW01_MASK>0x08</SRW01_MASK>
        <SRL0_MASK>0x10</SRL0_MASK>
        <SRL1_MASK>0x20</SRL1_MASK>
        <SRL2_MASK>0x40</SRL2_MASK>
      </XMCRA>
      <XMCRB>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x6C</MEM_ADDR>
        <XMM0_MASK>0x01</XMM0_MASK>
        <XMM1_MASK>0x02</XMM1_MASK>
        <XMM2_MASK>0x04</XMM2_MASK>
        <XMBK_MASK>0x80</XMBK_MASK>
      </XMCRB>
      <EICRA>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x6A</MEM_ADDR>
        <ISC00_MASK>0x01</ISC00_MASK>
        <ISC01_MASK>0x02</ISC01_MASK>
        <ISC10_MASK>0x04</ISC10_MASK>
        <ISC11_MASK>0x08</ISC11_MASK>
        <ISC20_MASK>0x10</ISC20_MASK>
        <ISC21_MASK>0x20</ISC21_MASK>
        <ISC30_MASK>0x40</ISC30_MASK>
        <ISC31_MASK>0x80</ISC31_MASK>
      </EICRA>
      <SPMCSR>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x68</MEM_ADDR>
        <SPMEN_MASK>0x01</SPMEN_MASK>
        <PGERS_MASK>0x02</PGERS_MASK>
        <PGWRT_MASK>0x04</PGWRT_MASK>
        <BLBSET_MASK>0x08</BLBSET_MASK>
        <RWWSRE_MASK>0x10</RWWSRE_MASK>
        <RWWSB_MASK>0x40</RWWSB_MASK>
        <SPMIE_MASK>0x80</SPMIE_MASK>
      </SPMCSR>
      <PORTG>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x65</MEM_ADDR>
        <PORTG0_MASK>0x01</PORTG0_MASK>
        <PORTG1_MASK>0x02</PORTG1_MASK>
        <PORTG2_MASK>0x04</PORTG2_MASK>
        <PORTG3_MASK>0x08</PORTG3_MASK>
        <PORTG4_MASK>0x10</PORTG4_MASK>
      </PORTG>
      <DDRG>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x64</MEM_ADDR>
        <DDG0_MASK>0x01</DDG0_MASK>
        <DDG1_MASK>0x02</DDG1_MASK>
        <DDG2_MASK>0x04</DDG2_MASK>
        <DDG3_MASK>0x08</DDG3_MASK>
        <DDG4_MASK>0x10</DDG4_MASK>
      </DDRG>
      <PING>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x63</MEM_ADDR>
        <PING0_MASK>0x01</PING0_MASK>
        <PING1_MASK>0x02</PING1_MASK>
        <PING2_MASK>0x04</PING2_MASK>
        <PING3_MASK>0x08</PING3_MASK>
        <PING4_MASK>0x10</PING4_MASK>
      </PING>
      <PORTF>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x62</MEM_ADDR>
        <PORTF0_MASK>0x01</PORTF0_MASK>
        <PORTF1_MASK>0x02</PORTF1_MASK>
        <PORTF2_MASK>0x04</PORTF2_MASK>
        <PORTF3_MASK>0x08</PORTF3_MASK>
        <PORTF4_MASK>0x10</PORTF4_MASK>
        <PORTF5_MASK>0x20</PORTF5_MASK>
        <PORTF6_MASK>0x40</PORTF6_MASK>
        <PORTF7_MASK>0x80</PORTF7_MASK>
      </PORTF>
      <DDRF>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x61</MEM_ADDR>
        <DDF0_MASK>0x01</DDF0_MASK>
        <DDF1_MASK>0x02</DDF1_MASK>
        <DDF2_MASK>0x04</DDF2_MASK>
        <DDF3_MASK>0x08</DDF3_MASK>
        <DDF4_MASK>0x10</DDF4_MASK>
        <DDF5_MASK>0x20</DDF5_MASK>
        <DDF6_MASK>0x40</DDF6_MASK>
        <DDF7_MASK>0x80</DDF7_MASK>
      </DDRF>
      <SREG>
        <IO_ADDR>0x3F</IO_ADDR>
        <MEM_ADDR>0x5F</MEM_ADDR>
        <C_MASK>0x01</C_MASK>
        <Z_MASK>0x02</Z_MASK>
        <N_MASK>0x04</N_MASK>
        <V_MASK>0x08</V_MASK>
        <S_MASK>0x10</S_MASK>
        <H_MASK>0x20</H_MASK>
        <T_MASK>0x40</T_MASK>
        <I_MASK>0x80</I_MASK>
      </SREG>
      <SPH>
        <IO_ADDR>0x3E</IO_ADDR>
        <MEM_ADDR>0x5E</MEM_ADDR>
        <SP8_MASK>0x01</SP8_MASK>
        <SP9_MASK>0x02</SP9_MASK>
        <SP10_MASK>0x04</SP10_MASK>
        <SP11_MASK>0x08</SP11_MASK>
        <SP12_MASK>0x10</SP12_MASK>
        <SP13_MASK>0x20</SP13_MASK>
        <SP14_MASK>0x40</SP14_MASK>
        <SP15_MASK>0x80</SP15_MASK>
      </SPH>
      <SPL>
        <IO_ADDR>0x3D</IO_ADDR>
        <MEM_ADDR>0x5D</MEM_ADDR>
        <SP0_MASK>0x01</SP0_MASK>
        <SP1_MASK>0x02</SP1_MASK>
        <SP2_MASK>0x04</SP2_MASK>
        <SP3_MASK>0x08</SP3_MASK>
        <SP4_MASK>0x10</SP4_MASK>
        <SP5_MASK>0x20</SP5_MASK>
        <SP6_MASK>0x40</SP6_MASK>
        <SP7_MASK>0x80</SP7_MASK>
      </SPL>
      <XDIV>
        <IO_ADDR>0x3C</IO_ADDR>
        <MEM_ADDR>0x5C</MEM_ADDR>
        <XDIV0_MASK>0x01</XDIV0_MASK>
        <XDIV1_MASK>0x02</XDIV1_MASK>
        <XDIV2_MASK>0x04</XDIV2_MASK>
        <XDIV3_MASK>0x08</XDIV3_MASK>
        <XDIV4_MASK>0x10</XDIV4_MASK>
        <XDIV5_MASK>0x20</XDIV5_MASK>
        <XDIV6_MASK>0x40</XDIV6_MASK>
        <XDIVEN_MASK>0x80</XDIVEN_MASK>
      </XDIV>
      <RAMPZ>
        <IO_ADDR>0x3B</IO_ADDR>
        <MEM_ADDR>0x5B</MEM_ADDR>
        <RAMPZ0_MASK>0x01</RAMPZ0_MASK>
      </RAMPZ>
      <EICRB>
        <IO_ADDR>0x3A</IO_ADDR>
        <MEM_ADDR>0x5A</MEM_ADDR>
        <ISC40_MASK>0x01</ISC40_MASK>
        <ISC41_MASK>0x02</ISC41_MASK>
        <ISC50_MASK>0x04</ISC50_MASK>
        <ISC51_MASK>0x08</ISC51_MASK>
        <ISC60_MASK>0x10</ISC60_MASK>
        <ISC61_MASK>0x20</ISC61_MASK>
        <ISC70_MASK>0x40</ISC70_MASK>
        <ISC71_MASK>0x80</ISC71_MASK>
      </EICRB>
      <EIMSK>
        <IO_ADDR>0x39</IO_ADDR>
        <MEM_ADDR>0x59</MEM_ADDR>
        <INT0_MASK>0x01</INT0_MASK>
        <INT1_MASK>0x02</INT1_MASK>
        <INT2_MASK>0x04</INT2_MASK>
        <INT3_MASK>0x08</INT3_MASK>
        <INT4_MASK>0x10</INT4_MASK>
        <INT5_MASK>0x20</INT5_MASK>
        <INT6_MASK>0x40</INT6_MASK>
        <INT7_MASK>0x80</INT7_MASK>
      </EIMSK>
      <EIFR>
        <IO_ADDR>0x38</IO_ADDR>
        <MEM_ADDR>0x58</MEM_ADDR>
        <INTF0_MASK>0x01</INTF0_MASK>
        <INTF1_MASK>0x02</INTF1_MASK>
        <INTF2_MASK>0x04</INTF2_MASK>
        <INTF3_MASK>0x08</INTF3_MASK>
        <INTF4_MASK>0x10</INTF4_MASK>
        <INTF5_MASK>0x20</INTF5_MASK>
        <INTF6_MASK>0x40</INTF6_MASK>
        <INTF7_MASK>0x80</INTF7_MASK>
      </EIFR>
      <TIMSK>
        <IO_ADDR>0x37</IO_ADDR>
        <MEM_ADDR>0x57</MEM_ADDR>
        <TOIE0_MASK>0x01</TOIE0_MASK>
        <OCIE0_MASK>0x02</OCIE0_MASK>
        <TOIE1_MASK>0x04</TOIE1_MASK>
        <OCIE1B_MASK>0x08</OCIE1B_MASK>
        <OCIE1A_MASK>0x10</OCIE1A_MASK>
        <TICIE1_MASK>0x20</TICIE1_MASK>
        <TOIE2_MASK>0x40</TOIE2_MASK>
        <OCIE2_MASK>0x80</OCIE2_MASK>
      </TIMSK>
      <TIFR>
        <IO_ADDR>0x36</IO_ADDR>
        <MEM_ADDR>0x56</MEM_ADDR>
        <TOV0_MASK>0x01</TOV0_MASK>
        <OCF0_MASK>0x02</OCF0_MASK>
        <TOV1_MASK>0x04</TOV1_MASK>
        <OCF1B_MASK>0x08</OCF1B_MASK>
        <OCF1A_MASK>0x10</OCF1A_MASK>
        <ICF1_MASK>0x20</ICF1_MASK>
        <TOV2_MASK>0x40</TOV2_MASK>
        <OCF2_MASK>0x80</OCF2_MASK>
      </TIFR>
      <MCUCR>
        <IO_ADDR>0x35</IO_ADDR>
        <MEM_ADDR>0x55</MEM_ADDR>
        <IVCE_MASK>0x01</IVCE_MASK>
        <IVSEL_MASK>0x02</IVSEL_MASK>
        <SM2_MASK>0x04</SM2_MASK>
        <SM0_MASK>0x08</SM0_MASK>
        <SM1_MASK>0x10</SM1_MASK>
        <SE_MASK>0x20</SE_MASK>
        <SRW10_MASK>0x40</SRW10_MASK>
        <SRE_MASK>0x80</SRE_MASK>
      </MCUCR>
      <MCUCSR>
        <IO_ADDR>0x34</IO_ADDR>
        <MEM_ADDR>0x54</MEM_ADDR>
        <PORF_MASK>0x01</PORF_MASK>
        <EXTRF_MASK>0x02</EXTRF_MASK>
        <BORF_MASK>0x04</BORF_MASK>
        <WDRF_MASK>0x08</WDRF_MASK>
        <JTRF_MASK>0x10</JTRF_MASK>
        <JTD_MASK>0x80</JTD_MASK>
      </MCUCSR>
      <TCCR0>
        <IO_ADDR>0x33</IO_ADDR>
        <MEM_ADDR>0x53</MEM_ADDR>
        <CS00_MASK>0x01</CS00_MASK>
        <CS01_MASK>0x02</CS01_MASK>
        <CS02_MASK>0x04</CS02_MASK>
        <WGM01_MASK>0x08</WGM01_MASK>
        <COM00_MASK>0x10</COM00_MASK>
        <COM01_MASK>0x20</COM01_MASK>
        <WGM00_MASK>0x40</WGM00_MASK>
        <FOC0_MASK>0x80</FOC0_MASK>
      </TCCR0>
      <TCNT0>
        <IO_ADDR>0x32</IO_ADDR>
        <MEM_ADDR>0x52</MEM_ADDR>
        <TCNT0_0_MASK>0x01</TCNT0_0_MASK>
        <TCNT0_1_MASK>0x02</TCNT0_1_MASK>
        <TCNT0_2_MASK>0x04</TCNT0_2_MASK>
        <TCNT0_3_MASK>0x08</TCNT0_3_MASK>
        <TCNT0_4_MASK>0x10</TCNT0_4_MASK>
        <TCNT0_5_MASK>0x20</TCNT0_5_MASK>
        <TCNT0_6_MASK>0x40</TCNT0_6_MASK>
        <TCNT0_7_MASK>0x80</TCNT0_7_MASK>
      </TCNT0>
      <OCR0>
        <IO_ADDR>0x31</IO_ADDR>
        <MEM_ADDR>0x51</MEM_ADDR>
        <OCR0_0_MASK>0x01</OCR0_0_MASK>
        <OCR0_1_MASK>0x02</OCR0_1_MASK>
        <OCR0_2_MASK>0x04</OCR0_2_MASK>
        <OCR0_3_MASK>0x08</OCR0_3_MASK>
        <OCR0_4_MASK>0x10</OCR0_4_MASK>
        <OCR0_5_MASK>0x20</OCR0_5_MASK>
        <OCR0_6_MASK>0x40</OCR0_6_MASK>
        <OCR0_7_MASK>0x80</OCR0_7_MASK>
      </OCR0>
      <ASSR>
        <IO_ADDR>0x30</IO_ADDR>
        <MEM_ADDR>0x50</MEM_ADDR>
        <TCR0UB_MASK>0x01</TCR0UB_MASK>
        <OCR0UB_MASK>0x02</OCR0UB_MASK>
        <TCN0UB_MASK>0x04</TCN0UB_MASK>
        <AS0_MASK>0x08</AS0_MASK>
      </ASSR>
      <TCCR1A>
        <IO_ADDR>0x2F</IO_ADDR>
        <MEM_ADDR>0x4F</MEM_ADDR>
        <WGM10_MASK>0x01</WGM10_MASK>
        <WGM11_MASK>0x02</WGM11_MASK>
        <COM1C0_MASK>0x04</COM1C0_MASK>
        <COM1C1_MASK>0x08</COM1C1_MASK>
        <COM1B0_MASK>0x10</COM1B0_MASK>
        <COM1B1_MASK>0x20</COM1B1_MASK>
        <COM1A0_MASK>0x40</COM1A0_MASK>
        <COM1A1_MASK>0x80</COM1A1_MASK>
      </TCCR1A>
      <TCCR1B>
        <IO_ADDR>0x2E</IO_ADDR>
        <MEM_ADDR>0x4E</MEM_ADDR>
        <CS10_MASK>0x01</CS10_MASK>
        <CS11_MASK>0x02</CS11_MASK>
        <CS12_MASK>0x04</CS12_MASK>
        <WGM12_MASK>0x08</WGM12_MASK>
        <WGM13_MASK>0x10</WGM13_MASK>
        <ICES1_MASK>0x40</ICES1_MASK>
        <ICNC1_MASK>0x80</ICNC1_MASK>
      </TCCR1B>
      <TCNT1H>
        <IO_ADDR>0x2D</IO_ADDR>
        <MEM_ADDR>0x4D</MEM_ADDR>
        <TCNT1H0_MASK>0x01</TCNT1H0_MASK>
        <TCNT1H1_MASK>0x02</TCNT1H1_MASK>
        <TCNT1H2_MASK>0x04</TCNT1H2_MASK>
        <TCNT1H3_MASK>0x08</TCNT1H3_MASK>
        <TCNT1H4_MASK>0x10</TCNT1H4_MASK>
        <TCNT1H5_MASK>0x20</TCNT1H5_MASK>
        <TCNT1H6_MASK>0x40</TCNT1H6_MASK>
        <TCNT1H7_MASK>0x80</TCNT1H7_MASK>
      </TCNT1H>
      <TCNT1L>
        <IO_ADDR>0x2C</IO_ADDR>
        <MEM_ADDR>0x4C</MEM_ADDR>
        <TCNT1L0_MASK>0x01</TCNT1L0_MASK>
        <TCNT1L1_MASK>0x02</TCNT1L1_MASK>
        <TCNT1L2_MASK>0x04</TCNT1L2_MASK>
        <TCNT1L3_MASK>0x08</TCNT1L3_MASK>
        <TCNT1L4_MASK>0x10</TCNT1L4_MASK>
        <TCNT1L5_MASK>0x20</TCNT1L5_MASK>
        <TCNT1L6_MASK>0x40</TCNT1L6_MASK>
        <TCNT1L7_MASK>0x80</TCNT1L7_MASK>
      </TCNT1L>
      <OCR1AH>
        <IO_ADDR>0x2B</IO_ADDR>
        <MEM_ADDR>0x4B</MEM_ADDR>
        <OCR1AH0_MASK>0x01</OCR1AH0_MASK>
        <OCR1AH1_MASK>0x02</OCR1AH1_MASK>
        <OCR1AH2_MASK>0x04</OCR1AH2_MASK>
        <OCR1AH3_MASK>0x08</OCR1AH3_MASK>
        <OCR1AH4_MASK>0x10</OCR1AH4_MASK>
        <OCR1AH5_MASK>0x20</OCR1AH5_MASK>
        <OCR1AH6_MASK>0x40</OCR1AH6_MASK>
        <OCR1AH7_MASK>0x80</OCR1AH7_MASK>
      </OCR1AH>
      <OCR1AL>
        <IO_ADDR>0x2A</IO_ADDR>
        <MEM_ADDR>0x4A</MEM_ADDR>
        <OCR1AL0_MASK>0x01</OCR1AL0_MASK>
        <OCR1AL1_MASK>0x02</OCR1AL1_MASK>
        <OCR1AL2_MASK>0x04</OCR1AL2_MASK>
        <OCR1AL3_MASK>0x08</OCR1AL3_MASK>
        <OCR1AL4_MASK>0x10</OCR1AL4_MASK>
        <OCR1AL5_MASK>0x20</OCR1AL5_MASK>
        <OCR1AL6_MASK>0x40</OCR1AL6_MASK>
        <OCR1AL7_MASK>0x80</OCR1AL7_MASK>
      </OCR1AL>
      <OCR1BH>
        <IO_ADDR>0x29</IO_ADDR>
        <MEM_ADDR>0x49</MEM_ADDR>
        <OCR1BH0_MASK>0x01</OCR1BH0_MASK>
        <OCR1BH1_MASK>0x02</OCR1BH1_MASK>
        <OCR1BH2_MASK>0x04</OCR1BH2_MASK>
        <OCR1BH3_MASK>0x08</OCR1BH3_MASK>
        <OCR1BH4_MASK>0x10</OCR1BH4_MASK>
        <OCR1BH5_MASK>0x20</OCR1BH5_MASK>
        <OCR1BH6_MASK>0x40</OCR1BH6_MASK>
        <OCR1BH7_MASK>0x80</OCR1BH7_MASK>
      </OCR1BH>
      <OCR1BL>
        <IO_ADDR>0x28</IO_ADDR>
        <MEM_ADDR>0x48</MEM_ADDR>
        <OCR1BL0_MASK>0x01</OCR1BL0_MASK>
        <OCR1BL1_MASK>0x02</OCR1BL1_MASK>
        <OCR1BL2_MASK>0x04</OCR1BL2_MASK>
        <OCR1BL3_MASK>0x08</OCR1BL3_MASK>
        <OCR1BL4_MASK>0x10</OCR1BL4_MASK>
        <OCR1BL5_MASK>0x20</OCR1BL5_MASK>
        <OCR1BL6_MASK>0x40</OCR1BL6_MASK>
        <OCR1BL7_MASK>0x80</OCR1BL7_MASK>
      </OCR1BL>
      <ICR1H>
        <IO_ADDR>0x27</IO_ADDR>
        <MEM_ADDR>0x47</MEM_ADDR>
        <ICR1H0_MASK>0x01</ICR1H0_MASK>
        <ICR1H1_MASK>0x02</ICR1H1_MASK>
        <ICR1H2_MASK>0x04</ICR1H2_MASK>
        <ICR1H3_MASK>0x08</ICR1H3_MASK>
        <ICR1H4_MASK>0x10</ICR1H4_MASK>
        <ICR1H5_MASK>0x20</ICR1H5_MASK>
        <ICR1H6_MASK>0x40</ICR1H6_MASK>
        <ICR1H7_MASK>0x80</ICR1H7_MASK>
      </ICR1H>
      <ICR1L>
        <IO_ADDR>0x26</IO_ADDR>
        <MEM_ADDR>0x46</MEM_ADDR>
        <ICR1L0_MASK>0x01</ICR1L0_MASK>
        <ICR1L1_MASK>0x02</ICR1L1_MASK>
        <ICR1L2_MASK>0x04</ICR1L2_MASK>
        <ICR1L3_MASK>0x08</ICR1L3_MASK>
        <ICR1L4_MASK>0x10</ICR1L4_MASK>
        <ICR1L5_MASK>0x20</ICR1L5_MASK>
        <ICR1L6_MASK>0x40</ICR1L6_MASK>
        <ICR1L7_MASK>0x80</ICR1L7_MASK>
      </ICR1L>
      <TCCR2>
        <IO_ADDR>0x25</IO_ADDR>
        <MEM_ADDR>0x45</MEM_ADDR>
        <CS20_MASK>0x01</CS20_MASK>
        <CS21_MASK>0x02</CS21_MASK>
        <CS22_MASK>0x04</CS22_MASK>
        <WGM21_MASK>0x08</WGM21_MASK>
        <COM20_MASK>0x10</COM20_MASK>
        <COM21_MASK>0x20</COM21_MASK>
        <WGM20_MASK>0x40</WGM20_MASK>
        <FOC2_MASK>0x80</FOC2_MASK>
      </TCCR2>
      <TCNT2>
        <IO_ADDR>0x24</IO_ADDR>
        <MEM_ADDR>0x44</MEM_ADDR>
        <TCNT2_0_MASK>0x01</TCNT2_0_MASK>
        <TCNT2_1_MASK>0x02</TCNT2_1_MASK>
        <TCNT2_2_MASK>0x04</TCNT2_2_MASK>
        <TCNT2_3_MASK>0x08</TCNT2_3_MASK>
        <TCNT2_4_MASK>0x10</TCNT2_4_MASK>
        <TCNT2_5_MASK>0x20</TCNT2_5_MASK>
        <TCNT2_6_MASK>0x40</TCNT2_6_MASK>
        <TCNT2_7_MASK>0x80</TCNT2_7_MASK>
      </TCNT2>
      <OCR2>
        <IO_ADDR>0x23</IO_ADDR>
        <MEM_ADDR>0x43</MEM_ADDR>
        <OCR2_0_MASK>0x01</OCR2_0_MASK>
        <OCR2_1_MASK>0x02</OCR2_1_MASK>
        <OCR2_2_MASK>0x04</OCR2_2_MASK>
        <OCR2_3_MASK>0x08</OCR2_3_MASK>
        <OCR2_4_MASK>0x10</OCR2_4_MASK>
        <OCR2_5_MASK>0x20</OCR2_5_MASK>
        <OCR2_6_MASK>0x40</OCR2_6_MASK>
        <OCR2_7_MASK>0x80</OCR2_7_MASK>
      </OCR2>
      <OCDR>
        <IO_ADDR>0x22</IO_ADDR>
        <MEM_ADDR>0x42</MEM_ADDR>
        <OCDR0_MASK>0x01</OCDR0_MASK>
        <OCDR1_MASK>0x02</OCDR1_MASK>
        <OCDR2_MASK>0x04</OCDR2_MASK>
        <OCDR3_MASK>0x08</OCDR3_MASK>
        <OCDR4_MASK>0x10</OCDR4_MASK>
        <OCDR5_MASK>0x20</OCDR5_MASK>
        <OCDR6_MASK>0x40</OCDR6_MASK>
        <OCDR7_MASK>0x80</OCDR7_MASK>
      </OCDR>
      <WDTCR>
        <IO_ADDR>0x21</IO_ADDR>
        <MEM_ADDR>0x41</MEM_ADDR>
        <WDP0_MASK>0x01</WDP0_MASK>
        <WDP1_MASK>0x02</WDP1_MASK>
        <WDP2_MASK>0x04</WDP2_MASK>
        <WDE_MASK>0x08</WDE_MASK>
        <WDCE_MASK>0x10</WDCE_MASK>
      </WDTCR>
      <SFIOR>
        <IO_ADDR>0x20</IO_ADDR>
        <MEM_ADDR>0x40</MEM_ADDR>
        <ACME_MASK>0x08</ACME_MASK>
        <PSR321_MASK>0x01</PSR321_MASK>
        <PSR0_MASK>0x02</PSR0_MASK>
        <PUD_MASK>0x04</PUD_MASK>
        <TSM_MASK>0x80</TSM_MASK>
      </SFIOR>
      <EEARH>
        <IO_ADDR>0x1F</IO_ADDR>
        <MEM_ADDR>0x3F</MEM_ADDR>
        <EEAR8_MASK>0x01</EEAR8_MASK>
        <EEAR9_MASK>0x02</EEAR9_MASK>
        <EEAR10_MASK>0x04</EEAR10_MASK>
        <EEAR11_MASK>0x08</EEAR11_MASK>
      </EEARH>
      <EEARL>
        <IO_ADDR>0x1E</IO_ADDR>
        <MEM_ADDR>0x3E</MEM_ADDR>
        <EEARL0_MASK>0x01</EEARL0_MASK>
        <EEARL1_MASK>0x02</EEARL1_MASK>
        <EEARL2_MASK>0x04</EEARL2_MASK>
        <EEARL3_MASK>0x08</EEARL3_MASK>
        <EEARL4_MASK>0x10</EEARL4_MASK>
        <EEARL5_MASK>0x20</EEARL5_MASK>
        <EEARL6_MASK>0x40</EEARL6_MASK>
        <EEARL7_MASK>0x80</EEARL7_MASK>
      </EEARL>
      <EEDR>
        <IO_ADDR>0x1D</IO_ADDR>
        <MEM_ADDR>0x3D</MEM_ADDR>
        <EEDR0_MASK>0x01</EEDR0_MASK>
        <EEDR1_MASK>0x02</EEDR1_MASK>
        <EEDR2_MASK>0x04</EEDR2_MASK>
        <EEDR3_MASK>0x08</EEDR3_MASK>
        <EEDR4_MASK>0x10</EEDR4_MASK>
        <EEDR5_MASK>0x20</EEDR5_MASK>
        <EEDR6_MASK>0x40</EEDR6_MASK>
        <EEDR7_MASK>0x80</EEDR7_MASK>
      </EEDR>
      <EECR>
        <IO_ADDR>0x1C</IO_ADDR>
        <MEM_ADDR>0x3C</MEM_ADDR>
        <EERE_MASK>0x01</EERE_MASK>
        <EEWE_MASK>0x02</EEWE_MASK>
        <EEMWE_MASK>0x04</EEMWE_MASK>
        <EERIE_MASK>0x08</EERIE_MASK>
      </EECR>
      <PORTA>
        <IO_ADDR>0x1B</IO_ADDR>
        <MEM_ADDR>0x3B</MEM_ADDR>
        <PORTA0_MASK>0x01</PORTA0_MASK>
        <PORTA1_MASK>0x02</PORTA1_MASK>
        <PORTA2_MASK>0x04</PORTA2_MASK>
        <PORTA3_MASK>0x08</PORTA3_MASK>
        <PORTA4_MASK>0x10</PORTA4_MASK>
        <PORTA5_MASK>0x20</PORTA5_MASK>
        <PORTA6_MASK>0x40</PORTA6_MASK>
        <PORTA7_MASK>0x80</PORTA7_MASK>
      </PORTA>
      <DDRA>
        <IO_ADDR>0x1A</IO_ADDR>
        <MEM_ADDR>0x3A</MEM_ADDR>
        <DDA0_MASK>0x01</DDA0_MASK>
        <DDA1_MASK>0x02</DDA1_MASK>
        <DDA2_MASK>0x04</DDA2_MASK>
        <DDA3_MASK>0x08</DDA3_MASK>
        <DDA4_MASK>0x10</DDA4_MASK>
        <DDA5_MASK>0x20</DDA5_MASK>
        <DDA6_MASK>0x40</DDA6_MASK>
        <DDA7_MASK>0x80</DDA7_MASK>
      </DDRA>
      <PINA>
        <IO_ADDR>0x19</IO_ADDR>
        <MEM_ADDR>0x39</MEM_ADDR>
        <PINA0_MASK>0x01</PINA0_MASK>
        <PINA1_MASK>0x02</PINA1_MASK>
        <PINA2_MASK>0x04</PINA2_MASK>
        <PINA3_MASK>0x08</PINA3_MASK>
        <PINA4_MASK>0x10</PINA4_MASK>
        <PINA5_MASK>0x20</PINA5_MASK>
        <PINA6_MASK>0x40</PINA6_MASK>
        <PINA7_MASK>0x80</PINA7_MASK>
      </PINA>
      <PORTB>
        <IO_ADDR>0x18</IO_ADDR>
        <MEM_ADDR>0x38</MEM_ADDR>
        <PORTB0_MASK>0x01</PORTB0_MASK>
        <PORTB1_MASK>0x02</PORTB1_MASK>
        <PORTB2_MASK>0x04</PORTB2_MASK>
        <PORTB3_MASK>0x08</PORTB3_MASK>
        <PORTB4_MASK>0x10</PORTB4_MASK>
        <PORTB5_MASK>0x20</PORTB5_MASK>
        <PORTB6_MASK>0x40</PORTB6_MASK>
        <PORTB7_MASK>0x80</PORTB7_MASK>
      </PORTB>
      <DDRB>
        <IO_ADDR>0x17</IO_ADDR>
        <MEM_ADDR>0x37</MEM_ADDR>
        <DDB0_MASK>0x01</DDB0_MASK>
        <DDB1_MASK>0x02</DDB1_MASK>
        <DDB2_MASK>0x04</DDB2_MASK>
        <DDB3_MASK>0x08</DDB3_MASK>
        <DDB4_MASK>0x10</DDB4_MASK>
        <DDB5_MASK>0x20</DDB5_MASK>
        <DDB6_MASK>0x40</DDB6_MASK>
        <DDB7_MASK>0x80</DDB7_MASK>
      </DDRB>
      <PINB>
        <IO_ADDR>0x16</IO_ADDR>
        <MEM_ADDR>0x36</MEM_ADDR>
        <PINB0_MASK>0x01</PINB0_MASK>
        <PINB1_MASK>0x02</PINB1_MASK>
        <PINB2_MASK>0x04</PINB2_MASK>
        <PINB3_MASK>0x08</PINB3_MASK>
        <PINB4_MASK>0x10</PINB4_MASK>
        <PINB5_MASK>0x20</PINB5_MASK>
        <PINB6_MASK>0x40</PINB6_MASK>
        <PINB7_MASK>0x80</PINB7_MASK>
      </PINB>
      <PORTC>
        <IO_ADDR>0x15</IO_ADDR>
        <MEM_ADDR>0x35</MEM_ADDR>
        <PORTC0_MASK>0x01</PORTC0_MASK>
        <PORTC1_MASK>0x02</PORTC1_MASK>
        <PORTC2_MASK>0x04</PORTC2_MASK>
        <PORTC3_MASK>0x08</PORTC3_MASK>
        <PORTC4_MASK>0x10</PORTC4_MASK>
        <PORTC5_MASK>0x20</PORTC5_MASK>
        <PORTC6_MASK>0x40</PORTC6_MASK>
        <PORTC7_MASK>0x80</PORTC7_MASK>
      </PORTC>
      <DDRC>
        <IO_ADDR>0x14</IO_ADDR>
        <MEM_ADDR>0x34</MEM_ADDR>
        <DDC0_MASK>0x01</DDC0_MASK>
        <DDC1_MASK>0x02</DDC1_MASK>
        <DDC2_MASK>0x04</DDC2_MASK>
        <DDC3_MASK>0x08</DDC3_MASK>
        <DDC4_MASK>0x10</DDC4_MASK>
        <DDC5_MASK>0x20</DDC5_MASK>
        <DDC6_MASK>0x40</DDC6_MASK>
        <DDC7_MASK>0x80</DDC7_MASK>
      </DDRC>
      <PINC>
        <IO_ADDR>0x13</IO_ADDR>
        <MEM_ADDR>0x33</MEM_ADDR>
        <PINC0_MASK>0x01</PINC0_MASK>
        <PINC1_MASK>0x02</PINC1_MASK>
        <PINC2_MASK>0x04</PINC2_MASK>
        <PINC3_MASK>0x08</PINC3_MASK>
        <PINC4_MASK>0x10</PINC4_MASK>
        <PINC5_MASK>0x20</PINC5_MASK>
        <PINC6_MASK>0x40</PINC6_MASK>
        <PINC7_MASK>0x80</PINC7_MASK>
      </PINC>
      <PORTD>
        <IO_ADDR>0x12</IO_ADDR>
        <MEM_ADDR>0x32</MEM_ADDR>
        <PORTD0_MASK>0x01</PORTD0_MASK>
        <PORTD1_MASK>0x02</PORTD1_MASK>
        <PORTD2_MASK>0x04</PORTD2_MASK>
        <PORTD3_MASK>0x08</PORTD3_MASK>
        <PORTD4_MASK>0x10</PORTD4_MASK>
        <PORTD5_MASK>0x20</PORTD5_MASK>
        <PORTD6_MASK>0x40</PORTD6_MASK>
        <PORTD7_MASK>0x80</PORTD7_MASK>
      </PORTD>
      <DDRD>
        <IO_ADDR>0x11</IO_ADDR>
        <MEM_ADDR>0x31</MEM_ADDR>
        <DDD0_MASK>0x01</DDD0_MASK>
        <DDD1_MASK>0x02</DDD1_MASK>
        <DDD2_MASK>0x04</DDD2_MASK>
        <DDD3_MASK>0x08</DDD3_MASK>
        <DDD4_MASK>0x10</DDD4_MASK>
        <DDD5_MASK>0x20</DDD5_MASK>
        <DDD6_MASK>0x40</DDD6_MASK>
        <DDD7_MASK>0x80</DDD7_MASK>
      </DDRD>
      <PIND>
        <IO_ADDR>0x10</IO_ADDR>
        <MEM_ADDR>0x30</MEM_ADDR>
        <PIND0_MASK>0x01</PIND0_MASK>
        <PIND1_MASK>0x02</PIND1_MASK>
        <PIND2_MASK>0x04</PIND2_MASK>
        <PIND3_MASK>0x08</PIND3_MASK>
        <PIND4_MASK>0x10</PIND4_MASK>
        <PIND5_MASK>0x20</PIND5_MASK>
        <PIND6_MASK>0x40</PIND6_MASK>
        <PIND7_MASK>0x80</PIND7_MASK>
      </PIND>
      <SPDR>
        <IO_ADDR>0x0F</IO_ADDR>
        <MEM_ADDR>0x2F</MEM_ADDR>
        <SPDR0_MASK>0x01</SPDR0_MASK>
        <SPDR1_MASK>0x02</SPDR1_MASK>
        <SPDR2_MASK>0x04</SPDR2_MASK>
        <SPDR3_MASK>0x08</SPDR3_MASK>
        <SPDR4_MASK>0x10</SPDR4_MASK>
        <SPDR5_MASK>0x20</SPDR5_MASK>
        <SPDR6_MASK>0x40</SPDR6_MASK>
        <SPDR7_MASK>0x80</SPDR7_MASK>
      </SPDR>
      <SPSR>
        <IO_ADDR>0x0E</IO_ADDR>
        <MEM_ADDR>0x2E</MEM_ADDR>
        <SPI2X_MASK>0x01</SPI2X_MASK>
        <WCOL_MASK>0x40</WCOL_MASK>
        <SPIF_MASK>0x80</SPIF_MASK>
      </SPSR>
      <SPCR>
        <IO_ADDR>0x0D</IO_ADDR>
        <MEM_ADDR>0x2D</MEM_ADDR>
        <SPR0_MASK>0x01</SPR0_MASK>
        <SPR1_MASK>0x02</SPR1_MASK>
        <CPHA_MASK>0x04</CPHA_MASK>
        <CPOL_MASK>0x08</CPOL_MASK>
        <MSTR_MASK>0x10</MSTR_MASK>
        <DORD_MASK>0x20</DORD_MASK>
        <SPE_MASK>0x40</SPE_MASK>
        <SPIE_MASK>0x80</SPIE_MASK>
      </SPCR>
      <UDR0>
        <IO_ADDR>0x0C</IO_ADDR>
        <MEM_ADDR>0x2C</MEM_ADDR>
        <UDR00_MASK>0x01</UDR00_MASK>
        <UDR01_MASK>0x02</UDR01_MASK>
        <UDR02_MASK>0x04</UDR02_MASK>
        <UDR03_MASK>0x08</UDR03_MASK>
        <UDR04_MASK>0x10</UDR04_MASK>
        <UDR05_MASK>0x20</UDR05_MASK>
        <UDR06_MASK>0x40</UDR06_MASK>
        <UDR07_MASK>0x80</UDR07_MASK>
      </UDR0>
      <UCSR0A>
        <IO_ADDR>0x0B</IO_ADDR>
        <MEM_ADDR>0x2B</MEM_ADDR>
        <MPCM0_MASK>0x01</MPCM0_MASK>
        <U2X0_MASK>0x02</U2X0_MASK>
        <UPE0_MASK>0x04</UPE0_MASK>
        <DOR0_MASK>0x08</DOR0_MASK>
        <FE0_MASK>0x10</FE0_MASK>
        <UDRE0_MASK>0x20</UDRE0_MASK>
        <TXC0_MASK>0x40</TXC0_MASK>
        <RXC0_MASK>0x80</RXC0_MASK>
      </UCSR0A>
      <UCSR0B>
        <IO_ADDR>0x0A</IO_ADDR>
        <MEM_ADDR>0x2A</MEM_ADDR>
        <TXB80_MASK>0x01</TXB80_MASK>
        <RXB80_MASK>0x02</RXB80_MASK>
        <UCSZ02_MASK>0x04</UCSZ02_MASK>
        <TXEN0_MASK>0x08</TXEN0_MASK>
        <RXEN0_MASK>0x10</RXEN0_MASK>
        <UDRIE0_MASK>0x20</UDRIE0_MASK>
        <TXCIE0_MASK>0x40</TXCIE0_MASK>
        <RXCIE0_MASK>0x80</RXCIE0_MASK>
      </UCSR0B>
      <UBRR0L>
        <IO_ADDR>0x09</IO_ADDR>
        <MEM_ADDR>0x29</MEM_ADDR>
        <UBRR0_MASK>0x01</UBRR0_MASK>
        <UBRR1_MASK>0x02</UBRR1_MASK>
        <UBRR2_MASK>0x04</UBRR2_MASK>
        <UBRR3_MASK>0x08</UBRR3_MASK>
        <UBRR4_MASK>0x10</UBRR4_MASK>
        <UBRR5_MASK>0x20</UBRR5_MASK>
        <UBRR6_MASK>0x40</UBRR6_MASK>
        <UBRR7_MASK>0x80</UBRR7_MASK>
      </UBRR0L>
      <ACSR>
        <IO_ADDR>0x08</IO_ADDR>
        <MEM_ADDR>0x28</MEM_ADDR>
        <ACIS0_MASK>0x01</ACIS0_MASK>
        <ACIS1_MASK>0x02</ACIS1_MASK>
        <ACIC_MASK>0x04</ACIC_MASK>
        <ACIE_MASK>0x08</ACIE_MASK>
        <ACI_MASK>0x10</ACI_MASK>
        <ACO_MASK>0x20</ACO_MASK>
        <ACBG_MASK>0x40</ACBG_MASK>
        <ACD_MASK>0x80</ACD_MASK>
      </ACSR>
      <ADMUX>
        <IO_ADDR>0x07</IO_ADDR>
        <MEM_ADDR>0x27</MEM_ADDR>
        <MUX0_MASK>0x01</MUX0_MASK>
        <MUX1_MASK>0x02</MUX1_MASK>
        <MUX2_MASK>0x04</MUX2_MASK>
        <MUX3_MASK>0x08</MUX3_MASK>
        <MUX4_MASK>0x10</MUX4_MASK>
        <ADLAR_MASK>0x20</ADLAR_MASK>
        <REFS0_MASK>0x40</REFS0_MASK>
        <REFS1_MASK>0x80</REFS1_MASK>
      </ADMUX>
      <ADCSRA>
        <IO_ADDR>0x06</IO_ADDR>
        <MEM_ADDR>0x26</MEM_ADDR>
        <ADPS0_MASK>0x01</ADPS0_MASK>
        <ADPS1_MASK>0x02</ADPS1_MASK>
        <ADPS2_MASK>0x04</ADPS2_MASK>
        <ADIE_MASK>0x08</ADIE_MASK>
        <ADIF_MASK>0x10</ADIF_MASK>
        <ADFR_MASK>0x20</ADFR_MASK>
        <ADSC_MASK>0x40</ADSC_MASK>
        <ADEN_MASK>0x80</ADEN_MASK>
      </ADCSRA>
      <ADCH>
        <IO_ADDR>0x05</IO_ADDR>
        <MEM_ADDR>0x25</MEM_ADDR>
        <ADCH0_MASK>0x01</ADCH0_MASK>
        <ADCH1_MASK>0x02</ADCH1_MASK>
        <ADCH2_MASK>0x04</ADCH2_MASK>
        <ADCH3_MASK>0x08</ADCH3_MASK>
        <ADCH4_MASK>0x10</ADCH4_MASK>
        <ADCH5_MASK>0x20</ADCH5_MASK>
        <ADCH6_MASK>0x40</ADCH6_MASK>
        <ADCH7_MASK>0x80</ADCH7_MASK>
      </ADCH>
      <ADCL>
        <IO_ADDR>0x04</IO_ADDR>
        <MEM_ADDR>0x24</MEM_ADDR>
        <ADCL0_MASK>0x01</ADCL0_MASK>
        <ADCL1_MASK>0x02</ADCL1_MASK>
        <ADCL2_MASK>0x04</ADCL2_MASK>
        <ADCL3_MASK>0x08</ADCL3_MASK>
        <ADCL4_MASK>0x10</ADCL4_MASK>
        <ADCL5_MASK>0x20</ADCL5_MASK>
        <ADCL6_MASK>0x40</ADCL6_MASK>
        <ADCL7_MASK>0x80</ADCL7_MASK>
      </ADCL>
      <PORTE>
        <IO_ADDR>0x03</IO_ADDR>
        <MEM_ADDR>0x23</MEM_ADDR>
        <PORTE0_MASK>0x01</PORTE0_MASK>
        <PORTE1_MASK>0x02</PORTE1_MASK>
        <PORTE2_MASK>0x04</PORTE2_MASK>
        <PORTE3_MASK>0x08</PORTE3_MASK>
        <PORTE4_MASK>0x10</PORTE4_MASK>
        <PORTE5_MASK>0x20</PORTE5_MASK>
        <PORTE6_MASK>0x40</PORTE6_MASK>
        <PORTE7_MASK>0x80</PORTE7_MASK>
      </PORTE>
      <DDRE>
        <IO_ADDR>0x02</IO_ADDR>
        <MEM_ADDR>0x22</MEM_ADDR>
        <DDE0_MASK>0x01</DDE0_MASK>
        <DDE1_MASK>0x02</DDE1_MASK>
        <DDE2_MASK>0x04</DDE2_MASK>
        <DDE3_MASK>0x08</DDE3_MASK>
        <DDE4_MASK>0x10</DDE4_MASK>
        <DDE5_MASK>0x20</DDE5_MASK>
        <DDE6_MASK>0x40</DDE6_MASK>
        <DDE7_MASK>0x80</DDE7_MASK>
      </DDRE>
      <PINE>
        <IO_ADDR>0x01</IO_ADDR>
        <MEM_ADDR>0x21</MEM_ADDR>
        <PINE0_MASK>0x01</PINE0_MASK>
        <PINE1_MASK>0x02</PINE1_MASK>
        <PINE2_MASK>0x04</PINE2_MASK>
        <PINE3_MASK>0x08</PINE3_MASK>
        <PINE4_MASK>0x10</PINE4_MASK>
        <PINE5_MASK>0x20</PINE5_MASK>
        <PINE6_MASK>0x40</PINE6_MASK>
        <PINE7_MASK>0x80</PINE7_MASK>
      </PINE>
      <PINF>
        <IO_ADDR>0x00</IO_ADDR>
        <MEM_ADDR>0x20</MEM_ADDR>
        <PINF0_MASK>0x01</PINF0_MASK>
        <PINF1_MASK>0x02</PINF1_MASK>
        <PINF2_MASK>0x04</PINF2_MASK>
        <PINF3_MASK>0x08</PINF3_MASK>
        <PINF4_MASK>0x10</PINF4_MASK>
        <PINF5_MASK>0x20</PINF5_MASK>
        <PINF6_MASK>0x40</PINF6_MASK>
        <PINF7_MASK>0x80</PINF7_MASK>
      </PINF>
    </IO_MEMORY>
    <BOOT_CONFIG>
      <NRWW_START_ADDR>$F000</NRWW_START_ADDR>
      <NRWW_STOP_ADDR>$FFFF</NRWW_STOP_ADDR>
      <RWW_START_ADDR>$0</RWW_START_ADDR>
      <RWW_STOP_ADDR>$EFFF</RWW_STOP_ADDR>
      <PAGESIZE>128</PAGESIZE>
      <BOOTSZMODE1>
        <BOOTSIZE>512</BOOTSIZE>
        <PAGES>4</PAGES>
        <APPSTART>$0</APPSTART>
        <BOOTSTART>$FE00</BOOTSTART>
        <BOOTRESET>$FE00</BOOTRESET>
      </BOOTSZMODE1>
      <BOOTSZMODE2>
        <BOOTSIZE>1024</BOOTSIZE>
        <PAGES>8</PAGES>
        <APPSTART>$0</APPSTART>
        <BOOTSTART>$FC00</BOOTSTART>
        <BOOTRESET>$FC00</BOOTRESET>
      </BOOTSZMODE2>
      <BOOTSZMODE3>
        <BOOTSIZE>2048</BOOTSIZE>
        <PAGES>16</PAGES>
        <APPSTART>0</APPSTART>
        <BOOTSTART>$F800</BOOTSTART>
        <BOOTRESET>$F800</BOOTRESET>
      </BOOTSZMODE3>
      <BOOTSZMODE4>
        <BOOTSIZE>4096</BOOTSIZE>
        <PAGES>32</PAGES>
        <APPSTART>0</APPSTART>
        <BOOTSTART>$F000</BOOTSTART>
        <BOOTRESET>$F000</BOOTRESET>
      </BOOTSZMODE4>
    </BOOT_CONFIG>
  </MEMORY>
  <PACKAGE>
    <PACKAGES>[TQFP]</PACKAGES>
    <TQFP>
      <NMB_PIN>64</NMB_PIN>
      <PIN1>
        <NAME>['PEN]</NAME>
        <TEXT/>
      </PIN1>
      <PIN2>
        <NAME>[PE0:RXD0:PDI]</NAME>
        <TEXT>PDI, Serial Programming Data Input. During Serial Program Downloading, this pin is used as data input line for the ATmega104. RXD0, USART0 Receive Pin. Receive Data (Data input pin for the USART0). When the USART0 receiver is enabled this pin is configured as an input regardless of the value of DDRE0. When the USART0 forces this pin to be an input, a logical one in PORTE0 will turn on the internal pull-up.</TEXT>
      </PIN2>
      <PIN3>
        <NAME>[PE1:TXD0:PDO]</NAME>
        <TEXT>PDO, Serial Programming Data Output. During Serial Program Downloading, this pin is used as data output line for the ATmega104. TXD0, UART0 Transmit Pin.</TEXT>
      </PIN3>
      <PIN4>
        <NAME>[PE2:XCK0:AIN0]</NAME>
        <TEXT>AIN0 - Analog Comparator Positive Input. This pin is directly connected to the positive input of the analog comparator. XCK0, USART0 external clock. The Data Direction Register (DDE2) controls whether the clock is output (DDE2 set) or input (DDE2 cleared). The XCK0 pin is active only when the USART0 operates in synchronous mode.</TEXT>
      </PIN4>
      <PIN5>
        <NAME>[PE3:OC3A:AIN1]</NAME>
        <TEXT>AIN1 - Analog Comparator Negative Input. This pin is directly connected to the negative input of the analog comparator. OC3A, Output Compare matchA output: The PE3 pin can serve as an external output for the Timer/Counter3 output com-pareA. The pin has to be configured as an output (DDE3 set (one)) to serve this function. The OC3A pin is also the output pin for the PWM mode timer function.</TEXT>
      </PIN5>
      <PIN6>
        <NAME>[PE4:OC3B:INT4]</NAME>
        <TEXT>INT4, External Interrupt source 4: The PE4 pin can serve as an external interrupt source. OC3B, Output Compare matchB output: The PE4 pin can serve as an external output for the Timer/Counter3 output com-pareB. The pin has to be configured as an output (DDE4 set (one)) to serve this function. The OC3B pin is also the output pin for the PWM mode timer function.</TEXT>
      </PIN6>
      <PIN7>
        <NAME>[PE5:OC3C:INT5]</NAME>
        <TEXT>INT5, External Interrupt source 5: The PE5 pin can serve as an external interrupt source. OC3C, Output Compare matchC output: The PE5 pin can serve as an external output for the Timer/Counter3 output com-pareC. The pin has to be configured as an output (DDE5 set (one)) to serve this function. The OC3C pin is also the output pin for the PWM mode timer function.</TEXT>
      </PIN7>
      <PIN8>
        <NAME>[PE6:T3:INT6]</NAME>
        <TEXT>INT6, External Interrupt source 6: The PE6 pin can serve as an external interrupt source. T3, Timer/Counter3 counter source.</TEXT>
      </PIN8>
      <PIN9>
        <NAME>[PE7:IC3:INT7]</NAME>
        <TEXT>INT7, External Interrupt source 7: The PE7 pin can serve as an external interrupt source. IC3 - Input Capture Pin3: The PE7 pin can act as an input capture pin for Timer/Counter3.</TEXT>
      </PIN9>
      <PIN10>
        <NAME>[PB0:'SS]</NAME>
        <TEXT>SS: Slave port select input. When the SPI is enabled as a slave, this pin is configured as an input regardless of the setting of DDB0. As a slave, the SPI is activated when this pin is driven low. When the SPI is enabled as a master, the data direc-tion of this pin is controlled by DDB0. When the pin is forced to be an input, the pull-up can still be controlled by the PORTB0 bit.</TEXT>
      </PIN10>
      <PIN11>
        <NAME>[PB1:SCK]</NAME>
        <TEXT>SCK: Master clock output, slave clock input pin for SPI channel. When the SPI is enabled as a slave, this pin is configured as an input regardless of the setting of DDB1. When the SPI is enabled as a master, the data direction of this pin is con-trolled by DDB1. When the pin is forced to be an input, the pull-up can still be controlled by the PORTB1 bit.</TEXT>
      </PIN11>
      <PIN12>
        <NAME>[PB2:MOSI]</NAME>
        <TEXT>MOSI: SPI Master data output, slave data input for SPI channel. When the SPI is enabled as a slave, this pin is configured as an input regardless of the setting of DDB2. When the SPI is enabled as a master, the data direction of this pin is con-trolled by DDB2. When the pin is forced to be an input, the pull-up can still be controlled by the PORTB2 bit.</TEXT>
      </PIN12>
      <PIN13>
        <NAME>[PB3:MISO]</NAME>
        <TEXT>MISO: Master data input, slave data output pin for SPI channel. When the SPI is enabled as a master, this pin is configured as an input regardless of the setting of DDB3. When the SPI is enabled as a slave, the data direction of this pin is controlled by DDB3. When the pin is forced to be an input, the pull-up can still be controlled by the PORTB3 bit.</TEXT>
      </PIN13>
      <PIN14>
        <NAME>[PB4:OC0:PWM0]</NAME>
        <TEXT>OC0, Output Compare match output: The PB4 pin can serve as an external output for the Timer/Counter0 output compare. The pin has to be configured as an output (DDB4 set (one)) to serve this function. The OC0 pin is also the output pin for the PWM mode timer function.</TEXT>
      </PIN14>
      <PIN15>
        <NAME>[PB5:OC1A:PWM1A]</NAME>
        <TEXT>OC1A, Output Compare matchA output: The PB5 pin can serve as an external output for the Timer/Counter1 output com-pareA. The pin has to be configured as an output (DDB5 set (one)) to serve this function. The OC1A pin is also the output pin for the PWM mode timer function.</TEXT>
      </PIN15>
      <PIN16>
        <NAME>[PB6:OC1B:PWM1B]</NAME>
        <TEXT>OC1B, Output Compare matchB output: The PB6 pin can serve as an external output for the Timer/Counter1 output compare B. The pin has to be configured as an output (DDB6 set (one)) to serve this function. The OC1B pin is also the output pin for the PWM mode timer function.</TEXT>
      </PIN16>
      <PIN17>
        <NAME>[PB7:OC2:PWM2:OC1C]</NAME>
        <TEXT>OC2, Output Compare match output: The PB7 pin can serve as an external output for the Timer/Counter2 output compare. The pin has to be configured as an output (DDB7 set (one)) to serve this function. The OC2 pin is also the output pin for the PWM mode timer function.</TEXT>
      </PIN17>
      <PIN18>
        <NAME>[PG3:TOSC2]</NAME>
        <TEXT>TOSC2, Timer Oscillator pin 2: When the AS0 bit in ASSR is set (one) to enable asynchronous clocking of Timer/Counter0, pin PG3 is disconnected from the port, and becomes the input of the inverting oscillator amplifier. In this mode, a crystal oscillator is connected to this pin, and the pin can not be used as an I/O pin.</TEXT>
      </PIN18>
      <PIN19>
        <NAME>[PG4:TOSC1]</NAME>
        <TEXT>TOSC1, Timer Oscillator pin 1: When the AS0 bit in ASSR is set (one) to enable asynchronous clocking of Timer/Counter0, pin PG4 is disconnected from the port, and becomes the inverting output of the oscillator amplifier. In this mode, a crystal oscillator is connected to this pin, and the pin can not be used as an I/O pin.</TEXT>
      </PIN19>
      <PIN20>
        <NAME>['RESET]</NAME>
        <TEXT/>
      </PIN20>
      <PIN21>
        <NAME>[VCC]</NAME>
        <TEXT/>
      </PIN21>
      <PIN22>
        <NAME>[GND]</NAME>
        <TEXT/>
      </PIN22>
      <PIN23>
        <NAME>[XTAL2]</NAME>
        <TEXT/>
      </PIN23>
      <PIN24>
        <NAME>[XTAL1]</NAME>
        <TEXT/>
      </PIN24>
      <PIN25>
        <NAME>[PD0:SCL:INT0]</NAME>
        <TEXT>INT0, External Interrupt source 0. The PD0 pin can serve as external active low interrupt source to the MCU. The internal pull up MOS resistors can be activated as described above. See the interrupt description for further details, and how to enable the source. SCL, 2-wire Serial Interface Clock: When the TWEN bit in TWCR is set (one) to enable the 2-wire Serial Interface, pin PD0 is disconnected from the port and becomes the Serial Clock I/O pin for the 2-wire Serial Interface. In this mode, there is a spike filter on the pin to suppress spikes shorter than 50 ns on the input signal, and the pin is driven by an open drain driver with slew-rate limitation</TEXT>
      </PIN25>
      <PIN26>
        <NAME>[PD1:SDA:INT1]</NAME>
        <TEXT>INT1, External Interrupt source 1. The PD1 pin can serve as external active low interrupt source to the MCU. The internal pull up MOS resistors can be activated as described above. See the interrupt description for further details, and how to enable the source. SDA, 2-wire Serial Interface Data: When the TWEN bit in TWCR is set (one) to enable the 2-wire Serial Interface, pin PD1 is disconnected from the port and becomes the Serial Data I/O pin for the 2-wire Serial Interface. In this mode, there is aspike filter on the pin to suppress spikes shorter than 50 ns on the input signal, and the pin is driven by an open drain driver with slew-rate limitati</TEXT>
      </PIN26>
      <PIN27>
        <NAME>[PD2:RXD1:INT2]</NAME>
        <TEXT>INT2, External Interrupt source 2. The PD2 pin can serve as external active low interrupt source to the MCU. The internal pull up MOS resistors can be activated as described above. See the interrupt description for further details, and how to enable the source. RXD1, Receive Data (Data input pin for the USART1). When the USART1 receiver is enabled this pin is configured as an input regardless of the value of DDD2. When the USART forces this pin to be an input, the pull-up can still be controlled by the PORTD2 bi</TEXT>
      </PIN27>
      <PIN28>
        <NAME>[PD3:TXD1:INT3]</NAME>
        <TEXT>INT3, External Interrupt source 3. The PD3 pin can serve as external active low interrupt source to the MCU. The internal pull up MOS resistors can be activated as described above. See the interrupt description for further details, and how to enable the source. TXD1, Transmit Data (Data output pin for the USART1). When the USART1 transmitter is enabled, this pin is configured as an output regardless of the value of DDD3.</TEXT>
      </PIN28>
      <PIN29>
        <NAME>[PD4:IC1]</NAME>
        <TEXT>IC1 - Input Capture Pin1: The PD4 pin can act as an input capture pin for Timer/Counter1.</TEXT>
      </PIN29>
      <PIN30>
        <NAME>[PD5:XCK1]</NAME>
        <TEXT>XCK1, USART1 external clock. The Data Direction Register (DDD4) controls whether the clock is output (DDD4 set) or input (DDD4 cleared). The XCK1 pin is active only when the USART1 operates in synchronous mode.</TEXT>
      </PIN30>
      <PIN31>
        <NAME>[PD6:T1]</NAME>
        <TEXT>T1, Timer/Counter1 counter source.</TEXT>
      </PIN31>
      <PIN32>
        <NAME>[PD7:T2]</NAME>
        <TEXT>T2, Timer/Counter2 counter source.</TEXT>
      </PIN32>
      <PIN33>
        <NAME>[PG0:'WR]</NAME>
        <TEXT>WR is the external data memory write control strobe.</TEXT>
      </PIN33>
      <PIN34>
        <NAME>[PG1:'RD]</NAME>
        <TEXT>RD is the external data memory read control strobe.</TEXT>
      </PIN34>
      <PIN35>
        <NAME>[PC0:A8]</NAME>
        <TEXT/>
      </PIN35>
      <PIN36>
        <NAME>[PC1:A9]</NAME>
        <TEXT/>
      </PIN36>
      <PIN37>
        <NAME>[PC2:A10]</NAME>
        <TEXT/>
      </PIN37>
      <PIN38>
        <NAME>[PC3:A11]</NAME>
        <TEXT/>
      </PIN38>
      <PIN39>
        <NAME>[PC4:A12]</NAME>
        <TEXT/>
      </PIN39>
      <PIN40>
        <NAME>[PC5:A13]</NAME>
        <TEXT/>
      </PIN40>
      <PIN41>
        <NAME>[PC6:A14]</NAME>
        <TEXT/>
      </PIN41>
      <PIN42>
        <NAME>[PC7:A15]</NAME>
        <TEXT/>
      </PIN42>
      <PIN43>
        <NAME>[PG2:ALE]</NAME>
        <TEXT>ALE is the external data memory Address Latch Enable signal.</TEXT>
      </PIN43>
      <PIN44>
        <NAME>[PA7:AD7]</NAME>
        <TEXT/>
      </PIN44>
      <PIN45>
        <NAME>[PA6:AD6]</NAME>
        <TEXT/>
      </PIN45>
      <PIN46>
        <NAME>[PA5:AD5]</NAME>
        <TEXT/>
      </PIN46>
      <PIN47>
        <NAME>[PA4:AD4]</NAME>
        <TEXT/>
      </PIN47>
      <PIN48>
        <NAME>[PA3:AD3]</NAME>
        <TEXT/>
      </PIN48>
      <PIN49>
        <NAME>[PA2:AD2]</NAME>
        <TEXT/>
      </PIN49>
      <PIN50>
        <NAME>[PA1:AD1]</NAME>
        <TEXT/>
      </PIN50>
      <PIN51>
        <NAME>[PA0:AD0]</NAME>
        <TEXT/>
      </PIN51>
      <PIN52>
        <NAME>[VCC]</NAME>
        <TEXT/>
      </PIN52>
      <PIN53>
        <NAME>[GND]</NAME>
        <TEXT/>
      </PIN53>
      <PIN54>
        <NAME>[PF7:ADC7:TDI]</NAME>
        <TEXT>ADC7, Analog to Digital Converter, channel 7. TDI, JTAG Test Data In: Serial input data to be shifted in to the Instruction Register or Data Register (scan chains). When the JTAG interface is enabled, this pin can not be used as an I/O pin.</TEXT>
      </PIN54>
      <PIN55>
        <NAME>[PF6:ADC6:TDO]</NAME>
        <TEXT>ADC6, Analog to Digital Converter, channel 6. TDO, JTAG Test Data Out: Serial output data from Instruction register or Data Register. When the JTAG interface is enabled, this pin can not be used as an I/O pin.</TEXT>
      </PIN55>
      <PIN56>
        <NAME>[PF5:ADC5:TMS]</NAME>
        <TEXT>ADC5, Analog to Digital Converter, channel 5. TMS, JTAG Test Mode Select: This pin is used for navigating through the TAP-controller state machine. When the JTAG interface is enabled, this pin can not be used as an I/O pin.</TEXT>
      </PIN56>
      <PIN57>
        <NAME>[PF4:ADC4:TCK]</NAME>
        <TEXT>ADC4, Analog to Digital Converter, channel 4. TCK, JTAG Test Clock: JTAG operation is synchronous to TCK. When the JTAG interface is enabled, this pin can not be used as an I/O pin.</TEXT>
      </PIN57>
      <PIN58>
        <NAME>[PF3:ADC3]</NAME>
        <TEXT>Analog to Digital Converter, Channel 3</TEXT>
      </PIN58>
      <PIN59>
        <NAME>[PF2:ADC2]</NAME>
        <TEXT>Analog to Digital Converter, Channel 2</TEXT>
      </PIN59>
      <PIN60>
        <NAME>[PF1:ADC1]</NAME>
        <TEXT>Analog to Digital Converter, Channel 1</TEXT>
      </PIN60>
      <PIN61>
        <NAME>[PF0:ADC0]</NAME>
        <TEXT>Analog to Digital Converter, Channel 0</TEXT>
      </PIN61>
      <PIN62>
        <NAME>[AREF]</NAME>
        <TEXT/>
      </PIN62>
      <PIN63>
        <NAME>[GND]</NAME>
        <TEXT/>
      </PIN63>
      <PIN64>
        <NAME>[AVCC]</NAME>
        <TEXT/>
      </PIN64>
    </TQFP>
  </PACKAGE>
  <POWER>
    <CLOCK>4MHz</CLOCK>
    <TEMP>25C</TEMP>
    <ACTIVE>3.0mA</ACTIVE>
    <IDLE>1.0mA</IDLE>
    <POWER_DOWN>&lt;1uA</POWER_DOWN>
  </POWER>
  <PROGVOLT>
    <SER_PROG_MIN_V>2.7</SER_PROG_MIN_V>
    <SER_PROG_MAX_V>6.0</SER_PROG_MAX_V>
    <PAR_PROG_MIN_V>4.5</PAR_PROG_MIN_V>
    <PAR_PROG_MAX_V>5.5</PAR_PROG_MAX_V>
  </PROGVOLT>
  <LOCKBIT>
    <ICON/>
    <ID/>
    <TEXT>[LB1 = 1 :  LB2 = 1] No memory lock features enabled. [LB1 = 0 :  LB2 = 1] Further programming of Flash and EEPROM is enabled. [LB1 = 0 :  LB2 = 0] Same as previous, but verify is also disabled</TEXT>
    <NMB_LOCK_BITS>6</NMB_LOCK_BITS>
    <NMB_TEXT>11</NMB_TEXT>
    <TEXT1>
      <MASK>0x03</MASK>
      <VALUE>0x03</VALUE>
      <TEXT>Mode 1: No memory lock features enabled</TEXT>
    </TEXT1>
    <TEXT2>
      <MASK>0x03</MASK>
      <VALUE>0x02</VALUE>
      <TEXT>Mode 2: Further programming disabled</TEXT>
    </TEXT2>
    <TEXT3>
      <MASK>0x03</MASK>
      <VALUE>0x00</VALUE>
      <TEXT>Mode 3: Further programming and verification disabled</TEXT>
    </TEXT3>
    <TEXT4>
      <MASK>0x0C</MASK>
      <VALUE>0x0C</VALUE>
      <TEXT>Application Protection Mode 1: No lock on SPM and LPM in Application Section</TEXT>
    </TEXT4>
    <TEXT5>
      <MASK>0x0C</MASK>
      <VALUE>0x08</VALUE>
      <TEXT>Application Protection Mode 2: SPM prohibited in Application Section</TEXT>
    </TEXT5>
    <TEXT6>
      <MASK>0x0C</MASK>
      <VALUE>0x00</VALUE>
      <TEXT>Application Protection Mode 3: LPM and SPM prohibited in Application Section</TEXT>
    </TEXT6>
    <TEXT7>
      <MASK>0x0C</MASK>
      <VALUE>0x04</VALUE>
      <TEXT>Application Protection Mode 4: LPM prohibited in Application Section</TEXT>
    </TEXT7>
    <TEXT8>
      <MASK>0x30</MASK>
      <VALUE>0x30</VALUE>
      <TEXT>Boot Loader Protection Mode 1: No lock on SPM and LPM in Boot Loader Section</TEXT>
    </TEXT8>
    <TEXT9>
      <MASK>0x30</MASK>
      <VALUE>0x20</VALUE>
      <TEXT>Boot Loader Protection Mode 2: SPM prohibited in Boot Loader Section</TEXT>
    </TEXT9>
    <TEXT10>
      <MASK>0x30</MASK>
      <VALUE>0x00</VALUE>
      <TEXT>Boot Loader Protection Mode 3: LPM and SPM prohibited in Boot Loader Section</TEXT>
    </TEXT10>
    <TEXT11>
      <MASK>0x30</MASK>
      <VALUE>0x10</VALUE>
      <TEXT>Boot Loader Protection Mode 4: LPM prohibited in Boot Loader Section</TEXT>
    </TEXT11>
    <LOCKBIT0>
      <NAME>LB1</NAME>
      <TEXT>Lock bit</TEXT>
    </LOCKBIT0>
    <LOCKBIT1>
      <NAME>LB2</NAME>
      <TEXT>Lock bit</TEXT>
    </LOCKBIT1>
    <LOCKBIT2>
      <NAME>BLB01</NAME>
      <TEXT>Boot Lock bit</TEXT>
    </LOCKBIT2>
    <LOCKBIT3>
      <NAME>BLB02</NAME>
      <TEXT>Boot Lock bit</TEXT>
    </LOCKBIT3>
    <LOCKBIT4>
      <NAME>BLB11</NAME>
      <TEXT>Boot lock bit</TEXT>
    </LOCKBIT4>
    <LOCKBIT5>
      <NAME>BLB12</NAME>
      <TEXT>Boot lock bit</TEXT>
    </LOCKBIT5>
  </LOCKBIT>
  <PROGRAMMING>
    <ISPInterface>
      <FuseReadMask>0xff,0xdf,0xff</FuseReadMask>
      <FuseProgMask>0xff,0xdf,0xff</FuseProgMask>
      <FuseWarning>1,0x40,0x40,WARNING! These fuse settings will disable the JTAG interface!</FuseWarning>
      <FuseWarning>1,0x20,0x20,WARNING! These fuse settings will disable the ISP interface!</FuseWarning>
    </ISPInterface>
    <HVInterface>
      <FuseWarning>1,0x40,0x40,WARNING! These fuse settings will disable the JTAG interface!</FuseWarning>
      <FuseWarning>1,0x20,0x20,WARNING! These fuse settings will disable the ISP interface!</FuseWarning>
    </HVInterface>
    <JTAGInterface>
      <FuseWarning>1,0x40,0x40,WARNING! These fuse settings will disable the JTAG interface!</FuseWarning>
      <FuseWarning>1,0x20,0x20,WARNING! These fuse settings will disable the ISP interface!</FuseWarning>
    </JTAGInterface>
    <OscCal>
      <OCEntry>0x00,1.0 MHz </OCEntry>
      <OCEntry>0x01,2.0 MHz </OCEntry>
      <OCEntry>0x02,4.0 MHz </OCEntry>
      <OCEntry>0x03,8.0 MHz</OCEntry>
    </OscCal>
    <FlashPageSize>256</FlashPageSize>
    <EepromPageSize>8</EepromPageSize>
  </PROGRAMMING>
  <IO_MODULE>
    <MODULE_LIST>[ANALOG_COMPARATOR:SPI:TWI:USART0:USART1:CPU:BOOT_LOAD:JTAG:MISC:EXTERNAL_INTERRUPT:EEPROM:PORTA:PORTB:PORTC:PORTD:PORTE:PORTF:PORTG:TIMER_COUNTER_0:TIMER_COUNTER_1:TIMER_COUNTER_2:TIMER_COUNTER_3:WATCHDOG:AD_CONVERTER]</MODULE_LIST>
    <ANALOG_COMPARATOR>
      <LIST>[SFIOR:ACSR]</LIST>
      <LINK/>
      <ICON>io_analo.bmp</ICON>
      <ID>AlgComp_01</ID>
      <TEXT/>
      <SFIOR>
        <NAME>SFIOR</NAME>
        <DESCRIPTION>Special Function IO Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x20</IO_ADDR>
        <MEM_ADDR>0x40</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT3>
          <NAME>ACME</NAME>
          <DESCRIPTION>Analog Comparator Multiplexer Enable</DESCRIPTION>
          <TEXT>When this bit is written logic one and the ADC is switched off (ADEN in ADCSR is zero), the ADC multiplexer selects the negative input to the Analog Comparator. When this bit is written logic zero, AIN1 is applied to the negative input of the Analog Comparator. For a detailed description of this bit, see &#x201C;Analog Comparator Multiplexed Input&#x201D; on page 186.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
      </SFIOR>
      <ACSR>
        <NAME>ACSR</NAME>
        <DESCRIPTION>Analog Comparator Control And Status Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x08</IO_ADDR>
        <MEM_ADDR>0x28</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>ACD</NAME>
          <DESCRIPTION>Analog Comparator Disable</DESCRIPTION>
          <TEXT>When this bit is written logic one, the power to the analog comparator is switched off. This bit can be set at any time to turn off the analog comparator. This will reduce power consumption in active and idle mode. When changing the ACD bit, the Analog Comparator Interrupt must be disabled by clearing the ACIE bit in ACSR. Otherwise an interrupt can occur when the bit is changed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ACBG</NAME>
          <DESCRIPTION>Analog Comparator Bandgap Select</DESCRIPTION>
          <TEXT>When this bit is set, a fixed bandgap reference voltage replaces the positive input to the Analog Comparator. When this bit is cleared, AIN0 is applied to the positive input of the Analog Comparator. See &#x201C;Internal Voltage Reference&#x201D; on page 42.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ACO</NAME>
          <DESCRIPTION>Analog Compare Output</DESCRIPTION>
          <TEXT>The output of the analog comparator is synchronized and then directly connected to ACO. The synchronization introduces a delay of 1-2 clock cycles.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>NA</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ACI</NAME>
          <DESCRIPTION>Analog Comparator Interrupt Flag</DESCRIPTION>
          <TEXT>This bit is set by hardware when a comparator output event triggers the interrupt mode defined by ACIS1 and ACIS0. The Analog Comparator Interrupt routine is executed if the ACIE bit is set and the I-bit in SREG is set. ACI is cleared by hard-ware when executing the corresponding interrupt handling vector. Alternatively, ACI is cleared by writing a logic one to the flag.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ACIE</NAME>
          <DESCRIPTION>Analog Comparator Interrupt Enable</DESCRIPTION>
          <TEXT>When the ACIE bit is written logic one and the I-bit in the Status Register is set, the analog comparator interrupt is acti-vated. When written logic zero, the interrupt is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ACIC</NAME>
          <DESCRIPTION>Analog Comparator Input Capture Enable</DESCRIPTION>
          <TEXT>When written logic one, this bit enables the Input Capture function in Timer/Counter1 to be triggered by the analog comparator. The comparator output is in this case directly connected to the Input Capture front-end logic, making the comparator utilize the noise canceler and edge select features of the Timer/Counter1 Input Capture interrupt. When written logic zero, no connection between the analog comparator and the Input Capture function exists. To make the comparator trigger the Timer/Counter1 Input Capture interrupt, the TICIE1 bit in the Timer Interrupt Mask Register (TIMSK) must be set</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ACIS1</NAME>
          <DESCRIPTION>Analog Comparator Interrupt Mode Select bit 1</DESCRIPTION>
          <TEXT>These bits determine which comparator events that trigger the Analog Comparator interrupt.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ACIS0</NAME>
          <DESCRIPTION>Analog Comparator Interrupt Mode Select bit 0</DESCRIPTION>
          <TEXT>These bits determine which comparator events that trigger the Analog Comparator interrupt.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>ANALOG_COMP_INTERRUPT</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ACSR>
    </ANALOG_COMPARATOR>
    <SPI>
      <LIST>[SPDR:SPSR:SPCR]</LIST>
      <LINK/>
      <ICON>io_com.bmp</ICON>
      <ID>SPI_01</ID>
      <TEXT>The Serial Peripheral Interface (SPI) allows high-speed synchronous data transfer between the device and peripheral devices or between several AVR devices. The SPI includes the following features: &#x2022; Full-duplex, 3-wire Synchronous Data Transfer &#x2022; Master or Slave Operation &#x2022; LSB First or MSB First Data Transfer &#x2022; Seven Programmable Bit Rates &#x2022; End of Transmission Interrupt Flag &#x2022; Write Collision Flag Protection &#x2022; Wake-up from Idle Mode &#x2022; Double Speed (CK/2) Master SPI Mode</TEXT>
      <SPDR>
        <NAME>SPDR</NAME>
        <DESCRIPTION>SPI Data Register</DESCRIPTION>
        <TEXT>The SPI Data Register is a read/write register used for data transfer between the register file and the SPI Shift register. Writing to the register initiates data transmission. Reading the register causes the Shift Register Receive buffer to be read.</TEXT>
        <IO_ADDR>0x0F</IO_ADDR>
        <MEM_ADDR>0x2F</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <READ_INTRUSIVE/>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>SPDR7</NAME>
          <DESCRIPTION>SPI Data Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SPDR6</NAME>
          <DESCRIPTION>SPI Data Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SPDR5</NAME>
          <DESCRIPTION>SPI Data Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SPDR4</NAME>
          <DESCRIPTION>SPI Data Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SPDR3</NAME>
          <DESCRIPTION>SPI Data Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SPDR2</NAME>
          <DESCRIPTION>SPI Data Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SPDR1</NAME>
          <DESCRIPTION>SPI Data Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SPDR0</NAME>
          <DESCRIPTION>SPI Data Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SPDR>
      <SPSR>
        <NAME>SPSR</NAME>
        <DESCRIPTION>SPI Status Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x0E</IO_ADDR>
        <MEM_ADDR>0x2E</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SPIF</NAME>
          <DESCRIPTION>SPI Interrupt Flag</DESCRIPTION>
          <TEXT>When a serial transfer is complete, the SPIF bit is set (one) and an interrupt is generated if SPIE in SPCR is set (one) and global interrupts are enabled. If SS is an input and is driven low when the SPI is in master mode, this will also set the SPIF flag. SPIF is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, the SPIF bit is cleared by first reading the SPI status register when SPIF is set (one), then accessing the SPI Data Register (SPDR).</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>WCOL</NAME>
          <DESCRIPTION>Write Collision Flag</DESCRIPTION>
          <TEXT>The WCOL bit is set if the SPI data register (SPDR) is written during a data transfer. The WCOL bit (and the SPIF bit) are cleared (zero) by first reading the SPI Status Register when WCOL is set (one), and then accessing the SPI Data Register.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT0>
          <NAME>SPI2X</NAME>
          <DESCRIPTION>Double SPI Speed Bit</DESCRIPTION>
          <TEXT>When this bit is written logic one the SPI speed (SCK Frequency) will be doubled when the SPI is in master mode (see Table 71). This means that the minimum SCK period will be 2 CPU clock periods. When the SPI is configured as Slave, the SPI is only guaranteed to work at f ck / 4 or lower. The SPI interface on the ATmega104 is also used for program memory and EEPROM downloading or uploading. See page 253 for serial programming and verification.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SPSR>
      <SPCR>
        <NAME>SPCR</NAME>
        <DESCRIPTION>SPI Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x0D</IO_ADDR>
        <MEM_ADDR>0x2D</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SPIE</NAME>
          <DESCRIPTION>SPI Interrupt Enable</DESCRIPTION>
          <TEXT>This bit causes the SPI interrupt to be executed if SPIF bit in the SPSR register is set and the global interrupts are enabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SPE</NAME>
          <DESCRIPTION>SPI Enable</DESCRIPTION>
          <TEXT>When the SPE bit is set (one), the SPI is enabled. This bit must be set to enable any SPI operations.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>DORD</NAME>
          <DESCRIPTION>Data Order</DESCRIPTION>
          <TEXT>When the DORD bit is set (one), the LSB of the data word is transmitted first. When the DORD bit is cleared (zero), the MSB of the data word is transmitted first.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>MSTR</NAME>
          <DESCRIPTION>Master/Slave Select</DESCRIPTION>
          <TEXT>This bit selects Master SPI mode when set (one), and Slave SPI mode when cleared (zero). If SS is configured as an input and is driven low while MSTR is set, MSTR will be cleared, and SPIF in SPSR will become set. The user will then have to set MSTR to re-enable SPI master mode.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>CPOL</NAME>
          <DESCRIPTION>Clock polarity</DESCRIPTION>
          <TEXT>When this bit is set (one), SCK is high when idle. When CPOL is cleared (zero), SCK is low when idle. Refer to Figure 36 and Figure 37 for additional information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CPHA</NAME>
          <DESCRIPTION>Clock Phase</DESCRIPTION>
          <TEXT>Refer to Figure 36 or Figure 37 for the functionality of this bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SPR1</NAME>
          <DESCRIPTION>SPI Clock Rate Select 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SPR0</NAME>
          <DESCRIPTION>SPI Clock Rate Select 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <ENUM>COMM_SCK_RATE_3BIT</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SPCR>
    </SPI>
    <TWI>
      <LIST>[TWBR:TWCR:TWSR:TWDR:TWAR]</LIST>
      <LINK/>
      <ICON>io_com.bmp</ICON>
      <ID/>
      <TEXT>TWI: Simple yet powerful and flexible communications interface, only two bus lines needed. Both master and slave operation supported. Device can operate as transmitter or receiver. 7-bit address space allows up to 128 different slave addresses.  Multi-master arbitration support  Up to 400 kHz data transfer speed  Slew-rate limited output drivers  Noise suppression circuitry rejects spikes on bus lines  Fully programmable slave address with general call support  Address recognition causes wake-up when AVR is in sleep mode The Two-Wire Serial Interface (TWI) is ideally suited to typical microcontroller applications. The TWI protocol allows the systems designer to interconnect up to 128 different devices using only two bidirectional bus lines, one for clock (SCL) andone for data (SDA). The only external hardware needed to implement the bus is a single pull-up resistor for each of the TWI bus lines. All devices connected to the bus have individual addresses, and mechanisms for resolving bus contention are inherent in the TWI pr</TEXT>
      <TWBR>
        <NAME>TWBR</NAME>
        <ALIAS>I2BR</ALIAS>
        <DESCRIPTION>TWI Bit Rate register</DESCRIPTION>
        <TEXT>TWBR selects the division factor for the bit rate generator. The bit rate generator is a frequency divider which generates the SCL clock frequency in the master modes. See &#x201C;Bit Rate Generator Unit&#x201D; on page 165 for calculating bit rates.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x70</MEM_ADDR>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TWBR7</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TWBR6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TWBR5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TWBR4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TWBR3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TWBR2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TWBR1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TWBR0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TWBR>
      <TWCR>
        <NAME>TWCR</NAME>
        <ALIAS>I2CR</ALIAS>
        <DESCRIPTION>TWI Control Register</DESCRIPTION>
        <TEXT>The TWCR is used to control the operation of the TWI. It is used to enable the TWI, to initiate a master access by applying a START condition to the bus, to generate a receiver acknowledge, to generate a stop condition, and to control halting of the bus while the data to be written to the bus are written to the TWDR. It also indicates a write collision if data is attempted written to TWDR while the register is inaccessible.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x74</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>TWINT</NAME>
          <ALIAS>I2INT</ALIAS>
          <DESCRIPTION>TWI Interrupt Flag</DESCRIPTION>
          <TEXT>This bit is set by hardware when the TWI has finished its current job and expects application software response. If the I-bit in SREG and TWIE in TWCR are set, the MCU will jump to the TWI interrupt vector. While the TWINT flag is set, the SCL low period is stretched. The TWINT flag must be cleared by software by writing a logic one to it. Note that this flag is not automatically cleared by hardware when executing the interrupt routine. Also note that clearing this flag starts the operation of the TWI, so all accesses to the TWI Address Register (TWAR), TWI Status Register (TWSR), and TWI Data Register (TWDR) must be complete before clearing this flag</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TWEA</NAME>
          <ALIAS>I2EA</ALIAS>
          <DESCRIPTION>TWI Enable Acknowledge Bit</DESCRIPTION>
          <TEXT>The TWEA bit controls the generation of the acknowledge pulse. If the TWEA bit is written to one, the ACK pulse is gener-ated on the TWI bus if the following conditions are met: 1. The device&#x2019;s own slave address has been received. 2. A general call has been received, while the TWGCE bit in the TWAR is set. 3. A data byte has been received in master receiver or slave receiver mode. By writing the TWEA bit to zero, the device can be virtually disconnected from the 2-wire Serial Bus temporarily. Address recognition can then be resumed by writing the TWEA bit to one again</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TWSTA</NAME>
          <ALIAS>I2STA</ALIAS>
          <DESCRIPTION>TWI Start Condition Bit</DESCRIPTION>
          <TEXT>The application writes the TWSTA bit to one when it desires to become a master on the 2-wire Serial Bus. The TWI hard-ware checks if the bus is available, and generates a START condition on the bus if it is free. However, if the bus is not free, the TWI waits until a STOP condition is detected, and then generates a new START condition to claim the bus Master sta-tus. TWSTA is cleared by the TWI hardware when the START condition has been transmitted.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TWSTO</NAME>
          <ALIAS>I2STO</ALIAS>
          <DESCRIPTION>TWI Stop Condition Bit</DESCRIPTION>
          <TEXT>Writing the TWSTO bit to one in master mode will generate a STOP condition on the 2-wire Serial Bus. When the STOP condition is executed on the bus, the TWSTO bit is cleared automatically. In slave mode, setting the TWSTO bit can be used to recover from an error condition. This will not generate a STOP condition, but the TWI returns to a well-defined unaddressed slave mode and releases the SCL and SDA lines to a high impedance state.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TWWC</NAME>
          <ALIAS>I2WC</ALIAS>
          <DESCRIPTION>TWI Write Collition Flag</DESCRIPTION>
          <TEXT>The TWWC bit is set when attempting to write to the TWI Data Register - TWDR when TWINT is low. This flag is cleared by writing the TWDR register when TWINT is high.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TWEN</NAME>
          <ALIAS>I2EN</ALIAS>
          <ALIAS>ENI2C</ALIAS>
          <DESCRIPTION>TWI Enable Bit</DESCRIPTION>
          <TEXT>The TWEN bit enables TWI operation and activates the TWI interface. When TWEN is written to one, the TWI takes control over the I/O pins connected to the SCL and SDA pins, enabling the slew-rate limiters and spike filters. If this bit is written to zero, the TWI is switched off and all TWI transmissions are terminated, regardless of any ongoing operation.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT0>
          <NAME>TWIE</NAME>
          <ALIAS>I2IE</ALIAS>
          <DESCRIPTION>TWI Interrupt Enable</DESCRIPTION>
          <TEXT>When this bit is written to one, and the I-bit in SREG is set, the TWI interrupt request will be activated for as long as the TWINT flag is high.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TWCR>
      <TWSR>
        <NAME>TWSR</NAME>
        <ALIAS>I2SR</ALIAS>
        <DESCRIPTION>TWI Status Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x71</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>TWS7</NAME>
          <ALIAS>I2S7</ALIAS>
          <DESCRIPTION>TWI Status</DESCRIPTION>
          <TEXT>Bits 7..3: These 5 bits reflect the status of the TWI logic and the 2-Wire Serial Bus. The different status codes are described later in this chapter. Note that the value read from TWSR contains both the 5-bit status value and the 2-bit prescaler value. The application designer should consider masking the prescaler bits to zero when checking the Status bits. This makes status checking independent of prescaler setting. This approach is used in this datasheet, unless otherwise noted. If the prescaler setting remains unchanged in the application, the prescaler bits need not be masked. Instead, bit 1:0 in the values that TWSR is compared to can be modified to match the prescaler setting. This will yield more efficient c</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TWS6</NAME>
          <ALIAS>I2S6</ALIAS>
          <DESCRIPTION>TWI Status</DESCRIPTION>
          <TEXT>Bits 7..3: These 5 bits reflect the status of the TWI logic and the 2-Wire Serial Bus. The different status codes are described later in this chapter. Note that the value read from TWSR contains both the 5-bit status value and the 2-bit prescaler value. The application designer should consider masking the prescaler bits to zero when checking the Status bits. This makes status checking independent of prescaler setting. This approach is used in this datasheet, unless otherwise noted. If the prescaler setting remains unchanged in the application, the prescaler bits need not be masked. Instead, bit 1:0 in the values that TWSR is compared to can be modified to match the prescaler setting. This will yield more efficient co</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TWS5</NAME>
          <ALIAS>I2S5</ALIAS>
          <DESCRIPTION>TWI Status</DESCRIPTION>
          <TEXT>Bits 7..3: These 5 bits reflect the status of the TWI logic and the 2-Wire Serial Bus. The different status codes are described later in this chapter. Note that the value read from TWSR contains both the 5-bit status value and the 2-bit prescaler value. The application designer should consider masking the prescaler bits to zero when checking the Status bits. This makes status checking independent of prescaler setting. This approach is used in this datasheet, unless otherwise noted. If the prescaler setting remains unchanged in the application, the prescaler bits need not be masked. Instead, bit 1:0 in the values that TWSR is compared to can be modified to match the prescaler setting. This will yield more efficient c</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TWS4</NAME>
          <ALIAS>I2S4</ALIAS>
          <DESCRIPTION>TWI Status</DESCRIPTION>
          <TEXT>Bits 7..3: These 5 bits reflect the status of the TWI logic and the 2-Wire Serial Bus. The different status codes are described later in this chapter. Note that the value read from TWSR contains both the 5-bit status value and the 2-bit prescaler value. The application designer should consider masking the prescaler bits to zero when checking the Status bits. This makes status checking independent of prescaler setting. This approach is used in this datasheet, unless otherwise noted. If the prescaler setting remains unchanged in the application, the prescaler bits need not be masked. Instead, bit 1:0 in the values that TWSR is compared to can be modified to match the prescaler setting. This will yield more efficient co</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TWS3</NAME>
          <ALIAS>I2S3</ALIAS>
          <DESCRIPTION>TWI Status</DESCRIPTION>
          <TEXT>Bits 7..3: These 5 bits reflect the status of the TWI logic and the 2-Wire Serial Bus. The different status codes are described later in this chapter. Note that the value read from TWSR contains both the 5-bit status value and the 2-bit prescaler value. The application designer should consider masking the prescaler bits to zero when checking the Status bits. This makes status checking independent of prescaler setting. This approach is used in this datasheet, unless otherwise noted. If the prescaler setting remains unchanged in the application, the prescaler bits need not be masked. Instead, bit 1:0 in the values that TWSR is compared to can be modified to match the prescaler setting. This will yield more efficient co</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT1>
          <NAME>TWPS1</NAME>
          <ALIAS>TWS1</ALIAS>
          <DESCRIPTION>TWI Prescaler</DESCRIPTION>
          <TEXT>Bits 1..0: These bits can be read and written, and control the bit rate prescaler. See &#x201C;Bit Rate Generator Unit&#x201D; on page 165 for calculating bit rates.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TWPS0</NAME>
          <ALIAS>TWS0</ALIAS>
          <ALIAS>I2GCE</ALIAS>
          <DESCRIPTION>TWI Prescaler</DESCRIPTION>
          <TEXT>Bits 1..0: These bits can be read and written, and control the bit rate prescaler. See &#x201C;Bit Rate Generator Unit&#x201D; on page 165 for calculating bit rates.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>COMM_TWI_PRESACLE</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TWSR>
      <TWDR>
        <NAME>TWDR</NAME>
        <ALIAS>I2DR</ALIAS>
        <DESCRIPTION>TWI Data register</DESCRIPTION>
        <TEXT>In transmit mode, TWDR contains the next byte to be transmitted. In receive mode, the TWDR contains the last byte received. It is writable while the TWI is not in the process of shifting a byte. This occurs when the TWI interrupt flag (TWINT) is set by hardware. Note that the data register cannot be initialized by the user before the first interrupt occurs. The data in TWDR remains stable as long as TWINT is set. While data is shifted out, data on the bus is simultaneously shifted in. TWDR always contains the last byte present on the bus, except after a wake up from a sleep mode by the TWI interrupt. In this case, the contents of TWDR is undefined. In the case of a lost bus arbitration, no data is lost in the transi-tion from Master to Slave. Handling of the ACK bit is controlled automatically by the TWI logic, the CPU cannot access the ACK bit directl</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x73</MEM_ADDR>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TWD7</NAME>
          <DESCRIPTION>TWI Data Register Bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TWD6</NAME>
          <DESCRIPTION>TWI Data Register Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TWD5</NAME>
          <DESCRIPTION>TWI Data Register Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TWD4</NAME>
          <DESCRIPTION>TWI Data Register Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TWD3</NAME>
          <DESCRIPTION>TWI Data Register Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TWD2</NAME>
          <DESCRIPTION>TWI Data Register Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TWD1</NAME>
          <DESCRIPTION>TWI Data Register Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TWD0</NAME>
          <DESCRIPTION>TWI Data Register Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT0>
      </TWDR>
      <TWAR>
        <NAME>TWAR</NAME>
        <ALIAS>I2AR</ALIAS>
        <DESCRIPTION>TWI (Slave) Address register</DESCRIPTION>
        <TEXT>The TWAR should be loaded with the 7-bit slave address (in the seven most significant bits of TWAR) to which the TWI will respond when programmed as a slave transmitter or receiver, and not needed in the master modes. In multimaster sys-tems, TWAR must be set in masters which can be addressed as slaves by other masters. The LSB of TWAR is used to enable recognition of the general call address ($00). There is an associated address compar-ator that looks for the slave address (or general call address if enabled) in the received serial address. If a match is found, an interrupt request is genera</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x72</MEM_ADDR>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>TWA6</NAME>
          <DESCRIPTION>TWI (Slave) Address register Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TWA5</NAME>
          <DESCRIPTION>TWI (Slave) Address register Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TWA4</NAME>
          <DESCRIPTION>TWI (Slave) Address register Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TWA3</NAME>
          <DESCRIPTION>TWI (Slave) Address register Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TWA2</NAME>
          <DESCRIPTION>TWI (Slave) Address register Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TWA1</NAME>
          <DESCRIPTION>TWI (Slave) Address register Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TWA0</NAME>
          <DESCRIPTION>TWI (Slave) Address register Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TWGCE</NAME>
          <DESCRIPTION>TWI General Call Recognition Enable Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TWAR>
    </TWI>
    <USART0>
      <LIST>[UDR0:UCSR0A:UCSR0B:UCSR0C:UBRR0H:UBRR0L]</LIST>
      <LINK>[UBRR0H:UBRR0L]</LINK>
      <ICON>io_com.bmp</ICON>
      <ID/>
      <TEXT>The Universal Synchronous and Asynchronous serial Receiver and Transmitter (USART) is a highly flexible serial communication device. The main features are: &#x2022; Full Duplex Operation (Independent Serial Receive and Transmit Registers) &#x2022; Asynchronous or Synchronous Operation &#x2022; Master or Slave Clocked Synchronous Operation &#x2022; High Resolution Baud Rate Generator &#x2022; Supports Serial Frames with 5, 6, 7, 8 or 9 Data Bits and 1 or 2 Stop Bits &#x2022; Odd or Even Parity Generation and Parity Check Supported by Hardware &#x2022; Data OverRun Detection &#x2022; Framing Error Detection &#x2022; Noise Filtering Includes False Start Bit Detection and Digital Low Pass Filter &#x2022; Three Separate Interrupts on TX Complete, TX Data Register Empty and RX Complete &#x2022; Multi-processor Communication Mode &#x2022; Double Speed Asynchronous Commu</TEXT>
      <UDR0>
        <NAME>UDR0</NAME>
        <DESCRIPTION>USART I/O Data Register</DESCRIPTION>
        <TEXT>The UDR0 register is actually two physically separate registers sharing the same I/O address. When writing to the register, the USART Transmit Data register is written. When reading from UDR0, the USART Receive Data register is read.</TEXT>
        <IO_ADDR>0x0C</IO_ADDR>
        <MEM_ADDR>0x2C</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <READ_INTRUSIVE/>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>UDR07</NAME>
          <DESCRIPTION>USART I/O Data Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>UDR06</NAME>
          <DESCRIPTION>USART I/O Data Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UDR05</NAME>
          <DESCRIPTION>USART I/O Data Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>UDR04</NAME>
          <DESCRIPTION>USART I/O Data Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>UDR03</NAME>
          <DESCRIPTION>USART I/O Data Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UDR02</NAME>
          <DESCRIPTION>USART I/O Data Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>UDR01</NAME>
          <DESCRIPTION>USART I/O Data Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>UDR00</NAME>
          <DESCRIPTION>USART I/O Data Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </UDR0>
      <UCSR0A>
        <NAME>UCSR0A</NAME>
        <DESCRIPTION>USART Control and Status Register A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x0B</IO_ADDR>
        <MEM_ADDR>0x2B</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>RXC0</NAME>
          <DESCRIPTION>USART Receive Complete</DESCRIPTION>
          <TEXT>This bit is set (one) when a received character is transferred from the Receiver Shift register to UDR0. The bit is set regard-less of any detected framing errors. When the RXCIE bit in UCR is set, the USART Receive Complete interrupt will be executed when RXC is set(one). RXC is cleared by reading UDR0. When interrupt-driven data reception is used, the USART Receive Complete Interrupt routine must read UDR0 in order to clear RXC, otherwise a new interrupt will occur once the interrupt routine terminates.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TXC0</NAME>
          <DESCRIPTION>USART Transmitt Complete</DESCRIPTION>
          <TEXT>This bit is set (one) when the entire character (including the stop bit) in the Transmit Shift register has been shifted out and no new data has been written to UDR0. This flag is especially useful in half-duplex communications interfaces, where a transmitting application must enter receive mode and free the communications bus immediately after completing the transmission. When the TXCIE bit in UCR is set, setting of TXC causes the USART Transmit Complete interrupt to be executed. TXC is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, the TXC bit is cleared (zero) by writing a logical one to th</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UDRE0</NAME>
          <DESCRIPTION>USART Data Register Empty</DESCRIPTION>
          <TEXT>This bit is set (one) when a character written to UDR0 is transferred to the Transmit shift register. Setting of this bit indicates that the transmitter is ready to receive a new character for transmission. When the UDR0IE bit in UCR is set, the USART Transmit Complete interrupt to be executed as long as UDR0E is set. UDR0E is cleared by writing UDR0. When interrupt-driven data transmittal is used, the USART Data Register Empty Interrupt routine must write UDR0 in order to clear UDR0E, otherwise a new interrupt will occur once the interrupt routine terminates. UDR0E is set (one) during reset to indicate that the transmitter is re</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>FE0</NAME>
          <DESCRIPTION>Framing Error</DESCRIPTION>
          <TEXT>This bit is set if a Framing Error condition is detected, i.e. when the stop bit of an incoming character is zero. The FE bit is cleared when the stop bit of received data is one.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>DOR0</NAME>
          <DESCRIPTION>Data overRun</DESCRIPTION>
          <TEXT>This bit is set if an Overrun condition is detected, i.e. when a character already present in the UDR0 register is not read before the next character has been shifted into the Receiver Shift register. The OR bit is buffered, which means that it will be set once the valid data still in UDR0E is read. The OR bit is cleared (zero) when data is received and transferred to UDR0. </TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UPE0</NAME>
          <DESCRIPTION>Parity Error</DESCRIPTION>
          <TEXT>This bit is set if the next character in the receive buffer had a Parity Error when received and the parity checking was enabled at that point (UPM1 = 1). This bit is valid until the receive buffer (UDR0) is read. Always set this bit to zero when writing to UCSR0A.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>U2X0</NAME>
          <DESCRIPTION>Double the USART transmission speed</DESCRIPTION>
          <TEXT>This bit only has effect for the asynchronous operation. Write this bit to zero when using synchronous operation. Writing this bit to one will reduce the divisor of the baud rate divider from 16 to 8 effectively doubling the transfer rate for asynchronous communication.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>MPCM0</NAME>
          <DESCRIPTION>Multi-processor Communication Mode</DESCRIPTION>
          <TEXT>This bit enables the Multi-processor Communication Mode. When the MPCM bit is written to one, all the incoming frames received by the USART receiver that do not contain address information will be ignored. The transmitter is unaffected by the MPCM setting. For more detailed information see &#x201C;Multi-processor Communication Mode&#x201D; on page 152.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </UCSR0A>
      <UCSR0B>
        <NAME>UCSR0B</NAME>
        <DESCRIPTION>USART Control and Status Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x0A</IO_ADDR>
        <MEM_ADDR>0x2A</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>RXCIE0</NAME>
          <DESCRIPTION>RX Complete Interrupt Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables interrupt on the RXC flag. A USART Receive Complete interrupt will be generated only if the RXCIE bit is written to one, the global interrupt flag in SREG is written to one and the RXC bit in UCSR0A is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TXCIE0</NAME>
          <DESCRIPTION>TX Complete Interrupt Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables interrupt on the TXC flag. A USART Transmit Complete interrupt will be generated only if the TXCIE bit is written to one, the global interrupt flag in SREG is written to one and the TXC bit in UCSR0A is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UDRIE0</NAME>
          <DESCRIPTION>USART Data register Empty Interrupt Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables interrupt on the UDR0E flag. A Data Register Empty interrupt will be generated only if the UDR0IE bit is written to one, the global interrupt flag in SREG is written to one and the UDR0E bit in UCSR0A is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>RXEN0</NAME>
          <DESCRIPTION>Receiver Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables the USART receiver. The receiver will override normal port operation for the RxD pin when enabled. Disabling the receiver will flush the receive buffer invalidating the FE, DOR and PE flags.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TXEN0</NAME>
          <DESCRIPTION>Transmitter Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables the USART transmitter. The transmitter will override normal port operation for the TxD pin when enabled. The disabling of the transmitter (writing TXEN to zero) will not become effective until ongoing and pending transmissions are completed, i.e. when the transmit shift register and transmit buffer register does not contain data to be transmitted. When disabled, the transmitter will no longer override the TxD port.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UCSZ02</NAME>
          <ALIAS>UCSZ2</ALIAS>
          <DESCRIPTION>Character Size</DESCRIPTION>
          <TEXT>The UCSZ2 bits combined with the UCSZ1:0 bit in UCSR0C sets the number of data bits (character size) in a frame the receiver and transmitter use.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>RXB80</NAME>
          <DESCRIPTION>Receive Data Bit 8</DESCRIPTION>
          <TEXT>RXB8 is the 9th data bit of the received character when operating with serial frames with 9 data bits. Must be read before reading the low bits from UDR0.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TXB80</NAME>
          <DESCRIPTION>Transmit Data Bit 8</DESCRIPTION>
          <TEXT>TXB8 is the 9th data bit in the character to be transmitted when operating with serial frames with 9 data bits. Must be writ-ten before writing the low bits to UDR0.</TEXT>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </UCSR0B>
      <UCSR0C>
        <NAME>UCSR0C</NAME>
        <DESCRIPTION>USART Control and Status Register C</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x95</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT6>
          <NAME>UMSEL0</NAME>
          <DESCRIPTION>USART Mode Select</DESCRIPTION>
          <TEXT>0: Asynchronous Operation.  1: Synchronous Operation</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>COMM_USART_MODE</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UPM01</NAME>
          <DESCRIPTION>Parity Mode Bit 1</DESCRIPTION>
          <TEXT>This bit enable and set type of parity generation and check. If enabled, the transmitter will automatically generate and send the parity of the transmitted data bits within each frame. The receiver will generate a parity value for the incoming data and compare it to the UPM0 setting. If a mismatch is detected, the PE flag in UCSR0A will be set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>UPM00</NAME>
          <DESCRIPTION>Parity Mode Bit 0</DESCRIPTION>
          <TEXT>This bit enable and set type of parity generation and check. If enabled, the transmitter will automatically generate and send the parity of the transmitted data bits within each frame. The receiver will generate a parity value for the incoming data and compare it to the UPM0 setting. If a mismatch is detected, the PE flag in UCSR0A will be set.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>COMM_UPM_PARITY_MODE</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>USBS0</NAME>
          <DESCRIPTION>Stop Bit Select</DESCRIPTION>
          <TEXT>0: 1-bit.  1: 2-bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>COMM_STOP_BIT_SEL</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UCSZ01</NAME>
          <DESCRIPTION>Character Size</DESCRIPTION>
          <TEXT>Character Size: 0 0 0 = 5-bit. 0 0 1 = 6-bit. 0 1 0 = 7 bit. 0 1 1 = 8-bit. 1 1 1 = 9 bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>UCSZ00</NAME>
          <DESCRIPTION>Character Size</DESCRIPTION>
          <TEXT>Character Size: 0 0 0 = 5-bit. 0 0 1 = 6-bit. 0 1 0 = 7 bit. 0 1 1 = 8-bit. 1 1 1 = 9 bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>UCPOL0</NAME>
          <DESCRIPTION>Clock Polarity</DESCRIPTION>
          <TEXT>This bit is used for synchronous mode only. Write this bit to zero when asynchronous mode is used. The UCPOL bit sets the relationship between data output change and data input sample, and the synchronous clock (XCK).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </UCSR0C>
      <UBRR0H>
        <NAME>UBRR0H</NAME>
        <DESCRIPTION>USART Baud Rate Register Hight Byte</DESCRIPTION>
        <TEXT>This is a 12-bit register which contains the USART baud rate. The UBRR0H contains the 4 most significant bits, and the UBRR0L contains the 8 least significant bits of the USART baud rate. Ongoing transmissions by the transmitter and receiver will be corrupted if the baud rate is changed. Writing UBRR0L will trigger an immediate update of the baud rate prescaler.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x90</MEM_ADDR>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT3>
          <NAME>UBRR11</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 11</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UBRR10</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 10</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>UBRR9</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 9</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>UBRR8</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 8</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </UBRR0H>
      <UBRR0L>
        <NAME>UBRR0L</NAME>
        <DESCRIPTION>USART Baud Rate Register Low Byte</DESCRIPTION>
        <TEXT>This is a 12-bit register which contains the USART baud rate. The UBRR0H contains the 4 most significant bits, and the UBRR0L contains the 8 least significant bits of the USART baud rate. Ongoing transmissions by the transmitter and receiver will be corrupted if the baud rate is changed. Writing UBRR0L will trigger an immediate update of the baud rate prescaler.</TEXT>
        <IO_ADDR>0x09</IO_ADDR>
        <MEM_ADDR>0x29</MEM_ADDR>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>UBRR7</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>UBRR6</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UBRR5</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>UBRR4</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>UBRR3</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UBRR2</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>UBRR1</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>UBRR0</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </UBRR0L>
    </USART0>
    <USART1>
      <LIST>[UDR1:UCSR1A:UCSR1B:UCSR1C:UBRR1H:UBRR1L]</LIST>
      <LINK>[UBRR1H:UBRR1L]</LINK>
      <ICON>io_com.bmp</ICON>
      <ID/>
      <TEXT>The Universal Synchronous and Asynchronous serial Receiver and Transmitter (USART) is a highly flexible serial communication device. The main features are: &#x2022; Full Duplex Operation (Independent Serial Receive and Transmit Registers) &#x2022; Asynchronous or Synchronous Operation &#x2022; Master or Slave Clocked Synchronous Operation &#x2022; High Resolution Baud Rate Generator &#x2022; Supports Serial Frames with 5, 6, 7, 8 or 9 Data Bits and 1 or 2 Stop Bits &#x2022; Odd or Even Parity Generation and Parity Check Supported by Hardware &#x2022; Data OverRun Detection &#x2022; Framing Error Detection &#x2022; Noise Filtering Includes False Start Bit Detection and Digital Low Pass Filter &#x2022; Three Separate Interrupts on TX Complete, TX Data Register Empty and RX Complete &#x2022; Multi-processor Communication Mode &#x2022; Double Speed Asynchronous Communicat</TEXT>
      <UDR1>
        <NAME>UDR1</NAME>
        <DESCRIPTION>USART I/O Data Register</DESCRIPTION>
        <TEXT>The UDR1 register is actually two physically separate registers sharing the same I/O address. When writing to the register, the USART Transmit Data register is written. When reading from UDR1, the USART Receive Data register is read.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x9C</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <READ_INTRUSIVE/>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>UDR17</NAME>
          <DESCRIPTION>USART I/O Data Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>UDR16</NAME>
          <DESCRIPTION>USART I/O Data Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UDR15</NAME>
          <DESCRIPTION>USART I/O Data Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>UDR14</NAME>
          <DESCRIPTION>USART I/O Data Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>UDR13</NAME>
          <DESCRIPTION>USART I/O Data Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UDR12</NAME>
          <DESCRIPTION>USART I/O Data Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>UDR11</NAME>
          <DESCRIPTION>USART I/O Data Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>UDR10</NAME>
          <DESCRIPTION>USART I/O Data Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </UDR1>
      <UCSR1A>
        <NAME>UCSR1A</NAME>
        <DESCRIPTION>USART Control and Status Register A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x9B</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>RXC1</NAME>
          <DESCRIPTION>USART Receive Complete</DESCRIPTION>
          <TEXT>This bit is set (one) when a received character is transferred from the Receiver Shift register to UDR1. The bit is set regard-less of any detected framing errors. When the RXCIE bit in UCR is set, the USART Receive Complete interrupt will be executed when RXC is set(one). RXC is cleared by reading UDR1. When interrupt-driven data reception is used, the USART Receive Complete Interrupt routine must read UDR1 in order to clear RXC, otherwise a new interrupt will occur once the interrupt routine terminates.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TXC1</NAME>
          <DESCRIPTION>USART Transmitt Complete</DESCRIPTION>
          <TEXT>This bit is set (one) when the entire character (including the stop bit) in the Transmit Shift register has been shifted out and no new data has been written to UDR1. This flag is especially useful in half-duplex communications interfaces, where a transmitting application must enter receive mode and free the communications bus immediately after completing the transmission. When the TXCIE bit in UCR is set, setting of TXC causes the USART Transmit Complete interrupt to be executed. TXC is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, the TXC bit is cleared (zero) by writing a logical one to the bi</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UDRE1</NAME>
          <DESCRIPTION>USART Data Register Empty</DESCRIPTION>
          <TEXT>This bit is set (one) when a character written to UDR1 is transferred to the Transmit shift register. Setting of this bit indicates that the transmitter is ready to receive a new character for transmission. When the UDR1IE bit in UCR is set, the USART Transmit Complete interrupt to be executed as long as UDR1E is set. UDR1E is cleared by writing UDR1. When interrupt-driven data transmittal is used, the USART Data Register Empty Interrupt routine must write UDR1 in order to clear UDR1E, otherwise a new interrupt will occur once the interrupt routine terminates. UDR1E is set (one) during reset to indicate that the transmitter is read</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>FE1</NAME>
          <DESCRIPTION>Framing Error</DESCRIPTION>
          <TEXT>This bit is set if a Framing Error condition is detected, i.e. when the stop bit of an incoming character is zero. The FE bit is cleared when the stop bit of received data is one.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>DOR1</NAME>
          <DESCRIPTION>Data overRun</DESCRIPTION>
          <TEXT>This bit is set if an Overrun condition is detected, i.e. when a character already present in the UDR1 register is not read before the next character has been shifted into the Receiver Shift register. The OR bit is buffered, which means that it will be set once the valid data still in UDR1E is read. The OR bit is cleared (zero) when data is received and transferred to UDR1. </TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UPE1</NAME>
          <DESCRIPTION>Parity Error</DESCRIPTION>
          <TEXT>This bit is set if the next character in the receive buffer had a Parity Error when received and the parity checking was enabled at that point (UPM1 = 1). This bit is valid until the receive buffer (UDR1) is read. Always set this bit to zero when writing to UCSR1A.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>U2X1</NAME>
          <DESCRIPTION>Double the USART transmission speed</DESCRIPTION>
          <TEXT>This bit only has effect for the asynchronous operation. Write this bit to zero when using synchronous operation. Writing this bit to one will reduce the divisor of the baud rate divider from 16 to 8 effectively doubling the transfer rate for asynchronous communication.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>MPCM1</NAME>
          <DESCRIPTION>Multi-processor Communication Mode</DESCRIPTION>
          <TEXT>This bit enables the Multi-processor Communication Mode. When the MPCM bit is written to one, all the incoming frames received by the USART receiver that do not contain address information will be ignored. The transmitter is unaffected by the MPCM setting. For more detailed information see &#x201C;Multi-processor Communication Mode&#x201D; on page 152.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </UCSR1A>
      <UCSR1B>
        <NAME>UCSR1B</NAME>
        <DESCRIPTION>USART Control and Status Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x9A</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>RXCIE1</NAME>
          <DESCRIPTION>RX Complete Interrupt Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables interrupt on the RXC flag. A USART Receive Complete interrupt will be generated only if the RXCIE bit is written to one, the global interrupt flag in SREG is written to one and the RXC bit in UCSR1A is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TXCIE1</NAME>
          <DESCRIPTION>TX Complete Interrupt Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables interrupt on the TXC flag. A USART Transmit Complete interrupt will be generated only if the TXCIE bit is written to one, the global interrupt flag in SREG is written to one and the TXC bit in UCSR1A is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UDRIE1</NAME>
          <DESCRIPTION>USART Data register Empty Interrupt Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables interrupt on the UDR1E flag. A Data Register Empty interrupt will be generated only if the UDR1IE bit is written to one, the global interrupt flag in SREG is written to one and the UDR1E bit in UCSR1A is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>RXEN1</NAME>
          <DESCRIPTION>Receiver Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables the USART receiver. The receiver will override normal port operation for the RxD pin when enabled. Disabling the receiver will flush the receive buffer invalidating the FE, DOR and PE flags.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TXEN1</NAME>
          <DESCRIPTION>Transmitter Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables the USART transmitter. The transmitter will override normal port operation for the TxD pin when enabled. The disabling of the transmitter (writing TXEN to zero) will not become effective until ongoing and pending transmissions are completed, i.e. when the transmit shift register and transmit buffer register does not contain data to be transmitted. When disabled, the transmitter will no longer override the TxD port.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UCSZ12</NAME>
          <DESCRIPTION>Character Size</DESCRIPTION>
          <TEXT>The UCSZ2 bits combined with the UCSZ1:0 bit in UCSR1C sets the number of data bits (character size) in a frame the receiver and transmitter use.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>RXB81</NAME>
          <DESCRIPTION>Receive Data Bit 8</DESCRIPTION>
          <TEXT>RXB8 is the 9th data bit of the received character when operating with serial frames with 9 data bits. Must be read before reading the low bits from UDR1.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TXB81</NAME>
          <DESCRIPTION>Transmit Data Bit 8</DESCRIPTION>
          <TEXT>TXB8 is the 9th data bit in the character to be transmitted when operating with serial frames with 9 data bits. Must be writ-ten before writing the low bits to UDR1.</TEXT>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </UCSR1B>
      <UCSR1C>
        <NAME>UCSR1C</NAME>
        <DESCRIPTION>USART Control and Status Register C</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x9D</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT6>
          <NAME>UMSEL1</NAME>
          <DESCRIPTION>USART Mode Select</DESCRIPTION>
          <TEXT>0: Asynchronous Operation.  1: Synchronous Operation</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>COMM_USART_MODE</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UPM11</NAME>
          <DESCRIPTION>Parity Mode Bit 1</DESCRIPTION>
          <TEXT>This bit enable and set type of parity generation and check. If enabled, the transmitter will automatically generate and send the parity of the transmitted data bits within each frame. The receiver will generate a parity value for the incoming data and compare it to the UPM0 setting. If a mismatch is detected, the PE flag in UCSR1A will be set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>UPM10</NAME>
          <DESCRIPTION>Parity Mode Bit 0</DESCRIPTION>
          <TEXT>This bit enable and set type of parity generation and check. If enabled, the transmitter will automatically generate and send the parity of the transmitted data bits within each frame. The receiver will generate a parity value for the incoming data and compare it to the UPM0 setting. If a mismatch is detected, the PE flag in UCSR1A will be set.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>COMM_UPM_PARITY_MODE</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>USBS1</NAME>
          <DESCRIPTION>Stop Bit Select</DESCRIPTION>
          <TEXT>0: 1-bit.  1: 2-bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>COMM_STOP_BIT_SEL</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UCSZ11</NAME>
          <DESCRIPTION>Character Size</DESCRIPTION>
          <TEXT>Character Size: 0 0 0 = 5-bit. 0 0 1 = 6-bit. 0 1 0 = 7 bit. 0 1 1 = 8-bit. 1 1 1 = 9 bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>UCSZ10</NAME>
          <DESCRIPTION>Character Size</DESCRIPTION>
          <TEXT>Character Size: 0 0 0 = 5-bit. 0 0 1 = 6-bit. 0 1 0 = 7 bit. 0 1 1 = 8-bit. 1 1 1 = 9 bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>UCPOL1</NAME>
          <DESCRIPTION>Clock Polarity</DESCRIPTION>
          <TEXT>This bit is used for synchronous mode only. Write this bit to zero when asynchronous mode is used. The UCPOL bit sets the relationship between data output change and data input sample, and the synchronous clock (XCK).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </UCSR1C>
      <UBRR1H>
        <NAME>UBRR1H</NAME>
        <DESCRIPTION>USART Baud Rate Register Hight Byte</DESCRIPTION>
        <TEXT>This is a 12-bit register which contains the USART baud rate. The UBRR1H contains the 4 most significant bits, and the UBRR1L contains the 8 least significant bits of the USART baud rate. Ongoing transmissions by the transmitter and receiver will be corrupted if the baud rate is changed. Writing UBRR1L will trigger an immediate update of the baud rate prescaler.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x98</MEM_ADDR>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT3>
          <NAME>UBRR11</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 11</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UBRR10</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 10</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>UBRR9</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 9</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>UBRR8</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 8</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </UBRR1H>
      <UBRR1L>
        <NAME>UBRR1L</NAME>
        <DESCRIPTION>USART Baud Rate Register Low Byte</DESCRIPTION>
        <TEXT>This is a 12-bit register which contains the USART baud rate. The UBRR1H contains the 4 most significant bits, and the UBRR1L contains the 8 least significant bits of the USART baud rate. Ongoing transmissions by the transmitter and receiver will be corrupted if the baud rate is changed. Writing UBRR1L will trigger an immediate update of the baud rate prescaler.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x99</MEM_ADDR>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>UBRR7</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>UBRR6</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UBRR5</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>UBRR4</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>UBRR3</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UBRR2</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>UBRR1</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>UBRR0</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </UBRR1L>
    </USART1>
    <CPU>
      <LIST>[SREG:SPH:SPL:MCUCR:XMCRA:XMCRB:OSCCAL:XDIV:MCUCSR:RAMPZ]</LIST>
      <LINK>[SPH:SPL]</LINK>
      <ICON>io_cpu.bmp</ICON>
      <ID/>
      <TEXT/>
      <SREG>
        <NAME>SREG</NAME>
        <DESCRIPTION>Status Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x3F</IO_ADDR>
        <MEM_ADDR>0x5F</MEM_ADDR>
        <ICON>io_sreg.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>I</NAME>
          <DESCRIPTION>Global Interrupt Enable</DESCRIPTION>
          <TEXT>The global interrupt enable bit must be set (one) for the interrupts to be enabled. The individual interrupt enable control is then performed in separate control registers. If the global interrupt enable bit is cleared (zero), none of the interrupts are enabled independent of the individual interrupt enable settings. The I-bit is cleared by hardware after an interrupt has occurred, and is set by the RETI instruction to enable subsequent interrupts.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>T</NAME>
          <DESCRIPTION>Bit Copy Storage</DESCRIPTION>
          <TEXT>The bit copy instructions BLD (Bit LoaD) and BST (Bit STore) use the T bit as source and destination for the operated bit. A bit from a register in the register file can be copied into T by the BST instruction, and a bit in T can be copied into a bit in a register in the register file by the BLD instruction.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>H</NAME>
          <DESCRIPTION>Half Carry Flag</DESCRIPTION>
          <TEXT>The half carry flag H indicates a half carry in some arithmetic operations. See the Instruction Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>S</NAME>
          <DESCRIPTION>Sign Bit</DESCRIPTION>
          <TEXT>The S-bit is always an exclusive or between the negative flag N and the two&#x2019;s complement overflow flag V. See the Instruc-tion Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>V</NAME>
          <DESCRIPTION>Two's Complement Overflow Flag</DESCRIPTION>
          <TEXT>The two&#x2019;s complement overflow flag V supports two&#x2019;s complement arithmetics. See the Instruction Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>N</NAME>
          <DESCRIPTION>Negative Flag</DESCRIPTION>
          <TEXT>The negative flag N indicates a negative result after the different arithmetic and logic operations. See the Instruction Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>Z</NAME>
          <DESCRIPTION>Zero Flag</DESCRIPTION>
          <TEXT>The zero flag Z indicates a zero result after the different arithmetic and logic operations. See the Instruction Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>C</NAME>
          <DESCRIPTION>Carry Flag</DESCRIPTION>
          <TEXT>The carry flag C indicates a carry in an arithmetic or logic operation. See the Instruction Set Description for detailed information. Note that the status register is not automatically stored when entering an interrupt routine and restored when returning from an interrupt routine. This must be handled by software.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SREG>
      <SPH>
        <NAME>SPH</NAME>
        <DESCRIPTION>Stack Pointer High</DESCRIPTION>
        <TEXT>The general AVR 16-bit Stack Pointer is effectively built up of two 8-bit registers in the I/O space locations $3E ($5E) and $3D ($5D). As the AT90S4414/8515 supports up to 64 kB external SRAM, all 16-bits are used. The Stack Pointer points to the data SRAM stack area where the Subroutine and Interrupt Stacks are located. This Stack space in the data SRAM must be defined by the program before any subroutine calls are executed or interrupts are enabled. The stack pointer must be set to point above $60. The Stack Pointer is decremented by one when data is pushed onto the Stack with the PUSH instruction, and it is decremented by two when an address is pushed onto the Stack with subroutine calls and interrupts. The Stack Pointer is incremented by one when data is popped from the Stack with the POP instruction, and it is incremented by two when an address is popped from the Stack with return from subroutine RET or return from interrupt R</TEXT>
        <IO_ADDR>0x3E</IO_ADDR>
        <MEM_ADDR>0x5E</MEM_ADDR>
        <ICON>io_sph.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>SP15</NAME>
          <DESCRIPTION>Stack pointer bit 15</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SP14</NAME>
          <DESCRIPTION>Stack pointer bit 14</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SP13</NAME>
          <DESCRIPTION>Stack pointer bit 13</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SP12</NAME>
          <DESCRIPTION>Stack pointer bit 12</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SP11</NAME>
          <DESCRIPTION>Stack pointer bit 11</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SP10</NAME>
          <DESCRIPTION>Stack pointer bit 10</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SP9</NAME>
          <DESCRIPTION>Stack pointer bit 9</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SP8</NAME>
          <DESCRIPTION>Stack pointer bit 8</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SPH>
      <SPL>
        <NAME>SPL</NAME>
        <DESCRIPTION>Stack Pointer Low</DESCRIPTION>
        <TEXT>The general AVR 16-bit Stack Pointer is effectively built up of two 8-bit registers in the I/O space locations $3E ($5E) and $3D ($5D). As the AT90S4414/8515 supports up to 64 kB external SRAM, all 16-bits are used. The Stack Pointer points to the data SRAM stack area where the Subroutine and Interrupt Stacks are located. This Stack space in the data SRAM must be defined by the program before any subroutine calls are executed or interrupts are enabled. The stack pointer must be set to point above $60. The Stack Pointer is decremented by one when data is pushed onto the Stack with the PUSH instruction, and it is decremented by two when an address is pushed onto the Stack with subroutine calls and interrupts. The Stack Pointer is incremented by one when data is popped from the Stack with the POP instruction, and it is incremented by two when an address is popped from the Stack with return from subroutine RET or return from interrupt </TEXT>
        <IO_ADDR>0x3D</IO_ADDR>
        <MEM_ADDR>0x5D</MEM_ADDR>
        <ICON>io_sph.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>SP7</NAME>
          <DESCRIPTION>Stack pointer bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SP6</NAME>
          <DESCRIPTION>Stack pointer bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SP5</NAME>
          <DESCRIPTION>Stack pointer bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SP4</NAME>
          <DESCRIPTION>Stack pointer bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SP3</NAME>
          <DESCRIPTION>Stack pointer bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SP2</NAME>
          <DESCRIPTION>Stack pointer bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SP1</NAME>
          <DESCRIPTION>Stack pointer bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SP0</NAME>
          <DESCRIPTION>Stack pointer bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SPL>
      <MCUCR>
        <NAME>MCUCR</NAME>
        <DESCRIPTION>MCU Control Register</DESCRIPTION>
        <TEXT>The MCU Control Register contains control bits for general MCU functions.</TEXT>
        <IO_ADDR>0x35</IO_ADDR>
        <MEM_ADDR>0x55</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SRE</NAME>
          <DESCRIPTION>External SRAM Enable</DESCRIPTION>
          <TEXT>Writing SRE to one enables the External Memory Interface.The pin functions AD7:0, A15:8, ALE, WR, and RD are acti-vated as the alternate pin functions. The SRE bit overrides any pin direction settings in the respective data direction regis-ters. Writing SRE to zero, disables the External Memory Interface and the normal pin and data direction settings are used.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SRW10</NAME>
          <DESCRIPTION>External SRAM Wait State Select</DESCRIPTION>
          <TEXT>For a detailed description in non ATmega103 Compatibility mode, see common description for the SRWn bits below (XMRA description). In ATmega103 Compatibility mode, writing SRW10 to one enables the wait state and one extra cycle is added during read/write strobe as shown in Figure 14.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SE</NAME>
          <DESCRIPTION>Sleep Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SM1</NAME>
          <DESCRIPTION>Sleep Mode Select</DESCRIPTION>
          <TEXT>The description is to long for the tooltip help, please refer to the manual</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SM0</NAME>
          <DESCRIPTION>Sleep Mode Select</DESCRIPTION>
          <TEXT>The description is to long for the tooltip help, please refer to the manual</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SM2</NAME>
          <DESCRIPTION>Sleep Mode Select</DESCRIPTION>
          <TEXT>The description is to long for the tooltip help, please refer to the manual</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>IVSEL</NAME>
          <DESCRIPTION>Interrupt Vector Select</DESCRIPTION>
          <TEXT>When the IVSEL bit is cleared (zero), the interrupt vectors are placed at the start of the Flash memory. When this bit is set (one), the interrupt vectors are moved to the beginning of the Boot Loader section of the flash. The actual address of the start of the boot flash section is determined by the BOOTSZ fuses. Refer to the section &#x201C;Boot Loader Support - Read While Write self-programming&#x201D; on page 228 for details. To avoid unintentional changes of interrupt vector tables, a special write procedure must be followed to change the IVSEL bit: 1. Write the Interrupt Vector Change Enable (IVCE) bit to one. 2. Within four cycles, write the desired value to IVSEL while writing a zero to IVCE. Interrupts will automatically be disabled while this sequence is executed. Interrupts are disabled in the cycle IVCE is set, and they remain disabled until after the instruction following the write to IVSEL. If IVSEL is not written, interrupts remain dis-abled for four cycles. The I-bit in the Status Register is unaffected by  the automatic disabling. Note: Note: If interrupt vectors are placed in the Boot Loader section and Boot Lock bit BLB02 is programmed, interrupts are disabled while executing from the Application section. If interrupt vectors are placed in the Application section and Boot Lock bit BLB01 is pro-gramed, interrupts are disabled while executing from the Boot Loader section. Refer to the section &#x201C;Boot Loader Support - Read While Write self-programming&#x201D; on page 228 for details on Boot Lock bits</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>IVCE</NAME>
          <DESCRIPTION>Interrupt Vector Change Enable</DESCRIPTION>
          <TEXT>The IVCE bit must be written to logic one to enable change of the IVSEL bit. IVCE is cleared by hardware four cycles after it is written or when IVSEL is written. Setting the IVCE bit will disable interrupts, as explained in the IVSEL description above.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </MCUCR>
      <MCUCSR>
        <NAME>MCUCSR</NAME>
        <DESCRIPTION>MCU Control And Status Register</DESCRIPTION>
        <TEXT>The MCU Control And Status Register provides information on which reset source caused a MCU reset.</TEXT>
        <IO_ADDR>0x34</IO_ADDR>
        <MEM_ADDR>0x54</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>JTD</NAME>
          <DESCRIPTION>JTAG Interface Disable</DESCRIPTION>
          <TEXT>When this bit is zero, the JTAG interface is enabled if the JTAGEN fuse is programmed.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT4>
          <NAME>JTRF</NAME>
          <DESCRIPTION>JTAG Reset Flag</DESCRIPTION>
          <TEXT>This bit is set if a reset is being caused by a logic one in the JTAG Reset Register selected by the JTAG instruction AVR_RESET. This bit is reset by a Power-on reset, or by writing a logic zero to the flag. &#x2022; Bit 3 - WDRF: Watchdog Reset Flag</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>WDRF</NAME>
          <DESCRIPTION>Watchdog Reset Flag</DESCRIPTION>
          <TEXT>This bit is set if a watchdog reset occurs. The bit is reset by a power-on reset, or by writing a logic zero to the flag.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>BORF</NAME>
          <DESCRIPTION>Brown-out Reset Flag</DESCRIPTION>
          <TEXT>This bit is set if a brown-out reset occurs. The bit is reset by a power-on reset, or by writing a logic zero to the flag.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>EXTRF</NAME>
          <DESCRIPTION>External Reset Flag</DESCRIPTION>
          <TEXT>This bit is set if an external reset occurs. The bit is reset by a power-on reset, or by writing a logic zero to the flag.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PORF</NAME>
          <DESCRIPTION>Power-on reset flag</DESCRIPTION>
          <TEXT>This bit is set if a power-on reset occurs. The bit is reset only by writing a logic zero to the flag. To make use of the reset flags to identify a reset condition, the user should read and then reset the MCUCSR as early as possible in the program. If the register is cleared before another reset occurs, the source of the reset can be found by examining the reset flags.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </MCUCSR>
      <XMCRA>
        <NAME>XMCRA</NAME>
        <DESCRIPTION>External Memory Control Register A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x6D</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT6>
          <NAME>SRL2</NAME>
          <DESCRIPTION>Wait state page limit</DESCRIPTION>
          <TEXT>It is possible to configure different wait-states for different external memory addresses. The external memory address space can be divided in two pages that have separate wait-state bits. The SRL2, SRL1, and SRL0 bits select the split of the pages, see Table 2 and Figure 11. As default, the SRL2, SRL1, and SRL0 bits are set to zero and the entire external mem-ory address space is treated as one page. When the entire SRAM address space is configured as one page, the wait-states are configured by the SRW11 and SRW10 bits</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SRL1</NAME>
          <DESCRIPTION>Wait state page limit</DESCRIPTION>
          <TEXT>It is possible to configure different wait-states for different external memory addresses. The external memory address space can be divided in two pages that have separate wait-state bits. The SRL2, SRL1, and SRL0 bits select the split of the pages, see Table 2 and Figure 11. As default, the SRL2, SRL1, and SRL0 bits are set to zero and the entire external mem-ory address space is treated as one page. When the entire SRAM address space is configured as one page, the wait-states are configured by the SRW11 and SRW10 bits</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SRL0</NAME>
          <DESCRIPTION>Wait state page limit</DESCRIPTION>
          <TEXT>It is possible to configure different wait-states for different external memory addresses. The external memory address space can be divided in two pages that have separate wait-state bits. The SRL2, SRL1, and SRL0 bits select the split of the pages, see Table 2 and Figure 11. As default, the SRL2, SRL1, and SRL0 bits are set to zero and the entire external mem-ory address space is treated as one page. When the entire SRAM address space is configured as one page, the wait-states are configured by the SRW11 and SRW10 bits</TEXT>
          <ACCESS>R/W</ACCESS>
          <ENUM>CPU_SECTOR_LIMITS</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SRW01</NAME>
          <DESCRIPTION>Wait state select bit lower page</DESCRIPTION>
          <TEXT>Note: n = 0 or 1 (lower/upper page). For further details of the timing and wait-states of the External Memory Interface, see Figure 13 to Figure 16 how the setting of the SRW bits affects the timing. Wait-states SRWn1 SRWn0 Wait-states 0 0 No wait states 0 1 Wait one cycle during read/write strobe 1 0 Wait two cycles during read/write strobe 1 1 Wait two cycles during read/write and wait one cycle before driving out new address </TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SRW00</NAME>
          <DESCRIPTION>Wait state select bit lower page</DESCRIPTION>
          <TEXT>Note: n = 0 or 1 (lower/upper page). For further details of the timing and wait-states of the External Memory Interface, see Figure 13 to Figure 16 how the setting of the SRW bits affects the timing. Wait-states SRWn1 SRWn0 Wait-states 0 0 No wait states 0 1 Wait one cycle during read/write strobe 1 0 Wait two cycles during read/write strobe 1 1 Wait two cycles during read/write and wait one cycle before driving out new address </TEXT>
          <ACCESS>R/W</ACCESS>
          <ENUM>CPU_WAIT_STATES</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SRW11</NAME>
          <DESCRIPTION>Wait state select bit upper page</DESCRIPTION>
          <TEXT>Wait state select bits for upper page. The SRW11 and SRW10 bits control the number of wait-states for the upper page of the external memory address space, see Table 3.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
      </XMCRA>
      <XMCRB>
        <NAME>XMCRB</NAME>
        <DESCRIPTION>External Memory Control Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x6C</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>XMBK</NAME>
          <DESCRIPTION>External Memory Bus Keeper Enable</DESCRIPTION>
          <TEXT>Writing XMBK to one enables the bus keeper on the AD7:0 lines. When the bus keeper is enabled, AD7:0 will keep the last driven value on the lines even if the XMEM interface has tri-stated the lines. Writing XMBK to zero disables the bus keeper. XMBK is not qualified with SRE, so even if the XMEM interface is disabled, the bus keepers are still activiated as long as XMBK is one. </TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT2>
          <NAME>XMM2</NAME>
          <DESCRIPTION>External Memory High Mask</DESCRIPTION>
          <TEXT>When the External Memory is enabled, all Port C pins are default used for the high address byte. If the full 60KB address space is not required to access the external memory, some, or all, Port C pins can be released for normal Port Pin function as described in Table 4. As described in &#x201C;Using all 64KB locations of external memory&#x201D; on page 27, it is possible to use the XMMn bits to access all 64KB locations of the external memory. </TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>XMM1</NAME>
          <DESCRIPTION>External Memory High Mask</DESCRIPTION>
          <TEXT>When the External Memory is enabled, all Port C pins are default used for the high address byte. If the full 60KB address space is not required to access the external memory, some, or all, Port C pins can be released for normal Port Pin function as described in Table 4. As described in &#x201C;Using all 64KB locations of external memory&#x201D; on page 27, it is possible to use the XMMn bits to access all 64KB locations of the external memory. </TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>XMM0</NAME>
          <DESCRIPTION>External Memory High Mask</DESCRIPTION>
          <TEXT>When the External Memory is enabled, all Port C pins are default used for the high address byte. If the full 60KB address space is not required to access the external memory, some, or all, Port C pins can be released for normal Port Pin function as described in Table 4. As described in &#x201C;Using all 64KB locations of external memory&#x201D; on page 27, it is possible to use the XMMn bits to access all 64KB locations of the external memory. </TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </XMCRB>
      <OSCCAL>
        <NAME>OSCCAL</NAME>
        <DESCRIPTION>Oscillator Calibration Value</DESCRIPTION>
        <TEXT>Writing the calibration byte to this address will trim the internal oscillator to remove process variations from the oscillator frequency. This is done automatically during chip reset. When OSCCAL is zero, the lowest available frequency is chosen. Writing non-zero values to this register will increase the frequency of the internal oscillator. Writing $FF to the register gives the highest available frequency. The calibrated oscillator is used to time EEPROM and Flash access. If EEPROM or Flash is written, do not calibrate to more than 10% above the nominal frequency. Otherwise, the EEPROM or Flash write may fail. Note that the Oscillator is intended for calibration to 1.0 MHz, 2.0 MHz, 4.0 MHz, or 8.0MHz. Tuning to other values is not guaranteed, as indicated in Table 14</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x6F</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>CAL7</NAME>
          <DESCRIPTION>Oscillator Calibration Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>CAL6</NAME>
          <DESCRIPTION>Oscillator Calibration Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>CAL5</NAME>
          <DESCRIPTION>Oscillator Calibration Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>CAL4</NAME>
          <DESCRIPTION>Oscillator Calibration Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>CAL3</NAME>
          <DESCRIPTION>Oscillator Calibration Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CAL2</NAME>
          <DESCRIPTION>Oscillator Calibration Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CAL1</NAME>
          <DESCRIPTION>Oscillator Calibration Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CAL0</NAME>
          <DESCRIPTION>Oscillator Calibration Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OSCCAL>
      <XDIV>
        <NAME>XDIV</NAME>
        <DESCRIPTION>XTAL Divide Control Register</DESCRIPTION>
        <TEXT>The XTAL Divide Control Register is used to divide the Source clock frequency by a number in the range 1 - 129. This fea-ture can be used to decrease power consumption when the requirement for processing power is low.</TEXT>
        <IO_ADDR>0x3C</IO_ADDR>
        <MEM_ADDR>0x5C</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>XDIVEN</NAME>
          <DESCRIPTION>XTAL Divide Enable</DESCRIPTION>
          <TEXT>When the XDIVEN bit is written one, the clock frequency of the CPU and all peripherals (clk I/O , clk ADC , clk CPU , clk FLASH ) is divided by the factor defined by the setting of XDIV6 - XDIV0. This bit can be written run-time to vary the clock frequency as suitable to the application.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>XDIV6</NAME>
          <DESCRIPTION>XTAl Divide Select Bit 6</DESCRIPTION>
          <TEXT>These bits define the division factor that applies when the XDIVEN bit is set (one). Please refer to the manual for details on the formulas.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>XDIV5</NAME>
          <DESCRIPTION>XTAl Divide Select Bit 5</DESCRIPTION>
          <TEXT>These bits define the division factor that applies when the XDIVEN bit is set (one). Please refer to the manual for details on the formulas.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>XDIV4</NAME>
          <DESCRIPTION>XTAl Divide Select Bit 4</DESCRIPTION>
          <TEXT>These bits define the division factor that applies when the XDIVEN bit is set (one). Please refer to the manual for details on the formulas.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>XDIV3</NAME>
          <DESCRIPTION>XTAl Divide Select Bit 3</DESCRIPTION>
          <TEXT>These bits define the division factor that applies when the XDIVEN bit is set (one). Please refer to the manual for details on the formulas.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>XDIV2</NAME>
          <DESCRIPTION>XTAl Divide Select Bit 2</DESCRIPTION>
          <TEXT>These bits define the division factor that applies when the XDIVEN bit is set (one). Please refer to the manual for details on the formulas.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>XDIV1</NAME>
          <DESCRIPTION>XTAl Divide Select Bit 1</DESCRIPTION>
          <TEXT>These bits define the division factor that applies when the XDIVEN bit is set (one). Please refer to the manual for details on the formulas.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>XDIV0</NAME>
          <DESCRIPTION>XTAl Divide Select Bit 0</DESCRIPTION>
          <TEXT>These bits define the division factor that applies when the XDIVEN bit is set (one). Please refer to the manual for details on the formulas.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </XDIV>
      <RAMPZ>
        <NAME>RAMPZ</NAME>
        <DESCRIPTION>RAM Page Z Select Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x3B</IO_ADDR>
        <MEM_ADDR>0x5B</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT0>
          <NAME>RAMPZ0</NAME>
          <DESCRIPTION>RAM Page Z Select Register Bit 0</DESCRIPTION>
          <TEXT>The RAMPZ register is normally used to select which 64K RAM Page is accessed by the Z pointer. As the ATmega104 does not support more than 64K of SRAM memory, this register is used only to select which page in the program memory is accessed when the ELPM/SPM instruction is used. The different settings of the RAMPZ0 bit have the following effects: Note that LPM is not affected by the RAMPZ setting. RAMPZ0 = 0: Program memory address $0000- $7FFF (lower 64K bytes) is accessed by ELPM/SPM RAMPZ0 = 1: Program memory address $8000- $FFFF (higher 64K bytes) is accessed by ELPM/</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </RAMPZ>
    </CPU>
    <BOOT_LOAD>
      <LIST>[SPMCSR]</LIST>
      <LINK/>
      <RULES/>
      <ICON>io_cpu.bmp</ICON>
      <ID>AVRSimIOSPM.SimIOSPM</ID>
      <TEXT>The Boot Loader Support provides a real Read While Write self-programming mechanism for downloading and uploading program code by the MCU itself. This feature allows flexible application software updates controlled by the MCU using a Flash-resident Boot Loader program. The Boot Loader program can use any available data interface and associated proto-col to read code and write (program) that code into the Flash memory, or read the code from the program memory. The program code within the Boot Loader section has the capability to write into the entire Flash, including the Boot Loader Memory. The Boot Loader can thus even modify itself, and it can also erase itself from the code if the feature is not needed anymore. The size of the Boot Loader Memory is configurable with fuses and the Boot Loader has two separate sets of Boot Lock Bits which can be set independently. This gives the user a unique flexibility to select different levels of protection. Boot Loader Features: Read While Write self-programming. Flexibl Boot Memory size. High security (separate Boot Lock bits for a flexible protection).  Separate fuse to select reset vector Optimized page (1) size. Code efficient algorithm Efficient read-modify-write suppor</TEXT>
      <SPMCSR>
        <NAME>SPMCSR</NAME>
        <ALIAS>SPMCR</ALIAS>
        <DESCRIPTION>Store Program Memory Control Register</DESCRIPTION>
        <TEXT>The Store Program Memory Control Register contains the control bits needed to control the Boot Loader operations.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x68</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SPMIE</NAME>
          <DESCRIPTION>SPM Interrupt Enable</DESCRIPTION>
          <TEXT>When the SPMIE bit is written to one, and the I-bit in the Status Register is set (one), the SPM ready interrupt will be enabled. The SPM ready Interrupt will be executed as long as the SPMEN bit in the SPMCR register is cleared.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>RWWSB</NAME>
          <ALIAS>ASB</ALIAS>
          <DESCRIPTION>Read While Write Section Busy</DESCRIPTION>
          <TEXT>When a self-programming (page erase or page write) operation to the RWW section is initiated, the RWWSB will be set (one) by hardware. When the RWWSB bit is set, the RWW section cannot be accessed. The RWWSB bit will be cleared if the RWWSRE bit is written to one after a self-programming operation is completed. Alternatively the RWWSB bit will auto-matically be cleared if a page load operation is initiated.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT4>
          <NAME>RWWSRE</NAME>
          <ALIAS>ASRE</ALIAS>
          <DESCRIPTION>Read While Write section read enable</DESCRIPTION>
          <TEXT>When programming (page erase or page write) to the RWW section, the RWW section is blocked for reading (the RWWSB will be set by hardware). To re-enable the RWW section, the user software must wait until the programming is completed (SPMEN will be cleared). Then, if the RWWSRE bit is written to one at the same time as SPMEN, the next SPM instruction within four clock cycles re-enables the RWW section. The RWW section cannot be re-enabled while Flash is busy with a page erase or a page write (SPMEN is set). If the RWWSRE bit is written while the Flash is being loaded, the Flash load operation will abort and the data loaded will be lo</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>BLBSET</NAME>
          <DESCRIPTION>Boot Lock Bit Set</DESCRIPTION>
          <TEXT>If this bit is written to one at the same time as SPMEN, the next SPM instruction within four clock cycles sets Boot Lock bits, according to the data in R0. The data in R1 and the address in the Z pointer are ignored. The BLBSET bit will automatically be cleared upon completion of the lock bit set, or if no SPM instruction is executed within four clock cycles. An LPM instruction within three cycles after BLBSET and SPMEN are set in the SPMCR register, will read either the Lock-bits or the Fuse bits (depending on Z0 in the Z pointer) into the destination register. See &#x201C;Reading the Fuse and Lock Bits from Software&#x201D; on page 235 for details</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PGWRT</NAME>
          <DESCRIPTION>Page Write</DESCRIPTION>
          <TEXT>If this bit is written to one at the same time as SPMEN, the next SPM instruction within four clock cycles executes page write, with the data stored in the temporary buffer. The page address is taken from the high part of the Z pointer. The data in R1 and R0 are ignored. The PGWRT bit will auto-clear upon completion of a page write, or if no SPM instruction is exe-cuted within four clock cycles. The CPU is halted during the entire page write operation if the NRWW section is addressed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PGERS</NAME>
          <DESCRIPTION>Page Erase</DESCRIPTION>
          <TEXT>If this bit is written to one at the same time as SPMEN, the next SPM instruction within four clock cycles executes page erase. The page address is taken from the high part of the Z pointer. The data in R1 and R0 are ignored. The PGERS bit will auto-clear upon completion of a page erase, or if no SPM instruction is executed within four clock cycles. The CPU is halted during the entire page write operation if the NRWW section is addressed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SPMEN</NAME>
          <DESCRIPTION>Store Program Memory Enable</DESCRIPTION>
          <TEXT>This bit enables the SPM instruction for the next four clock cycles. If written to one together with either RWWSRE, BLB-SET, PGWRT or PGERS, the following SPM instruction will have a special meaning, see description above. If only SPMEN is written, the following SPM instruction will store the value in R1:R0 in the temporary page buffer addressed by the Z pointer. The LSB of the Z pointer is ignored. The SPMEN bit will auto-clear upon completion of an SPM instruction, or if no SPM instruction is executed within four clock cycles. During page erase and page write, the SPMEN bit remain high until the operation is completed. Writing any other combination than &#x201C;10001&#x201D;, "01001", "00101", "00011" or "00001" in the lower five bits will have no effec</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SPMCSR>
    </BOOT_LOAD>
    <JTAG>
      <LIST>[OCDR:MCUCSR]</LIST>
      <LINK/>
      <RULES/>
      <ICON>io_com.bmp</ICON>
      <ID>00</ID>
      <TEXT>JTAG Features: JTAG (IEEE std. 1149.1 compliant) Interface. Boundary-Scan Capabilities According to the IEEE std. 1149.1 (JTAG) Standard. Debugger Access to: &#x2013; All Internal Peripheral Units &#x2013; Internal and External RAM &#x2013; The Internal Register File &#x2013;Program Counter &#x2013; EEPROM and Flash Memories. Extensive On-Chip Debug Support for Break Conditions, Including: &#x2013;AVR Break Instruction &#x2013; Break on Change of Program Memory Flow &#x2013;Single Step Break &#x2013;Program Memory Breakpoints on Single Address or Address Range &#x2013; Data Memory Breakpoints on Single Address or Address Range. Programming of Flash, EEPROM, Fuses, and Lock Bits through the JTAG Interface. On-Chip Debugging Supported by AVR S</TEXT>
      <OCDR>
        <NAME>OCDR</NAME>
        <DESCRIPTION>On-Chip Debug Related Register in I/O Memory</DESCRIPTION>
        <TEXT>The OCDR register provides a communication channel from the running program in the microcontroller to the debugger. The CPU can transfer a byte to the debugger by writing to this location. At the same time, an internal flag; I/O Debug Reg-ister Dirty - IDRD - is set to indicate to the debugger that the register has been written. When the CPU reads the OCDR reg-ister the 7 LSB will be from the OCDR register, while the MSB is the IDRD bit. The debugger clears the IDRD bit when it has read the information. In some AVR devices, this register is shared with a standard I/O location. In this case, the OCDR register can only be accessed if the OCDEN fuse is programmed, and the debugger enables access to the OCDR register. In all other cases, the standard I/O location is accessed. Refer to the debugger documentation for further information on how to use this registe</TEXT>
        <IO_ADDR>0x22</IO_ADDR>
        <MEM_ADDR>0x42</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <READ_INTRUSIVE/>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>OCDR7</NAME>
          <ALIAS>IDRD</ALIAS>
          <DESCRIPTION>On-Chip Debug Register Bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCDR6</NAME>
          <DESCRIPTION>On-Chip Debug Register Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCDR5</NAME>
          <DESCRIPTION>On-Chip Debug Register Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCDR4</NAME>
          <DESCRIPTION>On-Chip Debug Register Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCDR3</NAME>
          <DESCRIPTION>On-Chip Debug Register Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCDR2</NAME>
          <DESCRIPTION>On-Chip Debug Register Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCDR1</NAME>
          <DESCRIPTION>On-Chip Debug Register Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCDR0</NAME>
          <DESCRIPTION>On-Chip Debug Register Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCDR>
      <MCUCSR>
        <NAME>MCUCSR</NAME>
        <DESCRIPTION>MCU Control And Status Register</DESCRIPTION>
        <TEXT>The MCU Control and Status Register contains control bits for general MCU functions, and provides information on which reset source caused an MCU reset.</TEXT>
        <IO_ADDR>0x34</IO_ADDR>
        <MEM_ADDR>0x54</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>JTD</NAME>
          <DESCRIPTION>JTAG Interface Disable</DESCRIPTION>
          <TEXT>When this bit is written to zero, the JTAG interface is enabled if the JTAGEN fuse is programmed. If this bit is written to one, the JTAG interface is disabled. In order to avoid unintentional disabling or enabling of the JTAG interface, a timed sequence must be followed: The application software must write this to the desired value twice within four cycles to change the bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT4>
          <NAME>JTRF</NAME>
          <DESCRIPTION>JTAG Reset Flag</DESCRIPTION>
          <TEXT>This bit is set if a reset is being caused by a logic one in the JTAG Reset Register selected by the JTAG instruction AVR_RESET. This bit is reset by a Power-on reset, or by writing a logic zero to the flag.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
      </MCUCSR>
    </JTAG>
    <MISC>
      <LIST>[SFIOR]</LIST>
      <LINK/>
      <ICON>io_cpu.bmp</ICON>
      <ID/>
      <TEXT/>
      <SFIOR>
        <NAME>SFIOR</NAME>
        <DESCRIPTION>Special Function IO Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x20</IO_ADDR>
        <MEM_ADDR>0x40</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>TSM</NAME>
          <DESCRIPTION>Timer/Counter Synchronization Mode</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT3>
          <NAME>ACME</NAME>
          <DESCRIPTION>Analog Comparator Multiplexer Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PUD</NAME>
          <DESCRIPTION>Pull Up Disable</DESCRIPTION>
          <TEXT>When this bit is written to one, the pull-ups in the I/O ports are disabled even if the DDxn and PORTxn registers are config-ured to enable the pull-ups ({DDxn, PORTxn} = 0b01). See &#x201C;Configuring the Pin&#x201D; on page 52 for more details about this fea-ture.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PSR0</NAME>
          <DESCRIPTION>Prescaler Reset Timer/Counter0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PSR321</NAME>
          <ALIAS>PSR1</ALIAS>
          <ALIAS>PSR2</ALIAS>
          <ALIAS>PSR3</ALIAS>
          <DESCRIPTION>Prescaler Reset Timer/Counter3, Timer/Counter2, and Timer/Counter1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SFIOR>
    </MISC>
    <EXTERNAL_INTERRUPT>
      <LIST>[EICRA:EICRB:EIMSK:EIFR]</LIST>
      <LINK/>
      <ICON>io_ext.bmp</ICON>
      <ID/>
      <TEXT>The external interrupts are triggered by the INT7:0 pins. Observe that, if enabled, the interrupts will trigger even if the INT7:0 pins are configured as outputs. This feature provides a way of generating a software interrupt. The external inter-rupts can be triggered by a falling or rising edge or a low level. This is set up as indicated in the specification for the Exter-nal Interrupt Control Registers - EICRA (INT3:0) and EICRB (INT7:4). When the external interrupt is enabled and is configured as level triggered, the interrupt will trigger as long as the pin is held low. Note that recognition of falling or rising edge interrupts on INT7:4 requires the presence of an I/O clock, described in &#x201C;Clock Systems and their Distribution&#x201D; on page 29. Low level interrupts and the edge interrupt on INT3:0 are detected asynchronously. This implies that these inter-rupts can be used for waking the part also from sleep modes other than Idle mode. The I/O clock is halted in all sleep modes except Idle mode. Note that if a level triggered interrupt is used for wake-up from Power Down Mode, the changed level must be held for some time to wake up the MCU. This makes the MCU less sensitive to noise. The changed level is sampled twice by the watchdog oscillator clock. The period of the watchdog oscillator is 1 &#xB5;s (nominal) at 5.0V and 25&#xB0;C. The frequency of the watchdog oscillator is voltage dependent as shown in the Electrical Characteristics section. The MCU will wake up if the input has the required level during this sampling or if it is held until the end of the start-up time. The start-up time is defined by the SUT fuses as described in &#x201C;Clock Systems and their Distribution&#x201D; on page 29. If the level is sampled twice by the watchdog oscillator clock but disappears before the end of the start-up time, the MCU will still wake up, but no interrupt will be generated. The required level must be held long enough for the MCU to complete the wake up to trigger the level interrupt</TEXT>
      <EICRA>
        <NAME>EICRA</NAME>
        <DESCRIPTION>External Interrupt Control Register A</DESCRIPTION>
        <TEXT>This Register can not be reached in ATmega103 compatibility mode, but the initial value defines INT3:0 as low level inter-rupts,as in ATmega103. &#x2022; Bits 7..0 - ISC31, ISC30 - ISC00, ISC00: External Interrupt 3-0 Sense Control bits The External Interrupts 3 - 0 are activated by the external pins INT3:0 if the SREG I-flag and the corresponding interrupt mask in the EIMSK is set. The level and edges on the external pins that activate the interrupts are defined in Table 47. Edges on INT3..INT0 are registered asynchronously. Pulses on INT3:0 pins wider than the minimum pulse width given in Table 48 will generate an interrupt. Shorter pulses are not guaranteed to generate an interrupt. If low level interrupt is selected, the low level must be held until the completion of the currently executing instruction to generate an interrupt. If enabled, a level triggered interrupt will generate an interrupt request as long as the pin is held low. When changing the ISCn bit, an interrupt can occur. Therefore, it is recommended to first disable INTn by clearing its Interrupt Enable bit in the EIMSK register. Then, the ISCn bit can be changed. Finally, the INTn interrupt flag should be cleared by writing a logical one to its Interrupt Flag bit (INTFn) in the EIFR register before the interrupt is re-enable</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x6A</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>ISC31</NAME>
          <DESCRIPTION>External Interrupt Sense Control Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ISC30</NAME>
          <DESCRIPTION>External Interrupt Sense Control Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <ENUM>INTERRUPT_SENSE_CONTROL</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ISC21</NAME>
          <DESCRIPTION>External Interrupt Sense Control Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ISC20</NAME>
          <DESCRIPTION>External Interrupt Sense Control Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <ENUM>INTERRUPT_SENSE_CONTROL</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ISC11</NAME>
          <DESCRIPTION>External Interrupt Sense Control Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ISC10</NAME>
          <DESCRIPTION>External Interrupt Sense Control Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <ENUM>INTERRUPT_SENSE_CONTROL</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ISC01</NAME>
          <DESCRIPTION>External Interrupt Sense Control Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ISC00</NAME>
          <DESCRIPTION>External Interrupt Sense Control Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <ENUM>INTERRUPT_SENSE_CONTROL</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </EICRA>
      <EICRB>
        <NAME>EICRB</NAME>
        <DESCRIPTION>External Interrupt Control Register B</DESCRIPTION>
        <TEXT>The External Interrupts 7 - 4 are activated by the external pins INT7:4 if the SREG I-flag and the corresponding interrupt mask in the EIMSK is set. The level and edges on the external pins that activate the interrupts are defined in Table 49. The value on the INT7:4 pins are sampled before detecting edges. If edge or toggle interrupt is selected, pulses that last longer than one clock period will generate an interrupt. Shorter pulses are not guaranteed to generate an interrupt. Observe that CPU clock frequency can be lower than the XTAL frequency if the XTAL divider is enabled. If low level interrupt is selected, the low level must be held until the completion of the currently executing instruction to generate an interrupt. If enabled, a level triggered interrupt will generate an interrupt request as long as the pin is held low</TEXT>
        <IO_ADDR>0x3A</IO_ADDR>
        <MEM_ADDR>0x5A</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>ISC71</NAME>
          <DESCRIPTION>External Interrupt 7-4 Sense Control Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <ENUM>INTERRUPT_SENSE_CONTROL</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ISC70</NAME>
          <DESCRIPTION>External Interrupt 7-4 Sense Control Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ISC61</NAME>
          <DESCRIPTION>External Interrupt 7-4 Sense Control Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ISC60</NAME>
          <DESCRIPTION>External Interrupt 7-4 Sense Control Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <ENUM>INTERRUPT_SENSE_CONTROL</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ISC51</NAME>
          <DESCRIPTION>External Interrupt 7-4 Sense Control Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ISC50</NAME>
          <DESCRIPTION>External Interrupt 7-4 Sense Control Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <ENUM>INTERRUPT_SENSE_CONTROL</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ISC41</NAME>
          <DESCRIPTION>External Interrupt 7-4 Sense Control Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ISC40</NAME>
          <DESCRIPTION>External Interrupt 7-4 Sense Control Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <ENUM>INTERRUPT_SENSE_CONTROL</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </EICRB>
      <EIMSK>
        <NAME>EIMSK</NAME>
        <ALIAS>GICR</ALIAS>
        <ALIAS>GIMSK</ALIAS>
        <DESCRIPTION>External Interrupt Mask Register</DESCRIPTION>
        <TEXT>When an INT7- INT4 bit is written to one and the I-bit in the Status Register (SREG) is set (one), the corresponding external pin interrupt is enabled. The Interrupt Sense Control bits in the External Interrupt Control Registers - EICRA and EICRB defines whether the external interrupt is activated on rising or falling edge or level sensed. Activity on any of these pins will trigger an interrupt request even if the pin is enabled as an output. This provides a way of generating a software interrupt. </TEXT>
        <IO_ADDR>0x39</IO_ADDR>
        <MEM_ADDR>0x59</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>INT7</NAME>
          <DESCRIPTION>External Interrupt Request 7 Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>INT6</NAME>
          <DESCRIPTION>External Interrupt Request 6 Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>INT5</NAME>
          <DESCRIPTION>External Interrupt Request 5 Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>INT4</NAME>
          <DESCRIPTION>External Interrupt Request 4 Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>INT3</NAME>
          <DESCRIPTION>External Interrupt Request 3 Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>INT2</NAME>
          <DESCRIPTION>External Interrupt Request 2 Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>INT1</NAME>
          <DESCRIPTION>External Interrupt Request 1 Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>INT0</NAME>
          <DESCRIPTION>External Interrupt Request 0 Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </EIMSK>
      <EIFR>
        <NAME>EIFR</NAME>
        <ALIAS>GIFR</ALIAS>
        <DESCRIPTION>External Interrupt Flag Register</DESCRIPTION>
        <TEXT>When an event on the INT7 - INT0 pins triggers an interrupt request, the corresponding interrupt flag, INTF7 - INTF0 becomes set (one). If the I-bit in SREG and the corresponding interrupt enable bit, INT7 - INT0 in EIMSK, are set (one), the MCU will jump to the interrupt vector. The flag is cleared when the interrupt routine is executed. Alternatively, the flag is cleared by writing a logical one to it. Note that when entering some sleep modes with the INT3:0 interrupts disabled, the input buffers on these pin will be disabled. This may cause a logic change in internal signals which will set the INTF3:0 flags. See &#x201C;Digital Input Enable and Sleep Modes&#x201D; on page 54 for more informa</TEXT>
        <IO_ADDR>0x38</IO_ADDR>
        <MEM_ADDR>0x58</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>INTF7</NAME>
          <DESCRIPTION>External Interrupt Flag 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>INTF6</NAME>
          <DESCRIPTION>External Interrupt Flag 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>INTF5</NAME>
          <DESCRIPTION>External Interrupt Flag 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>INTF4</NAME>
          <DESCRIPTION>External Interrupt Flag 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>INTF3</NAME>
          <DESCRIPTION>External Interrupt Flag 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>INTF2</NAME>
          <DESCRIPTION>External Interrupt Flag 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>INTF1</NAME>
          <DESCRIPTION>External Interrupt Flag 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>INTF0</NAME>
          <DESCRIPTION>External Interrupt Flag 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </EIFR>
    </EXTERNAL_INTERRUPT>
    <EEPROM>
      <LIST>[EEARH:EEARL:EEDR:EECR]</LIST>
      <LINK>[EEARH:EEARL]</LINK>
      <ICON>io_cpu.bmp</ICON>
      <ID/>
      <TEXT>EEPROM Read/Write Access. The EEPROM access registers are accessible in the I/O space. The write access time for the EEPROM is given in Table 1. A self-timing function, however, lets the user software detect when the next byte can be written. If the user code contains instructions that write the EEPROM, some precautions must be taken. In heavily filtered power supplies, V CC is likely to rise or fall slowly on power-up/down. This causes the device for some period of time to run at a voltage lower than specified as minimum for the clock frequency used. See &#x201C;Preventing EEPROM Corruption&#x201D; on page 19. for details on how to avoid problems in these situations.In order to prevent unintentional EEPROM writes, a specific write procedure must be followed. Refer to the description of the EEPROM Control Register for details on this. When the EEPROM is read, the CPU is halted for four clock cycles before the next instruction is executed. When theEEPROM is written, the CPU is halted for two clock cycles before the next instruction is execute</TEXT>
      <EEARH>
        <NAME>EEARH</NAME>
        <DESCRIPTION>EEPROM Read/Write Access High Byte</DESCRIPTION>
        <TEXT>Bits 11..0 - EEAR11..0: EEPROM Address The EEPROM Address Registers - EEARH and EEARL specify the EEPROM address in the 4K bytes EEPROM space. The EEPROM data bytes are addressed linearly between 0 and 4096. The initial value of EEAR is undefined. A proper value must be written before the EEPROM may be accessed. </TEXT>
        <IO_ADDR>0x1F</IO_ADDR>
        <MEM_ADDR>0x3F</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT3>
          <NAME>EEAR11</NAME>
          <DESCRIPTION>EEPROM Read/Write Access Bit 11</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>EEAR10</NAME>
          <DESCRIPTION>EEPROM Read/Write Access Bit 10</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>EEAR9</NAME>
          <DESCRIPTION>EEPROM Read/Write Access Bit 9</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>EEAR8</NAME>
          <DESCRIPTION>EEPROM Read/Write Access Bit 8</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </EEARH>
      <EEARL>
        <NAME>EEARL</NAME>
        <DESCRIPTION>EEPROM Read/Write Access Low Byte</DESCRIPTION>
        <TEXT>Bits 11..0 - EEAR11..0: EEPROM Address The EEPROM Address Registers - EEARH and EEARL specify the EEPROM address in the 4K bytes EEPROM space. The EEPROM data bytes are addressed linearly between 0 and 4096. The initial value of EEAR is undefined. A proper value must be written before the EEPROM may be accessed. </TEXT>
        <IO_ADDR>0x1E</IO_ADDR>
        <MEM_ADDR>0x3E</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>EEARL7</NAME>
          <DESCRIPTION>EEPROM Read/Write Access Bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>EEARL6</NAME>
          <DESCRIPTION>EEPROM Read/Write Access Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>EEARL5</NAME>
          <DESCRIPTION>EEPROM Read/Write Access Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>EEARL4</NAME>
          <DESCRIPTION>EEPROM Read/Write Access Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>EEARL3</NAME>
          <DESCRIPTION>EEPROM Read/Write Access Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>EEARL2</NAME>
          <DESCRIPTION>EEPROM Read/Write Access Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>EEARL1</NAME>
          <DESCRIPTION>EEPROM Read/Write Access Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>EEARL0</NAME>
          <DESCRIPTION>EEPROM Read/Write Access Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </EEARL>
      <EEDR>
        <NAME>EEDR</NAME>
        <DESCRIPTION>EEPROM Data Register</DESCRIPTION>
        <TEXT>For the EEPROM write operation, the EEDR register contains the data to be written to the EEPROM in the address given by the EEAR register. For the EEPROM read operation, the EEDR contains the data read out from the EEPROM at the address given by EEAR.</TEXT>
        <IO_ADDR>0x1D</IO_ADDR>
        <MEM_ADDR>0x3D</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>EEDR7</NAME>
          <DESCRIPTION>EEPROM Data Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>EEDR6</NAME>
          <DESCRIPTION>EEPROM Data Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>EEDR5</NAME>
          <DESCRIPTION>EEPROM Data Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>EEDR4</NAME>
          <DESCRIPTION>EEPROM Data Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>EEDR3</NAME>
          <DESCRIPTION>EEPROM Data Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>EEDR2</NAME>
          <DESCRIPTION>EEPROM Data Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>EEDR1</NAME>
          <DESCRIPTION>EEPROM Data Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>EEDR0</NAME>
          <DESCRIPTION>EEPROM Data Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </EEDR>
      <EECR>
        <NAME>EECR</NAME>
        <DESCRIPTION>EEPROM Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x1C</IO_ADDR>
        <MEM_ADDR>0x3C</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT3>
          <NAME>EERIE</NAME>
          <DESCRIPTION>EEPROM Ready Interrupt Enable</DESCRIPTION>
          <TEXT>EEPROM Ready Interrupt Enable Writing EERIE to one enables the EEPROM Ready Interrupt if the I bit in SREG is set. Writing EERIE to zero disables the interrupt. The EEPROM Ready interrupt generates a constant interrupt when EEWE is cleared.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>EEMWE</NAME>
          <DESCRIPTION>EEPROM Master Write Enable</DESCRIPTION>
          <TEXT>The EEMWE bit determines whether setting EEWE to one causes the EEPROM to be written. When EEMWE is written to one, writing EEWE to one within 4 clock cycles will write data to the EEPROM at the selected address. If EEMWE is zero, writing EEWE to one will have no effect. When EEMWE has been written to one by software, hardware clears the bit to zero after four clock cycles. See the description of the EEWE bit for an EEPROM write procedure.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>EEWE</NAME>
          <DESCRIPTION>EEPROM Write Enable</DESCRIPTION>
          <TEXT>The EEPROM Write Enable Signal EEWE is the write strobe to the EEPROM. When address and data are correctly set up, the EEWE bit must be set to write the value into the EEPROM. The EEMWE bit must be set when the logical one is written to EEWE, otherwise no EEPROM write takes place. The following procedure should be followed when writing the EEPROM (the order of steps 3 and 4 is not essential): 1. Wait until EEWE becomes zero. 2. Wait until SPMEN in SPMCR becomes zero. 3. Write new EEPROM address to EEAR (optional). 4. Write new EEPROM data to EEDR (optional). 5. Write a logical one to the EEMWE bit while writing a zero to EEWE in EECR. 6. Within four clock cycles after setting EEMWE, write a logical one to EEWE. The EEPROM can not be programmed during a CPU write to the Flash memory. The software must check that the Flash programming is completed before initiating a new EEPROM write. Step 2 is only relevant if the software contains a boot loader allowing the CPU to program the Flash. If the Flash is never being updated by the CPU, step 2 can be omitted. See &#x201C;Boot Loader Support - Read While Write self-programming&#x201D; on page 228 for details about boot programming. Caution: An interrupt between step 5 and step 6 will make the write cycle fail, since the EEPROM Master Write Enable will time-out. If an interrupt routine accessing the EEPROM is interrupting another EEPROM access, the EEAR or EEDR regis-ter will be modified, causing the interrupted EEPROM access to fail. It is recommended to have the global interrupt flag cleared during the 4 last steps to avoid these problems. When the write access time has elapsed, the EEWE bit is cleared by hardware. The user software can poll this bit and wait for a zero before writing the next byte. When EEWE has been set, the CPU is halted for two cycles before the next instruc-tion is executed</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>EERE</NAME>
          <DESCRIPTION>EEPROM Read Enable</DESCRIPTION>
          <TEXT>The EEPROM Read Enable Signal EERE is the read strobe to the EEPROM. When the correct address is set up in the EEAR register, the EERE bit must be written to a logic one to trigger the EEPROM read. The EEPROM read access takes one instruction, and the requested data is available immediately. When the EEPROM is read, the CPU is halted for four cycles before the next instruction is executed. The user should poll the EEWE bit before starting the read operation. If a write operation is in progress, it is neither possible to read the EEPROM, nor to change the EEAR register. The calibrated oscillator is used to time the EEPROM accesses. Table 1 lists the typical programming time for EEPROM access from the CPU</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </EECR>
    </EEPROM>
    <PORTA>
      <LIST>[PORTA:DDRA:PINA]</LIST>
      <LINK/>
      <ICON>io_port.bmp</ICON>
      <ID>AVRSimIOPort.SimIOPort</ID>
      <TEXT/>
      <PORTA>
        <NAME>PORTA</NAME>
        <DESCRIPTION>Port A Data Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x1B</IO_ADDR>
        <MEM_ADDR>0x3B</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PORTA7</NAME>
          <DESCRIPTION>Port A Data Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PORTA6</NAME>
          <DESCRIPTION>Port A Data Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PORTA5</NAME>
          <DESCRIPTION>Port A Data Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PORTA4</NAME>
          <DESCRIPTION>Port A Data Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PORTA3</NAME>
          <DESCRIPTION>Port A Data Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PORTA2</NAME>
          <DESCRIPTION>Port A Data Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PORTA1</NAME>
          <DESCRIPTION>Port A Data Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PORTA0</NAME>
          <DESCRIPTION>Port A Data Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PORTA>
      <DDRA>
        <NAME>DDRA</NAME>
        <DESCRIPTION>Port A Data Direction Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x1A</IO_ADDR>
        <MEM_ADDR>0x3A</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>DDA7</NAME>
          <DESCRIPTION>Data Direction Register, Port A, bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>DDA6</NAME>
          <DESCRIPTION>Data Direction Register, Port A, bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>DDA5</NAME>
          <DESCRIPTION>Data Direction Register, Port A, bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>DDA4</NAME>
          <DESCRIPTION>Data Direction Register, Port A, bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>DDA3</NAME>
          <DESCRIPTION>Data Direction Register, Port A, bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>DDA2</NAME>
          <DESCRIPTION>Data Direction Register, Port A, bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>DDA1</NAME>
          <DESCRIPTION>Data Direction Register, Port A, bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>DDA0</NAME>
          <DESCRIPTION>Data Direction Register, Port A, bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </DDRA>
      <PINA>
        <NAME>PINA</NAME>
        <DESCRIPTION>Port A Input Pins</DESCRIPTION>
        <TEXT>The Port A Input Pins address - PINA - is not a register, and this address enables access to the physical value on each Port A pin. When reading PORTA the Port A Data Latch is read, and when reading PINA, the logical values present on the pins are read.</TEXT>
        <IO_ADDR>0x19</IO_ADDR>
        <MEM_ADDR>0x39</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PINA7</NAME>
          <DESCRIPTION>Input Pins, Port A bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>Hi-Z</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PINA6</NAME>
          <DESCRIPTION>Input Pins, Port A bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>Hi-Z</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PINA5</NAME>
          <DESCRIPTION>Input Pins, Port A bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>Hi-Z</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PINA4</NAME>
          <DESCRIPTION>Input Pins, Port A bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>Hi-Z</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PINA3</NAME>
          <DESCRIPTION>Input Pins, Port A bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>Hi-Z</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PINA2</NAME>
          <DESCRIPTION>Input Pins, Port A bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>Hi-Z</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PINA1</NAME>
          <DESCRIPTION>Input Pins, Port A bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>Hi-Z</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PINA0</NAME>
          <DESCRIPTION>Input Pins, Port A bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>Hi-Z</INIT_VAL>
        </BIT0>
      </PINA>
    </PORTA>
    <PORTB>
      <LIST>[PORTB:DDRB:PINB]</LIST>
      <LINK/>
      <ICON>io_port.bmp</ICON>
      <ID>AVRSimIOPort.SimIOPort</ID>
      <TEXT/>
      <PORTB>
        <NAME>PORTB</NAME>
        <DESCRIPTION>Port B Data Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x18</IO_ADDR>
        <MEM_ADDR>0x38</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PORTB7</NAME>
          <DESCRIPTION>Port B Data Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PORTB6</NAME>
          <DESCRIPTION>Port B Data Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PORTB5</NAME>
          <DESCRIPTION>Port B Data Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PORTB4</NAME>
          <DESCRIPTION>Port B Data Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PORTB3</NAME>
          <DESCRIPTION>Port B Data Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PORTB2</NAME>
          <DESCRIPTION>Port B Data Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PORTB1</NAME>
          <DESCRIPTION>Port B Data Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PORTB0</NAME>
          <DESCRIPTION>Port B Data Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PORTB>
      <DDRB>
        <NAME>DDRB</NAME>
        <DESCRIPTION>Port B Data Direction Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x17</IO_ADDR>
        <MEM_ADDR>0x37</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>DDB7</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>DDB6</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>DDB5</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>DDB4</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>DDB3</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>DDB2</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>DDB1</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>DDB0</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </DDRB>
      <PINB>
        <NAME>PINB</NAME>
        <DESCRIPTION>Port B Input Pins</DESCRIPTION>
        <TEXT>The Port B Input Pins address - PINB - is not a register, and this address enables access to the physical value on each Port B pin. When reading PORTB, the Port B Data Latch is read, and when reading PINB, the logical values present on the pins are read.</TEXT>
        <IO_ADDR>0x16</IO_ADDR>
        <MEM_ADDR>0x36</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PINB7</NAME>
          <DESCRIPTION>Port B Input Pins bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PINB6</NAME>
          <DESCRIPTION>Port B Input Pins bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PINB5</NAME>
          <DESCRIPTION>Port B Input Pins bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PINB4</NAME>
          <DESCRIPTION>Port B Input Pins bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PINB3</NAME>
          <DESCRIPTION>Port B Input Pins bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PINB2</NAME>
          <DESCRIPTION>Port B Input Pins bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PINB1</NAME>
          <DESCRIPTION>Port B Input Pins bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PINB0</NAME>
          <DESCRIPTION>Port B Input Pins bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PINB>
    </PORTB>
    <PORTC>
      <LIST>[PORTC:DDRC:PINC]</LIST>
      <LINK/>
      <ICON>io_port.bmp</ICON>
      <ID>AVRSimIOPort.SimIOPort</ID>
      <TEXT/>
      <PORTC>
        <NAME>PORTC</NAME>
        <DESCRIPTION>Port C Data Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x15</IO_ADDR>
        <MEM_ADDR>0x35</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PORTC7</NAME>
          <DESCRIPTION>Port C Data Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PORTC6</NAME>
          <DESCRIPTION>Port C Data Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PORTC5</NAME>
          <DESCRIPTION>Port C Data Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PORTC4</NAME>
          <DESCRIPTION>Port C Data Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PORTC3</NAME>
          <DESCRIPTION>Port C Data Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PORTC2</NAME>
          <DESCRIPTION>Port C Data Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PORTC1</NAME>
          <DESCRIPTION>Port C Data Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PORTC0</NAME>
          <DESCRIPTION>Port C Data Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PORTC>
      <DDRC>
        <NAME>DDRC</NAME>
        <DESCRIPTION>Port C Data Direction Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x14</IO_ADDR>
        <MEM_ADDR>0x34</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>DDC7</NAME>
          <DESCRIPTION>Port C Data Direction Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>DDC6</NAME>
          <DESCRIPTION>Port C Data Direction Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>DDC5</NAME>
          <DESCRIPTION>Port C Data Direction Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>DDC4</NAME>
          <DESCRIPTION>Port C Data Direction Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>DDC3</NAME>
          <DESCRIPTION>Port C Data Direction Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>DDC2</NAME>
          <DESCRIPTION>Port C Data Direction Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>DDC1</NAME>
          <DESCRIPTION>Port C Data Direction Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>DDC0</NAME>
          <DESCRIPTION>Port C Data Direction Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </DDRC>
      <PINC>
        <NAME>PINC</NAME>
        <DESCRIPTION>Port C Input Pins</DESCRIPTION>
        <TEXT>The Port C Input Pins address - PINC - is not a register, and this address enables access to the physical value on each Port C pin. When reading PORTC, the Port C Data Latch is read, and when reading PINC, the logical values present on the pins are read.</TEXT>
        <IO_ADDR>0x13</IO_ADDR>
        <MEM_ADDR>0x33</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PINC7</NAME>
          <DESCRIPTION>Port C Input Pins bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PINC6</NAME>
          <DESCRIPTION>Port C Input Pins bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PINC5</NAME>
          <DESCRIPTION>Port C Input Pins bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PINC4</NAME>
          <DESCRIPTION>Port C Input Pins bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PINC3</NAME>
          <DESCRIPTION>Port C Input Pins bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PINC2</NAME>
          <DESCRIPTION>Port C Input Pins bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PINC1</NAME>
          <DESCRIPTION>Port C Input Pins bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PINC0</NAME>
          <DESCRIPTION>Port C Input Pins bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PINC>
    </PORTC>
    <PORTD>
      <LIST>[PORTD:DDRD:PIND]</LIST>
      <LINK/>
      <ICON>io_port.bmp</ICON>
      <ID>AVRSimIOPort.SimIOPort</ID>
      <TEXT/>
      <PORTD>
        <NAME>PORTD</NAME>
        <DESCRIPTION>Port D Data Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x12</IO_ADDR>
        <MEM_ADDR>0x32</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PORTD7</NAME>
          <DESCRIPTION>Port D Data Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PORTD6</NAME>
          <DESCRIPTION>Port D Data Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PORTD5</NAME>
          <DESCRIPTION>Port D Data Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PORTD4</NAME>
          <DESCRIPTION>Port D Data Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PORTD3</NAME>
          <DESCRIPTION>Port D Data Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PORTD2</NAME>
          <DESCRIPTION>Port D Data Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PORTD1</NAME>
          <DESCRIPTION>Port D Data Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PORTD0</NAME>
          <DESCRIPTION>Port D Data Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PORTD>
      <DDRD>
        <NAME>DDRD</NAME>
        <DESCRIPTION>Port D Data Direction Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x11</IO_ADDR>
        <MEM_ADDR>0x31</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>DDD7</NAME>
          <DESCRIPTION>Port D Data Direction Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>DDD6</NAME>
          <DESCRIPTION>Port D Data Direction Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>DDD5</NAME>
          <DESCRIPTION>Port D Data Direction Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>DDD4</NAME>
          <DESCRIPTION>Port D Data Direction Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>DDD3</NAME>
          <DESCRIPTION>Port D Data Direction Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>DDD2</NAME>
          <DESCRIPTION>Port D Data Direction Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>DDD1</NAME>
          <DESCRIPTION>Port D Data Direction Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>DDD0</NAME>
          <DESCRIPTION>Port D Data Direction Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </DDRD>
      <PIND>
        <NAME>PIND</NAME>
        <DESCRIPTION>Port D Input Pins</DESCRIPTION>
        <TEXT>The Port D Input Pins address - PIND - is not a register, and this address enables access to the physical value on each Port D pin. When reading PORTD, the Port D Data Latch is read, and when reading PIND, the logical values present on the pins are read.</TEXT>
        <IO_ADDR>0x10</IO_ADDR>
        <MEM_ADDR>0x30</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PIND7</NAME>
          <DESCRIPTION>Port D Input Pins bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PIND6</NAME>
          <DESCRIPTION>Port D Input Pins bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PIND5</NAME>
          <DESCRIPTION>Port D Input Pins bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PIND4</NAME>
          <DESCRIPTION>Port D Input Pins bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PIND3</NAME>
          <DESCRIPTION>Port D Input Pins bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PIND2</NAME>
          <DESCRIPTION>Port D Input Pins bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PIND1</NAME>
          <DESCRIPTION>Port D Input Pins bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PIND0</NAME>
          <DESCRIPTION>Port D Input Pins bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PIND>
    </PORTD>
    <PORTE>
      <LIST>[PORTE:DDRE:PINE]</LIST>
      <LINK/>
      <ICON>io_port.bmp</ICON>
      <ID>AVRSimIOPort.SimIOPort</ID>
      <TEXT/>
      <PORTE>
        <NAME>PORTE</NAME>
        <DESCRIPTION>Data Register, Port E</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x03</IO_ADDR>
        <MEM_ADDR>0x23</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PORTE7</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PORTE6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PORTE5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PORTE4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PORTE3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PORTE2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PORTE1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PORTE0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PORTE>
      <DDRE>
        <NAME>DDRE</NAME>
        <DESCRIPTION>Data Direction Register, Port E</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x02</IO_ADDR>
        <MEM_ADDR>0x22</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>DDE7</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>DDE6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>DDE5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>DDE4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>DDE3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>DDE2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>DDE1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>DDE0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </DDRE>
      <PINE>
        <NAME>PINE</NAME>
        <DESCRIPTION>Input Pins, Port E</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x01</IO_ADDR>
        <MEM_ADDR>0x21</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PINE7</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PINE6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PINE5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PINE4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PINE3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PINE2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PINE1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PINE0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PINE>
    </PORTE>
    <PORTF>
      <LIST>[PORTF:DDRF:PINF]</LIST>
      <LINK/>
      <ICON>io_port.bmp</ICON>
      <ID>AVRSimIOPort.SimIOPort</ID>
      <TEXT/>
      <PORTF>
        <NAME>PORTF</NAME>
        <DESCRIPTION>Data Register, Port F</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x62</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PORTF7</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PORTF6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PORTF5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PORTF4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PORTF3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PORTF2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PORTF1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PORTF0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PORTF>
      <DDRF>
        <NAME>DDRF</NAME>
        <DESCRIPTION>Data Direction Register, Port F</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x61</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>DDF7</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>DDF6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>DDF5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>DDF4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>DDF3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>DDF2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>DDF1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>DDF0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </DDRF>
      <PINF>
        <NAME>PINF</NAME>
        <DESCRIPTION>Input Pins, Port F</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x00</IO_ADDR>
        <MEM_ADDR>0x20</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PINF7</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PINF6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PINF5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PINF4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PINF3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PINF2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PINF1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PINF0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PINF>
    </PORTF>
    <PORTG>
      <LIST>[PORTG:DDRG:PING]</LIST>
      <LINK/>
      <ICON>io_port.bmp</ICON>
      <ID>AVRSimIOPort.SimIOPort</ID>
      <TEXT/>
      <PORTG>
        <NAME>PORTG</NAME>
        <DESCRIPTION>Data Register, Port G</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x65</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT4>
          <NAME>PORTG4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PORTG3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PORTG2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PORTG1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PORTG0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PORTG>
      <DDRG>
        <NAME>DDRG</NAME>
        <DESCRIPTION>Data Direction Register, Port G</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x64</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT4>
          <NAME>DDG4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>DDG3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>DDG2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>DDG1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>DDG0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </DDRG>
      <PING>
        <NAME>PING</NAME>
        <DESCRIPTION>Input Pins, Port G</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x63</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT4>
          <NAME>PING4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PING3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PING2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PING1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PING0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PING>
    </PORTG>
    <TIMER_COUNTER_0>
      <LIST>[TCCR0:TCNT0:OCR0:ASSR:TIMSK:TIFR:SFIOR]</LIST>
      <LINK/>
      <ICON>io_timer.bmp</ICON>
      <ID>At8pwm1</ID>
      <TEXT/>
      <TCCR0>
        <NAME>TCCR0</NAME>
        <DESCRIPTION>Timer/Counter Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x33</IO_ADDR>
        <MEM_ADDR>0x53</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>FOC0</NAME>
          <DESCRIPTION>Force Output Compare</DESCRIPTION>
          <TEXT>The FOC0 bit is only active when the WGM bits specifies a non-PWM mode. However, for ensuring compatibility with future devices, this bit must be set to zero when TCCR0 is written when operating in PWM mode. When writing a logical one to the FOC0 bit, an immediate compare match is forced on the waveform generation unit. The OC0 output is changed accord-ing to its COM01:0 bits setting. Note that the FOC0 bit is implemented as a strobe. Therefore it is the value present in the COM01:0 bits that determines the effect of the forced compare. A FOC0 strobe will not generate any interrupt, nor will it clear the timer in CTC mode using OCR0 as TOP. The FOC0 bit is always read as zero.</TEXT>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>WGM00</NAME>
          <ALIAS>PWM0</ALIAS>
          <DESCRIPTION>Waveform Generation Mode 0</DESCRIPTION>
          <TEXT>These bits control the counting sequence of the counter, the source for the maximum (TOP) counter value, and what type of waveform generation to be used. Modes of operation supported by the Timer/Counter unit are: Normal mode, Clear Timer on Compare match (CTC) mode, and two types of Pulse Width Modulation (PWM) modes. See Table 51 and &#x201C;Modes of Operation&#x201D; on page 80. </TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>WAVEFORM_GEN_MODE</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>COM01</NAME>
          <DESCRIPTION>Compare Match Output Mode 1</DESCRIPTION>
          <TEXT>These bits control the output compare pin (OC0) behavior. If one or both of the COM01:0 bits are set, the OC0 output over-rides the normal port functionality of the I/O pin it is connected to. However, note that the Data Direction Register (DDR) bit corresponding to OC0 pin must be set in order to enable the output driver. When OC0 is connected to the pin, the function of the COM01:0 bits depends on the WGM01:0 bit setting. Table 52 shows the COM01:0 bit functionality when the WGM01:0 bits are set to a normal or CTC mode (non-PWM)</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>COM00</NAME>
          <DESCRIPTION>Compare match Output Mode 0</DESCRIPTION>
          <TEXT>These bits control the output compare pin (OC0) behavior. If one or both of the COM01:0 bits are set, the OC0 output over-rides the normal port functionality of the I/O pin it is connected to. However, note that the Data Direction Register (DDR) bit corresponding to OC0 pin must be set in order to enable the output driver. When OC0 is connected to the pin, the function of the COM01:0 bits depends on the WGM01:0 bit setting. Table 52 shows the COM01:0 bit functionality when the WGM01:0 bits are set to a normal or CTC mode (non-PWM)</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>WGM01</NAME>
          <ALIAS>CTC0</ALIAS>
          <DESCRIPTION>Waveform Generation Mode 1</DESCRIPTION>
          <TEXT>These bits control the counting sequence of the counter, the source for the maximum (TOP) counter value, and what type of waveform generation to be used. Modes of operation supported by the Timer/Counter unit are: Normal mode, Clear Timer on Compare match (CTC) mode, and two types of Pulse Width Modulation (PWM) modes. See Table 51 and &#x201C;Modes of Operation&#x201D; on page 80. </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CS02</NAME>
          <DESCRIPTION>Clock Select 2</DESCRIPTION>
          <TEXT>The three clock select bits select the clock source to be used by the Timer/Counter,</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CS01</NAME>
          <DESCRIPTION>Clock Select 1</DESCRIPTION>
          <TEXT>The three clock select bits select the clock source to be used by the Timer/Counter,</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CS00</NAME>
          <DESCRIPTION>Clock Select 0</DESCRIPTION>
          <TEXT>The three clock select bits select the clock source to be used by the Timer/Counter,</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>CLK_SEL_3BIT</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCCR0>
      <TCNT0>
        <NAME>TCNT0</NAME>
        <DESCRIPTION>Timer/Counter Register </DESCRIPTION>
        <TEXT>The Timer/Counter Register gives direct access, both for read and write operations, to the Timer/Counter unit 8-bit counter. Writing to the TCNT0 register blocks (removes) the compare match on the following timer clock. Modifying the counter (TCNT0) while the counter is running, introduces a risk of missing a compare match between TCNT0 the OCR0 register.</TEXT>
        <IO_ADDR>0x32</IO_ADDR>
        <MEM_ADDR>0x52</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TCNT0_7</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TCNT0_6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TCNT0_5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TCNT0_4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TCNT0_3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TCNT0_2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TCNT0_1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TCNT0_0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCNT0>
      <OCR0>
        <NAME>OCR0</NAME>
        <DESCRIPTION>Output Compare Register</DESCRIPTION>
        <TEXT>The Output Compare Register contains an 8-bit value that is continuously compared with the counter value (TCNT0). A match can be used to generate an output compare interrupt, or to generate a waveform output on the OC0 pin.</TEXT>
        <IO_ADDR>0x31</IO_ADDR>
        <MEM_ADDR>0x51</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR0_7</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR0_6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR0_5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR0_4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR0_3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR0_2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR0_1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR0_0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCR0>
      <ASSR>
        <NAME>ASSR</NAME>
        <DESCRIPTION>Asynchronus Status Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x30</IO_ADDR>
        <MEM_ADDR>0x50</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT3>
          <NAME>AS0</NAME>
          <DESCRIPTION>Asynchronus Timer/Counter 0</DESCRIPTION>
          <TEXT>When AS0 is cleared, Timer/Counter 0 is clocked from the I/O clock, clk I/O . When AS0 is set, Timer/Counter 0 is clocked from a crystal oscillator connected to the Timer Oscillator 1 (TOSC1) pin. When the value of AS0 is changed, the contents of TCNT0, OCR0, and TCCR0 might be corrupted.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TCN0UB</NAME>
          <DESCRIPTION>Timer/Counter0 Update Busy</DESCRIPTION>
          <TEXT>When Timer/Counter0 operates asynchronously and TCNT0 is written, this bit becomes set. When TCNT0 has been updated from the temporary storage register, this bit is cleared by hardware. A logical zero in this bit indicates that TCNT0 is ready to be updated with a new value.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR0UB</NAME>
          <DESCRIPTION>Output Compare register 0 Busy</DESCRIPTION>
          <TEXT>When Timer/Counter0 operates asynchronously and OCR0 is written, this bit becomes set. When OCR0 has been updated from the temporary storage register, this bit is cleared by hardware. A logical zero in this bit indicates that OCR0 is ready to be updated with a new value.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TCR0UB</NAME>
          <DESCRIPTION>Timer/Counter Control Register 0 Update Busy</DESCRIPTION>
          <TEXT>When Timer/Counter0 operates asynchronously and TCCR0 is written, this bit becomes set. When TCCR0 has been updated from the temporary storage register, this bit is cleared by hardware. A logical zero in this bit indicates that TCCR0 is ready to be updated with a new value. If a write is performed to any of the three Timer/Counter0 registers while its update busy flag is set, the updated value might get corrupted and cause an unintentional interrupt to occur.The mechanisms for reading TCNT0, OCR0, and TCCR0 are different. When reading TCNT0, the actual timer value is read. When reading OCR0 or TCCR0, the value in the temporary storage register is read</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ASSR>
      <TIMSK>
        <NAME>TIMSK</NAME>
        <DESCRIPTION>Timer/Counter Interrupt Mask Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x37</IO_ADDR>
        <MEM_ADDR>0x57</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT1>
          <NAME>OCIE0</NAME>
          <DESCRIPTION>Timer/Counter0 Output Compare Match Interrupt register</DESCRIPTION>
          <TEXT>When the OCIE0 bit is written to one, and the I-bit in the Status Register is set (one), the Timer/Counter0 Compare Match interrupt is enabled. The corresponding interrupt is executed if a compare match in Timer/Counter0 occurs, i.e. when the OCF0 bit is set in the Timer/Counter Interrupt Flag Register - TIFR.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TOIE0</NAME>
          <DESCRIPTION>Timer/Counter0 Overflow Interrupt Enable</DESCRIPTION>
          <TEXT>When the TOIE0 bit is written to one, and the I-bit in the Status Register is set (one), the Timer/Counter0 Overflow interrupt is enabled. The corresponding interrupt is executed if an overflow in Timer/Counter0 occurs, i.e. when the TOV0 bit is set in the Timer/Counter Interrupt Flag Register - TIFR.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TIMSK>
      <TIFR>
        <NAME>TIFR</NAME>
        <DESCRIPTION>Timer/Counter Interrupt Flag register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x36</IO_ADDR>
        <MEM_ADDR>0x56</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT1>
          <NAME>OCF0</NAME>
          <DESCRIPTION>Output Compare Flag 0</DESCRIPTION>
          <TEXT>The OCF0 bit is set (one) when a compare match occurs between the Timer/Counter0 and the data in OCR0 - Output Compare Register0. OCF0 is cleared by hardware when executing the corresponding interrupt handling vector. Alterna-tively, OCF0 is cleared by writing a logic one to the flag. When the I-bit in SREG, OCIE0 (Timer/Counter0 Compare match Interrupt Enable), and OCF0 are set (one), the Timer/Counter0 Compare match Interrupt is executed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TOV0</NAME>
          <DESCRIPTION>Timer/Counter0 Overflow Flag</DESCRIPTION>
          <TEXT>The bit TOV0 is set (one) when an overflow occurs in Timer/Counter0. TOV0 is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, TOV0 is cleared by writing a logic one to the flag. When the SREG I-bit, TOIE0 (Timer/Counter0 Overflow Interrupt Enable), and TOV0 are set (one), the Timer/Counter0 Overflow interrupt is executed. In PWM mode, this bit is set when Timer/Counter0 changes counting direction at $00.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TIFR>
      <SFIOR>
        <NAME>SFIOR</NAME>
        <DESCRIPTION>Special Function IO Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x20</IO_ADDR>
        <MEM_ADDR>0x40</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>TSM</NAME>
          <DESCRIPTION>Timer/Counter Synchronization Mode</DESCRIPTION>
          <TEXT>Writing TSM to one, PSR0 and PSR321 becomes registers that hold their value until rewritten, or the TSM bit is written zero. This mode is useful for synchronizing timer/counters. By setting both TSM and the appropriate PSR bit(s), the appro-priate timer/counters are halted, and can be configured to same value without the risk of one of them advancing during con-figuration. When the TSM bit written zero, the Timer/Counters start counting simultaneously.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT1>
          <NAME>PSR0</NAME>
          <DESCRIPTION>Prescaler Reset Timer/Counter0</DESCRIPTION>
          <TEXT>When this bit is written to one, the Timer/Counter0 prescaler will be reset. The bit will be cleared by hardware after the operation is performed. Writing a zero to this bit will have no effect. This bit will always be read as zero if Timer/Counter0 is clocked by the internal CPU clock. If this bit is written when Timer/Counter0 is operating in asynchronous mode, the bit will remain one until the prescaler has been reset.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
      </SFIOR>
    </TIMER_COUNTER_0>
    <TIMER_COUNTER_1>
      <LIST>[TIMSK:ETIMSK:TIFR:ETIFR:SFIOR:TCCR1A:TCCR1B:TCCR1C:TCNT1H:TCNT1L:OCR1AH:OCR1AL:OCR1BH:OCR1BL:OCR1CH:OCR1CL:ICR1H:ICR1L]</LIST>
      <LINK>[TCNT1H:TCNT1L];[OCR1AH:OCR1AL];[OCR1BH:OCR1BL];[OCR1CH:OCR1CL];[ICR1H:ICR1L]</LINK>
      <ICON>io_timer.bmp</ICON>
      <ID>t16pwm1_01.xml</ID>
      <TEXT/>
      <TIMSK>
        <NAME>TIMSK</NAME>
        <DESCRIPTION>Timer/Counter Interrupt Mask Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x37</IO_ADDR>
        <MEM_ADDR>0x57</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT5>
          <NAME>TICIE1</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Interrupt Enable</DESCRIPTION>
          <TEXT>When the TICIE1 bit is set (one) and the I-bit in the Status Register is set (one), the Timer/Counter1 Input Capture Event Interrupt is enabled. The corresponding interrupt (at vector $003) is executed if a capture-triggering event occurs on pin 31, ICP, i.e., when the ICF1 bit is set in the Timer/Counter Interrupt Flag Register - TIFR.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCIE1A</NAME>
          <DESCRIPTION>Timer/Counter1 Output CompareA Match Interrupt Enable</DESCRIPTION>
          <TEXT>When the OCIE1A bit is set (one) and the I-bit in the Status Register is set (one), the Timer/Counter1 CompareA Match interrupt is enabled. The corresponding interrupt (at vector $004) is executed if a CompareA match in Timer/Counter1 occurs, i.e., when the OCF1A bit is set in the Timer/Counter Interrupt Flag Register - TIFR.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCIE1B</NAME>
          <DESCRIPTION>Timer/Counter1 Output CompareB Match Interrupt Enable</DESCRIPTION>
          <TEXT>When the OCIE1B bit is set (one) and the I-bit in the Status Register is set (one), the Timer/Counter1 CompareB Match interrupt is enabled. The corresponding interrupt (at vector $005) is executed if a CompareB match in Timer/Counter1 occurs, i.e., when the OCF1B bit is set in the Timer/Counter Interrupt Flag Register - TIFR.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TOIE1</NAME>
          <DESCRIPTION>Timer/Counter1 Overflow Interrupt Enable</DESCRIPTION>
          <TEXT>When the TOIE1 bit is set (one) and the I-bit in the Status Register is set (one), the Timer/Counter1 Overflow interrupt is enabled. The corresponding interrupt (at vector $006) is executed if an overflow in Timer/Counter1 occurs, i.e., when the TOV1 bit is set in the Timer/Counter Interrupt Flag Register - TIFR.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
      </TIMSK>
      <ETIMSK>
        <NAME>ETIMSK</NAME>
        <DESCRIPTION>Extended Timer/Counter Interrupt Mask Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x7D</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT0>
          <NAME>OCIE1C</NAME>
          <DESCRIPTION>Timer/Counter 1, Output Compare Match C Interrupt Enable</DESCRIPTION>
          <TEXT>When this bit is written to one, and the I-flag in the status register is set (interrupts globally enabled), the timer/counter 1 output compare C match interrupt is enabled. The corresponding interrupt vector (See &#x201C;Interrupts&#x201D; on page 46.) is executed when the OCF1C flag, located in ETIFR, is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ETIMSK>
      <TIFR>
        <NAME>TIFR</NAME>
        <DESCRIPTION>Timer/Counter Interrupt Flag register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x36</IO_ADDR>
        <MEM_ADDR>0x56</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT5>
          <NAME>ICF1</NAME>
          <DESCRIPTION>Input Capture Flag 1</DESCRIPTION>
          <TEXT>The ICF1 bit is set (one) to flag an input capture event, indicating that the Timer/Counter1 value has been transferred to the input capture register - ICR1. ICF1 is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, ICF1 is cleared by writing a logic one to the flag. When the SREG I-bit, and TICIE1 (Timer/Counter1 Input Capture Interrupt Enable), and ICF1 are set (one), the Timer/Counter1 Capture Interrupt is executed. </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCF1A</NAME>
          <DESCRIPTION>Output Compare Flag 1A</DESCRIPTION>
          <TEXT>The OCF1A bit is set (one) when compare match occurs between the Timer/Counter1 and the data in OCR1A - Output Compare Register 1A. OCF1A is cleared by hardware when executing the corresponding interrupt handling vector. Alterna-tively, OCF1A is cleared by writing a logic one to the flag. When the I-bit in SREG, and OCIE1A (Timer/Counter1 Compare match InterruptA Enable), and the OCF1A are set (one), the Timer/Counter1 Compare A match Interrupt is executed. </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCF1B</NAME>
          <DESCRIPTION>Output Compare Flag 1B</DESCRIPTION>
          <TEXT>The OCF1B bit is set (one) when compare match occurs between the Timer/Counter1 and the data in OCR1B - Output Compare Register 1B. OCF1B is cleared by hardware when executing the corresponding interrupt handling vector. Alterna-tively, OCF1B is cleared by writing a logic one to the flag. When the I-bit in SREG, and OCIE1B (Timer/Counter1 Compare match InterruptB Enable), and the OCF1B are set (one), the Timer/Counter1 Compare B match Interrupt is executed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TOV1</NAME>
          <DESCRIPTION>Timer/Counter1 Overflow Flag</DESCRIPTION>
          <TEXT>The TOV1 is set (one) when an overflow occurs in Timer/Counter1. TOV1 is cleared by hardware when executing the cor-responding interrupt handling vector. Alternatively, TOV1 is cleared by writing a logic one to the flag. When the I-bit in SREG, and TOIE1 (Timer/Counter1 Overflow Interrupt Enable), and TOV1 are set (one), the Timer/Counter1 Overflow Interrupt is executed. In PWM mode, this bit is set when Timer/Counter1 changes counting direction at $0000.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
      </TIFR>
      <ETIFR>
        <NAME>ETIFR</NAME>
        <DESCRIPTION>Extended Timer/Counter Interrupt Flag register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x7C</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT0>
          <NAME>OCF1C</NAME>
          <DESCRIPTION>Timer/Counter 1, Output Compare C Match Flag</DESCRIPTION>
          <TEXT>This flag is set in the timer clock cycle after the counter (TCNT1) value matches the Output Compare Register C (OCR1C). Note that a forced output compare (FOC1C) strobe will not set the OCF1C flag. OCF1C is automatically cleared when the Output Compare Match 1 C interrupt vector is executed. Alternatively, OCF1C can be cleared by writing a logic one to its bit location. </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ETIFR>
      <SFIOR>
        <NAME>SFIOR</NAME>
        <DESCRIPTION>Special Function IO Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x20</IO_ADDR>
        <MEM_ADDR>0x40</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>TSM</NAME>
          <DESCRIPTION>Timer/Counter Synchronization Mode</DESCRIPTION>
          <TEXT>&#x2022; Bit 7 - TSM: Timer/Counter Synchronization Mode Writing TSM to one, PSR0 and PSR321 becomes registers that hold their value until rewritten, or the TSM bit is written zero. This mode is useful for synchronizing timer/counters. By setting both TSM and the appropriate PSR bit(s), the appro-priate timer/counters are halted, and can be configured to same value without the risk of one of them advancing during con-figuration. When the TSM bit written zero, the Timer/Counters start counting simultaneously. </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT0>
          <NAME>PSR321</NAME>
          <DESCRIPTION>Prescaler Reset, T/C3, T/C2, T/C1</DESCRIPTION>
          <TEXT>&#x2022; Bit 0 - PSR321: Prescaler Reset Timer/Counter3, Timer/Counter2, and Timer/Counter1 Writing PSR321 to one resets the prescalter for Timer/Counter3, Timer/Counter2, and Timer/Counter1. The bit will be cleared by hardware after the operation is performed. Writing a zero to this bit will have no effect. Note that Timer/Counter3 Timer/Counter2, and Timer/Counter1 share the same prescaler and a reset of this prescaler will affect both timers. This bit will always be read as zero.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SFIOR>
      <TCCR1A>
        <NAME>TCCR1A</NAME>
        <DESCRIPTION>Timer/Counter1 Control Register A</DESCRIPTION>
        <TEXT>Bit 7:6 - COMnA1:0: Compare Output Mode for channel A  &#x2022; Bit 5:4 - COMnB1:0: Compare Output Mode for channel B  &#x2022; Bit 3:2 - COMnC1:0: Compare Output Mode for channel C The COMnA1:0, COMnB1:0, and COMnC1:0 control the output compare pins (OCnA, OCnB, and OCnC respectively) behavior. If one or both of the COMnA1:0 bits are written to one, the OCnA output overrides the normal port functionality of the I/O pin it is connected to. If one or both of the COMnB1:0 bits are written to one, the OCnB output overrides the normal port functionality of the I/O pin it is connected to. If one or both of the COMnC1:0 bits are written to one, the OCnC output overrides the normal port functionality of the I/O pin it is connected to. However, note that the Data Direction Register (DDR) bit corresponding to OCnA, OCnB or OCnC pin must be set in order to enable the output driver. When the OCnA, OCnB or OCnC is connected to the pin, the function of the COMnx1:0 bits are dependent of the WGMn3:0 bits setting. Table 57 shows the COMnx1 0 bit functionality when the WGMn3:0 bits are set to a normal or a CTC mode (non-PW</TEXT>
        <IO_ADDR>0x2F</IO_ADDR>
        <MEM_ADDR>0x4F</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>COM1A1</NAME>
          <DESCRIPTION>Compare Output Mode 1A, bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>COM1A0</NAME>
          <DESCRIPTION>Compare Ouput Mode 1A, bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>COM1B1</NAME>
          <DESCRIPTION>Compare Output Mode 1B, bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>COM1B0</NAME>
          <DESCRIPTION>Compare Output Mode 1B, bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>COM1C1</NAME>
          <DESCRIPTION>Compare Output Mode 1C, bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>COM1C0</NAME>
          <DESCRIPTION>Compare Output Mode 1C, bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>WGM11</NAME>
          <ALIAS>PWM11</ALIAS>
          <DESCRIPTION>Waveform Generation Mode Bit 1</DESCRIPTION>
          <TEXT>Combined with the WGMn3:2 bits found in the TCCRnB register, these bits control the counting sequence of the counter, the source for maximum (TOP) counter value, and what type of waveform generation to be used, see Table 60. Modes of operation supported by the Timer/Counter unit are: Normal mode (counter), Clear Timer on Compare match (CTC) mode, and three types of Pulse Width Modulation (PWM) modes. (See &#x201C;Modes of Operation&#x201D; on page 101.) </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>WGM10</NAME>
          <ALIAS>PWM10</ALIAS>
          <DESCRIPTION>Waveform Generation Mode Bit 0</DESCRIPTION>
          <TEXT>Combined with the WGMn3:2 bits found in the TCCRnB register, these bits control the counting sequence of the counter, the source for maximum (TOP) counter value, and what type of waveform generation to be used, see Table 60. Modes of operation supported by the Timer/Counter unit are: Normal mode (counter), Clear Timer on Compare match (CTC) mode, and three types of Pulse Width Modulation (PWM) modes. (See &#x201C;Modes of Operation&#x201D; on page 101.) </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCCR1A>
      <TCCR1B>
        <NAME>TCCR1B</NAME>
        <DESCRIPTION>Timer/Counter1 Control Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x2E</IO_ADDR>
        <MEM_ADDR>0x4E</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>ICNC1</NAME>
          <DESCRIPTION>Input Capture 1 Noise Canceler</DESCRIPTION>
          <TEXT>When the ICNC1 bit is cleared (zero), the input capture trigger noise canceler function is disabled. The input capture is triggered at the first rising/falling edge sampled on the ICP - input capture pin - as specified. When the ICNC1 bit is set (one), four successive samples are measures on the ICP - input capture pin, and all samples must be high/low according to the input capture trigger specification in the ICES1 bit. The actual sampling frequency is XTAL clock frequency.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ICES1</NAME>
          <DESCRIPTION>Input Capture 1 Edge Select</DESCRIPTION>
          <TEXT>While the ICES1 bit is cleared (zero), the Timer/Counter1 contents are transferred to the Input Capture Register - ICR1 - on the falling edge of the input capture pin - ICP. While the ICES1 bit is set (one), the Timer/Counter1 contents are transferred to the Input Capture Register - ICR1 - on the rising edge of the input capture pin - ICP.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT4>
          <NAME>WGM13</NAME>
          <ALIAS>CTC11</ALIAS>
          <DESCRIPTION>Waveform Generation Mode</DESCRIPTION>
          <TEXT>See description found for TCCR1A</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>WGM12</NAME>
          <ALIAS>CTC10</ALIAS>
          <DESCRIPTION>Waveform Generation Mode</DESCRIPTION>
          <TEXT>See description found for TCCR1A</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CS12</NAME>
          <DESCRIPTION>Clock Select1 bit 2</DESCRIPTION>
          <TEXT>Select clock source</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CS11</NAME>
          <DESCRIPTION>Clock Select 1 bit 1</DESCRIPTION>
          <TEXT>Select clock source</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CS10</NAME>
          <DESCRIPTION>Clock Select bit 0</DESCRIPTION>
          <TEXT>Select clock source</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>CLK_SEL_3BIT_EXT</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCCR1B>
      <TCCR1C>
        <NAME>TCCR1C</NAME>
        <DESCRIPTION>Timer/Counter1 Control Register C</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x7A</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>FOC1A</NAME>
          <DESCRIPTION>Force Output Compare for channel A</DESCRIPTION>
          <TEXT>&#x2022; Bit 7- FOCnA: Force Output Compare for channel A  &#x2022; Bit 6- FOCnB: Force Output Compare for channel B  &#x2022; Bit 5- FOCnC: Force Output Compare for channel C The FOCnA/FOCnB//FOCnC bits are only active when the WGMn3:0 bits specifies a non-PWM mode. When writing a log-icalone to the FOCnA/FOCnB//FOCnC bit, an immediate compare match is forced on the waveform generation unit. The OCnA/OCnB/OCnC output is changed according to its COMnx1:0 bits setting. Note that the FOCnA/FOCnB/FOCnC bits are implemented as strobes. Therefore it is the value present in the COMnx1:0 bits that determine the effect of the forced compare. A FOCnA/FOCnB/FOCnC strobe will not generate any interrupt nor will it clear the timer in clear timer on compare match (CTC) mode using OCRnA as TOP. The FOCnA/FOCnB//FOCnB bits are always read as zero</TEXT>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>FOC1B</NAME>
          <DESCRIPTION>Force Output Compare for channel B</DESCRIPTION>
          <TEXT>&#x2022; Bit 7- FOCnA: Force Output Compare for channel A  &#x2022; Bit 6- FOCnB: Force Output Compare for channel B  &#x2022; Bit 5- FOCnC: Force Output Compare for channel C The FOCnA/FOCnB//FOCnC bits are only active when the WGMn3:0 bits specifies a non-PWM mode. When writing a log-icalone to the FOCnA/FOCnB//FOCnC bit, an immediate compare match is forced on the waveform generation unit. The OCnA/OCnB/OCnC output is changed according to its COMnx1:0 bits setting. Note that the FOCnA/FOCnB/FOCnC bits are implemented as strobes. Therefore it is the value present in the COMnx1:0 bits that determine the effect of the forced compare. A FOCnA/FOCnB/FOCnC strobe will not generate any interrupt nor will it clear the timer in clear timer on compare match (CTC) mode using OCRnA as TOP. The FOCnA/FOCnB//FOCnB bits are always read as zero</TEXT>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>FOC1C</NAME>
          <DESCRIPTION>Force Output Compare for channel C</DESCRIPTION>
          <TEXT>&#x2022; Bit 7- FOCnA: Force Output Compare for channel A  &#x2022; Bit 6- FOCnB: Force Output Compare for channel B  &#x2022; Bit 5- FOCnC: Force Output Compare for channel C The FOCnA/FOCnB//FOCnC bits are only active when the WGMn3:0 bits specifies a non-PWM mode. When writing a log-icalone to the FOCnA/FOCnB//FOCnC bit, an immediate compare match is forced on the waveform generation unit. The OCnA/OCnB/OCnC output is changed according to its COMnx1:0 bits setting. Note that the FOCnA/FOCnB/FOCnC bits are implemented as strobes. Therefore it is the value present in the COMnx1:0 bits that determine the effect of the forced compare. A FOCnA/FOCnB/FOCnC strobe will not generate any interrupt nor will it clear the timer in clear timer on compare match (CTC) mode using OCRnA as TOP. The FOCnA/FOCnB//FOCnB bits are always read as zero</TEXT>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
      </TCCR1C>
      <TCNT1H>
        <NAME>TCNT1H</NAME>
        <DESCRIPTION>Timer/Counter1 High Byte</DESCRIPTION>
        <TEXT>This 16-bit register contains the prescaled value of the 16-bit Timer/Counter1. To ensure that both the high and low bytes are read and written simultaneously when the CPU accesses these registers, the access is performed using an 8-bit temporary register (TEMP). This temporary register is also used when accessing OCR1A, OCR1B and ICR1. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within interrupt rou</TEXT>
        <IO_ADDR>0x2D</IO_ADDR>
        <MEM_ADDR>0x4D</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TCNT1H7</NAME>
          <DESCRIPTION>Timer/Counter1 High Byte bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TCNT1H6</NAME>
          <DESCRIPTION>Timer/Counter1 High Byte bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TCNT1H5</NAME>
          <DESCRIPTION>Timer/Counter1 High Byte bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TCNT1H4</NAME>
          <DESCRIPTION>Timer/Counter1 High Byte bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TCNT1H3</NAME>
          <DESCRIPTION>Timer/Counter1 High Byte bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TCNT1H2</NAME>
          <DESCRIPTION>Timer/Counter1 High Byte bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TCNT1H1</NAME>
          <DESCRIPTION>Timer/Counter1 High Byte bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TCNT1H0</NAME>
          <DESCRIPTION>Timer/Counter1 High Byte bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCNT1H>
      <TCNT1L>
        <NAME>TCNT1L</NAME>
        <DESCRIPTION>Timer/Counter1 Low Byte</DESCRIPTION>
        <TEXT>This 16-bit register contains the prescaled value of the 16-bit Timer/Counter1. To ensure that both the high and low bytes are read and written simultaneously when the CPU accesses these registers, the access is performed using an 8-bit temporary register (TEMP). This temporary register is also used when accessing OCR1A, OCR1B and ICR1. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within interrupt</TEXT>
        <IO_ADDR>0x2C</IO_ADDR>
        <MEM_ADDR>0x4C</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TCNT1L7</NAME>
          <DESCRIPTION>Timer/Counter1 Low Byte bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TCNT1L6</NAME>
          <DESCRIPTION>Timer/Counter1 Low Byte bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TCNT1L5</NAME>
          <DESCRIPTION>Timer/Counter1 Low Byte bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TCNT1L4</NAME>
          <DESCRIPTION>Timer/Counter1 Low Byte bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TCNT1L3</NAME>
          <DESCRIPTION>Timer/Counter1 Low Byte bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TCNT1L2</NAME>
          <DESCRIPTION>Timer/Counter1 Low Byte bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TCNT1L1</NAME>
          <DESCRIPTION>Timer/Counter1 Low Byte bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TCNT1L0</NAME>
          <DESCRIPTION>Timer/Counter1 Low Byte bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCNT1L>
      <OCR1AH>
        <NAME>OCR1AH</NAME>
        <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte</DESCRIPTION>
        <TEXT>The output compare registers are 16-bit read/write registers. The Timer/Counter1 Output Compare Registers contain the data to be continuously compared with Timer/Counter1. Actions on compare matches are specified in the Timer/Counter1 Control and Status register.A compare match does only occur if Timer/Counter1 counts to the OCR value. A software write that sets TCNT1 and OCR1A or OCR1B to the same value does not generate a compare match. A compare match will set the compare interrupt flag in the CPU clock cycle following the compare event. Since the Output Compare Registers - OCR1A and OCR1B - are 16-bit registers, a temporary register TEMP is used when OCR1A/B are written to ensure that both bytes are updated simultaneously. When the CPU writes the high byte, OCR1AH or OCR1BH, the data is temporarily stored in the TEMP register. When the CPU writes the low byte, OCR1AL or OCR1BL, the TEMP register is simultaneously written to OCR1AH or OCR1BH. Consequently, the high byte OCR1AH or OCR1BH must be written first for a full 16-bit register write operation. The TEMP register is also used when accessing TCNT1, and ICR1. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within interrupt</TEXT>
        <IO_ADDR>0x2B</IO_ADDR>
        <MEM_ADDR>0x4B</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR1AH7</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR1AH6</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR1AH5</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR1AH4</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR1AH3</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR1AH2</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR1AH1</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR1AH0</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCR1AH>
      <OCR1AL>
        <NAME>OCR1AL</NAME>
        <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte</DESCRIPTION>
        <TEXT>The output compare registers are 16-bit read/write registers. The Timer/Counter1 Output Compare Registers contain the data to be continuously compared with Timer/Counter1. Actions on compare matches are specified in the Timer/Counter1 Control and Status register.A compare match does only occur if Timer/Counter1 counts to the OCR value. A software write that sets TCNT1 and OCR1A or OCR1B to the same value does not generate a compare match. A compare match will set the compare interrupt flag in the CPU clock cycle following the compare event. Since the Output Compare Registers - OCR1A and OCR1B - are 16-bit registers, a temporary register TEMP is used when OCR1A/B are written to ensure that both bytes are updated simultaneously. When the CPU writes the high byte, OCR1AH or OCR1BH, the data is temporarily stored in the TEMP register. When the CPU writes the low byte, OCR1AL or OCR1BL, the TEMP register is simultaneously written to OCR1AH or OCR1BH. Consequently, the high byte OCR1AH or OCR1BH must be written first for a full 16-bit register write operation. The TEMP register is also used when accessing TCNT1, and ICR1. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within interru</TEXT>
        <IO_ADDR>0x2A</IO_ADDR>
        <MEM_ADDR>0x4A</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR1AL7</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte Bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR1AL6</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR1AL5</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR1AL4</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR1AL3</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR1AL2</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR1AL1</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR1AL0</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCR1AL>
      <OCR1BH>
        <NAME>OCR1BH</NAME>
        <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte</DESCRIPTION>
        <TEXT>The output compare registers are 16-bit read/write registers. The Timer/Counter1 Output Compare Registers contain the data to be continuously compared with Timer/Counter1. Actions on compare matches are specified in the Timer/Counter1 Control and Status register.A compare match does only occur if Timer/Counter1 counts to the OCR value. A software write that sets TCNT1 and OCR1A or OCR1B to the same value does not generate a compare match. A compare match will set the compare interrupt flag in the CPU clock cycle following the compare event. Since the Output Compare Registers - OCR1A and OCR1B - are 16-bit registers, a temporary register TEMP is used when OCR1A/B are written to ensure that both bytes are updated simultaneously. When the CPU writes the high byte, OCR1AH or OCR1BH, the data is temporarily stored in the TEMP register. When the CPU writes the low byte, OCR1AL or OCR1BL, the TEMP register is simultaneously written to OCR1AH or OCR1BH. Consequently, the high byte OCR1AH or OCR1BH must be written first for a full 16-bit register write operation. The TEMP register is also used when accessing TCNT1, and ICR1. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within interrupt ro</TEXT>
        <IO_ADDR>0x29</IO_ADDR>
        <MEM_ADDR>0x49</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR1BH7</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR1BH6</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR1BH5</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR1BH4</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR1BH3</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR1BH2</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR1BH1</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR1BH0</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCR1BH>
      <OCR1BL>
        <NAME>OCR1BL</NAME>
        <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte</DESCRIPTION>
        <TEXT>The output compare registers are 16-bit read/write registers. The Timer/Counter1 Output Compare Registers contain the data to be continuously compared with Timer/Counter1. Actions on compare matches are specified in the Timer/Counter1 Control and Status register.A compare match does only occur if Timer/Counter1 counts to the OCR value. A software write that sets TCNT1 and OCR1A or OCR1B to the same value does not generate a compare match. A compare match will set the compare interrupt flag in the CPU clock cycle following the compare event. Since the Output Compare Registers - OCR1A and OCR1B - are 16-bit registers, a temporary register TEMP is used when OCR1A/B are written to ensure that both bytes are updated simultaneously. When the CPU writes the high byte, OCR1AH or OCR1BH, the data is temporarily stored in the TEMP register. When the CPU writes the low byte, OCR1AL or OCR1BL, the TEMP register is simultaneously written to OCR1AH or OCR1BH. Consequently, the high byte OCR1AH or OCR1BH must be written first for a full 16-bit register write operation. The TEMP register is also used when accessing TCNT1, and ICR1. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within interrupt rout</TEXT>
        <IO_ADDR>0x28</IO_ADDR>
        <MEM_ADDR>0x48</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR1BL7</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR1BL6</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR1BL5</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR1BL4</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR1BL3</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR1BL2</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR1BL1</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR1BL0</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCR1BL>
      <OCR1CH>
        <NAME>OCR1CH</NAME>
        <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte</DESCRIPTION>
        <TEXT>The output compare registers are 16-bit read/write registers. The Timer/Counter1 Output Compare Registers contain the data to be continuously compared with Timer/Counter1. Actions on compare matches are specified in the Timer/Counter1 Control and Status register.A compare match does only occur if Timer/Counter1 counts to the OCR value. A software write that sets TCNT1 and OCR1A or OCR1B to the same value does not generate a compare match. A compare match will set the compare interrupt flag in the CPU clock cycle following the compare event. Since the Output Compare Registers - OCR1A and OCR1B - are 16-bit registers, a temporary register TEMP is used when OCR1A/B are written to ensure that both bytes are updated simultaneously. When the CPU writes the high byte, OCR1AH or OCR1BH, the data is temporarily stored in the TEMP register. When the CPU writes the low byte, OCR1AL or OCR1BL, the TEMP register is simultaneously written to OCR1AH or OCR1BH. Consequently, the high byte OCR1AH or OCR1BH must be written first for a full 16-bit register write operation. The TEMP register is also used when accessing TCNT1, and ICR1. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within interrupt r</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x79</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR1CH7</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR1CH6</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR1CH5</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR1CH4</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR1CH3</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR1CH2</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR1CH1</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR1CH0</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCR1CH>
      <OCR1CL>
        <NAME>OCR1CL</NAME>
        <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte</DESCRIPTION>
        <TEXT>The output compare registers are 16-bit read/write registers. The Timer/Counter1 Output Compare Registers contain the data to be continuously compared with Timer/Counter1. Actions on compare matches are specified in the Timer/Counter1 Control and Status register.A compare match does only occur if Timer/Counter1 counts to the OCR value. A software write that sets TCNT1 and OCR1A or OCR1B to the same value does not generate a compare match. A compare match will set the compare interrupt flag in the CPU clock cycle following the compare event. Since the Output Compare Registers - OCR1A and OCR1B - are 16-bit registers, a temporary register TEMP is used when OCR1A/B are written to ensure that both bytes are updated simultaneously. When the CPU writes the high byte, OCR1AH or OCR1BH, the data is temporarily stored in the TEMP register. When the CPU writes the low byte, OCR1AL or OCR1BL, the TEMP register is simultaneously written to OCR1AH or OCR1BH. Consequently, the high byte OCR1AH or OCR1BH must be written first for a full 16-bit register write operation. The TEMP register is also used when accessing TCNT1, and ICR1. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within interrupt rou</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x78</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR1CL7</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR1CL6</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR1CL5</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR1CL4</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR1CL3</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR1CL2</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR1CL1</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR1CL0</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCR1CL>
      <ICR1H>
        <NAME>ICR1H</NAME>
        <DESCRIPTION>Timer/Counter1 Input Capture Register High Byte</DESCRIPTION>
        <TEXT>The input capture register is a 16-bit read-only register. When the rising or falling edge (according to the input capture edge setting - ICES1) of the signal at the input capture pin -ICP - is detected, the current value of the Timer/Counter1 is transferred to the Input Capture Register - ICR1. At the same time, the input capture flag - ICF1 - is set (one). Since the Input Capture Register - ICR1 - is a 16-bit register, a temporary register TEMP is used when ICR1 is read to ensure that both bytes are read simultaneously. When the CPU reads the low byte ICR1L, the data is sent to the CPU and the data of the high byte ICR1H is placed in the TEMP register. When the CPU reads the data in the high byte ICR1H, the CPU receives the data in the TEMP register. Consequently, the low byte ICR1L must be accessed first for a full 16-bit register read operation. The TEMP register is also used when accessing TCNT1, OCR1A and OCR1B. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within interrupt</TEXT>
        <IO_ADDR>0x27</IO_ADDR>
        <MEM_ADDR>0x47</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>ICR1H7</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register High Byte bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ICR1H6</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register High Byte bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ICR1H5</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register High Byte bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ICR1H4</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register High Byte bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ICR1H3</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register High Byte bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ICR1H2</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register High Byte bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ICR1H1</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register High Byte bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ICR1H0</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register High Byte bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ICR1H>
      <ICR1L>
        <NAME>ICR1L</NAME>
        <DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte</DESCRIPTION>
        <TEXT>The input capture register is a 16-bit read-only register. When the rising or falling edge (according to the input capture edge setting - ICES1) of the signal at the input capture pin -ICP - is detected, the current value of the Timer/Counter1 is transferred to the Input Capture Register - ICR1. At the same time, the input capture flag - ICF1 - is set (one). Since the Input Capture Register - ICR1 - is a 16-bit register, a temporary register TEMP is used when ICR1 is read to ensure that both bytes are read simultaneously. When the CPU reads the low byte ICR1L, the data is sent to the CPU and the data of the high byte ICR1H is placed in the TEMP register. When the CPU reads the data in the high byte ICR1H, the CPU receives the data in the TEMP register. Consequently, the low byte ICR1L must be accessed first for a full 16-bit register read operation. The TEMP register is also used when accessing TCNT1, OCR1A and OCR1B. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within inter</TEXT>
        <IO_ADDR>0x26</IO_ADDR>
        <MEM_ADDR>0x46</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>ICR1L7</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ICR1L6</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ICR1L5</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ICR1L4</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ICR1L3</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ICR1L2</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ICR1L1</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ICR1L0</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ICR1L>
    </TIMER_COUNTER_1>
    <TIMER_COUNTER_2>
      <LIST>[TCCR2:TCNT2:OCR2:TIMSK:TIFR]</LIST>
      <LINK/>
      <ICON>io_timer.bmp</ICON>
      <ID>t8pwm1_00</ID>
      <TEXT/>
      <TCCR2>
        <NAME>TCCR2</NAME>
        <DESCRIPTION>Timer/Counter Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x25</IO_ADDR>
        <MEM_ADDR>0x45</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>FOC2</NAME>
          <DESCRIPTION>Force Output Compare</DESCRIPTION>
          <TEXT>The FOC2 bit is only active when the WGM20 bit specifies a non-PWM mode. However, for ensuring compatibility with future devices, this bit must be set to zero when TCCR2 is written when operating in PWM mode. When writing a logical one to the FOC2 bit, an immediate compare match is forced on the waveform generation unit. The OC2 output is changed according to its COM21:0 bits setting. Note that the FOC2 bit is implemented as a strobe. Therefore it is the value present in the COM21:0 bits that determines the effect of the forced compare. A FOC2 strobe will not generate any interrupt, nor will it clear the timer in CTC mode using OCR2 as TOP. The FOC2 bit is always read as zero.</TEXT>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>WGM20</NAME>
          <ALIAS>PWM2</ALIAS>
          <DESCRIPTION>Wafeform Generation Mode</DESCRIPTION>
          <TEXT>These bits control the counting sequence of the counter, the source for the maximum (TOP) counter value, and what type of waveform generation to be used. Modes of operation supported by the Timer/Counter unit are: Normal mode, Clear Timer on Compare match (CTC) mode, and two types of Pulse Width Modulation (PWM) modes.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>WAVEFORM_GEN_MODE</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>COM21</NAME>
          <DESCRIPTION>Compare Match Output Mode</DESCRIPTION>
          <TEXT>These bits control the output compare pin (OC2) behavior. If one or both of the COM21:0 bits are set, the OC2 output over-rides the normal port functionality of the I/O pin it is connected to. However, note that the Data Direction Register (DDR) bit corresponding to OC2 pin must be set in order to enable the output driver. When OC2 is connected to the pin, the function of the COM21:0 bits depends on the WGM21:0 bit setting. Table 64 shows the COM21:0 bit functionality when the WGM21:0 bits are set to a normal or CTC mode (non-PWM).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>COM20</NAME>
          <DESCRIPTION>Compare Match Output Mode</DESCRIPTION>
          <TEXT>These bits control the output compare pin (OC2) behavior. If one or both of the COM21:0 bits are set, the OC2 output over-rides the normal port functionality of the I/O pin it is connected to. However, note that the Data Direction Register (DDR) bit corresponding to OC2 pin must be set in order to enable the output driver. When OC2 is connected to the pin, the function of the COM21:0 bits depends on the WGM21:0 bit setting. Table 64 shows the COM21:0 bit functionality when the WGM21:0 bits are set to a normal or CTC mode (non-PWM)</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>WGM21</NAME>
          <ALIAS>CTC2</ALIAS>
          <DESCRIPTION>Waveform Generation Mode</DESCRIPTION>
          <TEXT>These bits control the counting sequence of the counter, the source for the maximum (TOP) counter value, and what type of waveform generation to be used. Modes of operation supported by the Timer/Counter unit are: Normal mode, Clear Timer on Compare match (CTC) mode, and two types of Pulse Width Modulation (PWM) modes.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CS22</NAME>
          <DESCRIPTION>Clock Select</DESCRIPTION>
          <TEXT>The three clock select bits select the clock source to be used by the Timer/Counter.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CS21</NAME>
          <DESCRIPTION>Clock Select</DESCRIPTION>
          <TEXT>The three clock select bits select the clock source to be used by the Timer/Counter.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CS20</NAME>
          <DESCRIPTION>Clock Select</DESCRIPTION>
          <TEXT>The three clock select bits select the clock source to be used by the Timer/Counter.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>CLK_SEL_3BIT_EXT</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCCR2>
      <TCNT2>
        <NAME>TCNT2</NAME>
        <DESCRIPTION>Timer/Counter Register</DESCRIPTION>
        <TEXT>The Timer/Counter Register gives direct access, both for read and write operations, to the Timer/Counter unit 8-bit counter. Writing to the TCNT2 register blocks (removes) the compare match on the following timer clock. Modifying the counter (TCNT2) while the counter is running, introduces a risk of missing a compare match between TCNT2 the OCR2 register. </TEXT>
        <IO_ADDR>0x24</IO_ADDR>
        <MEM_ADDR>0x44</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TCNT2_7</NAME>
          <DESCRIPTION>Timer/Counter Register Bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TCNT2_6</NAME>
          <DESCRIPTION>Timer/Counter Register Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TCNT2_5</NAME>
          <DESCRIPTION>Timer/Counter Register Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TCNT2_4</NAME>
          <DESCRIPTION>Timer/Counter Register Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TCNT2_3</NAME>
          <DESCRIPTION>Timer/Counter Register Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TCNT2_2</NAME>
          <DESCRIPTION>Timer/Counter Register Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TCNT2_1</NAME>
          <DESCRIPTION>Timer/Counter Register Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TCNT2_0</NAME>
          <DESCRIPTION>Timer/Counter Register Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCNT2>
      <OCR2>
        <NAME>OCR2</NAME>
        <DESCRIPTION>Output Compare Register</DESCRIPTION>
        <TEXT>The Output Compare Register contains an 8-bit value that is continuously compared with the counter value (TCNT2). A match can be used to generate an output compare interrupt, or to generate a waveform output on the OC2 pin.</TEXT>
        <IO_ADDR>0x23</IO_ADDR>
        <MEM_ADDR>0x43</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR2_7</NAME>
          <DESCRIPTION>Output Compare Register Bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR2_6</NAME>
          <DESCRIPTION>Output Compare Register Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR2_5</NAME>
          <DESCRIPTION>Output Compare Register Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR2_4</NAME>
          <DESCRIPTION>Output Compare Register Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR2_3</NAME>
          <DESCRIPTION>Output Compare Register Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR2_2</NAME>
          <DESCRIPTION>Output Compare Register Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR2_1</NAME>
          <DESCRIPTION>Output Compare Register Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR2_0</NAME>
          <DESCRIPTION>Output Compare Register Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCR2>
      <TIFR>
        <NAME>TIFR</NAME>
        <DESCRIPTION>Timer/Counter Interrupt Flag Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x36</IO_ADDR>
        <MEM_ADDR>0x56</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>OCF2</NAME>
          <DESCRIPTION>Output Compare Flag 2</DESCRIPTION>
          <TEXT>The OCF2 bit is set (one) when a compare match occurs between the Timer/Counter2 and the data in OCR2 - Output Compare Register2. OCF2 is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, OCF2 is cleared by writing a logic one to the flag. When the I-bit in SREG, OCIE2 (Timer/Counter2 Compare match Interrupt Enable), and OCF2 are set (one), the Timer/Counter2 Compare match Interrupt is executed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TOV2</NAME>
          <DESCRIPTION>Timer/Counter2 Overflow Flag</DESCRIPTION>
          <TEXT>The bit TOV2 is set (one) when an overflow occurs in Timer/Counter2. TOV2 is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, TOV2 is cleared by writing a logic one to the flag. When the SREG I-bit, TOIE2 (Timer/Counter2 Overflow Interrupt Enable), and TOV2 are set (one), the Timer/Counter2 Overflow interrupt is executed. In PWM mode, this bit is set when Timer/Counter2 changes counting direction at $00.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
      </TIFR>
      <TIMSK>
        <NAME>TIMSK</NAME>
        <DESCRIPTION/>
        <TEXT/>
        <IO_ADDR>0x37</IO_ADDR>
        <MEM_ADDR>0x57</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>OCIE2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS/>
          <INIT_VAL/>
        </BIT7>
        <BIT6>
          <NAME>TOIE2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS/>
          <INIT_VAL/>
        </BIT6>
      </TIMSK>
    </TIMER_COUNTER_2>
    <TIMER_COUNTER_3>
      <LIST>[ETIMSK:ETIFR:SFIOR:TCCR3A:TCCR3B:TCCR3C:TCNT3H:TCNT3L:OCR3AH:OCR3AL:OCR3BH:OCR3BL:OCR3CH:OCR3CL:ICR3H:ICR3L]</LIST>
      <LINK>[TCNT3H:TCNT3L];[OCR3AH:OCR3AL];[OCR3BH:OCR3BL];[OCR3CH:OCR3CL];[ICR3H:ICR3L]</LINK>
      <ICON>io_timer.bmp</ICON>
      <ID>t16pwm1_03.xml</ID>
      <TEXT/>
      <ETIMSK>
        <NAME>ETIMSK</NAME>
        <DESCRIPTION>Extended Timer/Counter Interrupt Mask Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x7D</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT5>
          <NAME>TICIE3</NAME>
          <DESCRIPTION>Timer/Counter3 Input Capture Interrupt Enable</DESCRIPTION>
          <TEXT>When the TICIE1 bit is set (one) and the I-bit in the Status Register is set (one), the Timer/Counter3 Input Capture Event Interrupt is enabled. The corresponding interrupt (at vector $003) is executed if a capture-triggering event occurs on pin 31, ICP, i.e., when the ICF1 bit is set in the Timer/Counter Interrupt Flag Register - TIFR.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCIE3A</NAME>
          <DESCRIPTION>Timer/Counter3 Output CompareA Match Interrupt Enable</DESCRIPTION>
          <TEXT>When the OCIE1A bit is set (one) and the I-bit in the Status Register is set (one), the Timer/Counter3 CompareA Match interrupt is enabled. The corresponding interrupt (at vector $004) is executed if a CompareA match in Timer/Counter3 occurs, i.e., when the OCF3Abit is set in the Timer/Counter Interrupt Flag Register - TIFR.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCIE3B</NAME>
          <DESCRIPTION>Timer/Counter3 Output CompareB Match Interrupt Enable</DESCRIPTION>
          <TEXT>When the OCIE1B bit is set (one) and the I-bit in the Status Register is set (one), the Timer/Counter3 CompareB Match interrupt is enabled. The corresponding interrupt (at vector $005) is executed if a CompareB match in Timer/Counter3 occurs, i.e., when the OCF3Bbit is set in the Timer/Counter Interrupt Flag Register - TIFR.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TOIE3</NAME>
          <DESCRIPTION>Timer/Counter3 Overflow Interrupt Enable</DESCRIPTION>
          <TEXT>When the TOIE1 bit is set (one) and the I-bit in the Status Register is set (one), the Timer/Counter3 Overflow interrupt is enabled. The corresponding interrupt (at vector $006) is executed if an overflow in Timer/Counter3 occurs, i.e., when the TOV3bit is set in the Timer/Counter Interrupt Flag Register - TIFR.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCIE3C</NAME>
          <DESCRIPTION>Timer/Counter3, Output Compare Match Interrupt Enable</DESCRIPTION>
          <TEXT>When this bit is written to one, and the I-flag status register is set (interrupts globally enabled), the timer/counter3 output compare C match interrupt is enabled. The corresponding interrupt vector is executed when the OCF3C flag, located in ETIFR is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
      </ETIMSK>
      <ETIFR>
        <NAME>ETIFR</NAME>
        <DESCRIPTION>Extended Timer/Counter Interrupt Flag register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x7C</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT5>
          <NAME>ICF3</NAME>
          <DESCRIPTION>Input Capture Flag 1</DESCRIPTION>
          <TEXT>The ICF3 bit is set (one) to flag an input capture event, indicating that the Timer/Counter3 value has been transferred to the input capture register - ICR1. ICF1 is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, ICF3 is cleared by writing a logic one to the flag. When the SREG I-bit, and TICIE3 (Timer/Counter3 Input Capture Interrupt Enable), and ICF3 are set (one), the Timer/Counter3 Capture Interrupt is executed. </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCF3A</NAME>
          <DESCRIPTION>Output Compare Flag 1A</DESCRIPTION>
          <TEXT>The OCF3Abit is set (one) when compare match occurs between the Timer/Counter3 and the data in OCR1A - Output Compare Register 1A. OCF3Ais cleared by hardware when executing the corresponding interrupt handling vector. Alterna-tively, OCF3Ais cleared by writing a logic one to the flag. When the I-bit in SREG, and OCIE1A (Timer/Counter3 Compare match InterruptA Enable), and the OCF3Aare set (one), the Timer/Counter3 Compare A match Interrupt is executed. </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCF3B</NAME>
          <DESCRIPTION>Output Compare Flag 1B</DESCRIPTION>
          <TEXT>The OCF3Bbit is set (one) when compare match occurs between the Timer/Counter3 and the data in OCR3B- Output Compare Register 1B. OCF3Bis cleared by hardware when executing the corresponding interrupt handling vector. Alterna-tively, OCF3Bis cleared by writing a logic one to the flag. When the I-bit in SREG, and OCIE1B (Timer/Counter3 Compare match InterruptB Enable), and the OCF3Bare set (one), the Timer/Counter3 Compare B match Interrupt is executed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TOV3</NAME>
          <DESCRIPTION>Timer/Counter3 Overflow Flag</DESCRIPTION>
          <TEXT>The TOV3is set (one) when an overflow occurs in Timer/Counter3. TOV3is cleared by hardware when executing the cor-responding interrupt handling vector. Alternatively, TOV3is cleared by writing a logic one to the flag. When the I-bit in SREG, and TOIE1 (Timer/Counter3 Overflow Interrupt Enable), and TOV3are set (one), the Timer/Counter3 Overflow Interrupt is executed. In PWM mode, this bit is set when Timer/Counter3 changes counting direction at $0000.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCF3C</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare C Match Flag</DESCRIPTION>
          <TEXT>This flag is set in the timer clock sycle after the counter (TCNT3) value matches the Output Compare Register C (OCR3C)</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
      </ETIFR>
      <SFIOR>
        <NAME>SFIOR</NAME>
        <DESCRIPTION>Special Function IO Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x20</IO_ADDR>
        <MEM_ADDR>0x40</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>TSM</NAME>
          <DESCRIPTION>Timer/Counter Synchronization Mode</DESCRIPTION>
          <TEXT>&#x2022; Bit 7 - TSM: Timer/Counter Synchronization Mode Writing TSM to one, PSR0 and PSR321 becomes registers that hold their value until rewritten, or the TSM bit is written zero. This mode is useful for synchronizing timer/counters. By setting both TSM and the appropriate PSR bit(s), the appro-priate timer/counters are halted, and can be configured to same value without the risk of one of them advancing during con-figuration. When the TSM bit written zero, the Timer/Counters start counting simultaneously. </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT0>
          <NAME>PSR321</NAME>
          <ALIAS>PSR1</ALIAS>
          <ALIAS>PSR2</ALIAS>
          <DESCRIPTION>Prescaler Reset, T/C3, T/C2, T/C1</DESCRIPTION>
          <TEXT>&#x2022; Bit 0 - PSR321: Prescaler Reset Timer/Counter3, Timer/Counter2, and Timer/Counter3 Writing PSR321 to one resets the prescalter for Timer/Counter3, Timer/Counter2, and Timer/Counter3. The bit will be cleared by hardware after the operation is performed. Writing a zero to this bit will have no effect. Note that Timer/Counter3 Timer/Counter2, and Timer/Counter3 share the same prescaler and a reset of this prescaler will affect both timers. This bit will always be read as zero.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SFIOR>
      <TCCR3A>
        <NAME>TCCR3A</NAME>
        <DESCRIPTION>Timer/Counter3 Control Register A</DESCRIPTION>
        <TEXT>Bit 7:6 - COMnA1:0: Compare Output Mode for channel A  &#x2022; Bit 5:4 - COMnB1:0: Compare Output Mode for channel B  &#x2022; Bit 3:2 - COMnC1:0: Compare Output Mode for channel C The COMnA1:0, COMnB1:0, and COMnC1:0 control the output compare pins (OCnA, OCnB, and OCnC respectively) behavior. If one or both of the COMnA1:0 bits are written to one, the OCnA output overrides the normal port functionality of the I/O pin it is connected to. If one or both of the COMnB1:0 bits are written to one, the OCnB output overrides the normal port functionality of the I/O pin it is connected to. If one or both of the COMnC1:0 bits are written to one, the OCnC output overrides the normal port functionality of the I/O pin it is connected to. However, note that the Data Direction Register (DDR) bit corresponding to OCnA, OCnB or OCnC pin must be set in order to enable the output driver. When the OCnA, OCnB or OCnC is connected to the pin, the function of the COMnx1:0 bits are dependent of the WGMn3:0 bits setting. Table 57 shows the COMnx1 0 bit functionality when the WGMn3:0 bits are set to a normal or a CTC mode (non-</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x8B</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>COM3A1</NAME>
          <DESCRIPTION>Compare Output Mode 3A, bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>COM3A0</NAME>
          <DESCRIPTION>Comparet Ouput Mode 3A, bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>COM3B1</NAME>
          <DESCRIPTION>Compare Output Mode 3B, bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>COM3B0</NAME>
          <DESCRIPTION>Compare Output Mode 3B, bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>COM3C1</NAME>
          <DESCRIPTION>Compare Output Mode 3C, bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>COM3C0</NAME>
          <DESCRIPTION>Compare Output Mode 3C, bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>WGM31</NAME>
          <ALIAS>PWM31</ALIAS>
          <DESCRIPTION>Waveform Generation Mode Bit 1</DESCRIPTION>
          <TEXT>Combined with the WGMn3:2 bits found in the TCCRnB register, these bits control the counting sequence of the counter, the source for maximum (TOP) counter value, and what type of waveform generation to be used, see Table 60. Modes of operation supported by the Timer/Counter unit are: Normal mode (counter), Clear Timer on Compare match (CTC) mode, and three types of Pulse Width Modulation (PWM) modes. (See &#x201C;Modes of Operation&#x201D; on page 101.) </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>WGM30</NAME>
          <ALIAS>PWM30</ALIAS>
          <DESCRIPTION>Waveform Generation Mode Bit 0</DESCRIPTION>
          <TEXT>Combined with the WGMn3:2 bits found in the TCCRnB register, these bits control the counting sequence of the counter, the source for maximum (TOP) counter value, and what type of waveform generation to be used, see Table 60. Modes of operation supported by the Timer/Counter unit are: Normal mode (counter), Clear Timer on Compare match (CTC) mode, and three types of Pulse Width Modulation (PWM) modes. (See &#x201C;Modes of Operation&#x201D; on page 101.) </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCCR3A>
      <TCCR3B>
        <NAME>TCCR3B</NAME>
        <DESCRIPTION>Timer/Counter3 Control Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x8A</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>ICNC3</NAME>
          <DESCRIPTION>Input Capture 3  Noise Canceler</DESCRIPTION>
          <TEXT>When the ICNC3 bit is cleared (zero), the input capture trigger noise canceler function is disabled. The input capture is triggered at the first rising/falling edge sampled on the ICP - input capture pin - as specified. When the ICNC3 bit is set (one), four successive samples are measures on the ICP - input capture pin, and all samples must be high/low according to the input capture trigger specification in the ICES3 bit. The actual sampling frequency is XTAL clock frequency.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ICES3</NAME>
          <DESCRIPTION>Input Capture 3 Edge Select</DESCRIPTION>
          <TEXT>While the ICES3 bit is cleared (zero), the Timer/Counter3 contents are transferred to the Input Capture Register - ICR3 - on the falling edge of the input capture pin - ICP. While the ICES3 bit is set (one), the Timer/Counter3 contents are transferred to the Input Capture Register - ICR3 - on the rising edge of the input capture pin - ICP.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT4>
          <NAME>WGM33</NAME>
          <ALIAS>CTC31</ALIAS>
          <DESCRIPTION>Waveform Generation Mode</DESCRIPTION>
          <TEXT>See description found for TCCR3A</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>WGM32</NAME>
          <ALIAS>CTC30</ALIAS>
          <DESCRIPTION>Waveform Generation Mode</DESCRIPTION>
          <TEXT>See description found for TCCR3A</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CS32</NAME>
          <DESCRIPTION>Clock Select3 bit 2</DESCRIPTION>
          <TEXT>Select clock source</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CS31</NAME>
          <DESCRIPTION>Clock Select 3 bit 1</DESCRIPTION>
          <TEXT>Select clock source</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CS30</NAME>
          <DESCRIPTION>Clock Select 3 bit 0</DESCRIPTION>
          <TEXT>Select clock source</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>CLK_SEL_3BIT_EXT</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCCR3B>
      <TCCR3C>
        <NAME>TCCR3C</NAME>
        <DESCRIPTION>Timer/Counter3 Control Register C</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x8C</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>FOC3A</NAME>
          <DESCRIPTION>Force Output Compare for channel A</DESCRIPTION>
          <TEXT>&#x2022; Bit 7- FOCnA: Force Output Compare for channel A  &#x2022; Bit 6- FOCnB: Force Output Compare for channel B  &#x2022; Bit 5- FOCnC: Force Output Compare for channel C The FOCnA/FOCnB//FOCnC bits are only active when the WGMn3:0 bits specifies a non-PWM mode. When writing a log-icalone to the FOCnA/FOCnB//FOCnC bit, an immediate compare match is forced on the waveform generation unit. The OCnA/OCnB/OCnC output is changed according to its COMnx1:0 bits setting. Note that the FOCnA/FOCnB/FOCnC bits are implemented as strobes. Therefore it is the value present in the COMnx1:0 bits that determine the effect of the forced compare. A FOCnA/FOCnB/FOCnC strobe will not generate any interrupt nor will it clear the timer in clear timer on compare match (CTC) mode using OCRnA as TOP. The FOCnA/FOCnB//FOCnB bits are always read as zer</TEXT>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>FOC3B</NAME>
          <DESCRIPTION>Force Output Compare for channel B</DESCRIPTION>
          <TEXT>&#x2022; Bit 7- FOCnA: Force Output Compare for channel A  &#x2022; Bit 6- FOCnB: Force Output Compare for channel B  &#x2022; Bit 5- FOCnC: Force Output Compare for channel C The FOCnA/FOCnB//FOCnC bits are only active when the WGMn3:0 bits specifies a non-PWM mode. When writing a log-icalone to the FOCnA/FOCnB//FOCnC bit, an immediate compare match is forced on the waveform generation unit. The OCnA/OCnB/OCnC output is changed according to its COMnx1:0 bits setting. Note that the FOCnA/FOCnB/FOCnC bits are implemented as strobes. Therefore it is the value present in the COMnx1:0 bits that determine the effect of the forced compare. A FOCnA/FOCnB/FOCnC strobe will not generate any interrupt nor will it clear the timer in clear timer on compare match (CTC) mode using OCRnA as TOP. The FOCnA/FOCnB//FOCnB bits are always read as zer</TEXT>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>FOC3C</NAME>
          <DESCRIPTION>Force Output Compare for channel C</DESCRIPTION>
          <TEXT>&#x2022; Bit 7- FOCnA: Force Output Compare for channel A  &#x2022; Bit 6- FOCnB: Force Output Compare for channel B  &#x2022; Bit 5- FOCnC: Force Output Compare for channel C The FOCnA/FOCnB//FOCnC bits are only active when the WGMn3:0 bits specifies a non-PWM mode. When writing a log-icalone to the FOCnA/FOCnB//FOCnC bit, an immediate compare match is forced on the waveform generation unit. The OCnA/OCnB/OCnC output is changed according to its COMnx1:0 bits setting. Note that the FOCnA/FOCnB/FOCnC bits are implemented as strobes. Therefore it is the value present in the COMnx1:0 bits that determine the effect of the forced compare. A FOCnA/FOCnB/FOCnC strobe will not generate any interrupt nor will it clear the timer in clear timer on compare match (CTC) mode using OCRnA as TOP. The FOCnA/FOCnB//FOCnB bits are always read as zero</TEXT>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
      </TCCR3C>
      <TCNT3H>
        <NAME>TCNT3H</NAME>
        <DESCRIPTION>Timer/Counter3 High Byte</DESCRIPTION>
        <TEXT>This 16-bit register contains the prescaled value of the 16-bit Timer/Counter3. To ensure that both the high and low bytes are read and written simultaneously when the CPU accesses these registers, the access is performed using an 8-bit temporary register (TEMP). This temporary register is also used when accessing OCR1A, OCR3Band ICR1. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within interrupt </TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x89</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TCNT3H7</NAME>
          <DESCRIPTION>Timer/Counter 3 bit 15</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TCNT3H6</NAME>
          <DESCRIPTION>Timer/Counter 3 bit 14</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TCNT3H5</NAME>
          <DESCRIPTION>Timer/Counter 3 bit 13</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TCNT3H4</NAME>
          <DESCRIPTION>Timer/Counter 3 bit 12</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TCNT3H3</NAME>
          <DESCRIPTION>Timer/Counter 3 bit 11</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TCNT3H2</NAME>
          <DESCRIPTION>Timer/Counter 3 bit 10</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TCNT3H1</NAME>
          <DESCRIPTION>Timer/Counter 3 bit 9</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TCNT3H0</NAME>
          <DESCRIPTION>Timer/Counter 3 bit 8</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCNT3H>
      <TCNT3L>
        <NAME>TCNT3L</NAME>
        <DESCRIPTION>Timer/Counter3 Low Byte</DESCRIPTION>
        <TEXT>This 16-bit register contains the prescaled value of the 16-bit Timer/Counter3. To ensure that both the high and low bytes are read and written simultaneously when the CPU accesses these registers, the access is performed using an 8-bit temporary register (TEMP). This temporary register is also used when accessing OCR1A, OCR3Band ICR1. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within interrup</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x88</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TCN3L7</NAME>
          <DESCRIPTION>Timer/Counter 3 bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TCN3L6</NAME>
          <DESCRIPTION>Timer/Counter 3 bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TCN3L5</NAME>
          <DESCRIPTION>Timer/Counter 3 bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL/>
        </BIT5>
        <BIT4>
          <NAME>TCN3L4</NAME>
          <DESCRIPTION>Timer/Counter 3 bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TCN3L3</NAME>
          <DESCRIPTION>Timer/Counter 3 bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TCN3L2</NAME>
          <DESCRIPTION>Timer/Counter 3 bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TCN3L1</NAME>
          <DESCRIPTION>Timer/Counter 3 bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TCN3L0</NAME>
          <DESCRIPTION>Timer/Counter 3 bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCNT3L>
      <OCR3AH>
        <NAME>OCR3AH</NAME>
        <DESCRIPTION>Timer/Counter3 Output Compare Register A High Byte</DESCRIPTION>
        <TEXT>The output compare registers are 16-bit read/write registers. The Timer/Counter3 Output Compare Registers contain the data to be continuously compared with Timer/Counter3. Actions on compare matches are specified in the Timer/Counter3 Control and Status register.A compare match does only occur if Timer/Counter3 counts to the OCR value. A software write that sets TCNT1 and OCR1A or OCR3Bto the same value does not generate a compare match. A compare match will set the compare interrupt flag in the CPU clock cycle following the compare event. Since the Output Compare Registers - OCR1A and OCR3B- are 16-bit registers, a temporary register TEMP is used when OCR1A/B are written to ensure that both bytes are updated simultaneously. When the CPU writes the high byte, OCR3AH or OCR3BH, the data is temporarily stored in the TEMP register. When the CPU writes the low byte, OCR3AL or OCR3BL, the TEMP register is simultaneously written to OCR3AH or OCR3BH. Consequently, the high byte OCR3AH or OCR3BH must be written first for a full 16-bit register write operation. The TEMP register is also used when accessing TCNT1, and ICR1. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within interru</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x87</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR3AH7</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register A bit 15</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR3AH6</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register A bit 14</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR3AH5</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register A bit 13</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR3AH4</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register A bit 12</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR3AH3</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register A bit 11</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR3AH2</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register A bit 10</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR3AH1</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register A bit 9</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR3AH0</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register A bit 8</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCR3AH>
      <OCR3AL>
        <NAME>OCR3AL</NAME>
        <DESCRIPTION>Timer/Counter3 Output Compare Register A Low Byte</DESCRIPTION>
        <TEXT>The output compare registers are 16-bit read/write registers. The Timer/Counter3 Output Compare Registers contain the data to be continuously compared with Timer/Counter3. Actions on compare matches are specified in the Timer/Counter3 Control and Status register.A compare match does only occur if Timer/Counter3 counts to the OCR value. A software write that sets TCNT1 and OCR1A or OCR3Bto the same value does not generate a compare match. A compare match will set the compare interrupt flag in the CPU clock cycle following the compare event. Since the Output Compare Registers - OCR1A and OCR3B- are 16-bit registers, a temporary register TEMP is used when OCR1A/B are written to ensure that both bytes are updated simultaneously. When the CPU writes the high byte, OCR3AH or OCR3BH, the data is temporarily stored in the TEMP register. When the CPU writes the low byte, OCR3AL or OCR3BL, the TEMP register is simultaneously written to OCR3AH or OCR3BH. Consequently, the high byte OCR3AH or OCR3BH must be written first for a full 16-bit register write operation. The TEMP register is also used when accessing TCNT1, and ICR1. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within inte</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x86</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR3AL7</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register A bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR3AL6</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register A bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR3AL5</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register A bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR3AL4</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register A bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR3AL3</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register A bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR3AL2</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register A bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR3AL1</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register A bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR3AL0</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register A bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCR3AL>
      <OCR3BH>
        <NAME>OCR3BH</NAME>
        <DESCRIPTION>Timer/Counter3 Output Compare Register B High Byte</DESCRIPTION>
        <TEXT>The output compare registers are 16-bit read/write registers. The Timer/Counter3 Output Compare Registers contain the data to be continuously compared with Timer/Counter3. Actions on compare matches are specified in the Timer/Counter3 Control and Status register.A compare match does only occur if Timer/Counter3 counts to the OCR value. A software write that sets TCNT1 and OCR1A or OCR3Bto the same value does not generate a compare match. A compare match will set the compare interrupt flag in the CPU clock cycle following the compare event. Since the Output Compare Registers - OCR1A and OCR3B- are 16-bit registers, a temporary register TEMP is used when OCR1A/B are written to ensure that both bytes are updated simultaneously. When the CPU writes the high byte, OCR3AH or OCR3BH, the data is temporarily stored in the TEMP register. When the CPU writes the low byte, OCR3AL or OCR3BL, the TEMP register is simultaneously written to OCR3AH or OCR3BH. Consequently, the high byte OCR3AH or OCR3BH must be written first for a full 16-bit register write operation. The TEMP register is also used when accessing TCNT1, and ICR1. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within interrup</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x85</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR3BH7</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register B bit 15</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR3BH6</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register B bit 14</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR3BH5</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register B bit 13</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR3BH4</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register B bit 12</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR3BH3</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register B bit 11</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR3BH2</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register B bit 10</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR3BH1</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register B bit 9</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR3BH0</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register B bit 8</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCR3BH>
      <OCR3BL>
        <NAME>OCR3BL</NAME>
        <DESCRIPTION>Timer/Counter3 Output Compare Register B Low Byte</DESCRIPTION>
        <TEXT>The output compare registers are 16-bit read/write registers. The Timer/Counter3 Output Compare Registers contain the data to be continuously compared with Timer/Counter3. Actions on compare matches are specified in the Timer/Counter3 Control and Status register.A compare match does only occur if Timer/Counter3 counts to the OCR value. A software write that sets TCNT1 and OCR1A or OCR3Bto the same value does not generate a compare match. A compare match will set the compare interrupt flag in the CPU clock cycle following the compare event. Since the Output Compare Registers - OCR1A and OCR3B- are 16-bit registers, a temporary register TEMP is used when OCR1A/B are written to ensure that both bytes are updated simultaneously. When the CPU writes the high byte, OCR3AH or OCR3BH, the data is temporarily stored in the TEMP register. When the CPU writes the low byte, OCR3AL or OCR3BL, the TEMP register is simultaneously written to OCR3AH or OCR3BH. Consequently, the high byte OCR3AH or OCR3BH must be written first for a full 16-bit register write operation. The TEMP register is also used when accessing TCNT1, and ICR1. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within interrupt r</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x84</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR3BL7</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register B bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR3BL6</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register B bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR3BL5</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register B bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR3BL4</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register B bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR3BL3</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register B bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR3BL2</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register B bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR3BL1</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register B bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR3BL0</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register 3 B bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCR3BL>
      <OCR3CH>
        <NAME>OCR3CH</NAME>
        <DESCRIPTION>Timer/Counter3 Output compare Register C High Byte</DESCRIPTION>
        <TEXT>The output compare registers are 16-bit read/write registers. The Timer/Counter3 Output Compare Registers contain the data to be continuously compared with Timer/Counter3. Actions on compare matches are specified in the Timer/Counter3 Control and Status register.A compare match does only occur if Timer/Counter3 counts to the OCR value. A software write that sets TCNT1 and OCR1A or OCR3Bto the same value does not generate a compare match. A compare match will set the compare interrupt flag in the CPU clock cycle following the compare event. Since the Output Compare Registers - OCR1A and OCR3B- are 16-bit registers, a temporary register TEMP is used when OCR1A/B are written to ensure that both bytes are updated simultaneously. When the CPU writes the high byte, OCR3AH or OCR3BH, the data is temporarily stored in the TEMP register. When the CPU writes the low byte, OCR3AL or OCR3BL, the TEMP register is simultaneously written to OCR3AH or OCR3BH. Consequently, the high byte OCR3AH or OCR3BH must be written first for a full 16-bit register write operation. The TEMP register is also used when accessing TCNT1, and ICR1. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within </TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x83</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR3CH7</NAME>
          <DESCRIPTION>Timer/Counter3 Output compare Register C 15</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR3CH6</NAME>
          <DESCRIPTION>Timer/Counter3 Output compare Register C 14</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR3CH5</NAME>
          <DESCRIPTION>Timer/Counter3 Output compare Register C 13</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR3CH4</NAME>
          <DESCRIPTION>Timer/Counter3 Output compare Register C 12</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR3CH3</NAME>
          <DESCRIPTION>Timer/Counter3 Output compare Register C 11</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR3CH2</NAME>
          <DESCRIPTION>Timer/Counter3 Output compare Register C 10</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR3CH1</NAME>
          <DESCRIPTION>Timer/Counter3 Output compare Register C 9</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR3CH0</NAME>
          <DESCRIPTION>Timer/Counter3 Output compare Register C 8</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCR3CH>
      <OCR3CL>
        <NAME>OCR3CL</NAME>
        <DESCRIPTION>Timer/Counter3 Output compare register C Low byte</DESCRIPTION>
        <TEXT>The output compare registers are 16-bit read/write registers. The Timer/Counter3 Output Compare Registers contain the data to be continuously compared with Timer/Counter3. Actions on compare matches are specified in the Timer/Counter3 Control and Status register.A compare match does only occur if Timer/Counter3 counts to the OCR value. A software write that sets TCNT1 and OCR1A or OCR3Bto the same value does not generate a compare match. A compare match will set the compare interrupt flag in the CPU clock cycle following the compare event. Since the Output Compare Registers - OCR1A and OCR3B- are 16-bit registers, a temporary register TEMP is used when OCR1A/B are written to ensure that both bytes are updated simultaneously. When the CPU writes the high byte, OCR3AH or OCR3BH, the data is temporarily stored in the TEMP register. When the CPU writes the low byte, OCR3AL or OCR3BL, the TEMP register is simultaneously written to OCR3AH or OCR3BH. Consequently, the high byte OCR3AH or OCR3BH must be written first for a full 16-bit register write operation. The TEMP register is also used when accessing TCNT1, and ICR1. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from with</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x82</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR3CL7</NAME>
          <DESCRIPTION>Timer/Counter3 Output compare register C bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR3CL6</NAME>
          <DESCRIPTION>Timer/Counter3 Output compare register C bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR3CL5</NAME>
          <DESCRIPTION>Timer/Counter3 Output compare register C bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR3CL4</NAME>
          <DESCRIPTION>Timer/Counter3 Output compare register C bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR3CL3</NAME>
          <DESCRIPTION>Timer/Counter3 Output compare register C bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR3CL2</NAME>
          <DESCRIPTION>Timer/Counter3 Output compare register C bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR3CL1</NAME>
          <DESCRIPTION>Timer/Counter3 Output compare register C bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR3CL0</NAME>
          <DESCRIPTION>Timer/Counter3 Output compare register C bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCR3CL>
      <ICR3H>
        <NAME>ICR3H</NAME>
        <DESCRIPTION>Timer/Counter3 Input Capture Register High Byte</DESCRIPTION>
        <TEXT>The input capture register is a 16-bit read-only register. When the rising or falling edge (according to the input capture edge setting - ICES3) of the signal at the input capture pin -ICP - is detected, the current value of the Timer/Counter3 is transferred to the Input Capture Register - ICR1. At the same time, the input capture flag - ICF1 - is set (one). Since the Input Capture Register - ICR1 - is a 16-bit register, a temporary register TEMP is used when ICR1 is read to ensure that both bytes are read simultaneously. When the CPU reads the low byte ICR3L, the data is sent to the CPU and the data of the high byte ICR3H is placed in the TEMP register. When the CPU reads the data in the high byte ICR3H, the CPU receives the data in the TEMP register. Consequently, the low byte ICR3L must be accessed first for a full 16-bit register read operation. The TEMP register is also used when accessing TCNT1, OCR1A and OCR1B. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within interrupt</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x81</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>ICR3H7</NAME>
          <DESCRIPTION>Timer/Counter3 Input Capture Register bit 15</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ICR3H6</NAME>
          <DESCRIPTION>Timer/Counter3 Input Capture Register bit 14</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ICR3H5</NAME>
          <DESCRIPTION>Timer/Counter3 Input Capture Register bit 13</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ICR3H4</NAME>
          <DESCRIPTION>Timer/Counter3 Input Capture Register bit 12</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ICR3H3</NAME>
          <DESCRIPTION>Timer/Counter3 Input Capture Register bit 11</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ICR3H2</NAME>
          <DESCRIPTION>Timer/Counter3 Input Capture Register bit 10</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ICR3H1</NAME>
          <DESCRIPTION>Timer/Counter3 Input Capture Register bit 9</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ICR3H0</NAME>
          <DESCRIPTION>Timer/Counter3 Input Capture Register bit 8</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ICR3H>
      <ICR3L>
        <NAME>ICR3L</NAME>
        <DESCRIPTION>Timer/Counter3 Input Capture Register Low Byte</DESCRIPTION>
        <TEXT>The input capture register is a 16-bit read-only register. When the rising or falling edge (according to the input capture edge setting - ICES3) of the signal at the input capture pin -ICP - is detected, the current value of the Timer/Counter3 is transferred to the Input Capture Register - ICR1. At the same time, the input capture flag - ICF1 - is set (one). Since the Input Capture Register - ICR1 - is a 16-bit register, a temporary register TEMP is used when ICR1 is read to ensure that both bytes are read simultaneously. When the CPU reads the low byte ICR3L, the data is sent to the CPU and the data of the high byte ICR3H is placed in the TEMP register. When the CPU reads the data in the high byte ICR3H, the CPU receives the data in the TEMP register. Consequently, the low byte ICR3L must be accessed first for a full 16-bit register read operation. The TEMP register is also used when accessing TCNT1, OCR1A and OCR1B. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within inter</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x80</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>ICR3L7</NAME>
          <DESCRIPTION>Timer/Counter3 Input Capture Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ICR3L6</NAME>
          <DESCRIPTION>Timer/Counter3 Input Capture Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ICR3L5</NAME>
          <DESCRIPTION>Timer/Counter3 Input Capture Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ICR3L4</NAME>
          <DESCRIPTION>Timer/Counter3 Input Capture Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ICR3L3</NAME>
          <DESCRIPTION>Timer/Counter3 Input Capture Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ICR3L2</NAME>
          <DESCRIPTION>Timer/Counter3 Input Capture Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ICR3L1</NAME>
          <DESCRIPTION>Timer/Counter3 Input Capture Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ICR3L0</NAME>
          <DESCRIPTION>Timer/Counter3 Input Capture Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ICR3L>
    </TIMER_COUNTER_3>
    <WATCHDOG>
      <LIST>[WDTCR]</LIST>
      <LINK/>
      <ICON>io_watch.bmp</ICON>
      <ID/>
      <TEXT/>
      <WDTCR>
        <NAME>WDTCR</NAME>
        <ALIAS>WDTCSR</ALIAS>
        <DESCRIPTION>Watchdog Timer Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x21</IO_ADDR>
        <MEM_ADDR>0x41</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT4>
          <NAME>WDCE</NAME>
          <ALIAS>WDTOE</ALIAS>
          <DESCRIPTION>Watchdog Change Enable</DESCRIPTION>
          <TEXT>This bit must be set when the WDE bit is written to logic zero.Otherwise,the watchdog will not be disabled.Once written to one,hardware will clear this bit after four clock cycles.Refer to the description of the WDE bit for a watchdog disable procedure.This bit must also be set when changing the prescaler bits.     </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>WDE</NAME>
          <DESCRIPTION>Watch Dog Enable</DESCRIPTION>
          <TEXT>When the WDE is set (one) the Watchdog Timer is enabled, and if the WDE is cleared (zero) the Watchdog Timer function is disabled. WDE can only be cleared if the WDTOE bit is set(one). To disable an enabled watchdog timer, the following procedure must be followed: 1. In the same operation, write a logical one to WDTOE and WDE. A logical one must be written to WDE even though it is set to one before the disable operation starts. 2. Within the next four clock cycles, write a logical 0 to WDE. This disables the watchdog</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>WDP2</NAME>
          <DESCRIPTION>Watch Dog Timer Prescaler bit 2</DESCRIPTION>
          <TEXT>The WDP2,WDP1,and WDP0 bits determine the Watchdog Timer prescaling when the Watchdog Timer is enabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>WDOG_TIMER_PRESCALE_3BITS</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>WDP1</NAME>
          <DESCRIPTION>Watch Dog Timer Prescaler bit 1</DESCRIPTION>
          <TEXT>The WDP2,WDP1,and WDP0 bits determine the Watchdog Timer prescaling when the Watchdog Timer is enabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>WDP0</NAME>
          <DESCRIPTION>Watch Dog Timer Prescaler bit 0</DESCRIPTION>
          <TEXT>The WDP2,WDP1,and WDP0 bits determine the Watchdog Timer prescaling when the Watchdog Timer is enabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </WDTCR>
    </WATCHDOG>
    <AD_CONVERTER>
      <LIST>[ADMUX:ADCSRA:ADCH:ADCL]</LIST>
      <LINK/>
      <RULES>((IF ADMUX.ADLAR = 1) LINK [ADCH(1:0):ADCL(7:0)]); (IF ADMUX.ADLAR = 0) LINK [ADCH(7:0):ADCL(7:6)]);</RULES>
      <ICON>io_analo.bmp</ICON>
      <ID/>
      <TEXT>AD Converter Feature list: 10-bit Resolution. 0.5 LSB Integral Non-Linearity. +-2 LSB Absolute Accuracy. TBD - 260 &#xB5;s Conversion Time. Up to TBD kSPS at maximum resolution. 8 Multiplexed Single Ended Input Channels. 7 Differential input channels (TQFP package only).  2 Differential input channels with optional gain of 10x and 200x (TQFP package only). Optional left adjustment for ADC result readout. 0 - VCC ADC Input Voltage Range. Selectable 2.56 V ADC reference voltage. Free Running or Single Conversion Mode. Interrupt on ADC Conversion Complete. Sleep Mode Noise</TEXT>
      <ADMUX>
        <NAME>ADMUX</NAME>
        <DESCRIPTION>The ADC multiplexer Selection Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x07</IO_ADDR>
        <MEM_ADDR>0x27</MEM_ADDR>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>REFS1</NAME>
          <DESCRIPTION>Reference Selection Bit 1</DESCRIPTION>
          <TEXT>These bits select the voltage reference for the ADC, as shown in Table 91. If these bits are changed during a conversion, the change will not go in effect until this conversion is complete (ADIF in ADCSR is set). If differential channels are used, the selected reference should not be closer to AV CC than indicated in Table 94 on page 200. The internal voltage reference options may not be used if an external reference voltage is being applied to the AREF pin.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>REFS0</NAME>
          <DESCRIPTION>Reference Selection Bit 0</DESCRIPTION>
          <TEXT>These bits select the voltage reference for the ADC, as shown in Table 91. If these bits are changed during a conversion, the change will not go in effect until this conversion is complete (ADIF in ADCSR is set). If differential channels are used, the selected reference should not be closer to AV CC than indicated in Table 94 on page 200. The internal voltage reference options may not be used if an external reference voltage is being applied to the AREF pin.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>ANALOG_ADC_V_REF2</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ADLAR</NAME>
          <DESCRIPTION>Left Adjust Result</DESCRIPTION>
          <TEXT>The ADLAR bit affects the presentation of the ADC conversion result in the ADC data register. If ADLAR is cleared, the result is right adjusted. If ADLAR is set, the result is left adjusted. Changing the ADLAR bit will affect the ADC data register immediately, regardless of any ongoing conversions. For a complete description of this bit, see &#x201C;The ADC Data Register -ADCL and ADCH&#x201D; on page 198. </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>MUX4</NAME>
          <DESCRIPTION>Analog Channel and Gain Selection Bits</DESCRIPTION>
          <TEXT>The value of these bits selects which combination of analog inputs are connected to the ADC. These bits also select the gain for the differential channels. See Table 92 for details. If these bits are changed during a conversion, the change will not go in effect until this conversion is complete (ADIF in ADCSR is set).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>MUX3</NAME>
          <DESCRIPTION>Analog Channel and Gain Selection Bits</DESCRIPTION>
          <TEXT>The value of these bits selects which combination of analog inputs are connected to the ADC. These bits also select the gain for the differential channels. See Table 92 for details. If these bits are changed during a conversion, the change will not go in effect until this conversion is complete (ADIF in ADCSR is set).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>MUX2</NAME>
          <DESCRIPTION>Analog Channel and Gain Selection Bits</DESCRIPTION>
          <TEXT>The value of these bits selects which combination of analog inputs are connected to the ADC. These bits also select the gain for the differential channels. See Table 92 for details. If these bits are changed during a conversion, the change will not go in effect until this conversion is complete (ADIF in ADCSR is set).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>MUX1</NAME>
          <DESCRIPTION>Analog Channel and Gain Selection Bits</DESCRIPTION>
          <TEXT>The value of these bits selects which combination of analog inputs are connected to the ADC. These bits also select the gain for the differential channels. See Table 92 for details. If these bits are changed during a conversion, the change will not go in effect until this conversion is complete (ADIF in ADCSR is set).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>MUX0</NAME>
          <DESCRIPTION>Analog Channel and Gain Selection Bits</DESCRIPTION>
          <TEXT>The value of these bits selects which combination of analog inputs are connected to the ADC. These bits also select the gain for the differential channels. See Table 92 for details. If these bits are changed during a conversion, the change will not go in effect until this conversion is complete (ADIF in ADCSR is set).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ADMUX>
      <ADCSRA>
        <NAME>ADCSRA</NAME>
        <ALIAS>ADCSR</ALIAS>
        <DESCRIPTION>The ADC Control and Status register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x06</IO_ADDR>
        <MEM_ADDR>0x26</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>ADEN</NAME>
          <DESCRIPTION>ADC Enable</DESCRIPTION>
          <TEXT>Writing a logical &#x2018;1&#x2019; to this bit enables the ADC. By clearing this bit to zero, the ADC is turned off. Turning the ADC off while a conversion is in progress, will terminate this conversion.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ADSC</NAME>
          <DESCRIPTION>ADC Start Conversion</DESCRIPTION>
          <TEXT>In Single Conversion Mode, a logical &#x2018;1&#x2019; must be written to this bit to start each conversion. In Free Running Mode, a logical &#x2018;1&#x2019; must be written to this bit to start the first conversion. The first time ADSC has been written after the ADC has been enabled, or if ADSC is written at the same time as the ADC is enabled, an extended conversion will result. This extended conversion performs initialization of the ADC. ADSC will read as one as long as a conversion is in progress. When the conversion is complete, it returns to zero. When a dummy conversion precedes a real conversion, ADSC will stay high until the real conversion completes. Writing a 0 to this bit has no effect</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ADFR</NAME>
          <DESCRIPTION>ADC  Free Running Select</DESCRIPTION>
          <TEXT>When this bit is set (one) the ADC operates in Free Running Mode. In this mode, the ADC samples and updates the data registers continuously. Clearing this bit (zero) will terminate Free Running Mode.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ADIF</NAME>
          <DESCRIPTION>ADC Interrupt Flag</DESCRIPTION>
          <TEXT>This bit is set (one) when an ADC conversion completes and the data registers are updated. The ADC Conversion Complete Interrupt is executed if the ADIE bit and the I-bit in SREG are set (one). ADIF is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, ADIF is cleared by writing a logical one to the flag. Beware that if doing a read-modify-write on ADCSR, a pending interrupt can be disabled. This also applies if the SBI and CBI instructions are used.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ADIE</NAME>
          <DESCRIPTION>ADC Interrupt Enable</DESCRIPTION>
          <TEXT>When this bit is set (one) and the I-bit in SREG is set (one), the ADC Conversion Complete Interrupt is activated.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ADPS2</NAME>
          <DESCRIPTION>ADC  Prescaler Select Bits</DESCRIPTION>
          <TEXT>These bits determine the division factor between the XTAL frequency and the input clock to the ADC.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ADPS1</NAME>
          <DESCRIPTION>ADC  Prescaler Select Bits</DESCRIPTION>
          <TEXT>These bits determine the division factor between the XTAL frequency and the input clock to the ADC.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ADPS0</NAME>
          <DESCRIPTION>ADC  Prescaler Select Bits</DESCRIPTION>
          <TEXT>These bits determine the division factor between the XTAL frequency and the input clock to the ADC.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>ANALIG_ADC_PRESCALER</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ADCSRA>
      <ADCH>
        <NAME>ADCH</NAME>
        <DESCRIPTION>ADC Data Register High Byte</DESCRIPTION>
        <TEXT>When an ADC conversion is complete, the result is found in these two registers. If differential channels are used, the result is presented in two&#x2019;s complement form. The selected channel is differential if MUX4..0 are between &#x2018;01000&#x2019; and &#x2018;11101&#x2019;, otherwise the selected channel is single ended. When ADCL is read, the ADC Data Register is not updated until ADCH is read. Consequently, if the result is left adjusted and no more than 8 bit precision (7 bit + sign bit for differential input channels) is required, it is sufficient to read ADCH. Otherwise, ADCL must be read first, then ADCH. The ADLAR bit in ADMUX, and the MUX4..0 bits in ADMUX affect the way the result is read from the registers. If ADLAR is set, the result is left adjusted. If ADLAR is cleared (default), the result is right adju</TEXT>
        <IO_ADDR>0x05</IO_ADDR>
        <MEM_ADDR>0x25</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>ADCH7</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ADCH6</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ADCH5</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ADCH4</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ADCH3</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ADCH2</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ADCH1</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ADCH0</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ADCH>
      <ADCL>
        <NAME>ADCL</NAME>
        <DESCRIPTION>ADC Data Register Low Byte</DESCRIPTION>
        <TEXT>When an ADC conversion is complete, the result is found in these two registers. If differential channels are used, the result is presented in two&#x2019;s complement form. The selected channel is differential if MUX4..0 are between &#x2018;01000&#x2019; and &#x2018;11101&#x2019;, otherwise the selected channel is single ended. When ADCL is read, the ADC Data Register is not updated until ADCH is read. Consequently, if the result is left adjusted and no more than 8 bit precision (7 bit + sign bit for differential input channels) is required, it is sufficient to read ADCH. Otherwise, ADCL must be read first, then ADCH. The ADLAR bit in ADMUX, and the MUX4..0 bits in ADMUX affect the way the result is read from the registers. If ADLAR is set, the result is left adjusted. If ADLAR is cleared (default), the result is right ad</TEXT>
        <IO_ADDR>0x04</IO_ADDR>
        <MEM_ADDR>0x24</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>ADCL7</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ADCL6</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ADCL5</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ADCL4</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ADCL3</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ADCL2</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ADCL1</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ADCL0</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ADCL>
    </AD_CONVERTER>
  </IO_MODULE>
  <ICE_SETTINGS>
    <MODULE_LIST>[ICE50:SIMULATOR:JTAGICEmkII:STK500:STK500_2:AVRISPmkII:AVRDragon:STK600:SIMULATOR2:AVRONE]</MODULE_LIST>
    <ICE50>
      <MMU_ACCESS>
        <MemTypeSram8Bit>0x05</MemTypeSram8Bit>
        <MemTypeSram16Bit>0x0F</MemTypeSram16Bit>
        <MemTypeSramShdw8Bit>0x0F</MemTypeSramShdw8Bit>
        <MemTypeSramShdw16Bit>0x0F</MemTypeSramShdw16Bit>
        <MemTypeEeprom>0x05</MemTypeEeprom>
        <MemTypeProgram>0x05</MemTypeProgram>
        <MemTypePrgEventBreak>0x05</MemTypePrgEventBreak>
        <MemTypePrgEventTrigOut>0x05</MemTypePrgEventTrigOut>
        <MemTypePrgEventTraceCtrl>0x05</MemTypePrgEventTraceCtrl>
        <MemTypePrgEventComplex>0x05</MemTypePrgEventComplex>
        <MemTypeSramEventLow>0x05</MemTypeSramEventLow>
        <MemTypeSramEventHigh>0x05</MemTypeSramEventHigh>
        <MemTypeEepromEvent>0x05</MemTypeEepromEvent>
        <MemTypeRegisterEvent>0x0F</MemTypeRegisterEvent>
        <MemTypeIoEvent>0x0F</MemTypeIoEvent>
        <MemTypePreTrace>0x0F</MemTypePreTrace>
        <MemTypeTrace>0x15</MemTypeTrace>
        <MemTypeCoreShdw>0x14</MemTypeCoreShdw>
        <MemTypeCoreMem>0x14</MemTypeCoreMem>
      </MMU_ACCESS>
      <MMU_NOXRAM>
        <MemTypeSram8Bit>0x000010FF</MemTypeSram8Bit>
        <MemTypeSram16Bit>0x00000000</MemTypeSram16Bit>
        <MemTypeSramShdw8Bit>0x00000000</MemTypeSramShdw8Bit>
        <MemTypeSramShdw16Bit>0x00000000</MemTypeSramShdw16Bit>
        <MemTypeEeprom>0x00000FFF</MemTypeEeprom>
        <MemTypeProgram>0x0001FFFF</MemTypeProgram>
        <MemTypePrgEventBreak>0x0000FFFF</MemTypePrgEventBreak>
        <MemTypePrgEventTrigOut>0x0000FFFF</MemTypePrgEventTrigOut>
        <MemTypePrgEventTraceCtrl>0x0000FFFF</MemTypePrgEventTraceCtrl>
        <MemTypePrgEventComplex>0x0000FFFF</MemTypePrgEventComplex>
        <MemTypeSramEventLow>0x000010FF</MemTypeSramEventLow>
        <MemTypeSramEventHigh>0x0000FFFF</MemTypeSramEventHigh>
        <MemTypeEepromEvent>0x00000FFF</MemTypeEepromEvent>
        <MemTypeRegisterEvent>0x00000000</MemTypeRegisterEvent>
        <MemTypeIoEvent>0x00000000</MemTypeIoEvent>
        <MemTypePreTrace>0x00000000</MemTypePreTrace>
        <MemTypeTrace>0x0023FFFF</MemTypeTrace>
        <MemTypeCoreShdw>0x00000FFF</MemTypeCoreShdw>
        <MemTypeCoreMem>0x000000FF</MemTypeCoreMem>
      </MMU_NOXRAM>
      <MMU_EMULATED>
        <MemTypeSram8Bit>0x0000FFFF</MemTypeSram8Bit>
        <MemTypeSram16Bit>0x00000000</MemTypeSram16Bit>
        <MemTypeSramShdw8Bit>0x00000000</MemTypeSramShdw8Bit>
        <MemTypeSramShdw16Bit>0x00000000</MemTypeSramShdw16Bit>
        <MemTypeEeprom>0x00000FFF</MemTypeEeprom>
        <MemTypeProgram>0x0001FFFF</MemTypeProgram>
        <MemTypePrgEventBreak>0x0000FFFF</MemTypePrgEventBreak>
        <MemTypePrgEventTrigOut>0x0000FFFF</MemTypePrgEventTrigOut>
        <MemTypePrgEventTraceCtrl>0x0000FFFF</MemTypePrgEventTraceCtrl>
        <MemTypePrgEventComplex>0x0000FFFF</MemTypePrgEventComplex>
        <MemTypeSramEventLow>0x0000FFFF</MemTypeSramEventLow>
        <MemTypeSramEventHigh>0x0000FFFF</MemTypeSramEventHigh>
        <MemTypeEepromEvent>0x00000FFF</MemTypeEepromEvent>
        <MemTypeRegisterEvent>0x00000000</MemTypeRegisterEvent>
        <MemTypeIoEvent>0x00000000</MemTypeIoEvent>
        <MemTypePreTrace>0x00000000</MemTypePreTrace>
        <MemTypeTrace>0x0023FFFF</MemTypeTrace>
        <MemTypeCoreShdw>0x00000FFF</MemTypeCoreShdw>
        <MemTypeCoreMem>0x000000FF</MemTypeCoreMem>
      </MMU_EMULATED>
      <MMU_XRAMIF>
        <MemTypeSram8Bit>0x000010FF</MemTypeSram8Bit>
        <MemTypeSram16Bit>0x00000000</MemTypeSram16Bit>
        <MemTypeSramShdw8Bit>0x00000000</MemTypeSramShdw8Bit>
        <MemTypeSramShdw16Bit>0x00000000</MemTypeSramShdw16Bit>
        <MemTypeEeprom>0x00000FFF</MemTypeEeprom>
        <MemTypeProgram>0x0001FFFF</MemTypeProgram>
        <MemTypePrgEventBreak>0x0000FFFF</MemTypePrgEventBreak>
        <MemTypePrgEventTrigOut>0x0000FFFF</MemTypePrgEventTrigOut>
        <MemTypePrgEventTraceCtrl>0x0000FFFF</MemTypePrgEventTraceCtrl>
        <MemTypePrgEventComplex>0x0000FFFF</MemTypePrgEventComplex>
        <MemTypeSramEventLow>0x0000FFFF</MemTypeSramEventLow>
        <MemTypeSramEventHigh>0x0000FFFF</MemTypeSramEventHigh>
        <MemTypeEepromEvent>0x00000FFF</MemTypeEepromEvent>
        <MemTypeRegisterEvent>0x00000000</MemTypeRegisterEvent>
        <MemTypeIoEvent>0x00000000</MemTypeIoEvent>
        <MemTypePreTrace>0x00000000</MemTypePreTrace>
        <MemTypeTrace>0x0023FFFF</MemTypeTrace>
        <MemTypeCoreShdw>0x00000FFF</MemTypeCoreShdw>
        <MemTypeCoreMem>0x0000FFFF</MemTypeCoreMem>
      </MMU_XRAMIF>
      <DEFAULT_SETTINGS>
        <HighFuse>0xF9</HighFuse>
        <ExtendedFuse>0xff</ExtendedFuse>
        <LowFuse>0xE1</LowFuse>
        <Lockbit>0xff</Lockbit>
        <ADDROSC>0x6f</ADDROSC>
        <VALOSC>0xc7</VALOSC>
        <BINFILE>ATmega128.bin</BINFILE>
        <PARAM_MMU_DMEM_PARTION>0x02</PARAM_MMU_DMEM_PARTION>
        <PARAM_MMU_MEMCFG>0x00</PARAM_MMU_MEMCFG>
        <FREQUENCY>1000000</FREQUENCY>
        <MAXFREQUENCY>40000000</MAXFREQUENCY>
        <MINFREQUENCY>7</MINFREQUENCY>
        <CLOCK>2    ; INTOSC = 1, INTRC=2;EXTCLK=4</CLOCK>
        <TIMEROSC>1    ;NOTUSE = 1, EXTERNAL = 4, INTERNAL = 2 </TIMEROSC>
        <XTAL2SOURCING>1 </XTAL2SOURCING>
        <PARAM_AVR_RMR>0</PARAM_AVR_RMR>
        <XRAMENABLE>0x00</XRAMENABLE>
        <XRAMOTHER>0x01</XRAMOTHER>
      </DEFAULT_SETTINGS>
      <SETTINGS>
        <BOOTSIZE>
          <OPT1>
            <LFMASK>0x00000600</LFMASK>
            <LFBITS>0x00000600</LFBITS>
            <TEXT>Boot Size 512 Words, 4 pages, $FE00-$FFFF, Boot reset $FE00</TEXT>
          </OPT1>
          <OPT2>
            <LFMASK>0x00000600</LFMASK>
            <LFBITS>0x00000400</LFBITS>
            <TEXT>Boot Size 1024 Words, 8 pages, $FC00-$FFFF, Boot reset $FC00</TEXT>
          </OPT2>
          <OPT3>
            <LFMASK>0x00000600</LFMASK>
            <LFBITS>0x00000200</LFBITS>
            <TEXT>Boot Size 2048 Words, 16 pages, $F800-$FFFF, Boot reset $F800</TEXT>
          </OPT3>
          <OPT4>
            <LFMASK>0x00000600</LFMASK>
            <LFBITS>0x00000000</LFBITS>
            <TEXT>Boot Size 4096 Words, 32 pages, $F000-$FFFF, Boot reset $F000</TEXT>
          </OPT4>
        </BOOTSIZE>
        <CLOCK>
          <STARTUP>
            <INTOSC>
              <OPT1>
                <LFMASK>0x00000031</LFMASK>
                <LFBITS>0x00000000</LFBITS>
                <TEXT>258 CK, 4 ms </TEXT>
              </OPT1>
              <OPT2>
                <LFMASK>0x00000031</LFMASK>
                <LFBITS>0x00000010</LFBITS>
                <TEXT>258 CK, 64 ms</TEXT>
              </OPT2>
              <OPT3>
                <LFMASK>0x00000031</LFMASK>
                <LFBITS>0x00000020</LFBITS>
                <TEXT>1K CK</TEXT>
              </OPT3>
              <OPT4>
                <LFMASK>0x00000031</LFMASK>
                <LFBITS>0x00000030</LFBITS>
                <TEXT>1K CK, 4 ms</TEXT>
              </OPT4>
              <OPT5>
                <LFMASK>0x00000031</LFMASK>
                <LFBITS>0x00000001</LFBITS>
                <TEXT>1K CK, 64 ms</TEXT>
              </OPT5>
              <OPT6>
                <LFMASK>0x00000031</LFMASK>
                <LFBITS>0x00000011</LFBITS>
                <TEXT>16K CK</TEXT>
              </OPT6>
              <OPT7>
                <LFMASK>0x00000031</LFMASK>
                <LFBITS>0x00000021</LFBITS>
                <TEXT>16K CK, 4 ms</TEXT>
              </OPT7>
              <OPT8>
                <LFMASK>0x00000031</LFMASK>
                <LFBITS>0x00000031</LFBITS>
                <TEXT>16K CK, 64 ms</TEXT>
              </OPT8>
            </INTOSC>
            <INTRC>
              <OPT1>
                <LFMASK>0x00000030</LFMASK>
                <LFBITS>0x00000000</LFBITS>
                <TEXT>6 CK</TEXT>
              </OPT1>
              <OPT2>
                <LFMASK>0x00000030</LFMASK>
                <LFBITS>0x00000010</LFBITS>
                <TEXT>6 CK,4 ms</TEXT>
              </OPT2>
              <OPT3>
                <LFMASK>0x00000030</LFMASK>
                <LFBITS>0x00000020</LFBITS>
                <TEXT>6 CK, 64 ms</TEXT>
              </OPT3>
            </INTRC>
            <EXTCLK>
              <OPT1>
                <LFMASK>0x00000030</LFMASK>
                <LFBITS>0x00000000</LFBITS>
                <TEXT>6 CK</TEXT>
              </OPT1>
              <OPT2>
                <LFMASK>0x00000030</LFMASK>
                <LFBITS>0x00000010</LFBITS>
                <TEXT>6 CK</TEXT>
              </OPT2>
              <OPT3>
                <LFMASK>0x00000030</LFMASK>
                <LFBITS>0x00000020</LFBITS>
                <TEXT>6 CK, 64 ms</TEXT>
              </OPT3>
            </EXTCLK>
          </STARTUP>
          <CLOCK>
            <INTOSC>
              <LFMASK>0x0000103f</LFMASK>
              <LFBITS>0x0000002b</LFBITS>
            </INTOSC>
            <INTRC>
              <OPT1>
                <LFMASK>0x0000103f</LFMASK>
                <LFBITS>0x00001021</LFBITS>
                <TEXT>1.0</TEXT>
              </OPT1>
              <OPT2>
                <LFMASK>0x0000103f</LFMASK>
                <LFBITS>0x00001022</LFBITS>
                <TEXT>2.0</TEXT>
              </OPT2>
              <OPT3>
                <LFMASK>0x0000103f</LFMASK>
                <LFBITS>0x00001023</LFBITS>
                <TEXT>4.0</TEXT>
              </OPT3>
              <OPT4>
                <LFMASK>0x0000103f</LFMASK>
                <LFBITS>0x00001024</LFBITS>
                <TEXT>8.0</TEXT>
              </OPT4>
            </INTRC>
            <EXTCLK>
              <LFMASK>0x0000103f</LFMASK>
              <LFBITS>0x00001020</LFBITS>
            </EXTCLK>
          </CLOCK>
        </CLOCK>
        <BOOTRESET>
          <OPT1>
            <LFMASK>0x00000100</LFMASK>
            <LFBITS>0x00000100</LFBITS>
            <TEXT>Application reset, address $0</TEXT>
          </OPT1>
          <OPT2>
            <LFMASK>0x00000100</LFMASK>
            <LFBITS>0x00000000</LFBITS>
            <TEXT>Boot loader reset</TEXT>
          </OPT2>
        </BOOTRESET>
        <BOOTLOCK0>
          <OPT1>
            <LFMASK>0x0c000000</LFMASK>
            <LFBITS>0x0c000000</LFBITS>
            <TEXT>No restrictions for SPM or (E)LPM</TEXT>
          </OPT1>
          <OPT2>
            <LFMASK>0x0c000000</LFMASK>
            <LFBITS>0x08000000</LFBITS>
            <TEXT>No write to the Application section</TEXT>
          </OPT2>
          <OPT3>
            <LFMASK>0x0c000000</LFMASK>
            <LFBITS>0x00000000</LFBITS>
            <TEXT>No write to Application section,  No read from the Application section</TEXT>
          </OPT3>
          <OPT4>
            <LFMASK>0x0c000000</LFMASK>
            <LFBITS>0x04000000</LFBITS>
            <TEXT>No read from the Application section</TEXT>
          </OPT4>
        </BOOTLOCK0>
        <BOOTLOCK1>
          <OPT1>
            <LFMASK>0x30000000</LFMASK>
            <LFBITS>0x30000000</LFBITS>
            <TEXT>No restrictions for SPM or (E)LPM</TEXT>
          </OPT1>
          <OPT2>
            <LFMASK>0x30000000</LFMASK>
            <LFBITS>0x20000000</LFBITS>
            <TEXT>No write to the Boot Loader section</TEXT>
          </OPT2>
          <OPT3>
            <LFMASK>0x30000000</LFMASK>
            <LFBITS>0x00000000</LFBITS>
            <TEXT>No write to Boot Loader section, No read from the Boot Loader section</TEXT>
          </OPT3>
          <OPT4>
            <LFMASK>0x30000000</LFMASK>
            <LFBITS>0x10000000</LFBITS>
            <TEXT>No read from the Boot Loader section</TEXT>
          </OPT4>
        </BOOTLOCK1>
        <WATCHDOG>
          <TRUE>
            <LFMASK>0x00010000</LFMASK>
            <LFBITS>0x00000000</LFBITS>
            <TEXT>Watchdog always ON</TEXT>
          </TRUE>
          <FALSE>
            <LFMASK>0x00010000</LFMASK>
            <LFBITS>0x00010000</LFBITS>
            <TEXT>Watchdog disabled</TEXT>
          </FALSE>
        </WATCHDOG>
        <BOD>
          <OPT1>
            <LFMASK>0x000000C0</LFMASK>
            <LFBITS>0x000000C0</LFBITS>
            <TEXT>BOD disabled</TEXT>
          </OPT1>
          <OPT2>
            <LFMASK>0x000000C0</LFMASK>
            <LFBITS>0x00000080</LFBITS>
            <TEXT>BOD enabled, 2.7 V</TEXT>
          </OPT2>
          <OPT3>
            <LFMASK>0x000000C0</LFMASK>
            <LFBITS>0x00000000</LFBITS>
            <TEXT>BOD enabled, 4.0 V</TEXT>
          </OPT3>
        </BOD>
      </SETTINGS>
    </ICE50>
    <SIMULATOR>
      <Model>libmega128.dll</Model>
      <CoreID>AVRSimCoreV2.SimCoreV2</CoreID>
      <MemoryID>AVRSimMemory8bit.SimMemory8bit</MemoryID>
      <InterruptID>AVRSimInterrupt.SimInterrupt</InterruptID>
      <EEINTERRUPT>0x2c</EEINTERRUPT>
      <EEAR_EXTRA_BIT>0</EEAR_EXTRA_BIT>
      <NmbIOModules>26</NmbIOModules>
      <PORTA>
        <ID>AVRSimIOPort.SimIOPort</ID>
        <TOGGLE_PIN>N</TOGGLE_PIN>
      </PORTA>
      <PORTB>
        <ID>AVRSimIOPort.SimIOPort</ID>
        <TOGGLE_PIN>N</TOGGLE_PIN>
      </PORTB>
      <PORTC>
        <ID>AVRSimIOPort.SimIOPort</ID>
        <TOGGLE_PIN>N</TOGGLE_PIN>
      </PORTC>
      <PORTD>
        <ID>AVRSimIOPort.SimIOPort</ID>
        <TOGGLE_PIN>N</TOGGLE_PIN>
      </PORTD>
      <PORTE>
        <ID>AVRSimIOPort.SimIOPort</ID>
        <TOGGLE_PIN>N</TOGGLE_PIN>
      </PORTE>
      <PORTF>
        <ID>AVRSimIOPort.SimIOPort</ID>
        <TOGGLE_PIN>N</TOGGLE_PIN>
      </PORTF>
      <PORTG>
        <ID>AVRSimIOPort.SimIOPort</ID>
        <TOGGLE_PIN>N</TOGGLE_PIN>
      </PORTG>
      <EXTINT0>
        <ID>AVRSimIOExtInterrupt.SimIOExtInterrupt</ID>
        <IntVector>0x02</IntVector>
        <EnableIOAdr>0x39</EnableIOAdr>
        <EnableMask>0x01</EnableMask>
        <FlagIOAdr>0x38</FlagIOAdr>
        <FlagMask>0x01</FlagMask>
        <ExtPinIOAdr>0x10</ExtPinIOAdr>
        <ExtPinMask>0x01</ExtPinMask>
        <SenseIOAdr>0x4a</SenseIOAdr>
        <SenseMask>0x03</SenseMask>
      </EXTINT0>
      <EXTINT1>
        <ID>AVRSimIOExtInterrupt.SimIOExtInterrupt</ID>
        <IntVector>0x04</IntVector>
        <EnableIOAdr>0x39</EnableIOAdr>
        <EnableMask>0x02</EnableMask>
        <FlagIOAdr>0x38</FlagIOAdr>
        <FlagMask>0x02</FlagMask>
        <ExtPinIOAdr>0x10</ExtPinIOAdr>
        <ExtPinMask>0x02</ExtPinMask>
        <SenseIOAdr>0x4a</SenseIOAdr>
        <SenseMask>0x0c</SenseMask>
      </EXTINT1>
      <EXTINT2>
        <ID>AVRSimIOExtInterrupt.SimIOExtInterrupt</ID>
        <IntVector>0x06</IntVector>
        <EnableIOAdr>0x39</EnableIOAdr>
        <EnableMask>0x04</EnableMask>
        <FlagIOAdr>0x38</FlagIOAdr>
        <FlagMask>0x04</FlagMask>
        <ExtPinIOAdr>0x10</ExtPinIOAdr>
        <ExtPinMask>0x04</ExtPinMask>
        <SenseIOAdr>0x4a</SenseIOAdr>
        <SenseMask>0x30</SenseMask>
      </EXTINT2>
      <EXTINT3>
        <ID>AVRSimIOExtInterrupt.SimIOExtInterrupt</ID>
        <IntVector>0x08</IntVector>
        <EnableIOAdr>0x39</EnableIOAdr>
        <EnableMask>0x08</EnableMask>
        <FlagIOAdr>0x38</FlagIOAdr>
        <FlagMask>0x08</FlagMask>
        <ExtPinIOAdr>0x10</ExtPinIOAdr>
        <ExtPinMask>0x08</ExtPinMask>
        <SenseIOAdr>0x4a</SenseIOAdr>
        <SenseMask>0xc0</SenseMask>
      </EXTINT3>
      <EXTINT4>
        <ID>AVRSimIOExtInterrupt.SimIOExtInterrupt</ID>
        <IntVector>0x0a</IntVector>
        <EnableIOAdr>0x39</EnableIOAdr>
        <EnableMask>0x10</EnableMask>
        <FlagIOAdr>0x38</FlagIOAdr>
        <FlagMask>0x10</FlagMask>
        <ExtPinIOAdr>0x01</ExtPinIOAdr>
        <ExtPinMask>0x10</ExtPinMask>
        <SenseIOAdr>0x3a</SenseIOAdr>
        <SenseMask>0x03</SenseMask>
      </EXTINT4>
      <EXTINT5>
        <ID>AVRSimIOExtInterrupt.SimIOExtInterrupt</ID>
        <IntVector>0x0c</IntVector>
        <EnableIOAdr>0x39</EnableIOAdr>
        <EnableMask>0x20</EnableMask>
        <FlagIOAdr>0x38</FlagIOAdr>
        <FlagMask>0x20</FlagMask>
        <ExtPinIOAdr>0x01</ExtPinIOAdr>
        <ExtPinMask>0x20</ExtPinMask>
        <SenseIOAdr>0x3a</SenseIOAdr>
        <SenseMask>0x0c</SenseMask>
      </EXTINT5>
      <EXTINT6>
        <ID>AVRSimIOExtInterrupt.SimIOExtInterrupt</ID>
        <IntVector>0x0e</IntVector>
        <EnableIOAdr>0x39</EnableIOAdr>
        <EnableMask>0x40</EnableMask>
        <FlagIOAdr>0x38</FlagIOAdr>
        <FlagMask>0x40</FlagMask>
        <ExtPinIOAdr>0x01</ExtPinIOAdr>
        <ExtPinMask>0x40</ExtPinMask>
        <SenseIOAdr>0x3a</SenseIOAdr>
        <SenseMask>0x30</SenseMask>
      </EXTINT6>
      <EXTINT7>
        <ID>AVRSimIOExtInterrupt.SimIOExtInterrupt</ID>
        <IntVector>0x10</IntVector>
        <EnableIOAdr>0x39</EnableIOAdr>
        <EnableMask>0x80</EnableMask>
        <FlagIOAdr>0x38</FlagIOAdr>
        <FlagMask>0x80</FlagMask>
        <ExtPinIOAdr>0x01</ExtPinIOAdr>
        <ExtPinMask>0x80</ExtPinMask>
        <SenseIOAdr>0x3a</SenseIOAdr>
        <SenseMask>0xc0</SenseMask>
      </EXTINT7>
      <TIMER0>
        <ID>AvrMasterTimer.MasterTimer</ID>
        <CompVector>0x1E</CompVector>
        <OvfVector>0x20</OvfVector>
        <OCnAport>PORTB</OCnAport>
        <OCnAbit>4</OCnAbit>
        <Prescaler>1:8:32:64:128:256:1024</Prescaler>
      </TIMER0>
      <TIMER1>
        <ID>AvrMasterTimer.MasterTimer</ID>
        <IcpVector>0x16</IcpVector>
        <CompAVector>0x18</CompAVector>
        <CompBVector>0x1A</CompBVector>
        <CompCVector>0x30</CompCVector>
        <OvfVector>0x1C</OvfVector>
        <IcpPinAdr>0x10</IcpPinAdr>
        <IcpPinMask>0x10</IcpPinMask>
        <OutputAAdr>0x18</OutputAAdr>
        <OutputAMask>0x20</OutputAMask>
        <OutputBAdr>0x18</OutputBAdr>
        <OutputBMask>0x40</OutputBMask>
        <OutputCAdr>0x18</OutputCAdr>
        <OutputCMask>0x80</OutputCMask>
        <OCFA>TIFR/OCF1A</OCFA>
        <OCFB>TIFR/OCF1B</OCFB>
        <OCFC>ETIFR/OCF1C</OCFC>
        <Prescaler>1:8:64:256:1024</Prescaler>
        <PSRregister>0x20</PSRregister>
        <PSRbitmask>0x01</PSRbitmask>
      </TIMER1>
      <TIMER2>
        <ID>AvrMasterTimer.MasterTimer</ID>
        <CompVector>0x12</CompVector>
        <OvfVector>0x14</OvfVector>
        <OCnAport>PORTB</OCnAport>
        <OCnAbit>7</OCnAbit>
        <CountAdr>0x10</CountAdr>
        <CountMask>0x80</CountMask>
        <Prescaler>1:8:64:256:1024</Prescaler>
      </TIMER2>
      <TIMER3>
        <ID>AvrMasterTimer.MasterTimer</ID>
        <IcpVector>0x32</IcpVector>
        <CompAVector>0x34</CompAVector>
        <CompBVector>0x36</CompBVector>
        <CompCVector>0x38</CompCVector>
        <OvfVector>0x3A</OvfVector>
        <CountPinAdr>0x01</CountPinAdr>
        <CountPinMask>0x40</CountPinMask>
        <IcpPinAdr>0x03</IcpPinAdr>
        <IcpPinMask>0x80</IcpPinMask>
        <IcpFlagRegister>ETIFR</IcpFlagRegister>
        <OutputAAdr>0x03</OutputAAdr>
        <OutputAMask>0x08</OutputAMask>
        <OutputBAdr>0x03</OutputBAdr>
        <OutputBMask>0x10</OutputBMask>
        <OutputCAdr>0x03</OutputCAdr>
        <OutputCMask>0x20</OutputCMask>
        <OCFA>ETIFR/OCF3A</OCFA>
        <OCFB>ETIFR/OCF3B</OCFB>
        <OCFC>ETIFR/OCF3C</OCFC>
        <Prescaler>1:8:64:256:1024</Prescaler>
      </TIMER3>
      <SPM>
        <ID>AVRSimIOSPM.SimIOSPM</ID>
        <IntVector>0x44</IntVector>
      </SPM>
      <SPI>
        <ID>AVRSimIOSpi.SimIOSpi</ID>
        <IntVector>0x22</IntVector>
        <SCKAddress>0x16</SCKAddress>
        <SCKMask>0x02</SCKMask>
        <MISOAddress>0x16</MISOAddress>
        <MISOMask>0x08</MISOMask>
        <MOSIAddress>0x16</MOSIAddress>
        <MOSIMask>0x04</MOSIMask>
        <SSAddress>0x16</SSAddress>
        <DIRAddress>0x17</DIRAddress>
        <SSMask>0x01</SSMask>
      </SPI>
      <USART0>
        <ID>AVRSimIOUsart.SimIOUsart</ID>
        <RXVector>0x24</RXVector>
        <TXVector>0x28</TXVector>
        <UDREVector>0x26</UDREVector>
        <TXPinAddress>0x01</TXPinAddress>
        <TXPinMask>0x02</TXPinMask>
        <RXPinAddress>0x01</RXPinAddress>
        <RXPinMask>0x01</RXPinMask>
      </USART0>
      <USART1>
        <ID>AVRSimIOUsart.SimIOUsart</ID>
        <RXVector>0x3C</RXVector>
        <TXVector>0x40</TXVector>
        <UDREVector>0x3E</UDREVector>
        <TXPinAddress>0x10</TXPinAddress>
        <TXPinMask>0x08</TXPinMask>
        <RXPinAddress>0x10</RXPinAddress>
        <RXPinMask>0x04</RXPinMask>
      </USART1>
      <ANALOGCOMP>
        <ID>AVRSimAC.SimIOAC</ID>
        <IntVector>0x2E</IntVector>
      </ANALOGCOMP>
      <ADC>
        <ID>AVRSimADC.SimADC</ID>
        <IntVector>0x2A</IntVector>
      </ADC>
      <TWI>
        <ID>AvrSimTWI.SimTWI</ID>
        <IntVector>0x42</IntVector>
      </TWI>
      <WATCHDOG>
        <ID>AvrMasterTimer.MasterTimer</ID>
        <Version>0</Version>
        <PrescaleArray>16384:32768:65536:131072:262144:524288:1048576:2097152</PrescaleArray>
      </WATCHDOG>
      <DEFAULT_SETTINGS>
        <HighFuse>0xFF</HighFuse>
        <ExtendedFuse>0xff</ExtendedFuse>
        <LowFuse>0xFF</LowFuse>
        <Lockbit>0xFF</Lockbit>
      </DEFAULT_SETTINGS>
    </SIMULATOR>
    <JTAGICEmkII>
      <ID>0x0970203F</ID>
      <Interface>JTAG</Interface>
<!--Bit 0 in byte 0 is I/O location, bit 7 in byte 7 is I/O location 63-->
      <ucRead>0xFF,0x6F,0xFF,0xFF,0xFB,0xFF,0xFF,0xFF</ucRead>
      <ucWrite>0x8C,0x26,0xB6,0xFD,0xFB,0xFF,0xBF,0xFE</ucWrite>
      <ucReadShadow>0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00</ucReadShadow>
      <ucWriteShadow>0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00</ucWriteShadow>
<!--Bit 0 in byte 0 is extended I/O location, bit 7 in byte 7 is I/O location 63-->
      <ucExtRead>0x3E,0xB5,0x1F,0x37,0xFF,0x1F,0x21,0x2F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00</ucExtRead>
      <ucExtWrite>0x36,0xB5,0x0F,0x27,0xFF,0x1F,0x21,0x27,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00</ucExtWrite>
      <ucExtReadShadow>0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00</ucExtReadShadow>
      <ucExtWriteShadow>0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00</ucExtWriteShadow>
<!--Register locations etc.-->
      <ucIDRAddress>0x22</ucIDRAddress>
      <ucSPMCAddress>0x68</ucSPMCAddress>
      <ucRAMPZAddress>0x3B</ucRAMPZAddress>
      <ulFlashPageSize>256</ulFlashPageSize>
      <ulEepromPageSize>8</ulEepromPageSize>
      <ulBootAddress>0xFE00</ulBootAddress>
      <BootAddress11>0xFE00</BootAddress11>
      <BootAddress10>0xFC00</BootAddress10>
      <BootAddress01>0xF800</BootAddress01>
      <BootAddress00>0xF000</BootAddress00>
      <ucUpperExtIOLoc>0x9D</ucUpperExtIOLoc>
      <ulFlashSize>0x20000</ulFlashSize>
      <ulRegStart>0x0000,32</ulRegStart>
      <ulIoStart>0x0020,64</ulIoStart>
<!--Other stuff-->
      <DWENmaskExt>0x00</DWENmaskExt>
      <DWENmaskHigh>0x00</DWENmaskHigh>
      <DWENmaskLow>0x00</DWENmaskLow>
      <SPIENmaskExt>0x00</SPIENmaskExt>
      <SPIENmaskHigh>0x00</SPIENmaskHigh>
      <SPIENmaskLow>0x00</SPIENmaskLow>
      <ucEepromInst>0x00</ucEepromInst>
      <ucFlashInst>0x00</ucFlashInst>
      <ucSPHaddr>0x3e</ucSPHaddr>
      <ucSPLaddr>0x3d</ucSPLaddr>
      <DWdatareg>0x00</DWdatareg>
      <DWbasePC>0x00</DWbasePC>
      <Osccalshared>0x00</Osccalshared>
      <ucAllowFullPageBitstream>0x01</ucAllowFullPageBitstream>
      <uiStartSmallestBootLoaderSection>0x00</uiStartSmallestBootLoaderSection>
      <ucUseJTAGID>0x01</ucUseJTAGID>
      <DaisyChainProgModes>1,0,0,0,0,0,0,0</DaisyChainProgModes>
      <EECRAddress>0x3c</EECRAddress>
    </JTAGICEmkII>
    <STK500>
      <DeviceId>0xB2</DeviceId>
      <SelfTimed>1</SelfTimed>
      <FullParallel>1</FullParallel>
      <Polled>1</Polled>
      <FPoll>0xFF</FPoll>
      <EPol1>0xFF</EPol1>
      <EPol2>0xFF</EPol2>
      <ComLockFuseRead>0</ComLockFuseRead>
    </STK500>
    <STK500_2>
      <IspEnterProgMode>
        <timeout>200</timeout>
        <stabDelay>100</stabDelay>
        <cmdexeDelay>25</cmdexeDelay>
        <synchLoops>32</synchLoops>
        <byteDelay>0</byteDelay>
        <pollIndex>3</pollIndex>
        <pollValue>0x53</pollValue>
      </IspEnterProgMode>
      <IspLeaveProgMode>
        <preDelay>1</preDelay>
        <postDelay>1</postDelay>
      </IspLeaveProgMode>
      <IspChipErase>
        <eraseDelay>20</eraseDelay>
        <pollMethod>0</pollMethod>
      </IspChipErase>
      <IspProgramFlash>
        <mode>0x21</mode>
        <blockSize>128</blockSize>
        <delay>10</delay>
        <cmd1>0x40</cmd1>
        <cmd2>0x4C</cmd2>
        <cmd3>0x20</cmd3>
        <pollVal1>0xFF</pollVal1>
        <pollVal2>0x00</pollVal2>
      </IspProgramFlash>
      <IspProgramEeprom>
        <mode>0x04</mode>
        <blockSize>64</blockSize>
        <delay>20</delay>
        <cmd1>0xC0</cmd1>
        <cmd2>0x00</cmd2>
        <cmd3>0xA0</cmd3>
        <pollVal1>0xFF</pollVal1>
        <pollVal2>0xFF</pollVal2>
      </IspProgramEeprom>
      <IspReadFlash>
        <blockSize>256</blockSize>
      </IspReadFlash>
      <IspReadEeprom>
        <blockSize>256</blockSize>
      </IspReadEeprom>
      <IspReadFuse>
        <pollIndex>4</pollIndex>
      </IspReadFuse>
      <IspReadLock>
        <pollIndex>4</pollIndex>
      </IspReadLock>
      <IspReadSign>
        <pollIndex>4</pollIndex>
      </IspReadSign>
      <IspReadOsccal>
        <pollIndex>4</pollIndex>
      </IspReadOsccal>
      <PPControlStack>0x0E 0x1E 0x0F 0x1F 0x2E 0x3E 0x2F 0x3F 0x4E 0x5E 0x4F 0x5F 0x6E 0x7E 0x6F 0x7F 0x66 0x76 0x67 0x77 0x6A 0x7A 0x6B 0x7B 0xBE 0xFD 0x00 0x01 0x00 0x00 0x00 0x00</PPControlStack>
      <PpEnterProgMode>
        <stabDelay>100</stabDelay>
        <progModeDelay>0</progModeDelay>
        <latchCycles>6</latchCycles>
        <toggleVtg>0</toggleVtg>
        <powerOffDelay>0</powerOffDelay>
        <resetDelayMs>0</resetDelayMs>
        <resetDelayUs>0</resetDelayUs>
      </PpEnterProgMode>
      <PpLeaveProgMode>
        <stabDelay>15</stabDelay>
        <resetDelay>15</resetDelay>
      </PpLeaveProgMode>
      <PpChipErase>
        <pulseWidth>0</pulseWidth>
        <pollTimeout>10</pollTimeout>
      </PpChipErase>
      <PpProgramFlash>
        <pollTimeout>5</pollTimeout>
        <mode>0x01</mode>
        <blockSize>256</blockSize>
      </PpProgramFlash>
      <PpReadFlash>
        <blockSize>256</blockSize>
      </PpReadFlash>
      <PpProgramEeprom>
        <pollTimeout>5</pollTimeout>
        <mode>0x07</mode>
        <blockSize>256</blockSize>
      </PpProgramEeprom>
      <PpReadEeprom>
        <blockSize>256</blockSize>
      </PpReadEeprom>
      <PpProgramFuse>
        <pulseWidth>0</pulseWidth>
        <pollTimeout>5</pollTimeout>
      </PpProgramFuse>
      <PpProgramLock>
        <pulseWidth>0</pulseWidth>
        <pollTimeout>5</pollTimeout>
      </PpProgramLock>
    </STK500_2>
    <AVRISPmkII/>
    <AVRDragon/>
    <STK600>
      <IspEnterProgMode>
        <timeout>200</timeout>
        <stabDelay>100</stabDelay>
        <cmdexeDelay>25</cmdexeDelay>
        <synchLoops>32</synchLoops>
        <byteDelay>0</byteDelay>
        <pollIndex>3</pollIndex>
        <pollValue>0x53</pollValue>
      </IspEnterProgMode>
      <IspLeaveProgMode>
        <preDelay>1</preDelay>
        <postDelay>1</postDelay>
      </IspLeaveProgMode>
      <IspChipErase>
        <eraseDelay>12</eraseDelay>
        <pollMethod>0</pollMethod>
      </IspChipErase>
      <IspProgramFlash>
        <mode>0x21</mode>
        <blockSize>128</blockSize>
        <delay>6</delay>
        <cmd1>0x40</cmd1>
        <cmd2>0x4C</cmd2>
        <cmd3>0x20</cmd3>
        <pollVal1>0xFF</pollVal1>
        <pollVal2>0x00</pollVal2>
      </IspProgramFlash>
      <IspProgramEeprom>
        <mode>0x04</mode>
        <blockSize>64</blockSize>
        <delay>12</delay>
        <cmd1>0xC0</cmd1>
        <cmd2>0x00</cmd2>
        <cmd3>0xA0</cmd3>
        <pollVal1>0xFF</pollVal1>
        <pollVal2>0xFF</pollVal2>
      </IspProgramEeprom>
      <IspReadFlash>
        <blockSize>256</blockSize>
      </IspReadFlash>
      <IspReadEeprom>
        <blockSize>256</blockSize>
      </IspReadEeprom>
      <IspReadFuse>
        <pollIndex>4</pollIndex>
      </IspReadFuse>
      <IspReadLock>
        <pollIndex>4</pollIndex>
      </IspReadLock>
      <IspReadSign>
        <pollIndex>4</pollIndex>
      </IspReadSign>
      <IspReadOsccal>
        <pollIndex>4</pollIndex>
      </IspReadOsccal>
      <PPControlStack>0x0E 0x1E 0x0F 0x1F 0x2E 0x3E 0x2F 0x3F 0x4E 0x5E 0x4F 0x5F 0x6E 0x7E 0x6F 0x7F 0x66 0x76 0x67 0x77 0x6A 0x7A 0x6B 0x7B 0xBE 0xFD 0x00 0x01 0x00 0x00 0x00 0x00</PPControlStack>
      <PpEnterProgMode>
        <stabDelay>100</stabDelay>
        <progModeDelay>0</progModeDelay>
        <latchCycles>6</latchCycles>
        <toggleVtg>0</toggleVtg>
        <powerOffDelay>0</powerOffDelay>
        <resetDelayMs>0</resetDelayMs>
        <resetDelayUs>0</resetDelayUs>
      </PpEnterProgMode>
      <PpLeaveProgMode>
        <stabDelay>15</stabDelay>
        <resetDelay>15</resetDelay>
      </PpLeaveProgMode>
      <PpChipErase>
        <pulseWidth>0</pulseWidth>
        <pollTimeout>10</pollTimeout>
      </PpChipErase>
      <PpProgramFlash>
        <pollTimeout>5</pollTimeout>
        <mode>0x01</mode>
        <blockSize>256</blockSize>
      </PpProgramFlash>
      <PpReadFlash>
        <blockSize>256</blockSize>
      </PpReadFlash>
      <PpProgramEeprom>
        <pollTimeout>5</pollTimeout>
        <mode>0x07</mode>
        <blockSize>256</blockSize>
      </PpProgramEeprom>
      <PpReadEeprom>
        <blockSize>256</blockSize>
      </PpReadEeprom>
      <PpProgramFuse>
        <pulseWidth>0</pulseWidth>
        <pollTimeout>5</pollTimeout>
      </PpProgramFuse>
      <PpProgramLock>
        <pulseWidth>0</pulseWidth>
        <pollTimeout>5</pollTimeout>
      </PpProgramLock>
    </STK600>
    <SIMULATOR2/>
    <AVRONE>
      <ID>0x0970203F</ID>
      <Interface>JTAG</Interface>
    </AVRONE>
  </ICE_SETTINGS>
  <V2>
    <templates>
      <module class="FUSE">
        <registers name="FUSE" memspace="FUSE">
          <reg size="1" name="EXTENDED" offset="0x02">
            <bitfield name="M103C" mask="0x02" text="ATmega103 Compatibility Mode" icon=""/>
            <bitfield name="WDTON" mask="0x01" text="Watchdog Timer always on" icon=""/>
          </reg>
          <reg size="1" name="HIGH" offset="0x01">
            <bitfield name="OCDEN" mask="0x80" text="On-Chip Debug Enabled" icon=""/>
            <bitfield name="JTAGEN" mask="0x40" text="JTAG Interface Enabled" icon=""/>
            <bitfield name="SPIEN" mask="0x20" text="Serial program downloading (SPI) enabled" icon=""/>
            <bitfield name="EESAVE" mask="0x08" text="Preserve EEPROM through the Chip Erase cycle" icon=""/>
            <bitfield name="BOOTSZ" mask="0x06" text="Select Boot Size" icon="" enum="ENUM_BOOTSZ"/>
            <bitfield name="BOOTRST" mask="0x01" text="Boot Reset vector Enabled" icon=""/>
            <bitfield name="CKOPT" mask="0x10" text="CKOPT fuse (operation dependent of CKSEL fuses)" icon=""/>
          </reg>
          <reg size="1" name="LOW" offset="0x00">
            <bitfield name="BODLEVEL" mask="0x80" text="Brown out detector trigger level" icon="" enum="ENUM_BODLEVEL"/>
            <bitfield name="BODEN" mask="0x40" text="Brown-out detection enabled" icon=""/>
            <bitfield name="SUT_CKSEL" mask="0x3F" text="Select Clock Source" icon="" enum="ENUM_SUT_CKSEL"/>
          </reg>
        </registers>
        <enumerator name="ENUM_BODLEVEL">
          <enum val="0x00" text="Brown-out detection level at VCC=4.0 V" constname="4V0"/>
          <enum val="0x01" text="Brown-out detection level at VCC=2.7 V" constname="2V7"/>
        </enumerator>
        <enumerator name="ENUM_SUT_CKSEL">
          <enum val="0x00" text="Ext. Clock; Start-up time: 6 CK + 0 ms" constname="EXTCLK_6CK_0MS"/>
          <enum val="0x10" text="Ext. Clock; Start-up time: 6 CK + 4 ms" constname="EXTCLK_6CK_4MS"/>
          <enum val="0x20" text="Ext. Clock; Start-up time: 6 CK + 64 ms" constname="EXTCLK_6CK_64MS"/>
          <enum val="0x01" text="Int. RC Osc. 1 MHz; Start-up time: 6 CK + 0 ms" constname="INTRCOSC_1MHZ_6CK_0MS"/>
          <enum val="0x11" text="Int. RC Osc. 1 MHz; Start-up time: 6 CK + 4 ms" constname="INTRCOSC_1MHZ_6CK_4MS"/>
          <enum val="0x21" text="Int. RC Osc. 1 MHz; Start-up time: 6 CK + 64 ms" constname="INTRCOSC_1MHZ_6CK_64MS"/>
          <enum val="0x02" text="Int. RC Osc. 2 MHz; Start-up time: 6 CK + 0 ms" constname="INTRCOSC_2MHZ_6CK_0MS"/>
          <enum val="0x12" text="Int. RC Osc. 2 MHz; Start-up time: 6 CK + 4 ms" constname="INTRCOSC_2MHZ_6CK_4MS"/>
          <enum val="0x22" text="Int. RC Osc. 2 MHz; Start-up time: 6 CK + 64 ms" constname="INTRCOSC_2MHZ_6CK_64MS"/>
          <enum val="0x03" text="Int. RC Osc. 4 MHz; Start-up time: 6 CK + 0 ms" constname="INTRCOSC_4MHZ_6CK_0MS"/>
          <enum val="0x13" text="Int. RC Osc. 4 MHz; Start-up time: 6 CK + 4 ms" constname="INTRCOSC_4MHZ_6CK_4MS"/>
          <enum val="0x23" text="Int. RC Osc. 4 MHz; Start-up time: 6 CK + 64 ms" constname="INTRCOSC_4MHZ_6CK_64MS"/>
          <enum val="0x04" text="Int. RC Osc. 8 MHz; Start-up time: 6 CK + 0 ms" constname="INTRCOSC_8MHZ_6CK_0MS"/>
          <enum val="0x14" text="Int. RC Osc. 8 MHz; Start-up time: 6 CK + 4 ms" constname="INTRCOSC_8MHZ_6CK_4MS"/>
          <enum val="0x24" text="Int. RC Osc. 8 MHz; Start-up time: 6 CK + 64 ms" constname="INTRCOSC_8MHZ_6CK_64MS"/>
          <enum val="0x05" text="Ext. RC Osc.         -  0.9 MHz; Start-up time: 18 CK + 0 ms" constname="EXTRCOSC_XX_0MHZ9_18CK_0MS"/>
          <enum val="0x15" text="Ext. RC Osc.         -  0.9 MHz; Start-up time: 18 CK + 4 ms" constname="EXTRCOSC_XX_0MHZ9_18CK_4MS"/>
          <enum val="0x25" text="Ext. RC Osc.         -  0.9 MHz; Start-up time: 18 CK + 64 ms" constname="EXTRCOSC_XX_0MHZ9_18CK_64MS"/>
          <enum val="0x35" text="Ext. RC Osc.         -  0.9 MHz; Start-up time: 6 CK + 4 ms" constname="EXTRCOSC_XX_0MHZ9_6CK_4MS"/>
          <enum val="0x06" text="Ext. RC Osc. 0.9 MHz -  3.0 MHz; Start-up time: 18 CK + 0 ms" constname="EXTRCOSC_0MHZ9_3MHZ_18CK_0MS"/>
          <enum val="0x16" text="Ext. RC Osc. 0.9 MHz -  3.0 MHz; Start-up time: 18 CK + 4 ms" constname="EXTRCOSC_0MHZ9_3MHZ_18CK_4MS"/>
          <enum val="0x26" text="Ext. RC Osc. 0.9 MHz -  3.0 MHz; Start-up time: 18 CK + 64 ms" constname="EXTRCOSC_0MHZ9_3MHZ_18CK_64MS"/>
          <enum val="0x36" text="Ext. RC Osc. 0.9 MHz -  3.0 MHz; Start-up time: 6 CK + 4 ms" constname="EXTRCOSC_0MHZ9_3MHZ_6CK_4MS"/>
          <enum val="0x07" text="Ext. RC Osc. 3.0 MHz -  8.0 MHz; Start-up time: 18 CK + 0 ms" constname="EXTRCOSC_3MHZ_8MHZ_18CK_0MS"/>
          <enum val="0x17" text="Ext. RC Osc. 3.0 MHz -  8.0 MHz; Start-up time: 18 CK + 4 ms" constname="EXTRCOSC_3MHZ_8MHZ_18CK_4MS"/>
          <enum val="0x27" text="Ext. RC Osc. 3.0 MHz -  8.0 MHz; Start-up time: 18 CK + 64 ms" constname="EXTRCOSC_3MHZ_8MHZ_18CK_64MS"/>
          <enum val="0x37" text="Ext. RC Osc. 3.0 MHz -  8.0 MHz; Start-up time: 6 CK + 4 ms" constname="EXTRCOSC_3MHZ_8MHZ_6CK_4MS"/>
          <enum val="0x08" text="Ext. RC Osc. 8.0 MHz - 12.0 MHz; Start-up time: 18 CK + 0 ms" constname="EXTRCOSC_8MHZ_12MHZ_18CK_0MS"/>
          <enum val="0x18" text="Ext. RC Osc. 8.0 MHz - 12.0 MHz; Start-up time: 18 CK + 4 ms" constname="EXTRCOSC_8MHZ_12MHZ_18CK_4MS"/>
          <enum val="0x28" text="Ext. RC Osc. 8.0 MHz - 12.0 MHz; Start-up time: 18 CK + 64 ms" constname="EXTRCOSC_8MHZ_12MHZ_18CK_64MS"/>
          <enum val="0x38" text="Ext. RC Osc. 8.0 MHz - 12.0 MHz; Start-up time: 6 CK + 4 ms" constname="EXTRCOSC_8MHZ_12MHZ_6CK_4MS"/>
          <enum val="0x09" text="Ext. Low-Freq. Crystal; Start-up time: 1K CK + 4 ms" constname="EXTLOFXTAL_1KCK_4MS"/>
          <enum val="0x19" text="Ext. Low-Freq. Crystal; Start-up time: 1K CK + 64 ms" constname="EXTLOFXTAL_1KCK_64MS"/>
          <enum val="0x29" text="Ext. Low-Freq. Crystal; Start-up time: 32K CK + 64 ms" constname="EXTLOFXTAL_32KCK_64MS"/>
          <enum val="0x0A" text="Ext. Crystal/Resonator Low Freq.; Start-up time: 258 CK + 4 ms" constname="EXTLOFXTALRES_258CK_4MS"/>
          <enum val="0x1A" text="Ext. Crystal/Resonator Low Freq.; Start-up time: 258 CK + 64 ms" constname="EXTLOFXTALRES_258CK_64MS"/>
          <enum val="0x2A" text="Ext. Crystal/Resonator Low Freq.; Start-up time: 1K CK + 0 ms" constname="EXTLOFXTALRES_1KCK_0MS"/>
          <enum val="0x3A" text="Ext. Crystal/Resonator Low Freq.; Start-up time: 1K CK + 4 ms" constname="EXTLOFXTALRES_1KCK_4MS"/>
          <enum val="0x0B" text="Ext. Crystal/Resonator Low Freq.; Start-up time: 1K CK + 64 ms" constname="EXTLOFXTALRES_1KCK_64MS"/>
          <enum val="0x1B" text="Ext. Crystal/Resonator Low Freq.; Start-up time: 16K CK + 0 ms" constname="EXTLOFXTALRES_16KCK_0MS"/>
          <enum val="0x2B" text="Ext. Crystal/Resonator Low Freq.; Start-up time: 16K CK + 4 ms" constname="EXTLOFXTALRES_16KCK_4MS"/>
          <enum val="0x3B" text="Ext. Crystal/Resonator Low Freq.; Start-up time: 16K CK + 64 ms" constname="EXTLOFXTALRES_16KCK_64MS"/>
          <enum val="0x0C" text="Ext. Crystal/Resonator Medium Freq.; Start-up time: 258 CK + 4 ms" constname="EXTMEDFXTALRES_258CK_4MS"/>
          <enum val="0x1C" text="Ext. Crystal/Resonator Medium Freq.; Start-up time: 258 CK + 64 ms" constname="EXTMEDFXTALRES_258CK_64MS"/>
          <enum val="0x2C" text="Ext. Crystal/Resonator Medium Freq.; Start-up time: 1K CK + 0 ms" constname="EXTMEDFXTALRES_1KCK_0MS"/>
          <enum val="0x3C" text="Ext. Crystal/Resonator Medium Freq.; Start-up time: 1K CK + 4 ms" constname="EXTMEDFXTALRES_1KCK_4MS"/>
          <enum val="0x0D" text="Ext. Crystal/Resonator Medium Freq.; Start-up time: 1K CK + 64 ms" constname="EXTMEDFXTALRES_1KCK_64MS"/>
          <enum val="0x1D" text="Ext. Crystal/Resonator Medium Freq.; Start-up time: 16K CK + 0 ms" constname="EXTMEDFXTALRES_16KCK_0MS"/>
          <enum val="0x2D" text="Ext. Crystal/Resonator Medium Freq.; Start-up time: 16K CK + 4 ms" constname="EXTMEDFXTALRES_16KCK_4MS"/>
          <enum val="0x3D" text="Ext. Crystal/Resonator Medium Freq.; Start-up time: 16K CK + 64 ms" constname="EXTMEDFXTALRES_16KCK_64MS"/>
          <enum val="0x0E" text="Ext. Crystal/Resonator High Freq.; Start-up time: 258 CK + 4 ms" constname="EXTHIFXTALRES_258CK_4MS"/>
          <enum val="0x1E" text="Ext. Crystal/Resonator High Freq.; Start-up time: 258 CK + 64 ms" constname="EXTHIFXTALRES_258CK_64MS"/>
          <enum val="0x2E" text="Ext. Crystal/Resonator High Freq.; Start-up time: 1K CK + 0 ms" constname="EXTHIFXTALRES_1KCK_0MS"/>
          <enum val="0x3E" text="Ext. Crystal/Resonator High Freq.; Start-up time: 1K CK + 4 ms" constname="EXTHIFXTALRES_1KCK_4MS"/>
          <enum val="0x0F" text="Ext. Crystal/Resonator High Freq.; Start-up time: 1K CK + 64 ms" constname="EXTHIFXTALRES_1KCK_64MS"/>
          <enum val="0x1F" text="Ext. Crystal/Resonator High Freq.; Start-up time: 16K CK + 0 ms" constname="EXTHIFXTALRES_16KCK_0MS"/>
          <enum val="0x2F" text="Ext. Crystal/Resonator High Freq.; Start-up time: 16K CK + 4 ms" constname="EXTHIFXTALRES_16KCK_4MS"/>
          <enum val="0x3F" text="Ext. Crystal/Resonator High Freq.; Start-up time: 16K CK + 64 ms" constname="EXTHIFXTALRES_16KCK_64MS"/>
        </enumerator>
        <enumerator name="ENUM_BOOTSZ">
          <enum val="0x03" text="Boot Flash size=512 words start address=$FE00" constname="512W_FE00"/>
          <enum val="0x02" text="Boot Flash size=1024 words start address=$FC00" constname="1024W_FC00"/>
          <enum val="0x01" text="Boot Flashsize=2048 words start address=$F800" constname="2048W_F800"/>
          <enum val="0x00" text="Boot Flash size=4096 words start address=$F000" constname="4096W_F000"/>
        </enumerator>
      </module>
      <module class="LOCKBIT">
        <registers name="LOCKBIT" memspace="LOCKBIT">
          <reg size="1" name="LOCKBIT" offset="0x00">
            <bitfield name="LB" mask="0x03" text="Memory Lock" icon="" enum="ENUM_LB"/>
            <bitfield name="BLB0" mask="0x0C" text="Boot Loader Protection Mode" icon="" enum="ENUM_BLB"/>
            <bitfield name="BLB1" mask="0x30" text="Boot Loader Protection Mode" icon="" enum="ENUM_BLB2"/>
          </reg>
        </registers>
        <enumerator name="ENUM_LB">
          <enum val="0x00" text="Further programming and verification disabled" constname="PROG_VER_DISABLED"/>
          <enum val="0x02" text="Further programming disabled" constname="PROG_DISABLED"/>
          <enum val="0x03" text="No memory lock features enabled" constname="NO_LOCK"/>
        </enumerator>
        <enumerator name="ENUM_BLB">
          <enum val="0x00" text="LPM and SPM prohibited in Application Section" constname="LPM_SPM_DISABLE"/>
          <enum val="0x01" text="LPM prohibited in Application Section" constname="LPM_DISABLE"/>
          <enum val="0x02" text="SPM prohibited in Application Section" constname="SPM_DISABLE"/>
          <enum val="0x03" text="No lock on SPM and LPM in Application Section" constname="NO_LOCK"/>
        </enumerator>
        <enumerator name="ENUM_BLB2">
          <enum val="0x00" text="LPM and SPM prohibited in Boot Section" constname="LPM_SPM_DISABLE"/>
          <enum val="0x01" text="LPM prohibited in Boot Section" constname="LPM_DISABLE"/>
          <enum val="0x02" text="SPM prohibited in Boot Section" constname="SPM_DISABLE"/>
          <enum val="0x03" text="No lock on SPM and LPM in Boot Section" constname="NO_LOCK"/>
        </enumerator>
      </module>
      <module class="ANALOG_COMPARATOR" text="">
        <registers name="ANALOG_COMPARATOR" memspace="DATAMEM" text="" icon="io_analo.bmp">
          <reg size="1" name="SFIOR" offset="0x40" text="Special Function IO Register" icon="io_flag.bmp">
            <bitfield name="ACME" mask="0x08" text="Analog Comparator Multiplexer Enable" icon=""/>
          </reg>
          <reg size="1" name="ACSR" offset="0x28" text="Analog Comparator Control And Status Register" icon="io_analo.bmp">
            <bitfield name="ACD" mask="0x80" text="Analog Comparator Disable" icon=""/>
            <bitfield name="ACBG" mask="0x40" text="Analog Comparator Bandgap Select" icon=""/>
            <bitfield name="ACO" mask="0x20" text="Analog Compare Output" icon=""/>
            <bitfield name="ACI" mask="0x10" text="Analog Comparator Interrupt Flag" icon=""/>
            <bitfield name="ACIE" mask="0x08" text="Analog Comparator Interrupt Enable" icon=""/>
            <bitfield name="ACIC" mask="0x04" text="Analog Comparator Input Capture Enable" icon=""/>
            <bitfield name="ACIS" mask="0x03" text="Analog Comparator Interrupt Mode Select bits" icon="" enum="ANALOG_COMP_INTERRUPT"/>
          </reg>
        </registers>
        <enumerator name="ANALOG_COMP_INTERRUPT">
          <enum val="0x00" text="Interrupt on Toggle"/>
          <enum val="0x01" text="Reserved"/>
          <enum val="0x02" text="Interrupt on Falling Edge"/>
          <enum val="0x03" text="Interrupt on Rising Edge"/>
        </enumerator>
      </module>
      <module class="SPI" text="">
        <registers name="SPI" memspace="DATAMEM" text="" icon="io_com.bmp">
          <reg size="1" name="SPDR" offset="0x2F" text="SPI Data Register" icon="io_com.bmp" mask="0xFF"/>
          <reg size="1" name="SPSR" offset="0x2E" text="SPI Status Register" icon="io_flag.bmp">
            <bitfield name="SPIF" mask="0x80" text="SPI Interrupt Flag" icon=""/>
            <bitfield name="WCOL" mask="0x40" text="Write Collision Flag" icon=""/>
            <bitfield name="SPI2X" mask="0x01" text="Double SPI Speed Bit" icon=""/>
          </reg>
          <reg size="1" name="SPCR" offset="0x2D" text="SPI Control Register" icon="io_flag.bmp">
            <bitfield name="SPIE" mask="0x80" text="SPI Interrupt Enable" icon=""/>
            <bitfield name="SPE" mask="0x40" text="SPI Enable" icon=""/>
            <bitfield name="DORD" mask="0x20" text="Data Order" icon=""/>
            <bitfield name="MSTR" mask="0x10" text="Master/Slave Select" icon=""/>
            <bitfield name="CPOL" mask="0x08" text="Clock polarity" icon=""/>
            <bitfield name="CPHA" mask="0x04" text="Clock Phase" icon=""/>
            <bitfield name="SPR" mask="0x03" text="SPI Clock Rate Selects" icon="" enum="COMM_SCK_RATE_3BIT"/>
          </reg>
        </registers>
        <enumerator name="COMM_SCK_RATE_3BIT">
          <enum val="0x00" text="fosc/4"/>
          <enum val="0x01" text="fosc/16"/>
          <enum val="0x02" text="fosc/64"/>
          <enum val="0x03" text="fosc/128"/>
          <enum val="0x04" text="fosc/2"/>
          <enum val="0x05" text="fosc/8"/>
          <enum val="0x06" text="fosc/32"/>
          <enum val="0x07" text="fosc/64"/>
        </enumerator>
      </module>
      <module class="TWI" text="">
        <registers name="TWI" memspace="DATAMEM" text="" icon="io_com.bmp">
          <reg size="1" name="TWBR" offset="0x70" text="TWI Bit Rate register" icon="io_com.bmp" mask="0xFF"/>
          <reg size="1" name="TWCR" offset="0x74" text="TWI Control Register" icon="io_flag.bmp">
            <bitfield name="TWINT" mask="0x80" text="TWI Interrupt Flag" icon=""/>
            <bitfield name="TWEA" mask="0x40" text="TWI Enable Acknowledge Bit" icon=""/>
            <bitfield name="TWSTA" mask="0x20" text="TWI Start Condition Bit" icon=""/>
            <bitfield name="TWSTO" mask="0x10" text="TWI Stop Condition Bit" icon=""/>
            <bitfield name="TWWC" mask="0x08" text="TWI Write Collition Flag" icon=""/>
            <bitfield name="TWEN" mask="0x04" text="TWI Enable Bit" icon=""/>
            <bitfield name="TWIE" mask="0x01" text="TWI Interrupt Enable" icon=""/>
          </reg>
          <reg size="1" name="TWSR" offset="0x71" text="TWI Status Register" icon="io_flag.bmp">
            <bitfield name="TWS" mask="0xF8" text="TWI Status" icon="" lsb="3"/>
            <bitfield name="TWPS" mask="0x03" text="TWI Prescaler" icon="" enum="COMM_TWI_PRESACLE"/>
          </reg>
          <reg size="1" name="TWDR" offset="0x73" text="TWI Data register" icon="io_com.bmp" mask="0xFF"/>
          <reg size="1" name="TWAR" offset="0x72" text="TWI (Slave) Address register" icon="io_com.bmp">
            <bitfield name="TWA" mask="0xFE" text="TWI (Slave) Address register Bits" icon=""/>
            <bitfield name="TWGCE" mask="0x01" text="TWI General Call Recognition Enable Bit" icon=""/>
          </reg>
        </registers>
        <enumerator name="COMM_TWI_PRESACLE">
          <enum val="0x00" text="1"/>
          <enum val="0x01" text="4"/>
          <enum val="0x02" text="16"/>
          <enum val="0x03" text="64"/>
        </enumerator>
      </module>
      <module class="USART0" text="">
        <registers name="USART0" memspace="DATAMEM" text="" icon="io_com.bmp">
          <reg size="1" name="UDR0" offset="0x2C" text="USART I/O Data Register" icon="io_com.bmp" mask="0xFF"/>
          <reg size="1" name="UCSR0A" offset="0x2B" text="USART Control and Status Register A" icon="io_flag.bmp">
            <bitfield name="RXC0" mask="0x80" text="USART Receive Complete" icon=""/>
            <bitfield name="TXC0" mask="0x40" text="USART Transmitt Complete" icon=""/>
            <bitfield name="UDRE0" mask="0x20" text="USART Data Register Empty" icon=""/>
            <bitfield name="FE0" mask="0x10" text="Framing Error" icon=""/>
            <bitfield name="DOR0" mask="0x08" text="Data overRun" icon=""/>
            <bitfield name="UPE0" mask="0x04" text="Parity Error" icon=""/>
            <bitfield name="U2X0" mask="0x02" text="Double the USART transmission speed" icon=""/>
            <bitfield name="MPCM0" mask="0x01" text="Multi-processor Communication Mode" icon=""/>
          </reg>
          <reg size="1" name="UCSR0B" offset="0x2A" text="USART Control and Status Register B" icon="io_flag.bmp">
            <bitfield name="RXCIE0" mask="0x80" text="RX Complete Interrupt Enable" icon=""/>
            <bitfield name="TXCIE0" mask="0x40" text="TX Complete Interrupt Enable" icon=""/>
            <bitfield name="UDRIE0" mask="0x20" text="USART Data register Empty Interrupt Enable" icon=""/>
            <bitfield name="RXEN0" mask="0x10" text="Receiver Enable" icon=""/>
            <bitfield name="TXEN0" mask="0x08" text="Transmitter Enable" icon=""/>
            <bitfield name="UCSZ02" mask="0x04" text="Character Size" icon=""/>
            <bitfield name="RXB80" mask="0x02" text="Receive Data Bit 8" icon=""/>
            <bitfield name="TXB80" mask="0x01" text="Transmit Data Bit 8" icon=""/>
          </reg>
          <reg size="1" name="UCSR0C" offset="0x95" text="USART Control and Status Register C" icon="io_flag.bmp">
            <bitfield name="UMSEL0" mask="0x40" text="USART Mode Select" icon="" enum="COMM_USART_MODE"/>
            <bitfield name="UPM0" mask="0x30" text="Parity Mode Bits" icon="" enum="COMM_UPM_PARITY_MODE"/>
            <bitfield name="USBS0" mask="0x08" text="Stop Bit Select" icon="" enum="COMM_STOP_BIT_SEL"/>
            <bitfield name="UCSZ0" mask="0x06" text="Character Size" icon=""/>
            <bitfield name="UCPOL0" mask="0x01" text="Clock Polarity" icon=""/>
          </reg>
          <reg size="1" name="UBRR0H" offset="0x90" text="USART Baud Rate Register Hight Byte" icon="io_com.bmp" mask="0x0F"/>
          <reg size="1" name="UBRR0L" offset="0x29" text="USART Baud Rate Register Low Byte" icon="io_com.bmp" mask="0xFF"/>
        </registers>
        <enumerator name="COMM_USART_MODE">
          <enum val="0x00" text="Asynchronous Operation"/>
          <enum val="0x01" text="Synchronous Operation"/>
        </enumerator>
        <enumerator name="COMM_UPM_PARITY_MODE">
          <enum val="0x00" text="Disabled"/>
          <enum val="0x01" text="Reserved"/>
          <enum val="0x02" text="Enabled, Even Parity"/>
          <enum val="0x03" text="Enabled, Odd Parity"/>
        </enumerator>
        <enumerator name="COMM_STOP_BIT_SEL">
          <enum val="0x00" text="1-bit"/>
          <enum val="0x01" text="2-bit"/>
        </enumerator>
      </module>
      <module class="USART1" text="">
        <registers name="USART1" memspace="DATAMEM" text="" icon="io_com.bmp">
          <reg size="1" name="UDR1" offset="0x9C" text="USART I/O Data Register" icon="io_com.bmp" mask="0xFF"/>
          <reg size="1" name="UCSR1A" offset="0x9B" text="USART Control and Status Register A" icon="io_flag.bmp">
            <bitfield name="RXC1" mask="0x80" text="USART Receive Complete" icon=""/>
            <bitfield name="TXC1" mask="0x40" text="USART Transmitt Complete" icon=""/>
            <bitfield name="UDRE1" mask="0x20" text="USART Data Register Empty" icon=""/>
            <bitfield name="FE1" mask="0x10" text="Framing Error" icon=""/>
            <bitfield name="DOR1" mask="0x08" text="Data overRun" icon=""/>
            <bitfield name="UPE1" mask="0x04" text="Parity Error" icon=""/>
            <bitfield name="U2X1" mask="0x02" text="Double the USART transmission speed" icon=""/>
            <bitfield name="MPCM1" mask="0x01" text="Multi-processor Communication Mode" icon=""/>
          </reg>
          <reg size="1" name="UCSR1B" offset="0x9A" text="USART Control and Status Register B" icon="io_flag.bmp">
            <bitfield name="RXCIE1" mask="0x80" text="RX Complete Interrupt Enable" icon=""/>
            <bitfield name="TXCIE1" mask="0x40" text="TX Complete Interrupt Enable" icon=""/>
            <bitfield name="UDRIE1" mask="0x20" text="USART Data register Empty Interrupt Enable" icon=""/>
            <bitfield name="RXEN1" mask="0x10" text="Receiver Enable" icon=""/>
            <bitfield name="TXEN1" mask="0x08" text="Transmitter Enable" icon=""/>
            <bitfield name="UCSZ12" mask="0x04" text="Character Size" icon=""/>
            <bitfield name="RXB81" mask="0x02" text="Receive Data Bit 8" icon=""/>
            <bitfield name="TXB81" mask="0x01" text="Transmit Data Bit 8" icon=""/>
          </reg>
          <reg size="1" name="UCSR1C" offset="0x9D" text="USART Control and Status Register C" icon="io_flag.bmp">
            <bitfield name="UMSEL1" mask="0x40" text="USART Mode Select" icon="" enum="COMM_USART_MODE"/>
            <bitfield name="UPM1" mask="0x30" text="Parity Mode Bits" icon="" enum="COMM_UPM_PARITY_MODE"/>
            <bitfield name="USBS1" mask="0x08" text="Stop Bit Select" icon="" enum="COMM_STOP_BIT_SEL"/>
            <bitfield name="UCSZ1" mask="0x06" text="Character Size" icon=""/>
            <bitfield name="UCPOL1" mask="0x01" text="Clock Polarity" icon=""/>
          </reg>
          <reg size="1" name="UBRR1H" offset="0x98" text="USART Baud Rate Register Hight Byte" icon="io_com.bmp" mask="0x0F"/>
          <reg size="1" name="UBRR1L" offset="0x99" text="USART Baud Rate Register Low Byte" icon="io_com.bmp" mask="0xFF"/>
        </registers>
        <enumerator name="COMM_USART_MODE">
          <enum val="0x00" text="Asynchronous Operation"/>
          <enum val="0x01" text="Synchronous Operation"/>
        </enumerator>
        <enumerator name="COMM_UPM_PARITY_MODE">
          <enum val="0x00" text="Disabled"/>
          <enum val="0x01" text="Reserved"/>
          <enum val="0x02" text="Enabled, Even Parity"/>
          <enum val="0x03" text="Enabled, Odd Parity"/>
        </enumerator>
        <enumerator name="COMM_STOP_BIT_SEL">
          <enum val="0x00" text="1-bit"/>
          <enum val="0x01" text="2-bit"/>
        </enumerator>
      </module>
      <module class="CPU" text="">
        <registers name="CPU" memspace="DATAMEM" text="" icon="io_cpu.bmp">
          <reg size="1" name="SREG" offset="0x5F" text="Status Register" icon="io_sreg.bmp">
            <bitfield name="I" mask="0x80" text="Global Interrupt Enable" icon=""/>
            <bitfield name="T" mask="0x40" text="Bit Copy Storage" icon=""/>
            <bitfield name="H" mask="0x20" text="Half Carry Flag" icon=""/>
            <bitfield name="S" mask="0x10" text="Sign Bit" icon=""/>
            <bitfield name="V" mask="0x08" text="Two's Complement Overflow Flag" icon=""/>
            <bitfield name="N" mask="0x04" text="Negative Flag" icon=""/>
            <bitfield name="Z" mask="0x02" text="Zero Flag" icon=""/>
            <bitfield name="C" mask="0x01" text="Carry Flag" icon=""/>
          </reg>
          <reg size="2" name="SP" offset="0x5D" text="Stack Pointer " icon="io_sph.bmp" mask="0xFFFF"/>
          <reg size="1" name="MCUCR" offset="0x55" text="MCU Control Register" icon="io_flag.bmp">
            <bitfield name="SRE" mask="0x80" text="External SRAM Enable" icon=""/>
            <bitfield name="SRW10" mask="0x40" text="External SRAM Wait State Select" icon=""/>
            <bitfield name="SE" mask="0x20" text="Sleep Enable" icon=""/>
            <bitfield name="SM" mask="0x18" text="Sleep Mode Select" icon=""/>
            <bitfield name="SM2" mask="0x04" text="Sleep Mode Select" icon=""/>
            <bitfield name="IVSEL" mask="0x02" text="Interrupt Vector Select" icon=""/>
            <bitfield name="IVCE" mask="0x01" text="Interrupt Vector Change Enable" icon=""/>
          </reg>
          <reg size="1" name="MCUCSR" offset="0x54" text="MCU Control And Status Register" icon="io_flag.bmp">
            <bitfield name="JTD" mask="0x80" text="JTAG Interface Disable" icon=""/>
            <bitfield name="JTRF" mask="0x10" text="JTAG Reset Flag" icon=""/>
            <bitfield name="WDRF" mask="0x08" text="Watchdog Reset Flag" icon=""/>
            <bitfield name="BORF" mask="0x04" text="Brown-out Reset Flag" icon=""/>
            <bitfield name="EXTRF" mask="0x02" text="External Reset Flag" icon=""/>
            <bitfield name="PORF" mask="0x01" text="Power-on reset flag" icon=""/>
          </reg>
          <reg size="1" name="XMCRA" offset="0x6D" text="External Memory Control Register A" icon="io_cpu.bmp">
            <bitfield name="SRL" mask="0x70" text="Wait state page limit" icon="" enum="CPU_SECTOR_LIMITS"/>
            <bitfield name="SRW0" mask="0x0C" text="Wait state select bit lower page" icon="" enum="CPU_WAIT_STATES"/>
            <bitfield name="SRW11" mask="0x02" text="Wait state select bit upper page" icon=""/>
          </reg>
          <reg size="1" name="XMCRB" offset="0x6C" text="External Memory Control Register B" icon="io_cpu.bmp">
            <bitfield name="XMBK" mask="0x80" text="External Memory Bus Keeper Enable" icon=""/>
            <bitfield name="XMM" mask="0x07" text="External Memory High Mask" icon=""/>
          </reg>
          <reg size="1" name="OSCCAL" offset="0x6F" text="Oscillator Calibration Value" icon="io_cpu.bmp" mask="0xFF"/>
          <reg size="1" name="XDIV" offset="0x5C" text="XTAL Divide Control Register" icon="io_cpu.bmp" mask="0xFF"/>
          <reg size="1" name="RAMPZ" offset="0x5B" text="RAM Page Z Select Register" icon="io_cpu.bmp">
            <bitfield name="RAMPZ0" mask="0x01" text="RAM Page Z Select Register Bit 0" icon=""/>
          </reg>
        </registers>
        <enumerator name="CPU_SECTOR_LIMITS">
          <enum val="0x00" text="LS = N/A, US = 0x1100 - 0xFFFF"/>
          <enum val="0x01" text="LS = 0x1100 - 0x1FFF, US = 0x2000 - 0xFFFF"/>
          <enum val="0x02" text="LS = 0x1100 - 0x3FFF, US = 0x4000 - 0xFFFF"/>
          <enum val="0x03" text="LS = 0x1100 - 0x5FFF, US = 0x6000 - 0xFFFF"/>
          <enum val="0x04" text="LS = 0x1100 - 0x7FFF, US = 0x8000 - 0xFFFF"/>
          <enum val="0x05" text="LS = 0x1100 - 0x9FFF, US = 0xA000 - 0xFFFF"/>
          <enum val="0x06" text="LS = 0x1100 - 0xBFFF, US = 0xC000 - 0xFFFF"/>
          <enum val="0x07" text="LS = 0x1100 - 0xDFFF, US = 0xE000 - 0xFFFF"/>
        </enumerator>
        <enumerator name="CPU_WAIT_STATES">
          <enum val="0x00" text="No wait-states"/>
          <enum val="0x01" text="Wait one cycle during read/write strobe"/>
          <enum val="0x02" text="Wait two cycles during read/write strobe"/>
          <enum val="0x03" text="Wait two cycles during read/write and wait one cycle before driving out new address"/>
        </enumerator>
      </module>
      <module class="BOOT_LOAD" text="">
        <registers name="BOOT_LOAD" memspace="DATAMEM" text="" icon="io_cpu.bmp">
          <reg size="1" name="SPMCSR" offset="0x68" text="Store Program Memory Control Register" icon="io_flag.bmp">
            <bitfield name="SPMIE" mask="0x80" text="SPM Interrupt Enable" icon=""/>
            <bitfield name="RWWSB" mask="0x40" text="Read While Write Section Busy" icon=""/>
            <bitfield name="RWWSRE" mask="0x10" text="Read While Write section read enable" icon=""/>
            <bitfield name="BLBSET" mask="0x08" text="Boot Lock Bit Set" icon=""/>
            <bitfield name="PGWRT" mask="0x04" text="Page Write" icon=""/>
            <bitfield name="PGERS" mask="0x02" text="Page Erase" icon=""/>
            <bitfield name="SPMEN" mask="0x01" text="Store Program Memory Enable" icon=""/>
          </reg>
        </registers>
      </module>
      <module class="JTAG" text="">
        <registers name="JTAG" memspace="DATAMEM" text="" icon="io_com.bmp">
          <reg size="1" name="OCDR" offset="0x42" text="On-Chip Debug Related Register in I/O Memory" icon="io_com.bmp">
            <bitfield name="OCDR" mask="0xFF" text="On-Chip Debug Register Bits" icon=""/>
          </reg>
          <reg size="1" name="MCUCSR" offset="0x54" text="MCU Control And Status Register" icon="io_flag.bmp">
            <bitfield name="JTD" mask="0x80" text="JTAG Interface Disable" icon=""/>
            <bitfield name="JTRF" mask="0x10" text="JTAG Reset Flag" icon=""/>
          </reg>
        </registers>
      </module>
      <module class="MISC" text="">
        <registers name="MISC" memspace="DATAMEM" text="" icon="io_cpu.bmp">
          <reg size="1" name="SFIOR" offset="0x40" text="Special Function IO Register" icon="io_flag.bmp">
            <bitfield name="TSM" mask="0x80" text="Timer/Counter Synchronization Mode" icon=""/>
            <bitfield name="ACME" mask="0x08" text="Analog Comparator Multiplexer Enable" icon=""/>
            <bitfield name="PUD" mask="0x04" text="Pull Up Disable" icon=""/>
            <bitfield name="PSR0" mask="0x02" text="Prescaler Reset Timer/Counter0" icon=""/>
            <bitfield name="PSR321" mask="0x01" text="Prescaler Reset Timer/Counter3, Timer/Counter2, and Timer/Counter1" icon=""/>
          </reg>
        </registers>
      </module>
      <module class="EXTERNAL_INTERRUPT" text="">
        <registers name="EXTERNAL_INTERRUPT" memspace="DATAMEM" text="" icon="io_ext.bmp">
          <reg size="1" name="EICRA" offset="0x6A" text="External Interrupt Control Register A" icon="io_flag.bmp">
            <bitfield name="ISC3" mask="0xC0" text="External Interrupt Sense Control Bit" icon="" enum="INTERRUPT_SENSE_CONTROL"/>
            <bitfield name="ISC2" mask="0x30" text="External Interrupt Sense Control Bit" icon="" enum="INTERRUPT_SENSE_CONTROL"/>
            <bitfield name="ISC1" mask="0x0C" text="External Interrupt Sense Control Bit" icon="" enum="INTERRUPT_SENSE_CONTROL"/>
            <bitfield name="ISC0" mask="0x03" text="External Interrupt Sense Control Bit" icon="" enum="INTERRUPT_SENSE_CONTROL"/>
          </reg>
          <reg size="1" name="EICRB" offset="0x5A" text="External Interrupt Control Register B" icon="io_flag.bmp">
            <bitfield name="ISC7" mask="0xC0" text="External Interrupt 7-4 Sense Control Bit" icon="" enum="INTERRUPT_SENSE_CONTROL"/>
            <bitfield name="ISC6" mask="0x30" text="External Interrupt 7-4 Sense Control Bit" icon="" enum="INTERRUPT_SENSE_CONTROL"/>
            <bitfield name="ISC5" mask="0x0C" text="External Interrupt 7-4 Sense Control Bit" icon="" enum="INTERRUPT_SENSE_CONTROL"/>
            <bitfield name="ISC4" mask="0x03" text="External Interrupt 7-4 Sense Control Bit" icon="" enum="INTERRUPT_SENSE_CONTROL"/>
          </reg>
          <reg size="1" name="EIMSK" offset="0x59" text="External Interrupt Mask Register" icon="io_flag.bmp">
            <bitfield name="INT" mask="0xFF" text="External Interrupt Request 7 Enable" icon=""/>
          </reg>
          <reg size="1" name="EIFR" offset="0x58" text="External Interrupt Flag Register" icon="io_flag.bmp">
            <bitfield name="INTF" mask="0xFF" text="External Interrupt Flags" icon=""/>
          </reg>
        </registers>
        <enumerator name="INTERRUPT_SENSE_CONTROL">
          <enum val="0x00" text="Low Level of INTX"/>
          <enum val="0x01" text="Reserved"/>
          <enum val="0x02" text="Falling Edge of INTX"/>
          <enum val="0x03" text="Rising Edge of INTX"/>
        </enumerator>
      </module>
      <module class="EEPROM" text="">
        <registers name="EEPROM" memspace="DATAMEM" text="" icon="io_cpu.bmp">
          <reg size="2" name="EEAR" offset="0x3E" text="EEPROM Read/Write Access  Bytes" icon="io_cpu.bmp" mask="0x0FFF"/>
          <reg size="1" name="EEDR" offset="0x3D" text="EEPROM Data Register" icon="io_cpu.bmp" mask="0xFF"/>
          <reg size="1" name="EECR" offset="0x3C" text="EEPROM Control Register" icon="io_flag.bmp">
            <bitfield name="EERIE" mask="0x08" text="EEPROM Ready Interrupt Enable" icon=""/>
            <bitfield name="EEMWE" mask="0x04" text="EEPROM Master Write Enable" icon=""/>
            <bitfield name="EEWE" mask="0x02" text="EEPROM Write Enable" icon=""/>
            <bitfield name="EERE" mask="0x01" text="EEPROM Read Enable" icon=""/>
          </reg>
        </registers>
      </module>
      <module class="PORTA" text="">
        <registers name="PORTA" memspace="DATAMEM" text="" icon="io_port.bmp">
          <reg size="1" name="PORTA" offset="0x3B" text="Port A Data Register" icon="io_port.bmp" mask="0xFF"/>
          <reg size="1" name="DDRA" offset="0x3A" text="Port A Data Direction Register" icon="io_flag.bmp" mask="0xFF"/>
          <reg size="1" name="PINA" offset="0x39" text="Port A Input Pins" icon="io_port.bmp" mask="0xFF"/>
        </registers>
      </module>
      <module class="PORTB" text="">
        <registers name="PORTB" memspace="DATAMEM" text="" icon="io_port.bmp">
          <reg size="1" name="PORTB" offset="0x38" text="Port B Data Register" icon="io_port.bmp" mask="0xFF"/>
          <reg size="1" name="DDRB" offset="0x37" text="Port B Data Direction Register" icon="io_flag.bmp" mask="0xFF"/>
          <reg size="1" name="PINB" offset="0x36" text="Port B Input Pins" icon="io_port.bmp" mask="0xFF"/>
        </registers>
      </module>
      <module class="PORTC" text="">
        <registers name="PORTC" memspace="DATAMEM" text="" icon="io_port.bmp">
          <reg size="1" name="PORTC" offset="0x35" text="Port C Data Register" icon="io_port.bmp" mask="0xFF"/>
          <reg size="1" name="DDRC" offset="0x34" text="Port C Data Direction Register" icon="io_flag.bmp" mask="0xFF"/>
          <reg size="1" name="PINC" offset="0x33" text="Port C Input Pins" icon="io_port.bmp" mask="0xFF"/>
        </registers>
      </module>
      <module class="PORTD" text="">
        <registers name="PORTD" memspace="DATAMEM" text="" icon="io_port.bmp">
          <reg size="1" name="PORTD" offset="0x32" text="Port D Data Register" icon="io_port.bmp" mask="0xFF"/>
          <reg size="1" name="DDRD" offset="0x31" text="Port D Data Direction Register" icon="io_flag.bmp" mask="0xFF"/>
          <reg size="1" name="PIND" offset="0x30" text="Port D Input Pins" icon="io_port.bmp" mask="0xFF"/>
        </registers>
      </module>
      <module class="PORTE" text="">
        <registers name="PORTE" memspace="DATAMEM" text="" icon="io_port.bmp">
          <reg size="1" name="PORTE" offset="0x23" text="Data Register, Port E" icon="io_port.bmp" mask="0xFF"/>
          <reg size="1" name="DDRE" offset="0x22" text="Data Direction Register, Port E" icon="io_flag.bmp" mask="0xFF"/>
          <reg size="1" name="PINE" offset="0x21" text="Input Pins, Port E" icon="io_port.bmp" mask="0xFF"/>
        </registers>
      </module>
      <module class="PORTF" text="">
        <registers name="PORTF" memspace="DATAMEM" text="" icon="io_port.bmp">
          <reg size="1" name="PORTF" offset="0x62" text="Data Register, Port F" icon="io_port.bmp" mask="0xFF"/>
          <reg size="1" name="DDRF" offset="0x61" text="Data Direction Register, Port F" icon="io_flag.bmp" mask="0xFF"/>
          <reg size="1" name="PINF" offset="0x20" text="Input Pins, Port F" icon="io_port.bmp" mask="0xFF"/>
        </registers>
      </module>
      <module class="PORTG" text="">
        <registers name="PORTG" memspace="DATAMEM" text="" icon="io_port.bmp">
          <reg size="1" name="PORTG" offset="0x65" text="Data Register, Port G" icon="io_port.bmp" mask="0x1F"/>
          <reg size="1" name="DDRG" offset="0x64" text="Data Direction Register, Port G" icon="io_flag.bmp" mask="0x1F"/>
          <reg size="1" name="PING" offset="0x63" text="Input Pins, Port G" icon="io_port.bmp" mask="0x1F"/>
        </registers>
      </module>
      <module class="TIMER_COUNTER_0" text="">
        <registers name="TIMER_COUNTER_0" memspace="DATAMEM" text="" icon="io_timer.bmp">
          <reg size="1" name="TCCR0" offset="0x53" text="Timer/Counter Control Register" icon="io_flag.bmp">
            <bitfield name="FOC0" mask="0x80" text="Force Output Compare" icon=""/>
            <bitfield name="WGM00" mask="0x40" text="Waveform Generation Mode 0" icon="" enum="WAVEFORM_GEN_MODE"/>
            <bitfield name="COM0" mask="0x30" text="Compare Match Output Modes" icon=""/>
            <bitfield name="WGM01" mask="0x08" text="Waveform Generation Mode 1" icon=""/>
            <bitfield name="CS0" mask="0x07" text="Clock Selects" icon="" enum="CLK_SEL_3BIT"/>
          </reg>
          <reg size="1" name="TCNT0" offset="0x52" text="Timer/Counter Register" icon="io_timer.bmp" mask="0xFF"/>
          <reg size="1" name="OCR0" offset="0x51" text="Output Compare Register" icon="io_timer.bmp" mask="0xFF"/>
          <reg size="1" name="ASSR" offset="0x50" text="Asynchronus Status Register" icon="io_flag.bmp">
            <bitfield name="AS0" mask="0x08" text="Asynchronus Timer/Counter 0" icon=""/>
            <bitfield name="TCN0UB" mask="0x04" text="Timer/Counter0 Update Busy" icon=""/>
            <bitfield name="OCR0UB" mask="0x02" text="Output Compare register 0 Busy" icon=""/>
            <bitfield name="TCR0UB" mask="0x01" text="Timer/Counter Control Register 0 Update Busy" icon=""/>
          </reg>
          <reg size="1" name="TIMSK" offset="0x57" text="Timer/Counter Interrupt Mask Register" icon="io_flag.bmp">
            <bitfield name="OCIE0" mask="0x02" text="Timer/Counter0 Output Compare Match Interrupt register" icon=""/>
            <bitfield name="TOIE0" mask="0x01" text="Timer/Counter0 Overflow Interrupt Enable" icon=""/>
          </reg>
          <reg size="1" name="TIFR" offset="0x56" text="Timer/Counter Interrupt Flag register" icon="io_flag.bmp">
            <bitfield name="OCF0" mask="0x02" text="Output Compare Flag 0" icon=""/>
            <bitfield name="TOV0" mask="0x01" text="Timer/Counter0 Overflow Flag" icon=""/>
          </reg>
          <reg size="1" name="SFIOR" offset="0x40" text="Special Function IO Register" icon="io_cpu.bmp">
            <bitfield name="TSM" mask="0x80" text="Timer/Counter Synchronization Mode" icon=""/>
            <bitfield name="PSR0" mask="0x02" text="Prescaler Reset Timer/Counter0" icon=""/>
          </reg>
        </registers>
        <enumerator name="WAVEFORM_GEN_MODE">
          <enum val="0x00" text="Normal"/>
          <enum val="0x02" text="PWM, Phase Correct"/>
          <enum val="0x01" text="CTC"/>
          <enum val="0x03" text="Fast PWM"/>
        </enumerator>
        <enumerator name="CLK_SEL_3BIT">
          <enum val="0x00" text="No Clock Source (Stopped)"/>
          <enum val="0x01" text="Running, No Prescaling"/>
          <enum val="0x02" text="Running, CLK/8"/>
          <enum val="0x03" text="Running, CLK/32"/>
          <enum val="0x04" text="Running, CLK/64"/>
          <enum val="0x05" text="Running, CLK/128"/>
          <enum val="0x06" text="Running, CLK/256"/>
          <enum val="0x07" text="Running, CLK/1024"/>
        </enumerator>
      </module>
      <module class="TIMER_COUNTER_1" text="">
        <registers name="TIMER_COUNTER_1" memspace="DATAMEM" text="" icon="io_timer.bmp">
          <reg size="1" name="TIMSK" offset="0x57" text="Timer/Counter Interrupt Mask Register" icon="io_flag.bmp">
            <bitfield name="TICIE1" mask="0x20" text="Timer/Counter1 Input Capture Interrupt Enable" icon=""/>
            <bitfield name="OCIE1A" mask="0x10" text="Timer/Counter1 Output CompareA Match Interrupt Enable" icon=""/>
            <bitfield name="OCIE1B" mask="0x08" text="Timer/Counter1 Output CompareB Match Interrupt Enable" icon=""/>
            <bitfield name="TOIE1" mask="0x04" text="Timer/Counter1 Overflow Interrupt Enable" icon=""/>
          </reg>
          <reg size="1" name="ETIMSK" offset="0x7D" text="Extended Timer/Counter Interrupt Mask Register" icon="io_flag.bmp">
            <bitfield name="OCIE1C" mask="0x01" text="Timer/Counter 1, Output Compare Match C Interrupt Enable" icon=""/>
          </reg>
          <reg size="1" name="TIFR" offset="0x56" text="Timer/Counter Interrupt Flag register" icon="io_flag.bmp">
            <bitfield name="ICF1" mask="0x20" text="Input Capture Flag 1" icon=""/>
            <bitfield name="OCF1A" mask="0x10" text="Output Compare Flag 1A" icon=""/>
            <bitfield name="OCF1B" mask="0x08" text="Output Compare Flag 1B" icon=""/>
            <bitfield name="TOV1" mask="0x04" text="Timer/Counter1 Overflow Flag" icon=""/>
          </reg>
          <reg size="1" name="ETIFR" offset="0x7C" text="Extended Timer/Counter Interrupt Flag register" icon="io_flag.bmp">
            <bitfield name="OCF1C" mask="0x01" text="Timer/Counter 1, Output Compare C Match Flag" icon=""/>
          </reg>
          <reg size="1" name="SFIOR" offset="0x40" text="Special Function IO Register" icon="io_cpu.bmp">
            <bitfield name="TSM" mask="0x80" text="Timer/Counter Synchronization Mode" icon=""/>
            <bitfield name="PSR321" mask="0x01" text="Prescaler Reset, T/C3, T/C2, T/C1" icon=""/>
          </reg>
          <reg size="1" name="TCCR1A" offset="0x4F" text="Timer/Counter1 Control Register A" icon="io_flag.bmp">
            <bitfield name="COM1A" mask="0xC0" text="Compare Output Mode 1A, bits" icon=""/>
            <bitfield name="COM1B" mask="0x30" text="Compare Output Mode 1B, bits" icon=""/>
            <bitfield name="COM1C" mask="0x0C" text="Compare Output Mode 1C, bits" icon=""/>
            <bitfield name="WGM1" mask="0x03" text="Waveform Generation Mode Bits" icon=""/>
          </reg>
          <reg size="1" name="TCCR1B" offset="0x4E" text="Timer/Counter1 Control Register B" icon="io_flag.bmp">
            <bitfield name="ICNC1" mask="0x80" text="Input Capture 1 Noise Canceler" icon=""/>
            <bitfield name="ICES1" mask="0x40" text="Input Capture 1 Edge Select" icon=""/>
            <bitfield name="WGM1" mask="0x18" text="Waveform Generation Mode" icon="" lsb="2"/>
            <bitfield name="CS1" mask="0x07" text="Clock Select1 bits" icon="" enum="CLK_SEL_3BIT_EXT"/>
          </reg>
          <reg size="1" name="TCCR1C" offset="0x7A" text="Timer/Counter1 Control Register C" icon="io_flag.bmp">
            <bitfield name="FOC1A" mask="0x80" text="Force Output Compare for channel A" icon=""/>
            <bitfield name="FOC1B" mask="0x40" text="Force Output Compare for channel B" icon=""/>
            <bitfield name="FOC1C" mask="0x20" text="Force Output Compare for channel C" icon=""/>
          </reg>
          <reg size="2" name="TCNT1" offset="0x4C" text="Timer/Counter1  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="2" name="OCR1A" offset="0x4A" text="Timer/Counter1 Output Compare Register  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="2" name="OCR1B" offset="0x48" text="Timer/Counter1 Output Compare Register  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="2" name="OCR1C" offset="0x78" text="Timer/Counter1 Output Compare Register  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="2" name="ICR1" offset="0x46" text="Timer/Counter1 Input Capture Register  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
        </registers>
        <enumerator name="CLK_SEL_3BIT_EXT">
          <enum val="0x00" text="No Clock Source (Stopped)"/>
          <enum val="0x01" text="Running, No Prescaling"/>
          <enum val="0x02" text="Running, CLK/8"/>
          <enum val="0x03" text="Running, CLK/64"/>
          <enum val="0x04" text="Running, CLK/256"/>
          <enum val="0x05" text="Running, CLK/1024"/>
          <enum val="0x06" text="Running, ExtClk Tx Falling Edge"/>
          <enum val="0x07" text="Running, ExtClk Tx Rising Edge"/>
        </enumerator>
      </module>
      <module class="TIMER_COUNTER_2" text="">
        <registers name="TIMER_COUNTER_2" memspace="DATAMEM" text="" icon="io_timer.bmp">
          <reg size="1" name="TCCR2" offset="0x45" text="Timer/Counter Control Register" icon="io_flag.bmp">
            <bitfield name="FOC2" mask="0x80" text="Force Output Compare" icon=""/>
            <bitfield name="WGM20" mask="0x40" text="Wafeform Generation Mode" icon="" enum="WAVEFORM_GEN_MODE"/>
            <bitfield name="COM2" mask="0x30" text="Compare Match Output Mode" icon=""/>
            <bitfield name="WGM21" mask="0x08" text="Waveform Generation Mode" icon=""/>
            <bitfield name="CS2" mask="0x07" text="Clock Select" icon="" enum="CLK_SEL_3BIT_EXT"/>
          </reg>
          <reg size="1" name="TCNT2" offset="0x44" text="Timer/Counter Register" icon="io_timer.bmp" mask="0xFF"/>
          <reg size="1" name="OCR2" offset="0x43" text="Output Compare Register" icon="io_timer.bmp" mask="0xFF"/>
          <reg size="1" name="TIFR" offset="0x56" text="Timer/Counter Interrupt Flag Register" icon="io_flag.bmp">
            <bitfield name="OCF2" mask="0x80" text="Output Compare Flag 2" icon=""/>
            <bitfield name="TOV2" mask="0x40" text="Timer/Counter2 Overflow Flag" icon=""/>
          </reg>
          <reg size="1" name="TIMSK" offset="0x57" text="" icon="io_flag.bmp">
            <bitfield name="OCIE2" mask="0x80" text="" icon=""/>
            <bitfield name="TOIE2" mask="0x40" text="" icon=""/>
          </reg>
        </registers>
        <enumerator name="WAVEFORM_GEN_MODE">
          <enum val="0x00" text="Normal"/>
          <enum val="0x02" text="PWM, Phase Correct"/>
          <enum val="0x01" text="CTC"/>
          <enum val="0x03" text="Fast PWM"/>
        </enumerator>
        <enumerator name="CLK_SEL_3BIT_EXT">
          <enum val="0x00" text="No Clock Source (Stopped)"/>
          <enum val="0x01" text="Running, No Prescaling"/>
          <enum val="0x02" text="Running, CLK/8"/>
          <enum val="0x03" text="Running, CLK/64"/>
          <enum val="0x04" text="Running, CLK/256"/>
          <enum val="0x05" text="Running, CLK/1024"/>
          <enum val="0x06" text="Running, ExtClk Tx Falling Edge"/>
          <enum val="0x07" text="Running, ExtClk Tx Rising Edge"/>
        </enumerator>
      </module>
      <module class="TIMER_COUNTER_3" text="">
        <registers name="TIMER_COUNTER_3" memspace="DATAMEM" text="" icon="io_timer.bmp">
          <reg size="1" name="ETIMSK" offset="0x7D" text="Extended Timer/Counter Interrupt Mask Register" icon="io_flag.bmp">
            <bitfield name="TICIE3" mask="0x20" text="Timer/Counter3 Input Capture Interrupt Enable" icon=""/>
            <bitfield name="OCIE3A" mask="0x10" text="Timer/Counter3 Output CompareA Match Interrupt Enable" icon=""/>
            <bitfield name="OCIE3B" mask="0x08" text="Timer/Counter3 Output CompareB Match Interrupt Enable" icon=""/>
            <bitfield name="TOIE3" mask="0x04" text="Timer/Counter3 Overflow Interrupt Enable" icon=""/>
            <bitfield name="OCIE3C" mask="0x02" text="Timer/Counter3, Output Compare Match Interrupt Enable" icon=""/>
          </reg>
          <reg size="1" name="ETIFR" offset="0x7C" text="Extended Timer/Counter Interrupt Flag register" icon="io_flag.bmp">
            <bitfield name="ICF3" mask="0x20" text="Input Capture Flag 1" icon=""/>
            <bitfield name="OCF3A" mask="0x10" text="Output Compare Flag 1A" icon=""/>
            <bitfield name="OCF3B" mask="0x08" text="Output Compare Flag 1B" icon=""/>
            <bitfield name="TOV3" mask="0x04" text="Timer/Counter3 Overflow Flag" icon=""/>
            <bitfield name="OCF3C" mask="0x02" text="Timer/Counter3 Output Compare C Match Flag" icon=""/>
          </reg>
          <reg size="1" name="SFIOR" offset="0x40" text="Special Function IO Register" icon="io_cpu.bmp">
            <bitfield name="TSM" mask="0x80" text="Timer/Counter Synchronization Mode" icon=""/>
            <bitfield name="PSR321" mask="0x01" text="Prescaler Reset, T/C3, T/C2, T/C1" icon=""/>
          </reg>
          <reg size="1" name="TCCR3A" offset="0x8B" text="Timer/Counter3 Control Register A" icon="io_flag.bmp">
            <bitfield name="COM3A" mask="0xC0" text="Compare Output Mode 3A, bits" icon=""/>
            <bitfield name="COM3B" mask="0x30" text="Compare Output Mode 3B, bits" icon=""/>
            <bitfield name="COM3C" mask="0x0C" text="Compare Output Mode 3C, bits" icon=""/>
            <bitfield name="WGM3" mask="0x03" text="Waveform Generation Mode Bits" icon=""/>
          </reg>
          <reg size="1" name="TCCR3B" offset="0x8A" text="Timer/Counter3 Control Register B" icon="io_flag.bmp">
            <bitfield name="ICNC3" mask="0x80" text="Input Capture 3  Noise Canceler" icon=""/>
            <bitfield name="ICES3" mask="0x40" text="Input Capture 3 Edge Select" icon=""/>
            <bitfield name="WGM3" mask="0x18" text="Waveform Generation Mode" icon="" lsb="2"/>
            <bitfield name="CS3" mask="0x07" text="Clock Select3 bits" icon="" enum="CLK_SEL_3BIT_EXT"/>
          </reg>
          <reg size="1" name="TCCR3C" offset="0x8C" text="Timer/Counter3 Control Register C" icon="io_flag.bmp">
            <bitfield name="FOC3A" mask="0x80" text="Force Output Compare for channel A" icon=""/>
            <bitfield name="FOC3B" mask="0x40" text="Force Output Compare for channel B" icon=""/>
            <bitfield name="FOC3C" mask="0x20" text="Force Output Compare for channel C" icon=""/>
          </reg>
          <reg size="2" name="TCNT3" offset="0x88" text="Timer/Counter3  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="2" name="OCR3A" offset="0x86" text="Timer/Counter3 Output Compare Register A  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="2" name="OCR3B" offset="0x84" text="Timer/Counter3 Output Compare Register B  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="2" name="OCR3C" offset="0x82" text="Timer/Counter3 Output compare Register C  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="2" name="ICR3" offset="0x80" text="Timer/Counter3 Input Capture Register  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
        </registers>
        <enumerator name="CLK_SEL_3BIT_EXT">
          <enum val="0x00" text="No Clock Source (Stopped)"/>
          <enum val="0x01" text="Running, No Prescaling"/>
          <enum val="0x02" text="Running, CLK/8"/>
          <enum val="0x03" text="Running, CLK/64"/>
          <enum val="0x04" text="Running, CLK/256"/>
          <enum val="0x05" text="Running, CLK/1024"/>
          <enum val="0x06" text="Running, ExtClk Tx Falling Edge"/>
          <enum val="0x07" text="Running, ExtClk Tx Rising Edge"/>
        </enumerator>
      </module>
      <module class="WATCHDOG" text="">
        <registers name="WATCHDOG" memspace="DATAMEM" text="" icon="io_watch.bmp">
          <reg size="1" name="WDTCR" offset="0x41" text="Watchdog Timer Control Register" icon="io_flag.bmp">
            <bitfield name="WDCE" mask="0x10" text="Watchdog Change Enable" icon=""/>
            <bitfield name="WDE" mask="0x08" text="Watch Dog Enable" icon=""/>
            <bitfield name="WDP" mask="0x07" text="Watch Dog Timer Prescaler bits" icon="" enum="WDOG_TIMER_PRESCALE_3BITS"/>
          </reg>
        </registers>
        <enumerator name="WDOG_TIMER_PRESCALE_3BITS">
          <enum val="0x00" text="Oscillator Cycles 16K"/>
          <enum val="0x01" text="Oscillator Cycles 32K"/>
          <enum val="0x02" text="Oscillator Cycles 64K"/>
          <enum val="0x03" text="Oscillator Cycles 128K"/>
          <enum val="0x04" text="Oscillator Cycles 256K"/>
          <enum val="0x05" text="Oscillator Cycles 512K"/>
          <enum val="0x06" text="Oscillator Cycles 1024K"/>
          <enum val="0x07" text="Oscillator Cycles 2048K"/>
        </enumerator>
      </module>
      <module class="AD_CONVERTER" text="">
        <registers name="AD_CONVERTER" memspace="DATAMEM" text="" icon="io_analo.bmp">
          <reg size="1" name="ADMUX" offset="0x27" text="The ADC multiplexer Selection Register" icon="io_analo.bmp">
            <bitfield name="REFS" mask="0xC0" text="Reference Selection Bits" icon="" enum="ANALOG_ADC_V_REF2"/>
            <bitfield name="ADLAR" mask="0x20" text="Left Adjust Result" icon=""/>
            <bitfield name="MUX" mask="0x1F" text="Analog Channel and Gain Selection Bits" icon=""/>
          </reg>
          <reg size="1" name="ADCSRA" offset="0x26" text="The ADC Control and Status register" icon="io_flag.bmp">
            <bitfield name="ADEN" mask="0x80" text="ADC Enable" icon=""/>
            <bitfield name="ADSC" mask="0x40" text="ADC Start Conversion" icon=""/>
            <bitfield name="ADFR" mask="0x20" text="ADC  Free Running Select" icon=""/>
            <bitfield name="ADIF" mask="0x10" text="ADC Interrupt Flag" icon=""/>
            <bitfield name="ADIE" mask="0x08" text="ADC Interrupt Enable" icon=""/>
            <bitfield name="ADPS" mask="0x07" text="ADC  Prescaler Select Bits" icon="" enum="ANALIG_ADC_PRESCALER"/>
          </reg>
          <reg size="2" name="ADC" offset="0x24" text="ADC Data Register  Bytes" icon="io_analo.bmp" mask="0xFFFF"/>
        </registers>
        <enumerator name="ANALOG_ADC_V_REF2">
          <enum val="0x00" text="AREF, Internal Vref turned off"/>
          <enum val="0x01" text="AVCC with external capacitor at AREF pin"/>
          <enum val="0x02" text="Reserved"/>
          <enum val="0x03" text="Internal 2.56V Voltage Reference with external capacitor at AREF pin"/>
        </enumerator>
        <enumerator name="ANALIG_ADC_PRESCALER">
          <enum val="0x00" text="2"/>
          <enum val="0x01" text="2"/>
          <enum val="0x02" text="4"/>
          <enum val="0x03" text="8"/>
          <enum val="0x04" text="16"/>
          <enum val="0x05" text="32"/>
          <enum val="0x06" text="64"/>
          <enum val="0x07" text="128"/>
        </enumerator>
      </module>
    </templates>
    <modules>
      <module implements="ANALOG_COMPARATOR" name="ANALOG_COMPARATOR">
        <registers implements="ANALOG_COMPARATOR" name="ANALOG_COMPARATOR" offset="0x00" text=""/>
      </module>
      <module implements="SPI" name="SPI">
        <registers implements="SPI" name="SPI" offset="0x00" text=""/>
      </module>
      <module implements="TWI" name="TWI">
        <registers implements="TWI" name="TWI" offset="0x00" text=""/>
      </module>
      <module implements="USART0" name="USART0">
        <registers implements="USART0" name="USART0" offset="0x00" text=""/>
      </module>
      <module implements="USART1" name="USART1">
        <registers implements="USART1" name="USART1" offset="0x00" text=""/>
      </module>
      <module implements="CPU" name="CPU">
        <registers implements="CPU" name="CPU" offset="0x00" text=""/>
      </module>
      <module implements="BOOT_LOAD" name="BOOT_LOAD">
        <registers implements="BOOT_LOAD" name="BOOT_LOAD" offset="0x00" text=""/>
      </module>
      <module implements="JTAG" name="JTAG">
        <registers implements="JTAG" name="JTAG" offset="0x00" text=""/>
      </module>
      <module implements="MISC" name="MISC">
        <registers implements="MISC" name="MISC" offset="0x00" text=""/>
      </module>
      <module implements="EXTERNAL_INTERRUPT" name="EXTERNAL_INTERRUPT">
        <registers implements="EXTERNAL_INTERRUPT" name="EXTERNAL_INTERRUPT" offset="0x00" text=""/>
      </module>
      <module implements="EEPROM" name="EEPROM">
        <registers implements="EEPROM" name="EEPROM" offset="0x00" text=""/>
      </module>
      <module implements="PORTA" name="PORTA">
        <registers implements="PORTA" name="PORTA" offset="0x00" text=""/>
      </module>
      <module implements="PORTB" name="PORTB">
        <registers implements="PORTB" name="PORTB" offset="0x00" text=""/>
      </module>
      <module implements="PORTC" name="PORTC">
        <registers implements="PORTC" name="PORTC" offset="0x00" text=""/>
      </module>
      <module implements="PORTD" name="PORTD">
        <registers implements="PORTD" name="PORTD" offset="0x00" text=""/>
      </module>
      <module implements="PORTE" name="PORTE">
        <registers implements="PORTE" name="PORTE" offset="0x00" text=""/>
      </module>
      <module implements="PORTF" name="PORTF">
        <registers implements="PORTF" name="PORTF" offset="0x00" text=""/>
      </module>
      <module implements="PORTG" name="PORTG">
        <registers implements="PORTG" name="PORTG" offset="0x00" text=""/>
      </module>
      <module implements="TIMER_COUNTER_0" name="TIMER_COUNTER_0">
        <registers implements="TIMER_COUNTER_0" name="TIMER_COUNTER_0" offset="0x00" text=""/>
      </module>
      <module implements="TIMER_COUNTER_1" name="TIMER_COUNTER_1">
        <registers implements="TIMER_COUNTER_1" name="TIMER_COUNTER_1" offset="0x00" text=""/>
      </module>
      <module implements="TIMER_COUNTER_2" name="TIMER_COUNTER_2">
        <registers implements="TIMER_COUNTER_2" name="TIMER_COUNTER_2" offset="0x00" text=""/>
      </module>
      <module implements="TIMER_COUNTER_3" name="TIMER_COUNTER_3">
        <registers implements="TIMER_COUNTER_3" name="TIMER_COUNTER_3" offset="0x00" text=""/>
      </module>
      <module implements="WATCHDOG" name="WATCHDOG">
        <registers implements="WATCHDOG" name="WATCHDOG" offset="0x00" text=""/>
      </module>
      <module implements="AD_CONVERTER" name="AD_CONVERTER">
        <registers implements="AD_CONVERTER" name="AD_CONVERTER" offset="0x00" text=""/>
      </module>
    </modules>
    <fuses>
      <fuse implements="FUSE" name="FUSE">
        <registers implements="FUSE" name="FUSE"/>
      </fuse>
    </fuses>
    <lockbits>
      <lockbit implements="LOCKBIT" name="LOCKBIT">
        <registers implements="LOCKBIT" name="LOCKBIT"/>
      </lockbit>
    </lockbits>
  </V2>
</AVRPART>

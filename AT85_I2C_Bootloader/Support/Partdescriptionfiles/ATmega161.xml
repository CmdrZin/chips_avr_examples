<?xml version="1.0"?>
<AVRPART>
  <MODULE_LIST>[ADMIN:CORE:INTERRUPT_VECTOR:MEMORY:PACKAGE:POWER:PROGVOLT:LOCKBIT:FUSE:IO_MODULE:ICE_SETTINGS:PROGRAMMING]</MODULE_LIST>
  <ADMIN>
    <PART_NAME>ATmega161</PART_NAME>
    <SPEED>8MHZ</SPEED>
    <BUILD>233</BUILD>
    <RELEASE_STATUS>RELEASED</RELEASE_STATUS>
    <SIGNATURE>
      <ADDR000>$1E</ADDR000>
      <ADDR001>$94</ADDR001>
      <ADDR002>$01</ADDR002>
    </SIGNATURE>
    <COMPATIBILITYMODE>
      <COMPATIBILITYPART>ATmega161</COMPATIBILITYPART>
      <NORMAL>ATmega162</NORMAL>
    </COMPATIBILITYMODE>
  </ADMIN>
  <CORE>
    <CORE_VERSION>V2E</CORE_VERSION>
    <ID>AVRSimCoreV2.SimCoreV2</ID>
    <NEW_INSTRUCTIONS>[]</NEW_INSTRUCTIONS>
    <INSTRUCTIONS_NOT_SUPPORTED>[]</INSTRUCTIONS_NOT_SUPPORTED>
    <RAMP_REGISTERS>[]</RAMP_REGISTERS>
    <GP_REG_FILE>
      <NMB_REG>32</NMB_REG>
      <START_ADDR>$00</START_ADDR>
      <X_REG_HIGH>$1B</X_REG_HIGH>
      <X_REG_LOW>$1A</X_REG_LOW>
      <Y_REG_HIGH>$1D</Y_REG_HIGH>
      <Y_REG_LOW>$1C</Y_REG_LOW>
      <Z_REG_HIGH>$1F</Z_REG_HIGH>
      <Z_REG_LOW>$1E</Z_REG_LOW>
    </GP_REG_FILE>
  </CORE>
  <INTERRUPT_VECTOR>
    <NMB_VECTORS>21</NMB_VECTORS>
    <VECTOR1>
      <PROGRAM_ADDRESS>$000</PROGRAM_ADDRESS>
      <SOURCE>RESET</SOURCE>
      <DEFINITION>External Reset, Power-on Reset and Watchdog Reset</DEFINITION>
    </VECTOR1>
    <VECTOR2>
      <PROGRAM_ADDRESS>$002</PROGRAM_ADDRESS>
      <SOURCE>INT0</SOURCE>
      <DEFINITION>External Interrupt 0</DEFINITION>
    </VECTOR2>
    <VECTOR3>
      <PROGRAM_ADDRESS>$004</PROGRAM_ADDRESS>
      <SOURCE>INT1</SOURCE>
      <DEFINITION>External Interrupt 1</DEFINITION>
    </VECTOR3>
    <VECTOR4>
      <PROGRAM_ADDRESS>$006</PROGRAM_ADDRESS>
      <SOURCE>INT2</SOURCE>
      <DEFINITION>External Interrupt 2</DEFINITION>
    </VECTOR4>
    <VECTOR5>
      <PROGRAM_ADDRESS>$008</PROGRAM_ADDRESS>
      <SOURCE>TIMER2_COMP</SOURCE>
      <DEFINITION>Timer/Counter2 Compare Match</DEFINITION>
    </VECTOR5>
    <VECTOR6>
      <PROGRAM_ADDRESS>$00A</PROGRAM_ADDRESS>
      <SOURCE>TIMER2_OVF</SOURCE>
      <DEFINITION>Timer/Counter2 Overflow</DEFINITION>
    </VECTOR6>
    <VECTOR7>
      <PROGRAM_ADDRESS>$00C</PROGRAM_ADDRESS>
      <SOURCE>TIMER1_CAPT</SOURCE>
      <DEFINITION>Timer/Counter1 Capture Event</DEFINITION>
    </VECTOR7>
    <VECTOR8>
      <PROGRAM_ADDRESS>$00E</PROGRAM_ADDRESS>
      <SOURCE>TIMER1_COMPA</SOURCE>
      <DEFINITION>Timer/Counter1 Compare Match A</DEFINITION>
    </VECTOR8>
    <VECTOR9>
      <PROGRAM_ADDRESS>$010</PROGRAM_ADDRESS>
      <SOURCE>TIMER1_COMPB</SOURCE>
      <DEFINITION>Timer/Counter1 Compare Match B</DEFINITION>
    </VECTOR9>
    <VECTOR10>
      <PROGRAM_ADDRESS>$012</PROGRAM_ADDRESS>
      <SOURCE>TIMER1_OVF</SOURCE>
      <DEFINITION>Timer/Counter1 Overflow</DEFINITION>
    </VECTOR10>
    <VECTOR11>
      <PROGRAM_ADDRESS>$014</PROGRAM_ADDRESS>
      <SOURCE>TIMER0_COMP</SOURCE>
      <DEFINITION>Timer/Counter0 Compare Match</DEFINITION>
    </VECTOR11>
    <VECTOR12>
      <PROGRAM_ADDRESS>$016</PROGRAM_ADDRESS>
      <SOURCE>TIMER0_OVF</SOURCE>
      <DEFINITION>Timer/Counter0 Overflow</DEFINITION>
    </VECTOR12>
    <VECTOR13>
      <PROGRAM_ADDRESS>$018</PROGRAM_ADDRESS>
      <SOURCE>SPI,STC</SOURCE>
      <DEFINITION>Serial Transfer Complete</DEFINITION>
    </VECTOR13>
    <VECTOR14>
      <PROGRAM_ADDRESS>$01A</PROGRAM_ADDRESS>
      <SOURCE>UART0,RX</SOURCE>
      <DEFINITION>UART0, Rx Complete</DEFINITION>
    </VECTOR14>
    <VECTOR15>
      <PROGRAM_ADDRESS>$01C</PROGRAM_ADDRESS>
      <SOURCE>UART1,RX</SOURCE>
      <DEFINITION>UART1, Rx Complete</DEFINITION>
    </VECTOR15>
    <VECTOR16>
      <PROGRAM_ADDRESS>$01E</PROGRAM_ADDRESS>
      <SOURCE>UART0,UDRE</SOURCE>
      <DEFINITION>UART0 Data Register Empty</DEFINITION>
    </VECTOR16>
    <VECTOR17>
      <PROGRAM_ADDRESS>$020</PROGRAM_ADDRESS>
      <SOURCE>UART1,UDRE</SOURCE>
      <DEFINITION>UART1 Data Register Empty</DEFINITION>
    </VECTOR17>
    <VECTOR18>
      <PROGRAM_ADDRESS>$022</PROGRAM_ADDRESS>
      <SOURCE>UART0,TX</SOURCE>
      <DEFINITION>UART0, Tx Complete</DEFINITION>
    </VECTOR18>
    <VECTOR19>
      <PROGRAM_ADDRESS>$024</PROGRAM_ADDRESS>
      <SOURCE>UART1,TX</SOURCE>
      <DEFINITION>UART1, Tx Complete</DEFINITION>
    </VECTOR19>
    <VECTOR20>
      <PROGRAM_ADDRESS>$026</PROGRAM_ADDRESS>
      <SOURCE>EE_RDY</SOURCE>
      <DEFINITION>EEPROM Ready</DEFINITION>
    </VECTOR20>
    <VECTOR21>
      <PROGRAM_ADDRESS>$028</PROGRAM_ADDRESS>
      <SOURCE>ANA_COMP</SOURCE>
      <DEFINITION>Analog Comparator</DEFINITION>
    </VECTOR21>
  </INTERRUPT_VECTOR>
  <MEMORY>
    <ID>AVRSimMemory8bit.SimMemory8bit</ID>
    <PROG_FLASH>16384</PROG_FLASH>
    <EEPROM>512</EEPROM>
    <INT_SRAM>
      <SIZE>1024</SIZE>
      <START_ADDR>$60</START_ADDR>
    </INT_SRAM>
    <EXT_SRAM>
      <SIZE>64512</SIZE>
      <START_ADDR>$460</START_ADDR>
    </EXT_SRAM>
    <IO_MEMORY>
      <IO_START_ADDR>$00</IO_START_ADDR>
      <IO_STOP_ADDR>$3F</IO_STOP_ADDR>
      <EXT_IO_START_ADDR>NA</EXT_IO_START_ADDR>
      <EXT_IO_STOP_ADDR>NA</EXT_IO_STOP_ADDR>
      <MEM_START_ADDR>$20</MEM_START_ADDR>
      <MEM_STOP_ADDR>$5F</MEM_STOP_ADDR>
      <SREG>
        <IO_ADDR>$3F</IO_ADDR>
        <MEM_ADDR>$5F</MEM_ADDR>
        <C_MASK>0x01</C_MASK>
        <Z_MASK>0x02</Z_MASK>
        <N_MASK>0x04</N_MASK>
        <V_MASK>0x08</V_MASK>
        <S_MASK>0x10</S_MASK>
        <H_MASK>0x20</H_MASK>
        <T_MASK>0x40</T_MASK>
        <I_MASK>0x80</I_MASK>
      </SREG>
      <SPH>
        <IO_ADDR>$3E</IO_ADDR>
        <MEM_ADDR>$5E</MEM_ADDR>
        <SP8_MASK>0x01</SP8_MASK>
        <SP9_MASK>0x02</SP9_MASK>
        <SP10_MASK>0x04</SP10_MASK>
        <SP11_MASK>0x08</SP11_MASK>
        <SP12_MASK>0x10</SP12_MASK>
        <SP13_MASK>0x20</SP13_MASK>
        <SP14_MASK>0x40</SP14_MASK>
        <SP15_MASK>0x80</SP15_MASK>
      </SPH>
      <SPL>
        <IO_ADDR>$3D</IO_ADDR>
        <MEM_ADDR>$5D</MEM_ADDR>
        <SP0_MASK>0x01</SP0_MASK>
        <SP1_MASK>0x02</SP1_MASK>
        <SP2_MASK>0x04</SP2_MASK>
        <SP3_MASK>0x08</SP3_MASK>
        <SP4_MASK>0x10</SP4_MASK>
        <SP5_MASK>0x20</SP5_MASK>
        <SP6_MASK>0x40</SP6_MASK>
        <SP7_MASK>0x80</SP7_MASK>
      </SPL>
      <GIMSK>
        <IO_ADDR>$3B</IO_ADDR>
        <MEM_ADDR>$5B</MEM_ADDR>
        <INT2_MASK>0x20</INT2_MASK>
        <INT0_MASK>0x40</INT0_MASK>
        <INT1_MASK>0x80</INT1_MASK>
      </GIMSK>
      <GIFR>
        <IO_ADDR>$3A</IO_ADDR>
        <MEM_ADDR>$5A</MEM_ADDR>
        <INTF2_MASK>0x20</INTF2_MASK>
        <INTF0_MASK>0x40</INTF0_MASK>
        <INTF1_MASK>0x80</INTF1_MASK>
      </GIFR>
      <TIMSK>
        <IO_ADDR>$39</IO_ADDR>
        <MEM_ADDR>$59</MEM_ADDR>
        <OCIE0_MASK>0x01</OCIE0_MASK>
        <TOIE0_MASK>0x02</TOIE0_MASK>
        <OCIE2_MASK>0x04</OCIE2_MASK>
        <TOIE2_MASK>0x10</TOIE2_MASK>
        <TICIE1_MASK>0x08</TICIE1_MASK>
        <OCIE1B_MASK>0x20</OCIE1B_MASK>
        <OCIE1A_MASK>0x40</OCIE1A_MASK>
        <TOIE1_MASK>0x80</TOIE1_MASK>
      </TIMSK>
      <TIFR>
        <IO_ADDR>$38</IO_ADDR>
        <MEM_ADDR>$58</MEM_ADDR>
        <OCF0_MASK>0x01</OCF0_MASK>
        <TOV0_MASK>0x02</TOV0_MASK>
        <OCF2_MASK>0x04</OCF2_MASK>
        <TOV2_MASK>0x10</TOV2_MASK>
        <ICF1_MASK>0x08</ICF1_MASK>
        <OCF1B_MASK>0x20</OCF1B_MASK>
        <OCF1A_MASK>0x40</OCF1A_MASK>
        <TOV1_MASK>0x80</TOV1_MASK>
      </TIFR>
      <SPMCR>
        <IO_ADDR>$37</IO_ADDR>
        <MEM_ADDR>$57</MEM_ADDR>
        <SPMEN_MASK>0x01</SPMEN_MASK>
        <PGERS_MASK>0x02</PGERS_MASK>
        <PGWRT_MASK>0x04</PGWRT_MASK>
        <BLBSET_MASK>0x08</BLBSET_MASK>
      </SPMCR>
      <EMCUCR>
        <IO_ADDR>$36</IO_ADDR>
        <MEM_ADDR>$56</MEM_ADDR>
        <ISC2_MASK>0x01</ISC2_MASK>
        <SRW11_MASK>0x02</SRW11_MASK>
        <SRW00_MASK>0x04</SRW00_MASK>
        <SRW01_MASK>0x08</SRW01_MASK>
        <SRL0_MASK>0x10</SRL0_MASK>
        <SRL1_MASK>0x20</SRL1_MASK>
        <SRL2_MASK>0x40</SRL2_MASK>
        <SM0_MASK>0x80</SM0_MASK>
      </EMCUCR>
      <MCUCR>
        <IO_ADDR>$35</IO_ADDR>
        <MEM_ADDR>$55</MEM_ADDR>
        <ISC00_MASK>0x01</ISC00_MASK>
        <ISC01_MASK>0x02</ISC01_MASK>
        <ISC10_MASK>0x04</ISC10_MASK>
        <ISC11_MASK>0x08</ISC11_MASK>
        <SM1_MASK>0x10</SM1_MASK>
        <SE_MASK>0x20</SE_MASK>
        <SRW10_MASK>0x40</SRW10_MASK>
        <SRE_MASK>0x80</SRE_MASK>
      </MCUCR>
      <MCUSR>
        <IO_ADDR>$34</IO_ADDR>
        <MEM_ADDR>$54</MEM_ADDR>
        <PORF_MASK>0x01</PORF_MASK>
        <EXTRF_MASK>0x02</EXTRF_MASK>
        <BORF_MASK>0x04</BORF_MASK>
        <WDRF_MASK>0x08</WDRF_MASK>
      </MCUSR>
      <TCCR0>
        <IO_ADDR>$33</IO_ADDR>
        <MEM_ADDR>$53</MEM_ADDR>
        <CS00_MASK>0x01</CS00_MASK>
        <CS01_MASK>0x02</CS01_MASK>
        <CS02_MASK>0x04</CS02_MASK>
        <WGM01_MASK>0x08</WGM01_MASK>
        <COM00_MASK>0x10</COM00_MASK>
        <COM01_MASK>0x20</COM01_MASK>
        <WGM00_MASK>0x40</WGM00_MASK>
        <FOC0_MASK>0x80</FOC0_MASK>
      </TCCR0>
      <TCNT0>
        <IO_ADDR>$32</IO_ADDR>
        <MEM_ADDR>$52</MEM_ADDR>
        <TCNT0_0_MASK>0x01</TCNT0_0_MASK>
        <TCNT0_1_MASK>0x02</TCNT0_1_MASK>
        <TCNT0_2_MASK>0x04</TCNT0_2_MASK>
        <TCNT0_3_MASK>0x08</TCNT0_3_MASK>
        <TCNT0_4_MASK>0x10</TCNT0_4_MASK>
        <TCNT0_5_MASK>0x20</TCNT0_5_MASK>
        <TCNT0_6_MASK>0x40</TCNT0_6_MASK>
        <TCNT0_7_MASK>0x80</TCNT0_7_MASK>
      </TCNT0>
      <OCR0>
        <IO_ADDR>$31</IO_ADDR>
        <MEM_ADDR>$51</MEM_ADDR>
        <OCR0_0_MASK>0x01</OCR0_0_MASK>
        <OCR0_1_MASK>0x02</OCR0_1_MASK>
        <OCR0_2_MASK>0x04</OCR0_2_MASK>
        <OCR0_3_MASK>0x08</OCR0_3_MASK>
        <OCR0_4_MASK>0x10</OCR0_4_MASK>
        <OCR0_5_MASK>0x20</OCR0_5_MASK>
        <OCR0_6_MASK>0x40</OCR0_6_MASK>
        <OCR0_7_MASK>0x80</OCR0_7_MASK>
      </OCR0>
      <SFIOR>
        <IO_ADDR>$30</IO_ADDR>
        <MEM_ADDR>$50</MEM_ADDR>
        <PSR10_MASK>0x01</PSR10_MASK>
        <PSR2_MASK>0x02</PSR2_MASK>
      </SFIOR>
      <TCCR1A>
        <IO_ADDR>$2F</IO_ADDR>
        <MEM_ADDR>$4F</MEM_ADDR>
        <WGM10_MASK>0x01</WGM10_MASK>
        <WGM11_MASK>0x02</WGM11_MASK>
        <FOC1B_MASK>0x04</FOC1B_MASK>
        <FOC1A_MASK>0x08</FOC1A_MASK>
        <COM1B0_MASK>0x10</COM1B0_MASK>
        <COM1B1_MASK>0x20</COM1B1_MASK>
        <COM1A0_MASK>0x40</COM1A0_MASK>
        <COM1A1_MASK>0x80</COM1A1_MASK>
      </TCCR1A>
      <TCCR1B>
        <IO_ADDR>$2E</IO_ADDR>
        <MEM_ADDR>$4E</MEM_ADDR>
        <CS10_MASK>0x01</CS10_MASK>
        <CS11_MASK>0x02</CS11_MASK>
        <CS12_MASK>0x04</CS12_MASK>
        <CTC1_MASK>0x08</CTC1_MASK>
        <ICES1_MASK>0x40</ICES1_MASK>
        <ICNC1_MASK>0x80</ICNC1_MASK>
      </TCCR1B>
      <TCNT1H>
        <IO_ADDR>$2D</IO_ADDR>
        <MEM_ADDR>$4D</MEM_ADDR>
        <TCNT1H0_MASK>0x01</TCNT1H0_MASK>
        <TCNT1H1_MASK>0x02</TCNT1H1_MASK>
        <TCNT1H2_MASK>0x04</TCNT1H2_MASK>
        <TCNT1H3_MASK>0x08</TCNT1H3_MASK>
        <TCNT1H4_MASK>0x10</TCNT1H4_MASK>
        <TCNT1H5_MASK>0x20</TCNT1H5_MASK>
        <TCNT1H6_MASK>0x40</TCNT1H6_MASK>
        <TCNT1H7_MASK>0x80</TCNT1H7_MASK>
      </TCNT1H>
      <TCNT1L>
        <IO_ADDR>$2C</IO_ADDR>
        <MEM_ADDR>$4C</MEM_ADDR>
        <TCNT1L0_MASK>0x01</TCNT1L0_MASK>
        <TCNT1L1_MASK>0x02</TCNT1L1_MASK>
        <TCNT1L2_MASK>0x04</TCNT1L2_MASK>
        <TCNT1L3_MASK>0x08</TCNT1L3_MASK>
        <TCNT1L4_MASK>0x10</TCNT1L4_MASK>
        <TCNT1L5_MASK>0x20</TCNT1L5_MASK>
        <TCNT1L6_MASK>0x40</TCNT1L6_MASK>
        <TCNT1L7_MASK>0x80</TCNT1L7_MASK>
      </TCNT1L>
      <OCR1AH>
        <IO_ADDR>$2B</IO_ADDR>
        <MEM_ADDR>$4B</MEM_ADDR>
        <OCR1AH0_MASK>0x01</OCR1AH0_MASK>
        <OCR1AH1_MASK>0x02</OCR1AH1_MASK>
        <OCR1AH2_MASK>0x04</OCR1AH2_MASK>
        <OCR1AH3_MASK>0x08</OCR1AH3_MASK>
        <OCR1AH4_MASK>0x10</OCR1AH4_MASK>
        <OCR1AH5_MASK>0x20</OCR1AH5_MASK>
        <OCR1AH6_MASK>0x40</OCR1AH6_MASK>
        <OCR1AH7_MASK>0x80</OCR1AH7_MASK>
      </OCR1AH>
      <OCR1AL>
        <IO_ADDR>$2A</IO_ADDR>
        <MEM_ADDR>$4A</MEM_ADDR>
        <OCR1AL0_MASK>0x01</OCR1AL0_MASK>
        <OCR1AL1_MASK>0x02</OCR1AL1_MASK>
        <OCR1AL2_MASK>0x04</OCR1AL2_MASK>
        <OCR1AL3_MASK>0x08</OCR1AL3_MASK>
        <OCR1AL4_MASK>0x10</OCR1AL4_MASK>
        <OCR1AL5_MASK>0x20</OCR1AL5_MASK>
        <OCR1AL6_MASK>0x40</OCR1AL6_MASK>
        <OCR1AL7_MASK>0x80</OCR1AL7_MASK>
      </OCR1AL>
      <OCR1BH>
        <IO_ADDR>$29</IO_ADDR>
        <MEM_ADDR>$49</MEM_ADDR>
        <OCR1BH0_MASK>0x01</OCR1BH0_MASK>
        <OCR1BH1_MASK>0x02</OCR1BH1_MASK>
        <OCR1BH2_MASK>0x04</OCR1BH2_MASK>
        <OCR1BH3_MASK>0x08</OCR1BH3_MASK>
        <OCR1BH4_MASK>0x10</OCR1BH4_MASK>
        <OCR1BH5_MASK>0x20</OCR1BH5_MASK>
        <OCR1BH6_MASK>0x40</OCR1BH6_MASK>
        <OCR1BH7_MASK>0x80</OCR1BH7_MASK>
      </OCR1BH>
      <OCR1BL>
        <IO_ADDR>$28</IO_ADDR>
        <MEM_ADDR>$48</MEM_ADDR>
        <OCR1BL0_MASK>0x01</OCR1BL0_MASK>
        <OCR1BL1_MASK>0x02</OCR1BL1_MASK>
        <OCR1BL2_MASK>0x04</OCR1BL2_MASK>
        <OCR1BL3_MASK>0x08</OCR1BL3_MASK>
        <OCR1BL4_MASK>0x10</OCR1BL4_MASK>
        <OCR1BL5_MASK>0x20</OCR1BL5_MASK>
        <OCR1BL6_MASK>0x40</OCR1BL6_MASK>
        <OCR1BL7_MASK>0x80</OCR1BL7_MASK>
      </OCR1BL>
      <TCCR2>
        <IO_ADDR>$27</IO_ADDR>
        <MEM_ADDR>$47</MEM_ADDR>
        <CS20_MASK>0x01</CS20_MASK>
        <CS21_MASK>0x02</CS21_MASK>
        <CS22_MASK>0x04</CS22_MASK>
        <CTC2_MASK>0x08</CTC2_MASK>
        <COM20_MASK>0x10</COM20_MASK>
        <COM21_MASK>0x20</COM21_MASK>
        <PWM2_MASK>0x40</PWM2_MASK>
        <FOC2_MASK>0x80</FOC2_MASK>
      </TCCR2>
      <ASSR>
        <IO_ADDR>$26</IO_ADDR>
        <MEM_ADDR>$46</MEM_ADDR>
        <TCR2UB_MASK>0x01</TCR2UB_MASK>
        <OCR2UB_MASK>0x02</OCR2UB_MASK>
        <TCN2UB_MASK>0x04</TCN2UB_MASK>
        <AS2_MASK>0x08</AS2_MASK>
      </ASSR>
      <ICR1H>
        <IO_ADDR>$25</IO_ADDR>
        <MEM_ADDR>$45</MEM_ADDR>
        <ICR1H0_MASK>0x01</ICR1H0_MASK>
        <ICR1H1_MASK>0x02</ICR1H1_MASK>
        <ICR1H2_MASK>0x04</ICR1H2_MASK>
        <ICR1H3_MASK>0x08</ICR1H3_MASK>
        <ICR1H4_MASK>0x10</ICR1H4_MASK>
        <ICR1H5_MASK>0x20</ICR1H5_MASK>
        <ICR1H6_MASK>0x40</ICR1H6_MASK>
        <ICR1H7_MASK>0x80</ICR1H7_MASK>
      </ICR1H>
      <ICR1L>
        <IO_ADDR>$24</IO_ADDR>
        <MEM_ADDR>$44</MEM_ADDR>
        <ICR1L0_MASK>0x01</ICR1L0_MASK>
        <ICR1L1_MASK>0x02</ICR1L1_MASK>
        <ICR1L2_MASK>0x04</ICR1L2_MASK>
        <ICR1L3_MASK>0x08</ICR1L3_MASK>
        <ICR1L4_MASK>0x10</ICR1L4_MASK>
        <ICR1L5_MASK>0x20</ICR1L5_MASK>
        <ICR1L6_MASK>0x40</ICR1L6_MASK>
        <ICR1L7_MASK>0x80</ICR1L7_MASK>
      </ICR1L>
      <TCNT2>
        <IO_ADDR>$23</IO_ADDR>
        <MEM_ADDR>$43</MEM_ADDR>
        <TCNT2-0_MASK>0x01</TCNT2-0_MASK>
        <TCNT2-1_MASK>0x02</TCNT2-1_MASK>
        <TCNT2-2_MASK>0x04</TCNT2-2_MASK>
        <TCNT2-3_MASK>0x08</TCNT2-3_MASK>
        <TCNT2-4_MASK>0x10</TCNT2-4_MASK>
        <TCNT2-5_MASK>0x20</TCNT2-5_MASK>
        <TCNT2-6_MASK>0x40</TCNT2-6_MASK>
        <TCNT2-7_MASK>0x80</TCNT2-7_MASK>
      </TCNT2>
      <OCR2>
        <IO_ADDR>$22</IO_ADDR>
        <MEM_ADDR>$42</MEM_ADDR>
        <OCR2-0_MASK>0x01</OCR2-0_MASK>
        <OCR2-1_MASK>0x02</OCR2-1_MASK>
        <OCR2-2_MASK>0x04</OCR2-2_MASK>
        <OCR2-3_MASK>0x08</OCR2-3_MASK>
        <OCR2-4_MASK>0x10</OCR2-4_MASK>
        <OCR2-5_MASK>0x20</OCR2-5_MASK>
        <OCR2-6_MASK>0x40</OCR2-6_MASK>
        <OCR2-7_MASK>0x80</OCR2-7_MASK>
      </OCR2>
      <WDTCR>
        <IO_ADDR>$21</IO_ADDR>
        <MEM_ADDR>$41</MEM_ADDR>
        <WDP0_MASK>0x01</WDP0_MASK>
        <WDP1_MASK>0x02</WDP1_MASK>
        <WDP2_MASK>0x04</WDP2_MASK>
        <WDE_MASK>0x08</WDE_MASK>
        <WDTOE_MASK>0x10</WDTOE_MASK>
      </WDTCR>
      <UBRRHI>
        <IO_ADDR>$20</IO_ADDR>
        <MEM_ADDR>$40</MEM_ADDR>
        <UBRRHI00_MASK>0x01</UBRRHI00_MASK>
        <UBRRHI01_MASK>0x02</UBRRHI01_MASK>
        <UBRRHI02_MASK>0x04</UBRRHI02_MASK>
        <UBRRHI03_MASK>0x08</UBRRHI03_MASK>
        <UBRRHI10_MASK>0x10</UBRRHI10_MASK>
        <UBRRHI11_MASK>0x20</UBRRHI11_MASK>
        <UBRRHI12_MASK>0x40</UBRRHI12_MASK>
        <UBRRHI13_MASK>0x80</UBRRHI13_MASK>
      </UBRRHI>
      <EEARH>
        <IO_ADDR>$1F</IO_ADDR>
        <MEM_ADDR>$3F</MEM_ADDR>
        <EEAR8_MASK>0x01</EEAR8_MASK>
      </EEARH>
      <EEARL>
        <IO_ADDR>$1E</IO_ADDR>
        <MEM_ADDR>$3E</MEM_ADDR>
        <EEAR0_MASK>0x01</EEAR0_MASK>
        <EEAR1_MASK>0x02</EEAR1_MASK>
        <EEAR2_MASK>0x04</EEAR2_MASK>
        <EEAR3_MASK>0x08</EEAR3_MASK>
        <EEAR4_MASK>0x10</EEAR4_MASK>
        <EEAR5_MASK>0x20</EEAR5_MASK>
        <EEAR6_MASK>0x40</EEAR6_MASK>
        <EEAR7_MASK>0x80</EEAR7_MASK>
      </EEARL>
      <EEDR>
        <IO_ADDR>$1D</IO_ADDR>
        <MEM_ADDR>$3D</MEM_ADDR>
        <EEDR0_MASK>0x01</EEDR0_MASK>
        <EEDR1_MASK>0x02</EEDR1_MASK>
        <EEDR2_MASK>0x04</EEDR2_MASK>
        <EEDR3_MASK>0x08</EEDR3_MASK>
        <EEDR4_MASK>0x10</EEDR4_MASK>
        <EEDR5_MASK>0x20</EEDR5_MASK>
        <EEDR6_MASK>0x40</EEDR6_MASK>
        <EEDR7_MASK>0x80</EEDR7_MASK>
      </EEDR>
      <EECR>
        <IO_ADDR>$1C</IO_ADDR>
        <MEM_ADDR>$3C</MEM_ADDR>
        <EERE_MASK>0x01</EERE_MASK>
        <EEWE_MASK>0x02</EEWE_MASK>
        <EEMWE_MASK>0x04</EEMWE_MASK>
        <EERIE_MASK>0x08</EERIE_MASK>
      </EECR>
      <PORTA>
        <IO_ADDR>$1B</IO_ADDR>
        <MEM_ADDR>$3B</MEM_ADDR>
        <MASK>$ff</MASK>
        <PORTA0_MASK>0x01</PORTA0_MASK>
        <PORTA1_MASK>0x02</PORTA1_MASK>
        <PORTA2_MASK>0x04</PORTA2_MASK>
        <PORTA3_MASK>0x08</PORTA3_MASK>
        <PORTA4_MASK>0x10</PORTA4_MASK>
        <PORTA5_MASK>0x20</PORTA5_MASK>
        <PORTA6_MASK>0x40</PORTA6_MASK>
        <PORTA7_MASK>0x80</PORTA7_MASK>
      </PORTA>
      <DDRA>
        <IO_ADDR>$1A</IO_ADDR>
        <MEM_ADDR>$3A</MEM_ADDR>
        <DDA0_MASK>0x01</DDA0_MASK>
        <DDA1_MASK>0x02</DDA1_MASK>
        <DDA2_MASK>0x04</DDA2_MASK>
        <DDA3_MASK>0x08</DDA3_MASK>
        <DDA4_MASK>0x10</DDA4_MASK>
        <DDA5_MASK>0x20</DDA5_MASK>
        <DDA6_MASK>0x40</DDA6_MASK>
        <DDA7_MASK>0x80</DDA7_MASK>
      </DDRA>
      <PINA>
        <IO_ADDR>$19</IO_ADDR>
        <MEM_ADDR>$39</MEM_ADDR>
        <PINA0_MASK>0x01</PINA0_MASK>
        <PINA1_MASK>0x02</PINA1_MASK>
        <PINA2_MASK>0x04</PINA2_MASK>
        <PINA3_MASK>0x08</PINA3_MASK>
        <PINA4_MASK>0x10</PINA4_MASK>
        <PINA5_MASK>0x20</PINA5_MASK>
        <PINA6_MASK>0x40</PINA6_MASK>
        <PINA7_MASK>0x80</PINA7_MASK>
      </PINA>
      <PORTB>
        <IO_ADDR>$18</IO_ADDR>
        <MEM_ADDR>$38</MEM_ADDR>
        <MASK>$ff</MASK>
        <PORTB0_MASK>0x01</PORTB0_MASK>
        <PORTB1_MASK>0x02</PORTB1_MASK>
        <PORTB2_MASK>0x04</PORTB2_MASK>
        <PORTB3_MASK>0x08</PORTB3_MASK>
        <PORTB4_MASK>0x10</PORTB4_MASK>
        <PORTB5_MASK>0x20</PORTB5_MASK>
        <PORTB6_MASK>0x40</PORTB6_MASK>
        <PORTB7_MASK>0x80</PORTB7_MASK>
      </PORTB>
      <DDRB>
        <IO_ADDR>$17</IO_ADDR>
        <MEM_ADDR>$37</MEM_ADDR>
        <DDB0_MASK>0x01</DDB0_MASK>
        <DDB1_MASK>0x02</DDB1_MASK>
        <DDB2_MASK>0x04</DDB2_MASK>
        <DDB3_MASK>0x08</DDB3_MASK>
        <DDB4_MASK>0x10</DDB4_MASK>
        <DDB5_MASK>0x20</DDB5_MASK>
        <DDB6_MASK>0x40</DDB6_MASK>
        <DDB7_MASK>0x80</DDB7_MASK>
      </DDRB>
      <PINB>
        <IO_ADDR>$16</IO_ADDR>
        <MEM_ADDR>$36</MEM_ADDR>
        <PINB0_MASK>0x01</PINB0_MASK>
        <PINB1_MASK>0x02</PINB1_MASK>
        <PINB2_MASK>0x04</PINB2_MASK>
        <PINB3_MASK>0x08</PINB3_MASK>
        <PINB4_MASK>0x10</PINB4_MASK>
        <PINB5_MASK>0x20</PINB5_MASK>
        <PINB6_MASK>0x40</PINB6_MASK>
        <PINB7_MASK>0x80</PINB7_MASK>
      </PINB>
      <PORTC>
        <IO_ADDR>$15</IO_ADDR>
        <MEM_ADDR>$35</MEM_ADDR>
        <MASK>$ff</MASK>
        <PORTC0_MASK>0x01</PORTC0_MASK>
        <PORTC1_MASK>0x02</PORTC1_MASK>
        <PORTC2_MASK>0x04</PORTC2_MASK>
        <PORTC3_MASK>0x08</PORTC3_MASK>
        <PORTC4_MASK>0x10</PORTC4_MASK>
        <PORTC5_MASK>0x20</PORTC5_MASK>
        <PORTC6_MASK>0x40</PORTC6_MASK>
        <PORTC7_MASK>0x80</PORTC7_MASK>
      </PORTC>
      <DDRC>
        <IO_ADDR>$14</IO_ADDR>
        <MEM_ADDR>$34</MEM_ADDR>
        <DDC0_MASK>0x01</DDC0_MASK>
        <DDC1_MASK>0x02</DDC1_MASK>
        <DDC2_MASK>0x04</DDC2_MASK>
        <DDC3_MASK>0x08</DDC3_MASK>
        <DDC4_MASK>0x10</DDC4_MASK>
        <DDC5_MASK>0x20</DDC5_MASK>
        <DDC6_MASK>0x40</DDC6_MASK>
        <DDC7_MASK>0x80</DDC7_MASK>
      </DDRC>
      <PINC>
        <IO_ADDR>$13</IO_ADDR>
        <MEM_ADDR>$33</MEM_ADDR>
        <PINC0_MASK>0x01</PINC0_MASK>
        <PINC1_MASK>0x02</PINC1_MASK>
        <PINC2_MASK>0x04</PINC2_MASK>
        <PINC3_MASK>0x08</PINC3_MASK>
        <PINC4_MASK>0x10</PINC4_MASK>
        <PINC5_MASK>0x20</PINC5_MASK>
        <PINC6_MASK>0x40</PINC6_MASK>
        <PINC7_MASK>0x80</PINC7_MASK>
      </PINC>
      <PORTD>
        <IO_ADDR>$12</IO_ADDR>
        <MEM_ADDR>$32</MEM_ADDR>
        <MASK>$ff</MASK>
        <PORTD0_MASK>0x01</PORTD0_MASK>
        <PORTD1_MASK>0x02</PORTD1_MASK>
        <PORTD2_MASK>0x04</PORTD2_MASK>
        <PORTD3_MASK>0x08</PORTD3_MASK>
        <PORTD4_MASK>0x10</PORTD4_MASK>
        <PORTD5_MASK>0x20</PORTD5_MASK>
        <PORTD6_MASK>0x40</PORTD6_MASK>
        <PORTD7_MASK>0x80</PORTD7_MASK>
      </PORTD>
      <DDRD>
        <IO_ADDR>$11</IO_ADDR>
        <MEM_ADDR>$31</MEM_ADDR>
        <DDD0_MASK>0x01</DDD0_MASK>
        <DDD1_MASK>0x02</DDD1_MASK>
        <DDD2_MASK>0x04</DDD2_MASK>
        <DDD3_MASK>0x08</DDD3_MASK>
        <DDD4_MASK>0x10</DDD4_MASK>
        <DDD5_MASK>0x20</DDD5_MASK>
        <DDD6_MASK>0x40</DDD6_MASK>
        <DDD7_MASK>0x80</DDD7_MASK>
      </DDRD>
      <PIND>
        <IO_ADDR>$10</IO_ADDR>
        <MEM_ADDR>$30</MEM_ADDR>
        <PIND0_MASK>0x01</PIND0_MASK>
        <PIND1_MASK>0x02</PIND1_MASK>
        <PIND2_MASK>0x04</PIND2_MASK>
        <PIND3_MASK>0x08</PIND3_MASK>
        <PIND4_MASK>0x10</PIND4_MASK>
        <PIND5_MASK>0x20</PIND5_MASK>
        <PIND6_MASK>0x40</PIND6_MASK>
        <PIND7_MASK>0x80</PIND7_MASK>
      </PIND>
      <SPDR>
        <IO_ADDR>$0F</IO_ADDR>
        <MEM_ADDR>$2F</MEM_ADDR>
        <SPDR0_MASK>0x01</SPDR0_MASK>
        <SPDR1_MASK>0x02</SPDR1_MASK>
        <SPDR2_MASK>0x04</SPDR2_MASK>
        <SPDR3_MASK>0x08</SPDR3_MASK>
        <SPDR4_MASK>0x10</SPDR4_MASK>
        <SPDR5_MASK>0x20</SPDR5_MASK>
        <SPDR6_MASK>0x40</SPDR6_MASK>
        <SPDR7_MASK>0x80</SPDR7_MASK>
      </SPDR>
      <SPSR>
        <IO_ADDR>$0E</IO_ADDR>
        <MEM_ADDR>$2E</MEM_ADDR>
        <SPI2X_MASK>0x01</SPI2X_MASK>
        <WCOL_MASK>0x40</WCOL_MASK>
        <SPIF_MASK>0x80</SPIF_MASK>
      </SPSR>
      <SPCR>
        <IO_ADDR>$0D</IO_ADDR>
        <MEM_ADDR>$2D</MEM_ADDR>
        <SPR0_MASK>0x01</SPR0_MASK>
        <SPR1_MASK>0x02</SPR1_MASK>
        <CPHA_MASK>0x04</CPHA_MASK>
        <CPOL_MASK>0x08</CPOL_MASK>
        <MSTR_MASK>0x10</MSTR_MASK>
        <DORD_MASK>0x20</DORD_MASK>
        <SPE_MASK>0x40</SPE_MASK>
        <SPIE_MASK>0x80</SPIE_MASK>
      </SPCR>
      <UDR0>
        <IO_ADDR>$0C</IO_ADDR>
        <MEM_ADDR>$2C</MEM_ADDR>
        <UDR00_MASK>0x01</UDR00_MASK>
        <UDR01_MASK>0x02</UDR01_MASK>
        <UDR02_MASK>0x04</UDR02_MASK>
        <UDR03_MASK>0x08</UDR03_MASK>
        <UDR04_MASK>0x10</UDR04_MASK>
        <UDR05_MASK>0x20</UDR05_MASK>
        <UDR06_MASK>0x40</UDR06_MASK>
        <UDR07_MASK>0x80</UDR07_MASK>
      </UDR0>
      <UCSR0A>
        <IO_ADDR>$0B</IO_ADDR>
        <MEM_ADDR>$2B</MEM_ADDR>
        <MPCM0_MASK>0x01</MPCM0_MASK>
        <U2X0_MASK>0x02</U2X0_MASK>
        <OR0_MASK>0x08</OR0_MASK>
        <FE0_MASK>0x10</FE0_MASK>
        <UDRE0_MASK>0x20</UDRE0_MASK>
        <TXC0_MASK>0x40</TXC0_MASK>
        <RXC0_MASK>0x80</RXC0_MASK>
      </UCSR0A>
      <UCSR0B>
        <IO_ADDR>$0A</IO_ADDR>
        <MEM_ADDR>$2A</MEM_ADDR>
        <TXB80_MASK>0x01</TXB80_MASK>
        <RXB80_MASK>0x02</RXB80_MASK>
        <CHR90_MASK>0x04</CHR90_MASK>
        <TXEN0_MASK>0x08</TXEN0_MASK>
        <RXEN0_MASK>0x10</RXEN0_MASK>
        <UDR0IE0_MASK>0x20</UDR0IE0_MASK>
        <TXCIE0_MASK>0x40</TXCIE0_MASK>
        <RXCIE0_MASK>0x80</RXCIE0_MASK>
      </UCSR0B>
      <UBRR0>
        <IO_ADDR>$09</IO_ADDR>
        <MEM_ADDR>$29</MEM_ADDR>
        <UBRR00_MASK>0x01</UBRR00_MASK>
        <UBRR01_MASK>0x02</UBRR01_MASK>
        <UBRR02_MASK>0x04</UBRR02_MASK>
        <UBRR03_MASK>0x08</UBRR03_MASK>
        <UBRR04_MASK>0x10</UBRR04_MASK>
        <UBRR05_MASK>0x20</UBRR05_MASK>
        <UBRR06_MASK>0x40</UBRR06_MASK>
        <UBRR07_MASK>0x80</UBRR07_MASK>
      </UBRR0>
      <ACSR>
        <IO_ADDR>$08</IO_ADDR>
        <MEM_ADDR>$28</MEM_ADDR>
        <ACIS0_MASK>0x01</ACIS0_MASK>
        <ACIS1_MASK>0x02</ACIS1_MASK>
        <ACIC_MASK>0x04</ACIC_MASK>
        <ACIE_MASK>0x08</ACIE_MASK>
        <ACI_MASK>0x10</ACI_MASK>
        <ACO_MASK>0x20</ACO_MASK>
        <AINBG_MASK>0x40</AINBG_MASK>
        <ACD_MASK>0x80</ACD_MASK>
      </ACSR>
      <PORTE>
        <IO_ADDR>$07</IO_ADDR>
        <MEM_ADDR>$27</MEM_ADDR>
        <PORTE0_MASK>0x01</PORTE0_MASK>
        <PORTE1_MASK>0x02</PORTE1_MASK>
        <PORTE2_MASK>0x04</PORTE2_MASK>
      </PORTE>
      <DDRE>
        <IO_ADDR>$06</IO_ADDR>
        <MEM_ADDR>$26</MEM_ADDR>
        <DDE0_MASK>0x01</DDE0_MASK>
        <DDE1_MASK>0x02</DDE1_MASK>
        <DDE2_MASK>0x04</DDE2_MASK>
      </DDRE>
      <PINE>
        <IO_ADDR>$05</IO_ADDR>
        <MEM_ADDR>$25</MEM_ADDR>
        <PINE0_MASK>0x01</PINE0_MASK>
        <PINE1_MASK>0x02</PINE1_MASK>
        <PINE2_MASK>0x04</PINE2_MASK>
      </PINE>
      <UDR1>
        <IO_ADDR>$03</IO_ADDR>
        <MEM_ADDR>$23</MEM_ADDR>
        <UDR10_MASK>0x01</UDR10_MASK>
        <UDR11_MASK>0x02</UDR11_MASK>
        <UDR12_MASK>0x04</UDR12_MASK>
        <UDR13_MASK>0x08</UDR13_MASK>
        <UDR14_MASK>0x10</UDR14_MASK>
        <UDR15_MASK>0x20</UDR15_MASK>
        <UDR16_MASK>0x40</UDR16_MASK>
        <UDR17_MASK>0x80</UDR17_MASK>
      </UDR1>
      <UCSR1A>
        <IO_ADDR>$02</IO_ADDR>
        <MEM_ADDR>$22</MEM_ADDR>
        <MPCM1_MASK>0x01</MPCM1_MASK>
        <U2X1_MASK>0x02</U2X1_MASK>
        <OR1_MASK>0x08</OR1_MASK>
        <FE1_MASK>0x10</FE1_MASK>
        <UDRE1_MASK>0x20</UDRE1_MASK>
        <TXC1_MASK>0x40</TXC1_MASK>
        <RXC1_MASK>0x80</RXC1_MASK>
      </UCSR1A>
      <UCSR1B>
        <IO_ADDR>$01</IO_ADDR>
        <MEM_ADDR>$21</MEM_ADDR>
        <TXB81_MASK>0x01</TXB81_MASK>
        <RXB81_MASK>0x02</RXB81_MASK>
        <CHR91_MASK>0x04</CHR91_MASK>
        <TXEN1_MASK>0x08</TXEN1_MASK>
        <RXEN1_MASK>0x10</RXEN1_MASK>
        <UDR1IE1_MASK>0x20</UDR1IE1_MASK>
        <TXCIE1_MASK>0x40</TXCIE1_MASK>
        <RXCIE1_MASK>0x80</RXCIE1_MASK>
      </UCSR1B>
      <UBRR1>
        <IO_ADDR>$00</IO_ADDR>
        <MEM_ADDR>$20</MEM_ADDR>
        <UBRR10_MASK>0x01</UBRR10_MASK>
        <UBRR11_MASK>0x02</UBRR11_MASK>
        <UBRR12_MASK>0x04</UBRR12_MASK>
        <UBRR13_MASK>0x08</UBRR13_MASK>
        <UBRR14_MASK>0x10</UBRR14_MASK>
        <UBRR15_MASK>0x20</UBRR15_MASK>
        <UBRR16_MASK>0x40</UBRR16_MASK>
        <UBRR17_MASK>0x80</UBRR17_MASK>
      </UBRR1>
    </IO_MEMORY>
    <BOOT_CONFIG>
      <NRWW_START_ADDR>0</NRWW_START_ADDR>
      <NRWW_STOP_ADDR>0x1FFF</NRWW_STOP_ADDR>
      <RWW_START_ADDR>NA</RWW_START_ADDR>
      <RWW_STOP_ADDR>NA</RWW_STOP_ADDR>
      <PAGESIZE>64</PAGESIZE>
      <BOOTSZMODE1>
        <BOOTSIZE>512</BOOTSIZE>
        <PAGES>8</PAGES>
        <APPSTART>0</APPSTART>
        <BOOTSTART>$1E00</BOOTSTART>
        <BOOTRESET>$1E00</BOOTRESET>
      </BOOTSZMODE1>
    </BOOT_CONFIG>
  </MEMORY>
  <PACKAGE>
    <PACKAGES>[TQFP]</PACKAGES>
    <TQFP>
      <NMB_PIN>44</NMB_PIN>
      <PIN1>
        <NAME>[PB5:MOSI]</NAME>
        <TEXT>MOSI: SPI Master data output, slave data input for SPI channel. When the SPI is enabled as a slave, this pin is configured as an input regardless of the setting of DDB5. When the SPI is enabled as a master, the data direction of this pin is con-trolled by DDB5. When the pin is forced to be an input, the pull-up can still be controlled by the PORTB5 bit. See the description of the SPI port for further details.</TEXT>
      </PIN1>
      <PIN2>
        <NAME>[PB6:MISO]</NAME>
        <TEXT>MISO: Master data input, slave data output pin for SPI channel. When the SPI is enabled as a master, this pin is configured as an input regardless of the setting of DDB6. When the SPI is enabled as a slave, the data direction of this pin is controlled by DDB6. When the pin is forced to be an input, the pull-up can still be controlled by the PORTB6 bit. See the description of the SPI port for further details.</TEXT>
      </PIN2>
      <PIN3>
        <NAME>[PB7:SCK]</NAME>
        <TEXT>SCK: Master clock output, slave clock input pin for SPI channel. When the SPI is enabled as a slave, this pin is configured as an input regardless of the setting of DDB7. When the SPI is enabled as a master, the data direction of this pin is con-trolled by DDB7. When the pin is forced to be an input, the pull-up can still be controlled by the PORTB7 bit. See the description of the SPI port for further details.</TEXT>
      </PIN3>
      <PIN4>
        <NAME>['RESET]</NAME>
        <TEXT/>
      </PIN4>
      <PIN5>
        <NAME>[PD0:RXD]</NAME>
        <TEXT>Receive Data (data input pin for the UART). When the UART receiver is enabled, this pin is configured as an input, regardless of the value of DDRD0. When the UART forces this pin to be an input, a logical &#x201C;1&#x201D; in PORTD0 will turn on the internal pull-up.</TEXT>
      </PIN5>
      <PIN6>
        <NAME>[NC]</NAME>
        <TEXT/>
      </PIN6>
      <PIN7>
        <NAME>[PD1:TXD]</NAME>
        <TEXT>Transmit Data (data output pin for the UART). When the UART transmitter is enabled, this pin is configured as an output, regardless of the value of DDRD1.</TEXT>
      </PIN7>
      <PIN8>
        <NAME>[PD2:INT0]</NAME>
        <TEXT>INT0: External Interrupt source 0. The PD2 pin can serve as an external interrupt source to the MCU. See the interrupt description for further details and how to enable the source.</TEXT>
      </PIN8>
      <PIN9>
        <NAME>[PD3:INT1]</NAME>
        <TEXT>INT1: External Interrupt source 1. The PD3 pin can serve as an external interrupt source to the MCU. See the interrupt description for further details and how to enable the source.</TEXT>
      </PIN9>
      <PIN10>
        <NAME>[PD4]</NAME>
        <TEXT/>
      </PIN10>
      <PIN11>
        <NAME>[PD5:OC1A:TOSC2]</NAME>
        <TEXT>OC1A: Output compare match output. The PD5 pin can serve as an external output when the Timer/Counter1 compare matches. The PD5 pin has to be configured as an output (DDD5 set [one]) to serve this function. See the Timer/Counter1 description for further details and how to enable the output. The OC1A pin is also the output pin for the PWM mode timer function.</TEXT>
      </PIN11>
      <PIN12>
        <NAME>[PD6:'WR]</NAME>
        <TEXT>WR is the external data memory write control strobe. See &#x201C;Interface to External SRAM&#x201D; on page 52 for detailed information.</TEXT>
      </PIN12>
      <PIN13>
        <NAME>[PD7:'RD]</NAME>
        <TEXT>RD is the external data memory read control strobe. See &#x201C;Interface to External SRAM&#x201D; on page 52 for detailed information.</TEXT>
      </PIN13>
      <PIN14>
        <NAME>[XTAL2]</NAME>
        <TEXT/>
      </PIN14>
      <PIN15>
        <NAME>[XTAL1]</NAME>
        <TEXT/>
      </PIN15>
      <PIN16>
        <NAME>[GND]</NAME>
        <TEXT/>
      </PIN16>
      <PIN17>
        <NAME>[NC]</NAME>
        <TEXT/>
      </PIN17>
      <PIN18>
        <NAME>[PC0:A8]</NAME>
        <TEXT/>
      </PIN18>
      <PIN19>
        <NAME>[PC1:A9]</NAME>
        <TEXT/>
      </PIN19>
      <PIN20>
        <NAME>[PC2:A10]</NAME>
        <TEXT/>
      </PIN20>
      <PIN21>
        <NAME>[PC3:A11]</NAME>
        <TEXT/>
      </PIN21>
      <PIN22>
        <NAME>[PC4:A12]</NAME>
        <TEXT/>
      </PIN22>
      <PIN23>
        <NAME>[PC5:A13]</NAME>
        <TEXT/>
      </PIN23>
      <PIN24>
        <NAME>[PC6:A14]</NAME>
        <TEXT/>
      </PIN24>
      <PIN25>
        <NAME>[PC7:A15]</NAME>
        <TEXT/>
      </PIN25>
      <PIN26>
        <NAME>[PE2:OC1B]</NAME>
        <TEXT/>
      </PIN26>
      <PIN27>
        <NAME>[PE1:ALE]</NAME>
        <TEXT/>
      </PIN27>
      <PIN28>
        <NAME>[NC]</NAME>
        <TEXT/>
      </PIN28>
      <PIN29>
        <NAME>[PE0:ICP/INT2]</NAME>
        <TEXT/>
      </PIN29>
      <PIN30>
        <NAME>[PA7:AD7]</NAME>
        <TEXT/>
      </PIN30>
      <PIN31>
        <NAME>[PA6:AD6]</NAME>
        <TEXT/>
      </PIN31>
      <PIN32>
        <NAME>[PA5:AD5]</NAME>
        <TEXT/>
      </PIN32>
      <PIN33>
        <NAME>[PA4:AD4]</NAME>
        <TEXT/>
      </PIN33>
      <PIN34>
        <NAME>[PA3:AD3]</NAME>
        <TEXT/>
      </PIN34>
      <PIN35>
        <NAME>[PA2:AD2]</NAME>
        <TEXT/>
      </PIN35>
      <PIN36>
        <NAME>[PA1:AD1]</NAME>
        <TEXT/>
      </PIN36>
      <PIN37>
        <NAME>[PA0:AD0]</NAME>
        <TEXT/>
      </PIN37>
      <PIN38>
        <NAME>[VCC]</NAME>
        <TEXT/>
      </PIN38>
      <PIN39>
        <NAME>[NC]</NAME>
        <TEXT/>
      </PIN39>
      <PIN40>
        <NAME>[PB0:OC0/T0]</NAME>
        <TEXT>T0: Timer/Counter0 counter source. See the timer description for further details.</TEXT>
      </PIN40>
      <PIN41>
        <NAME>[PB1:OC2/T1]</NAME>
        <TEXT>T1: Timer/Counter1 counter source. See the timer description for further details</TEXT>
      </PIN41>
      <PIN42>
        <NAME>[PB2:RXD1:AIN0]</NAME>
        <TEXT>AIN0: Analog Comparator Positive Input. When configured as an input (DDB2 is cleared [zero]) and with the internal MOS pull-up resistor switched off (PB2 is cleared [zero]), this pin also serves as the positive input of the on-chip Analog Comparator.</TEXT>
      </PIN42>
      <PIN43>
        <NAME>[PB3:TXD1:AIN1]</NAME>
        <TEXT>AIN1: Analog Comparator Negative Input. When configured as an input (DDB3 is cleared [zero]) and with the internal MOS pull-up resistor switched off (PB3 is cleared [zero]), this pin also serves as the negative input of the on-chip Analog Comparator.</TEXT>
      </PIN43>
      <PIN44>
        <NAME>[PB4:SS]</NAME>
        <TEXT>SS: Slave port select input. When the SPI is enabled as a slave, this pin is configured as an input regardless of the setting of DDB4. As a slave, the SPI is activated when this pin is driven low. When the SPI is enabled as a master, the data direc-tion of this pin is controlled by DDB4. When the pin is forced to be an input, the pull-up can still be controlled by the PORTB4 bit. See the description of the SPI port for further details.</TEXT>
      </PIN44>
    </TQFP>
  </PACKAGE>
  <POWER>
    <CLOCK>4MHz</CLOCK>
    <TEMP>25C</TEMP>
    <ACTIVE>3.0 mA</ACTIVE>
    <IDLE>1.2 mA</IDLE>
    <POWER_DOWN>&lt;1uA</POWER_DOWN>
  </POWER>
  <PROGVOLT>
    <SER_PROG_MIN_V>4.0</SER_PROG_MIN_V>
    <SER_PROG_MAX_V>5.5</SER_PROG_MAX_V>
    <PAR_PROG_MIN_V>4.0</PAR_PROG_MIN_V>
    <PAR_PROG_MAX_V>5.5</PAR_PROG_MAX_V>
  </PROGVOLT>
  <LOCKBIT>
    <ICON/>
    <ID/>
    <TEXT>[LB1 = 1 :  LB2 = 1] No memory lock features enabled. [LB1 = 0 :  LB2 = 1] Further programming of Flash and EEPROM is enabled. [LB1 = 0 :  LB2 = 0] Same as previous, but verify is also disabled</TEXT>
    <NMB_LOCK_BITS>6</NMB_LOCK_BITS>
    <NMB_TEXT>11</NMB_TEXT>
    <TEXT1>
      <MASK>0x03</MASK>
      <VALUE>0x03</VALUE>
      <TEXT>Mode 1: No memory lock features enabled</TEXT>
    </TEXT1>
    <TEXT2>
      <MASK>0x03</MASK>
      <VALUE>0x02</VALUE>
      <TEXT>Mode 2: Further programming disabled</TEXT>
    </TEXT2>
    <TEXT3>
      <MASK>0x03</MASK>
      <VALUE>0x00</VALUE>
      <TEXT>Mode 3: Further programming and verification disabled</TEXT>
    </TEXT3>
    <TEXT4>
      <MASK>0x0C</MASK>
      <VALUE>0x0C</VALUE>
      <TEXT>Application Protection Mode 1: No lock on SPM and LPM in Application Section</TEXT>
    </TEXT4>
    <TEXT5>
      <MASK>0x0C</MASK>
      <VALUE>0x08</VALUE>
      <TEXT>Application Protection Mode 2: SPM prohibited in Application Section</TEXT>
    </TEXT5>
    <TEXT6>
      <MASK>0x0C</MASK>
      <VALUE>0x00</VALUE>
      <TEXT>Application Protection Mode 3: LPM and SPM prohibited in Application Section</TEXT>
    </TEXT6>
    <TEXT7>
      <MASK>0x0C</MASK>
      <VALUE>0x04</VALUE>
      <TEXT>Application Protection Mode 4: LPM prohibited in Application Section</TEXT>
    </TEXT7>
    <TEXT8>
      <MASK>0x30</MASK>
      <VALUE>0x30</VALUE>
      <TEXT>Boot Loader Protection Mode 1: No lock on SPM and LPM in Boot Loader Section</TEXT>
    </TEXT8>
    <TEXT9>
      <MASK>0x30</MASK>
      <VALUE>0x20</VALUE>
      <TEXT>Boot Loader Protection Mode 2: SPM prohibited in Boot Loader Section</TEXT>
    </TEXT9>
    <TEXT10>
      <MASK>0x30</MASK>
      <VALUE>0x00</VALUE>
      <TEXT>Boot Loader Protection Mode 3: LPM and SPM prohibited in Boot Loader Section</TEXT>
    </TEXT10>
    <TEXT11>
      <MASK>0x30</MASK>
      <VALUE>0x10</VALUE>
      <TEXT>Boot Loader Protection Mode 4: LPM prohibited in Boot Loader Section</TEXT>
    </TEXT11>
    <LOCKBIT0>
      <NAME>LB1</NAME>
      <TEXT>Lock bit</TEXT>
    </LOCKBIT0>
    <LOCKBIT1>
      <NAME>LB2</NAME>
      <TEXT>Lock bit</TEXT>
    </LOCKBIT1>
    <LOCKBIT2>
      <NAME>BLB01</NAME>
      <TEXT>Boot Lock bit</TEXT>
    </LOCKBIT2>
    <LOCKBIT3>
      <NAME>BLB02</NAME>
      <TEXT>Boot Lock bit</TEXT>
    </LOCKBIT3>
    <LOCKBIT4>
      <NAME>BLB11</NAME>
      <TEXT>Boot lock bit</TEXT>
    </LOCKBIT4>
    <LOCKBIT5>
      <NAME>BLB12</NAME>
      <TEXT>Boot lock bit</TEXT>
    </LOCKBIT5>
  </LOCKBIT>
  <FUSE>
    <LIST>[LOW:HIGH:EXTENDED]</LIST>
    <ID/>
    <ICON/>
    <TEXT/>
    <LOW>
      <NMB_FUSE_BITS>6</NMB_FUSE_BITS>
      <FUSE5>
        <NAME>BOOTRST</NAME>
        <TEXT>Boot Reset Vector Enabled</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE5>
      <FUSE4>
        <NAME>SPIEN</NAME>
        <TEXT>Serial program downloading (SPI) enabled</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE4>
      <FUSE3>
        <NAME>SUT</NAME>
        <TEXT>Start-up time</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE3>
      <FUSE2>
        <NAME>CKSEL2</NAME>
        <TEXT>Select Clock Source</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE2>
      <FUSE1>
        <NAME>CKSEL1</NAME>
        <TEXT>Select Clock Source</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE1>
      <FUSE0>
        <NAME>CKSEL0</NAME>
        <TEXT>Select Clock Source</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE0>
      <NMB_TEXT>11</NMB_TEXT>
      <TEXT1>
        <MASK>0x20</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Boot Reset Vector Enabled</TEXT>
      </TEXT1>
      <TEXT2>
        <MASK>0x10</MASK>
        <VALUE>0x0</VALUE>
        <TEXT>Serial program downloading (SPI) enabled</TEXT>
      </TEXT2>
      <TEXT3>
        <MASK>0x08</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Start-up time</TEXT>
      </TEXT3>
      <TEXT4>
        <MASK>0x07</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>CKSEL=000 External Clock; fast rising power</TEXT>
      </TEXT4>
      <TEXT5>
        <MASK>0x07</MASK>
        <VALUE>0x01</VALUE>
        <TEXT>CKSEL=001 External Clock; BOD Enabled or power-on reset</TEXT>
      </TEXT5>
      <TEXT6>
        <MASK>0x07</MASK>
        <VALUE>0x02</VALUE>
        <TEXT>CKSEL=010 Crystal Oscillator; slowly rising power ; default value</TEXT>
      </TEXT6>
      <TEXT7>
        <MASK>0x07</MASK>
        <VALUE>0x03</VALUE>
        <TEXT>CKSEL=011 Crystal Oscillator; fast rising power</TEXT>
      </TEXT7>
      <TEXT8>
        <MASK>0x07</MASK>
        <VALUE>0x04</VALUE>
        <TEXT>CKSEL=100 Crystal Oscillator; BOD Enabled or power-on reset</TEXT>
      </TEXT8>
      <TEXT9>
        <MASK>0x07</MASK>
        <VALUE>0x05</VALUE>
        <TEXT>CKSEL=101 Ceramic Resonator / External Clock; Slowly rising power</TEXT>
      </TEXT9>
      <TEXT10>
        <MASK>0x07</MASK>
        <VALUE>0x06</VALUE>
        <TEXT>CKSEL=110 Ceramic Resonator; fast rising power</TEXT>
      </TEXT10>
      <TEXT11>
        <MASK>0x07</MASK>
        <VALUE>0x07</VALUE>
        <TEXT>CKSEL=111 Ceramic Resonator; BOD Enabled or power-on reset</TEXT>
      </TEXT11>
    </LOW>
  </FUSE>
  <PROGRAMMING>
    <ISPInterface>
      <FuseProgMask>0xdf</FuseProgMask>
      <FuseWarning>0,0x20,0x20,WARNING! These fuse settings will disable the ISP interface!</FuseWarning>
    </ISPInterface>
    <HVInterface>
      <FuseWarning>0,0x20,0x20,WARNING! These fuse settings will disable the ISP interface!</FuseWarning>
    </HVInterface>
    <OscCal>
		</OscCal>
    <FlashPageSize>128</FlashPageSize>
    <EepromPageSize>0</EepromPageSize>
  </PROGRAMMING>
  <IO_MODULE>
    <MODULE_LIST>[ANALOG_COMPARATOR:SPI:USART0:USART1:PORTA:PORTB:PORTC:PORTD:PORTE:EEPROM:EXTERNAL_INTERRUPT:CPU:TIMER_COUNTER_0:TIMER_COUNTER_2:TIMER_COUNTER_1:WATCHDOG]</MODULE_LIST>
    <ANALOG_COMPARATOR>
      <LIST>[ACSR]</LIST>
      <LINK/>
      <ICON>io_analo.bmp</ICON>
      <ID>AlgComp_01</ID>
      <TEXT/>
      <ACSR>
        <NAME>ACSR</NAME>
        <DESCRIPTION>Analog Comparator Control And Status Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$08</IO_ADDR>
        <MEM_ADDR>$28</MEM_ADDR>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>ACD</NAME>
          <DESCRIPTION>Analog Comparator Disable</DESCRIPTION>
          <TEXT>When this bit is written logic one, the power to the analog comparator is switched off. This bit can be set at any time to turn off the analog comparator. This will reduce power consumption in active and idle mode. When changing the ACD bit, the Analog Comparator Interrupt must be disabled by clearing the ACIE bit in ACSR. Otherwise an interrupt can occur when the bit is changed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>AINBG</NAME>
          <DESCRIPTION>Analog Comparator Bandgap Select</DESCRIPTION>
          <TEXT>When this bit is set, a fixed bandgap reference voltage replaces the positive input to the Analog Comparator. When this bit is cleared, AIN0 is applied to the positive input of the Analog Comparator. See &#x201C;Internal Voltage Reference&#x201D; on page 42.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ACO</NAME>
          <DESCRIPTION>Analog Compare Output</DESCRIPTION>
          <TEXT>The output of the analog comparator is synchronized and then directly connected to ACO. The synchronization introduces a delay of 1-2 clock cycles.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>NA</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ACI</NAME>
          <DESCRIPTION>Analog Comparator Interrupt Flag</DESCRIPTION>
          <TEXT>This bit is set by hardware when a comparator output event triggers the interrupt mode defined by ACIS1 and ACIS0. The Analog Comparator Interrupt routine is executed if the ACIE bit is set and the I-bit in SREG is set. ACI is cleared by hard-ware when executing the corresponding interrupt handling vector. Alternatively, ACI is cleared by writing a logic one to the flag.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ACIE</NAME>
          <DESCRIPTION>Analog Comparator Interrupt Enable</DESCRIPTION>
          <TEXT>When the ACIE bit is written logic one and the I-bit in the Status Register is set, the analog comparator interrupt is acti-vated. When written logic zero, the interrupt is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ACIC</NAME>
          <DESCRIPTION>Analog Comparator Input Capture Enable</DESCRIPTION>
          <TEXT>When written logic one, this bit enables the Input Capture function in Timer/Counter1 to be triggered by the analog comparator. The comparator output is in this case directly connected to the Input Capture front-end logic, making the comparator utilize the noise canceler and edge select features of the Timer/Counter1 Input Capture interrupt. When written logic zero, no connection between the analog comparator and the Input Capture function exists. To make the comparator trigger the Timer/Counter1 Input Capture interrupt, the TICIE1 bit in the Timer Interrupt Mask Register (TIMSK) must be set</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ACIS1</NAME>
          <DESCRIPTION>Analog Comparator Interrupt Mode Select bit 1</DESCRIPTION>
          <TEXT>These bits determine which comparator events that trigger the Analog Comparator interrupt.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ACIS0</NAME>
          <DESCRIPTION>Analog Comparator Interrupt Mode Select bit 0</DESCRIPTION>
          <TEXT>These bits determine which comparator events that trigger the Analog Comparator interrupt.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>ANALOG_COMP_INTERRUPT</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ACSR>
    </ANALOG_COMPARATOR>
    <SPI>
      <LIST>[SPDR:SPSR:SPCR]</LIST>
      <LINK/>
      <ICON>io_com.bmp</ICON>
      <ID>SPI_01</ID>
      <TEXT>The Serial Peripheral Interface (SPI) allows high-speed synchronous data transfer between the device and peripheral devices or between several AVR devices. The SPI includes the following features: &#x2022; Full-duplex, 3-wire Synchronous Data Transfer &#x2022; Master or Slave Operation &#x2022; LSB First or MSB First Data Transfer &#x2022; Seven Programmable Bit Rates &#x2022; End of Transmission Interrupt Flag &#x2022; Write Collision Flag Protection &#x2022; Wake-up from Idle Mode &#x2022; Double Speed (CK/2) Master SPI Mode</TEXT>
      <SPDR>
        <NAME>SPDR</NAME>
        <DESCRIPTION>SPI Data Register</DESCRIPTION>
        <TEXT>The SPI Data Register is a read/write register used for data transfer between the register file and the SPI Shift register. Writing to the register initiates data transmission. Reading the register causes the Shift Register Receive buffer to be read.</TEXT>
        <IO_ADDR>$0F</IO_ADDR>
        <MEM_ADDR>$2F</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <READ_INTRUSIVE/>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>SPDR7</NAME>
          <DESCRIPTION>SPI Data Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SPDR6</NAME>
          <DESCRIPTION>SPI Data Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SPDR5</NAME>
          <DESCRIPTION>SPI Data Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SPDR4</NAME>
          <DESCRIPTION>SPI Data Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SPDR3</NAME>
          <DESCRIPTION>SPI Data Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SPDR2</NAME>
          <DESCRIPTION>SPI Data Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SPDR1</NAME>
          <DESCRIPTION>SPI Data Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SPDR0</NAME>
          <DESCRIPTION>SPI Data Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SPDR>
      <SPSR>
        <NAME>SPSR</NAME>
        <DESCRIPTION>SPI Status Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$0E</IO_ADDR>
        <MEM_ADDR>$2E</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SPIF</NAME>
          <DESCRIPTION>SPI Interrupt Flag</DESCRIPTION>
          <TEXT>When a serial transfer is complete, the SPIF bit is set (one) and an interrupt is generated if SPIE in SPCR is set (one) and global interrupts are enabled. If SS is an input and is driven low when the SPI is in master mode, this will also set the SPIF flag. SPIF is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, the SPIF bit is cleared by first reading the SPI status register when SPIF is set (one), then accessing the SPI Data Register (SPDR).</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>WCOL</NAME>
          <DESCRIPTION>Write Collision Flag</DESCRIPTION>
          <TEXT>The WCOL bit is set if the SPI data register (SPDR) is written during a data transfer. The WCOL bit (and the SPIF bit) are cleared (zero) by first reading the SPI Status Register when WCOL is set (one), and then accessing the SPI Data Register.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT0>
          <NAME>SPI2X</NAME>
          <DESCRIPTION>Double SPI Speed Bit</DESCRIPTION>
          <TEXT>When this bit is written logic one the SPI speed (SCK Frequency) will be doubled when the SPI is in master mode (see Table 71). This means that the minimum SCK period will be 2 CPU clock periods. When the SPI is configured as Slave, the SPI is only guaranteed to work at f ck / 4 or lower. The SPI interface on the ATmega104 is also used for program memory and EEPROM downloading or uploading. See page 253 for serial programming and verification.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SPSR>
      <SPCR>
        <NAME>SPCR</NAME>
        <DESCRIPTION>SPI Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$0D</IO_ADDR>
        <MEM_ADDR>$2D</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SPIE</NAME>
          <DESCRIPTION>SPI Interrupt Enable</DESCRIPTION>
          <TEXT>This bit causes the SPI interrupt to be executed if SPIF bit in the SPSR register is set and the global interrupts are enabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SPE</NAME>
          <DESCRIPTION>SPI Enable</DESCRIPTION>
          <TEXT>When the SPE bit is set (one), the SPI is enabled. This bit must be set to enable any SPI operations.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>DORD</NAME>
          <DESCRIPTION>Data Order</DESCRIPTION>
          <TEXT>When the DORD bit is set (one), the LSB of the data word is transmitted first. When the DORD bit is cleared (zero), the MSB of the data word is transmitted first.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>MSTR</NAME>
          <DESCRIPTION>Master/Slave Select</DESCRIPTION>
          <TEXT>This bit selects Master SPI mode when set (one), and Slave SPI mode when cleared (zero). If SS is configured as an input and is driven low while MSTR is set, MSTR will be cleared, and SPIF in SPSR will become set. The user will then have to set MSTR to re-enable SPI master mode.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>CPOL</NAME>
          <DESCRIPTION>Clock polarity</DESCRIPTION>
          <TEXT>When this bit is set (one), SCK is high when idle. When CPOL is cleared (zero), SCK is low when idle. Refer to Figure 36 and Figure 37 for additional information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CPHA</NAME>
          <DESCRIPTION>Clock Phase</DESCRIPTION>
          <TEXT>Refer to Figure 36 or Figure 37 for the functionality of this bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SPR1</NAME>
          <DESCRIPTION>SPI Clock Rate Select 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SPR0</NAME>
          <DESCRIPTION>SPI Clock Rate Select 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <ENUM>COMM_SCK_RATE_3BIT</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SPCR>
    </SPI>
    <USART0>
      <LIST>[UDR0:UCSR0A:UCSR0B:UBRR0:UBRRHI]</LIST>
      <LINK/>
      <ICON>io_com.bmp</ICON>
      <ID/>
      <TEXT>The Universal Synchronous and Asynchronous serial Receiver and Transmitter (USART) is a highly flexible serial communication device. The main features are: &#x2022; Full Duplex Operation (Independent Serial Receive and Transmit Registers) &#x2022; Asynchronous or Synchronous Operation &#x2022; Master or Slave Clocked Synchronous Operation &#x2022; High Resolution Baud Rate Generator &#x2022; Supports Serial Frames with 5, 6, 7, 8 or 9 Data Bits and 1 or 2 Stop Bits &#x2022; Odd or Even Parity Generation and Parity Check Supported by Hardware &#x2022; Data OverRun Detection &#x2022; Framing Error Detection &#x2022; Noise Filtering Includes False Start Bit Detection and Digital Low Pass Filter &#x2022; Three Separate Interrupts on TX Complete, TX Data Register Empty and RX Complete &#x2022; Multi-processor Communication Mode &#x2022; Double Speed Asynchronous Com</TEXT>
      <UDR0>
        <NAME>UDR0</NAME>
        <DESCRIPTION>USART I/O Data Register</DESCRIPTION>
        <TEXT>The UDR0 register is actually two physically separate registers sharing the same I/O address. When writing to the register, the USART Transmit Data register is written. When reading from UDR0, the USART Receive Data register is read.</TEXT>
        <IO_ADDR>$0C</IO_ADDR>
        <MEM_ADDR>$2C</MEM_ADDR>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>UDR07</NAME>
          <DESCRIPTION>USART I/O Data Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>UDR06</NAME>
          <DESCRIPTION>USART I/O Data Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UDR05</NAME>
          <DESCRIPTION>USART I/O Data Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>UDR04</NAME>
          <DESCRIPTION>USART I/O Data Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>UDR03</NAME>
          <DESCRIPTION>USART I/O Data Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UDR02</NAME>
          <DESCRIPTION>USART I/O Data Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>UDR01</NAME>
          <DESCRIPTION>USART I/O Data Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>UDR00</NAME>
          <DESCRIPTION>USART I/O Data Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </UDR0>
      <UCSR0A>
        <NAME>UCSR0A</NAME>
        <DESCRIPTION>USART Control and Status Register A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$0B</IO_ADDR>
        <MEM_ADDR>$2B</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>RXC0</NAME>
          <DESCRIPTION>USART Receive Complete</DESCRIPTION>
          <TEXT>This bit is set (one) when a received character is transferred from the Receiver Shift register to UDR0. The bit is set regardless of any detected framing errors. When the RXCIE bit in UCR is set, the USART Receive Complete interrupt will be executed when RXC is set(one). RXC is cleared by reading UDR0. When interrupt-driven data reception is used, the USART Receive Complete Interrupt routine must read UDR0 in order to clear RXC, otherwise a new interrupt will occur once the interrupt routine terminates.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TXC0</NAME>
          <DESCRIPTION>USART Transmitt Complete</DESCRIPTION>
          <TEXT>This bit is set (one) when the entire character (including the stop bit) in the Transmit Shift register has been shifted out and no new data has been written to UDR0. This flag is especially useful in half-duplex communications interfaces, where a transmitting application must enter receive mode and free the communications bus immediately after completing the transmission. When the TXCIE bit in UCR is set, setting of TXC causes the USART Transmit Complete interrupt to be executed. TXC is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, the TXC bit is cleared (zero) by writing a logical one to t</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UDRE0</NAME>
          <DESCRIPTION>USART Data Register Empty</DESCRIPTION>
          <TEXT>This bit is set (one) when a character written to UDR0 is transferred to the Transmit shift register. Setting of this bit indicates that the transmitter is ready to receive a new character for transmission. When the UDR0IE bit in UCR is set, the USART Transmit Complete interrupt to be executed as long as UDR0E is set. UDR0E is cleared by writing UDR0. When interrupt-driven data transmittal is used, the USART Data Register Empty Interrupt routine must write UDR0 in order to clear UDR0E, otherwise a new interrupt will occur once the interrupt routine terminates. UDR0E is set (one) during reset to indicate that the transmitter is r</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>FE0</NAME>
          <DESCRIPTION>Framing Error</DESCRIPTION>
          <TEXT>This bit is set if a Framing Error condition is detected, i.e. when the stop bit of an incoming character is zero. The FE bit is cleared when the stop bit of received data is one.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OR0</NAME>
          <DESCRIPTION>Data overRun</DESCRIPTION>
          <TEXT>This bit is set if an Overrun condition is detected, i.e. when a character already present in the UDR0 register is not read before the next character has been shifted into the Receiver Shift register. The OR bit is buffered, which means that it will be set once the valid data still in UDR0E is read. The OR bit is cleared (zero) when data is received and transferred to UDR0. </TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT1>
          <NAME>U2X0</NAME>
          <DESCRIPTION>Double the USART transmission speed</DESCRIPTION>
          <TEXT>This bit only has effect for the asynchronous operation. Write this bit to zero when using synchronous operation. Writing this bit to one will reduce the divisor of the baud rate divider from 16 to 8 effectively doubling the transfer rate for asynchronous communication.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>MPCM0</NAME>
          <DESCRIPTION>Multi-processor Communication Mode</DESCRIPTION>
          <TEXT>This bit enables the Multi-processor Communication Mode. When the MPCM bit is written to one, all the incoming frames received by the USART receiver that do not contain address information will be ignored. The transmitter is unaffected by the MPCM setting. For more detailed information see &#x201C;Multi-processor Communication Mode&#x201D; on page 152.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </UCSR0A>
      <UCSR0B>
        <NAME>UCSR0B</NAME>
        <DESCRIPTION>USART Control and Status Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$0A</IO_ADDR>
        <MEM_ADDR>$2A</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>RXCIE0</NAME>
          <DESCRIPTION>RX Complete Interrupt Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables interrupt on the RXC flag. A USART Receive Complete interrupt will be generated only if the RXCIE bit is written to one, the global interrupt flag in SREG is written to one and the RXC bit in UCSR0A is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TXCIE0</NAME>
          <DESCRIPTION>TX Complete Interrupt Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables interrupt on the TXC flag. A USART Transmit Complete interrupt will be generated only if the TXCIE bit is written to one, the global interrupt flag in SREG is written to one and the TXC bit in UCSR0A is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UDR0IE0</NAME>
          <DESCRIPTION>USART Data register Empty Interrupt Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables interrupt on the UDR0E flag. A Data Register Empty interrupt will be generated only if the UDR0IE bit is written to one, the global interrupt flag in SREG is written to one and the UDR0E bit in UCSR0A is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>RXEN0</NAME>
          <DESCRIPTION>Receiver Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables the USART receiver. The receiver will override normal port operation for the RxD pin when enabled. Disabling the receiver will flush the receive buffer invalidating the FE, DOR and PE flags.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TXEN0</NAME>
          <DESCRIPTION>Transmitter Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables the USART transmitter. The transmitter will override normal port operation for the TxD pin when enabled. The disabling of the transmitter (writing TXEN to zero) will not become effective until ongoing and pending transmissions are completed, i.e. when the transmit shift register and transmit buffer register does not contain data to be transmitted. When disabled, the transmitter will no longer override the TxD port.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CHR90</NAME>
          <DESCRIPTION>9-Bit Character</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>RXB80</NAME>
          <DESCRIPTION>Receive Data Bit 8</DESCRIPTION>
          <TEXT>RXB8 is the 9th data bit of the received character when operating with serial frames with 9 data bits. Must be read before reading the low bits from UDR0.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TXB80</NAME>
          <DESCRIPTION>Transmit Data Bit 8</DESCRIPTION>
          <TEXT>TXB8 is the 9th data bit in the character to be transmitted when operating with serial frames with 9 data bits. Must be writ-ten before writing the low bits to UDR0.</TEXT>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </UCSR0B>
      <UBRR0>
        <NAME>UBRR0</NAME>
        <DESCRIPTION>USART Baud Rate Register Byte</DESCRIPTION>
        <TEXT>This is a 8-bit register which contains the USART baud rate.</TEXT>
        <IO_ADDR>$09</IO_ADDR>
        <MEM_ADDR>$29</MEM_ADDR>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>UBRR07</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>UBRR06</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UBRR05</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>UBRR04</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>UBRR03</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UBRR02</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>UBRR01</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>UBRR00</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </UBRR0>
      <UBRRHI>
        <NAME>UBRRHI</NAME>
        <DESCRIPTION>High Byte Baud Rate Register</DESCRIPTION>
        <TEXT>This is a 8-bit register which contains the USART baud rate.</TEXT>
        <IO_ADDR>$20</IO_ADDR>
        <MEM_ADDR>$40</MEM_ADDR>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT3>
          <NAME>UBRRHI03</NAME>
          <DESCRIPTION>High Byte Baud Rate Register Port 0 Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UBRRHI02</NAME>
          <DESCRIPTION>High Byte Baud Rate Register Port 0 Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>UBRRHI01</NAME>
          <DESCRIPTION>High Byte Baud Rate Register Port 0 Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>UBRRHI00</NAME>
          <DESCRIPTION>High Byte Baud Rate Register Port 0 Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </UBRRHI>
    </USART0>
    <USART1>
      <LIST>[UDR1:UCSR1A:UCSR1B:UBRR1:UBRRHI]</LIST>
      <LINK/>
      <ICON>io_com.bmp</ICON>
      <ID/>
      <TEXT>The Universal Synchronous and Asynchronous serial Receiver and Transmitter (USART) is a highly flexible serial communication device. The main features are: &#x2022; Full Duplex Operation (Independent Serial Receive and Transmit Registers) &#x2022; Asynchronous or Synchronous Operation &#x2022; Master or Slave Clocked Synchronous Operation &#x2022; High Resolution Baud Rate Generator &#x2022; Supports Serial Frames with 5, 6, 7, 8 or 9 Data Bits and 1 or 2 Stop Bits &#x2022; Odd or Even Parity Generation and Parity Check Supported by Hardware &#x2022; Data OverRun Detection &#x2022; Framing Error Detection &#x2022; Noise Filtering Includes False Start Bit Detection and Digital Low Pass Filter &#x2022; Three Separate Interrupts on TX Complete, TX Data Register Empty and RX Complete &#x2022; Multi-processor Communication Mode &#x2022; Double Speed Asynchronous Com</TEXT>
      <UDR1>
        <NAME>UDR1</NAME>
        <DESCRIPTION>USART I/O Data Register</DESCRIPTION>
        <TEXT>The UDR1 register is actually two physically separate registers sharing the same I/O address. When writing to the register, the USART Transmit Data register is written. When reading from UDR1, the USART Receive Data register is read.</TEXT>
        <IO_ADDR>$03</IO_ADDR>
        <MEM_ADDR>$23</MEM_ADDR>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>UDR17</NAME>
          <DESCRIPTION>USART I/O Data Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>UDR16</NAME>
          <DESCRIPTION>USART I/O Data Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UDR15</NAME>
          <DESCRIPTION>USART I/O Data Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>UDR14</NAME>
          <DESCRIPTION>USART I/O Data Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>UDR13</NAME>
          <DESCRIPTION>USART I/O Data Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UDR12</NAME>
          <DESCRIPTION>USART I/O Data Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>UDR11</NAME>
          <DESCRIPTION>USART I/O Data Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>UDR10</NAME>
          <DESCRIPTION>USART I/O Data Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </UDR1>
      <UCSR1A>
        <NAME>UCSR1A</NAME>
        <DESCRIPTION>USART Control and Status Register A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$02</IO_ADDR>
        <MEM_ADDR>$22</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>RXC1</NAME>
          <DESCRIPTION>USART Receive Complete</DESCRIPTION>
          <TEXT>This bit is set (one) when a received character is transferred from the Receiver Shift register to UDR1. The bit is set regardless of any detected framing errors. When the RXCIE bit in UCR is set, the USART Receive Complete interrupt will be executed when RXC is set(one). RXC is cleared by reading UDR1. When interrupt-driven data reception is used, the USART Receive Complete Interrupt routine must read UDR1 in order to clear RXC, otherwise a new interrupt will occur once the interrupt routine terminates.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TXC1</NAME>
          <DESCRIPTION>USART Transmitt Complete</DESCRIPTION>
          <TEXT>This bit is set (one) when the entire character (including the stop bit) in the Transmit Shift register has been shifted out and no new data has been written to UDR1. This flag is especially useful in half-duplex communications interfaces, where a transmitting application must enter receive mode and free the communications bus immediately after completing the transmission. When the TXCIE bit in UCR is set, setting of TXC causes the USART Transmit Complete interrupt to be executed. TXC is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, the TXC bit is cleared (zero) by writing a logical one to </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UDRE1</NAME>
          <DESCRIPTION>USART Data Register Empty</DESCRIPTION>
          <TEXT>This bit is set (one) when a character written to UDR1 is transferred to the Transmit shift register. Setting of this bit indicates that the transmitter is ready to receive a new character for transmission. When the UDR1IE bit in UCR is set, the USART Transmit Complete interrupt to be executed as long as UDR1E is set. UDR1E is cleared by writing UDR1. When interrupt-driven data transmittal is used, the USART Data Register Empty Interrupt routine must write UDR1 in order to clear UDR1E, otherwise a new interrupt will occur once the interrupt routine terminates. UDR1E is set (one) during reset to indicate that the transmitter is </TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>FE1</NAME>
          <DESCRIPTION>Framing Error</DESCRIPTION>
          <TEXT>This bit is set if a Framing Error condition is detected, i.e. when the stop bit of an incoming character is zero. The FE bit is cleared when the stop bit of received data is one.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OR1</NAME>
          <DESCRIPTION>Data overRun</DESCRIPTION>
          <TEXT>This bit is set if an Overrun condition is detected, i.e. when a character already present in the UDR1 register is not read before the next character has been shifted into the Receiver Shift register. The OR bit is buffered, which means that it will be set once the valid data still in UDR1E is read. The OR bit is cleared (zero) when data is received and transferred to UDR1. </TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT1>
          <NAME>U2X1</NAME>
          <DESCRIPTION>Double the USART transmission speed</DESCRIPTION>
          <TEXT>This bit only has effect for the asynchronous operation. Write this bit to zero when using synchronous operation. Writing this bit to one will reduce the divisor of the baud rate divider from 16 to 8 effectively doubling the transfer rate for asynchronous communication.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>MPCM1</NAME>
          <DESCRIPTION>Multi-processor Communication Mode</DESCRIPTION>
          <TEXT>This bit enables the Multi-processor Communication Mode. When the MPCM bit is written to one, all the incoming frames received by the USART receiver that do not contain address information will be ignored. The transmitter is unaffected by the MPCM setting. For more detailed information see &#x201C;Multi-processor Communication Mode&#x201D; on page 152.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </UCSR1A>
      <UCSR1B>
        <NAME>UCSR1B</NAME>
        <DESCRIPTION>USART Control and Status Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$01</IO_ADDR>
        <MEM_ADDR>$21</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>RXCIE1</NAME>
          <DESCRIPTION>RX Complete Interrupt Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables interrupt on the RXC flag. A USART Receive Complete interrupt will be generated only if the RXCIE bit is written to one, the global interrupt flag in SREG is written to one and the RXC bit in UCSR1A is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TXCIE1</NAME>
          <DESCRIPTION>TX Complete Interrupt Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables interrupt on the TXC flag. A USART Transmit Complete interrupt will be generated only if the TXCIE bit is written to one, the global interrupt flag in SREG is written to one and the TXC bit in UCSR1A is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UDR1IE1</NAME>
          <DESCRIPTION>USART Data register Empty Interrupt Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables interrupt on the UDR1E flag. A Data Register Empty interrupt will be generated only if the UDR1IE bit is written to one, the global interrupt flag in SREG is written to one and the UDR1E bit in UCSR1A is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>RXEN1</NAME>
          <DESCRIPTION>Receiver Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables the USART receiver. The receiver will override normal port operation for the RxD pin when enabled. Disabling the receiver will flush the receive buffer invalidating the FE, DOR and PE flags.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TXEN1</NAME>
          <DESCRIPTION>Transmitter Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables the USART transmitter. The transmitter will override normal port operation for the TxD pin when enabled. The disabling of the transmitter (writing TXEN to zero) will not become effective until ongoing and pending transmissions are completed, i.e. when the transmit shift register and transmit buffer register does not contain data to be transmitted. When disabled, the transmitter will no longer override the TxD port.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CHR91</NAME>
          <DESCRIPTION>9-Bit Character</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>RXB81</NAME>
          <DESCRIPTION>Receive Data Bit 8</DESCRIPTION>
          <TEXT>RXB8 is the 9th data bit of the received character when operating with serial frames with 9 data bits. Must be read before reading the low bits from UDR1.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TXB81</NAME>
          <DESCRIPTION>Transmit Data Bit 8</DESCRIPTION>
          <TEXT>TXB8 is the 9th data bit in the character to be transmitted when operating with serial frames with 9 data bits. Must be writ-ten before writing the low bits to UDR1.</TEXT>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </UCSR1B>
      <UBRR1>
        <NAME>UBRR1</NAME>
        <DESCRIPTION>USART Baud Rate Register Byte</DESCRIPTION>
        <TEXT>This is a 8-bit register which contains the USART baud rate. </TEXT>
        <IO_ADDR>$00</IO_ADDR>
        <MEM_ADDR>$20</MEM_ADDR>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>UBRR17</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>UBRR16</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UBRR15</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>UBRR14</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>UBRR13</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UBRR12</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>UBRR11</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>UBRR10</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </UBRR1>
      <UBRRHI>
        <NAME>UBRRHI</NAME>
        <DESCRIPTION>high Byte Baud Rate Register</DESCRIPTION>
        <TEXT>This is a 8-bit register that contains the USART baud rate.</TEXT>
        <IO_ADDR>$20</IO_ADDR>
        <MEM_ADDR>$40</MEM_ADDR>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>UBRRHI13</NAME>
          <DESCRIPTION>High Byte Baud Rate Register Port 0 Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>UBRRHI12</NAME>
          <DESCRIPTION>High Byte Baud Rate Register Port 0 Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UBRRHI11</NAME>
          <DESCRIPTION>High Byte Baud Rate Register Port 0 Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>UBRRHI10</NAME>
          <DESCRIPTION>High Byte Baud Rate Register Port 0 Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
      </UBRRHI>
    </USART1>
    <PORTA>
      <LIST>[PORTA:DDRA:PINA]</LIST>
      <LINK/>
      <ICON>io_port.bmp</ICON>
      <ID>AVRSimIOPort.SimIOPort</ID>
      <TEXT/>
      <PORTA>
        <NAME>PORTA</NAME>
        <DESCRIPTION>Port A Data Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$1B</IO_ADDR>
        <MEM_ADDR>$3B</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PORTA7</NAME>
          <DESCRIPTION>Port A Data Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PORTA6</NAME>
          <DESCRIPTION>Port A Data Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PORTA5</NAME>
          <DESCRIPTION>Port A Data Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PORTA4</NAME>
          <DESCRIPTION>Port A Data Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PORTA3</NAME>
          <DESCRIPTION>Port A Data Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PORTA2</NAME>
          <DESCRIPTION>Port A Data Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PORTA1</NAME>
          <DESCRIPTION>Port A Data Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PORTA0</NAME>
          <DESCRIPTION>Port A Data Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PORTA>
      <DDRA>
        <NAME>DDRA</NAME>
        <DESCRIPTION>Port A Data Direction Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$1A</IO_ADDR>
        <MEM_ADDR>$3A</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>DDA7</NAME>
          <DESCRIPTION>Data Direction Register, Port A, bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>DDA6</NAME>
          <DESCRIPTION>Data Direction Register, Port A, bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>DDA5</NAME>
          <DESCRIPTION>Data Direction Register, Port A, bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>DDA4</NAME>
          <DESCRIPTION>Data Direction Register, Port A, bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>DDA3</NAME>
          <DESCRIPTION>Data Direction Register, Port A, bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>DDA2</NAME>
          <DESCRIPTION>Data Direction Register, Port A, bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>DDA1</NAME>
          <DESCRIPTION>Data Direction Register, Port A, bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>DDA0</NAME>
          <DESCRIPTION>Data Direction Register, Port A, bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </DDRA>
      <PINA>
        <NAME>PINA</NAME>
        <DESCRIPTION>Port A Input Pins</DESCRIPTION>
        <TEXT>The Port A Input Pins address - PINA - is not a register, and this address enables access to the physical value on each Port A pin. When reading PORTA the Port A Data Latch is read, and when reading PINA, the logical values present on the pins are read.</TEXT>
        <IO_ADDR>$19</IO_ADDR>
        <MEM_ADDR>$39</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PINA7</NAME>
          <DESCRIPTION>Input Pins, Port A bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>Hi-Z</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PINA6</NAME>
          <DESCRIPTION>Input Pins, Port A bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>Hi-Z</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PINA5</NAME>
          <DESCRIPTION>Input Pins, Port A bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>Hi-Z</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PINA4</NAME>
          <DESCRIPTION>Input Pins, Port A bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>Hi-Z</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PINA3</NAME>
          <DESCRIPTION>Input Pins, Port A bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>Hi-Z</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PINA2</NAME>
          <DESCRIPTION>Input Pins, Port A bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>Hi-Z</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PINA1</NAME>
          <DESCRIPTION>Input Pins, Port A bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>Hi-Z</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PINA0</NAME>
          <DESCRIPTION>Input Pins, Port A bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>Hi-Z</INIT_VAL>
        </BIT0>
      </PINA>
    </PORTA>
    <PORTB>
      <LIST>[PORTB:DDRB:PINB]</LIST>
      <LINK/>
      <ICON>io_port.bmp</ICON>
      <ID>AVRSimIOPort.SimIOPort</ID>
      <TEXT/>
      <PORTB>
        <NAME>PORTB</NAME>
        <DESCRIPTION>Port B Data Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$18</IO_ADDR>
        <MEM_ADDR>$38</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PORTB7</NAME>
          <DESCRIPTION>Port B Data Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PORTB6</NAME>
          <DESCRIPTION>Port B Data Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PORTB5</NAME>
          <DESCRIPTION>Port B Data Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PORTB4</NAME>
          <DESCRIPTION>Port B Data Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PORTB3</NAME>
          <DESCRIPTION>Port B Data Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PORTB2</NAME>
          <DESCRIPTION>Port B Data Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PORTB1</NAME>
          <DESCRIPTION>Port B Data Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PORTB0</NAME>
          <DESCRIPTION>Port B Data Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PORTB>
      <DDRB>
        <NAME>DDRB</NAME>
        <DESCRIPTION>Port B Data Direction Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$17</IO_ADDR>
        <MEM_ADDR>$37</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>DDB7</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>DDB6</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>DDB5</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>DDB4</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>DDB3</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>DDB2</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>DDB1</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>DDB0</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </DDRB>
      <PINB>
        <NAME>PINB</NAME>
        <DESCRIPTION>Port B Input Pins</DESCRIPTION>
        <TEXT>The Port B Input Pins address - PINB - is not a register, and this address enables access to the physical value on each Port B pin. When reading PORTB, the Port B Data Latch is read, and when reading PINB, the logical values present on the pins are read.</TEXT>
        <IO_ADDR>$16</IO_ADDR>
        <MEM_ADDR>$36</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PINB7</NAME>
          <DESCRIPTION>Port B Input Pins bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PINB6</NAME>
          <DESCRIPTION>Port B Input Pins bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PINB5</NAME>
          <DESCRIPTION>Port B Input Pins bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PINB4</NAME>
          <DESCRIPTION>Port B Input Pins bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PINB3</NAME>
          <DESCRIPTION>Port B Input Pins bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PINB2</NAME>
          <DESCRIPTION>Port B Input Pins bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PINB1</NAME>
          <DESCRIPTION>Port B Input Pins bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PINB0</NAME>
          <DESCRIPTION>Port B Input Pins bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PINB>
    </PORTB>
    <PORTC>
      <LIST>[PORTC:DDRC:PINC]</LIST>
      <LINK/>
      <ICON>io_port.bmp</ICON>
      <ID>AVRSimIOPort.SimIOPort</ID>
      <TEXT/>
      <PORTC>
        <NAME>PORTC</NAME>
        <DESCRIPTION>Port C Data Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$15</IO_ADDR>
        <MEM_ADDR>$35</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PORTC7</NAME>
          <DESCRIPTION>Port C Data Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PORTC6</NAME>
          <DESCRIPTION>Port C Data Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PORTC5</NAME>
          <DESCRIPTION>Port C Data Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PORTC4</NAME>
          <DESCRIPTION>Port C Data Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PORTC3</NAME>
          <DESCRIPTION>Port C Data Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PORTC2</NAME>
          <DESCRIPTION>Port C Data Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PORTC1</NAME>
          <DESCRIPTION>Port C Data Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PORTC0</NAME>
          <DESCRIPTION>Port C Data Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PORTC>
      <DDRC>
        <NAME>DDRC</NAME>
        <DESCRIPTION>Port C Data Direction Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$14</IO_ADDR>
        <MEM_ADDR>$34</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>DDC7</NAME>
          <DESCRIPTION>Port C Data Direction Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>DDC6</NAME>
          <DESCRIPTION>Port C Data Direction Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>DDC5</NAME>
          <DESCRIPTION>Port C Data Direction Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>DDC4</NAME>
          <DESCRIPTION>Port C Data Direction Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>DDC3</NAME>
          <DESCRIPTION>Port C Data Direction Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>DDC2</NAME>
          <DESCRIPTION>Port C Data Direction Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>DDC1</NAME>
          <DESCRIPTION>Port C Data Direction Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>DDC0</NAME>
          <DESCRIPTION>Port C Data Direction Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </DDRC>
      <PINC>
        <NAME>PINC</NAME>
        <DESCRIPTION>Port C Input Pins</DESCRIPTION>
        <TEXT>The Port C Input Pins address - PINC - is not a register, and this address enables access to the physical value on each Port C pin. When reading PORTC, the Port C Data Latch is read, and when reading PINC, the logical values present on the pins are read.</TEXT>
        <IO_ADDR>$13</IO_ADDR>
        <MEM_ADDR>$33</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PINC7</NAME>
          <DESCRIPTION>Port C Input Pins bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PINC6</NAME>
          <DESCRIPTION>Port C Input Pins bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PINC5</NAME>
          <DESCRIPTION>Port C Input Pins bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PINC4</NAME>
          <DESCRIPTION>Port C Input Pins bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PINC3</NAME>
          <DESCRIPTION>Port C Input Pins bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PINC2</NAME>
          <DESCRIPTION>Port C Input Pins bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PINC1</NAME>
          <DESCRIPTION>Port C Input Pins bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PINC0</NAME>
          <DESCRIPTION>Port C Input Pins bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PINC>
    </PORTC>
    <PORTD>
      <LIST>[PORTD:DDRD:PIND]</LIST>
      <LINK/>
      <ICON>io_port.bmp</ICON>
      <ID>AVRSimIOPort.SimIOPort</ID>
      <TEXT/>
      <PORTD>
        <NAME>PORTD</NAME>
        <DESCRIPTION>Port D Data Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$12</IO_ADDR>
        <MEM_ADDR>$32</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PORTD7</NAME>
          <DESCRIPTION>Port D Data Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PORTD6</NAME>
          <DESCRIPTION>Port D Data Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PORTD5</NAME>
          <DESCRIPTION>Port D Data Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PORTD4</NAME>
          <DESCRIPTION>Port D Data Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PORTD3</NAME>
          <DESCRIPTION>Port D Data Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PORTD2</NAME>
          <DESCRIPTION>Port D Data Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PORTD1</NAME>
          <DESCRIPTION>Port D Data Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PORTD0</NAME>
          <DESCRIPTION>Port D Data Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PORTD>
      <DDRD>
        <NAME>DDRD</NAME>
        <DESCRIPTION>Port D Data Direction Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$11</IO_ADDR>
        <MEM_ADDR>$31</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>DDD7</NAME>
          <DESCRIPTION>Port D Data Direction Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>DDD6</NAME>
          <DESCRIPTION>Port D Data Direction Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>DDD5</NAME>
          <DESCRIPTION>Port D Data Direction Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>DDD4</NAME>
          <DESCRIPTION>Port D Data Direction Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>DDD3</NAME>
          <DESCRIPTION>Port D Data Direction Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>DDD2</NAME>
          <DESCRIPTION>Port D Data Direction Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>DDD1</NAME>
          <DESCRIPTION>Port D Data Direction Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>DDD0</NAME>
          <DESCRIPTION>Port D Data Direction Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </DDRD>
      <PIND>
        <NAME>PIND</NAME>
        <DESCRIPTION>Port D Input Pins</DESCRIPTION>
        <TEXT>The Port D Input Pins address - PIND - is not a register, and this address enables access to the physical value on each Port D pin. When reading PORTD, the Port D Data Latch is read, and when reading PIND, the logical values present on the pins are read.</TEXT>
        <IO_ADDR>$10</IO_ADDR>
        <MEM_ADDR>$30</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PIND7</NAME>
          <DESCRIPTION>Port D Input Pins bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PIND6</NAME>
          <DESCRIPTION>Port D Input Pins bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PIND5</NAME>
          <DESCRIPTION>Port D Input Pins bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PIND4</NAME>
          <DESCRIPTION>Port D Input Pins bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PIND3</NAME>
          <DESCRIPTION>Port D Input Pins bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PIND2</NAME>
          <DESCRIPTION>Port D Input Pins bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PIND1</NAME>
          <DESCRIPTION>Port D Input Pins bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PIND0</NAME>
          <DESCRIPTION>Port D Input Pins bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PIND>
    </PORTD>
    <PORTE>
      <LIST>[PORTE:DDRE:PINE]</LIST>
      <LINK/>
      <ICON>io_port.bmp</ICON>
      <ID>AVRSimIOPort.SimIOPort</ID>
      <TEXT/>
      <PORTE>
        <NAME>PORTE</NAME>
        <DESCRIPTION>Port E Data Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$07</IO_ADDR>
        <MEM_ADDR>$27</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT2>
          <NAME>PORTE2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PORTE1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PORTE0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PORTE>
      <DDRE>
        <NAME>DDRE</NAME>
        <DESCRIPTION>Port E Data Direction Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$06</IO_ADDR>
        <MEM_ADDR>$26</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT2>
          <NAME>DDE2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>DDE1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>DDE0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </DDRE>
      <PINE>
        <NAME>PINE</NAME>
        <DESCRIPTION>Port E Input Pins</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$05</IO_ADDR>
        <MEM_ADDR>$25</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT2>
          <NAME>PINE2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PINE1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PINE0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PINE>
    </PORTE>
    <EEPROM>
      <LIST>[EEARH:EEARL:EEDR:EECR]</LIST>
      <LINK>[EEARH:EEARL]</LINK>
      <ICON>io_cpu.bmp</ICON>
      <ID/>
      <TEXT>EEPROM Read/Write Access. The EEPROM access registers are accessible in the I/O space. The write access time for the EEPROM is given in Table 1. A self-timing function, however, lets the user software detect when the next byte can be written. If the user code contains instructions that write the EEPROM, some precautions must be taken. In heavily filtered power supplies, V CC is likely to rise or fall slowly on power-up/down. This causes the device for some period of time to run at a voltage lower than specified as minimum for the clock frequency used. See &#x201C;Preventing EEPROM Corruption&#x201D; on page 19. for details on how to avoid problems in these situations.In order to prevent unintentional EEPROM writes, a specific write procedure must be followed. Refer to the description of the EEPROM Control Register for details on this. When the EEPROM is read, the CPU is halted for four clock cycles before the next instruction is executed. When theEEPROM is written, the CPU is halted for two clock cycles before the next instruction is execute</TEXT>
      <EEARH>
        <NAME>EEARH</NAME>
        <DESCRIPTION>EEPROM Address Register High Byte</DESCRIPTION>
        <TEXT>Bits 11..0 - EEAR11..0: EEPROM Address The EEPROM Address Registers - EEARH and EEARL specify the EEPROM address in the 4K bytes EEPROM space. The EEPROM data bytes are addressed linearly between 0 and 4096. The initial value of EEAR is undefined. A proper value must be written before the EEPROM may be accessed. </TEXT>
        <IO_ADDR>$1F</IO_ADDR>
        <MEM_ADDR>$3F</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT0>
          <NAME>EEAR8</NAME>
          <DESCRIPTION>EEPROM Read/Write Access Bit 8</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </EEARH>
      <EEARL>
        <NAME>EEARL</NAME>
        <DESCRIPTION>EEPROM Address Register Low Byte</DESCRIPTION>
        <TEXT>Bits 11..0 - EEAR11..0: EEPROM Address The EEPROM Address Registers - EEARH and EEARL specify the EEPROM address in the 4K bytes EEPROM space. The EEPROM data bytes are addressed linearly between 0 and 4096. The initial value of EEAR is undefined. A proper value must be written before the EEPROM may be accessed. </TEXT>
        <IO_ADDR>$1E</IO_ADDR>
        <MEM_ADDR>$3E</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>EEAR7</NAME>
          <DESCRIPTION>EEPROM Read/Write Access Bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>EEAR6</NAME>
          <DESCRIPTION>EEPROM Read/Write Access Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>EEAR5</NAME>
          <DESCRIPTION>EEPROM Read/Write Access Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>EEAR4</NAME>
          <DESCRIPTION>EEPROM Read/Write Access Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>EEAR3</NAME>
          <DESCRIPTION>EEPROM Read/Write Access Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>EEAR2</NAME>
          <DESCRIPTION>EEPROM Read/Write Access Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>EEAR1</NAME>
          <DESCRIPTION>EEPROM Read/Write Access Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>EEAR0</NAME>
          <DESCRIPTION>EEPROM Read/Write Access Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </EEARL>
      <EEDR>
        <NAME>EEDR</NAME>
        <DESCRIPTION>EEPROM Data Register</DESCRIPTION>
        <TEXT>For the EEPROM write operation, the EEDR register contains the data to be written to the EEPROM in the address given by the EEAR register. For the EEPROM read operation, the EEDR contains the data read out from the EEPROM at the address given by EEAR.</TEXT>
        <IO_ADDR>$1D</IO_ADDR>
        <MEM_ADDR>$3D</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>EEDR7</NAME>
          <DESCRIPTION>EEPROM Data Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>EEDR6</NAME>
          <DESCRIPTION>EEPROM Data Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>EEDR5</NAME>
          <DESCRIPTION>EEPROM Data Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>EEDR4</NAME>
          <DESCRIPTION>EEPROM Data Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>EEDR3</NAME>
          <DESCRIPTION>EEPROM Data Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>EEDR2</NAME>
          <DESCRIPTION>EEPROM Data Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>EEDR1</NAME>
          <DESCRIPTION>EEPROM Data Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>EEDR0</NAME>
          <DESCRIPTION>EEPROM Data Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </EEDR>
      <EECR>
        <NAME>EECR</NAME>
        <DESCRIPTION>EEPROM Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$1C</IO_ADDR>
        <MEM_ADDR>$3C</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT3>
          <NAME>EERIE</NAME>
          <DESCRIPTION>EEPROM Ready Interrupt Enable</DESCRIPTION>
          <TEXT>EEPROM Ready Interrupt Enable Writing EERIE to one enables the EEPROM Ready Interrupt if the I bit in SREG is set. Writing EERIE to zero disables the interrupt. The EEPROM Ready interrupt generates a constant interrupt when EEWE is cleared.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>EEMWE</NAME>
          <ALIAS>EEWEE</ALIAS>
          <DESCRIPTION>EEPROM Master Write Enable</DESCRIPTION>
          <TEXT>The EEMWE bit determines whether setting EEWE to one causes the EEPROM to be written. When EEMWE is written to one, writing EEWE to one within 4 clock cycles will write data to the EEPROM at the selected address. If EEMWE is zero, writing EEWE to one will have no effect. When EEMWE has been written to one by software, hardware clears the bit to zero after four clock cycles. See the description of the EEWE bit for an EEPROM write procedure.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>EEWE</NAME>
          <DESCRIPTION>EEPROM Write Enable</DESCRIPTION>
          <TEXT>The EEPROM Write Enable Signal EEWE is the write strobe to the EEPROM. When address and data are correctly set up, the EEWE bit must be set to write the value into the EEPROM. The EEMWE bit must be set when the logical one is written to EEWE, otherwise no EEPROM write takes place. The following procedure should be followed when writing the EEPROM (the order of steps 3 and 4 is not essential): 1. Wait until EEWE becomes zero. 2. Wait until SPMEN in SPMCR becomes zero. 3. Write new EEPROM address to EEAR (optional). 4. Write new EEPROM data to EEDR (optional). 5. Write a logical one to the EEMWE bit while writing a zero to EEWE in EECR. 6. Within four clock cycles after setting EEMWE, write a logical one to EEWE. The EEPROM can not be programmed during a CPU write to the Flash memory. The software must check that the Flash programming is completed before initiating a new EEPROM write. Step 2 is only relevant if the software contains a boot loader allowing the CPU to program the Flash. If the Flash is never being updated by the CPU, step 2 can be omitted. See &#x201C;Boot Loader Support - Read While Write self-programming&#x201D; on page 228 for details about boot programming. Caution: An interrupt between step 5 and step 6 will make the write cycle fail, since the EEPROM Master Write Enable will time-out. If an interrupt routine accessing the EEPROM is interrupting another EEPROM access, the EEAR or EEDR regis-ter will be modified, causing the interrupted EEPROM access to fail. It is recommended to have the global interrupt flag cleared during the 4 last steps to avoid these problems. When the write access time has elapsed, the EEWE bit is cleared by hardware. The user software can poll this bit and wait for a zero before writing the next byte. When EEWE has been set, the CPU is halted for two cycles before the next instruc-tion is executed</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>EERE</NAME>
          <DESCRIPTION>EEPROM Read Enable</DESCRIPTION>
          <TEXT>The EEPROM Read Enable Signal EERE is the read strobe to the EEPROM. When the correct address is set up in the EEAR register, the EERE bit must be written to a logic one to trigger the EEPROM read. The EEPROM read access takes one instruction, and the requested data is available immediately. When the EEPROM is read, the CPU is halted for four cycles before the next instruction is executed. The user should poll the EEWE bit before starting the read operation. If a write operation is in progress, it is neither possible to read the EEPROM, nor to change the EEAR register. The calibrated oscillator is used to time the EEPROM accesses. Table 1 lists the typical programming time for EEPROM access from the CPU</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </EECR>
    </EEPROM>
    <EXTERNAL_INTERRUPT>
      <LIST>[GIMSK:GIFR]</LIST>
      <LINK/>
      <ICON>io_ext.bmp</ICON>
      <ID/>
      <TEXT/>
      <GIMSK>
        <NAME>GIMSK</NAME>
        <DESCRIPTION>General Interrupt Mask Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$3B</IO_ADDR>
        <MEM_ADDR>$5B</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>INT1</NAME>
          <DESCRIPTION>External Interrupt Request 1 Enable</DESCRIPTION>
          <TEXT>When the INT1 bit is set (one) and the I-bit in the Status Register (SREG) is set (one), the external pin interrupt is enabled. The Interrupt Sense Control1 bits 1/0 (ISC11 and ISC10) in the MCU general Control Register (MCUCR) defines whether the external interrupt is activated on rising or falling edge of the INT1 pin or level sensed. Activity on the pin will cause an interrupt request even if INT1 is configured as an output. The corresponding interrupt of External Interrupt Request 1 is executed from program memory address $002. See also &#x201C;External Interrupts&#x201D;.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>INT0</NAME>
          <DESCRIPTION>External Interrupt Request 0 Enable</DESCRIPTION>
          <TEXT>When the INT0 bit is set (one) and the I-bit in the Status Register (SREG) is set (one), the external pin interrupt is enabled. The Interrupt Sense Control0 bits 1/0 (ISC01 and ISC00) in the MCU general Control Register (MCUCR) defines whether the external interrupt is activated on rising or falling edge of the INT0 pin or level sensed. Activity on the pin will cause an interrupt request even if INT0 is configured as an output. The corresponding interrupt of External Interrupt Request 0 is executed from program memory address $001. See also &#x201C;External Interrupts.&#x201D; &#x2022; Bits 5..0 - Res: Reserved bits</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>INT2</NAME>
          <DESCRIPTION>External Interrupt Request 2 Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
      </GIMSK>
      <GIFR>
        <NAME>GIFR</NAME>
        <DESCRIPTION>General Interrupt Flag Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$3A</IO_ADDR>
        <MEM_ADDR>$5A</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>INTF1</NAME>
          <DESCRIPTION>External Interrupt Flag 1</DESCRIPTION>
          <TEXT>When an event on the INT1 pin triggers an interrupt request,INTF1 becomes set (one).If the I bit in SREG and the INT1 bit in GICR are set (one),the MCU will jump to the corresponding interrupt vector.The flag is cleared when the interrupt routine is executed.Alternatively,the flag can be cleared by writing a logical one to it.This flag is always cleared when INT1 is configured as a level interrupt.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>INTF0</NAME>
          <DESCRIPTION>External Interrupt Flag 0</DESCRIPTION>
          <TEXT>When an event on the INT0 pin triggers an interrupt request,INTF0 becomes set (one).If the I bit in SREG and the INT0 bit in GICR are set (one),the MCU will jump to the corresponding interrupt vector.The flag is cleared when the interrupt rou tine is executed.Alternatively,the flag can be cleared by writing a logical one to it.This flag is always cleared when INT0 is configured as a level interrupt.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>INTF2</NAME>
          <DESCRIPTION>External Interrupt Flag 2</DESCRIPTION>
          <TEXT>When an event on the INT2 pin triggers an interrupt request,INTF2 becomes set (one).If the I bit in SREG and the INT2 bit in GICR are set (one),the MCU will jump to the corresponding interrupt vector.The flag is cleared when the interrupt rou tine is executed.Alternatively,the flag can be cleared by writing a logical one to it.Note that when entering some sleep modes with the INT2 interrupt disabled,the input buffer on this pin will be disabled.This may cause a logic change in inter nal signals which will set the INTF2 flag</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
      </GIFR>
    </EXTERNAL_INTERRUPT>
    <CPU>
      <LIST>[SREG:SPH:SPL:MCUCR:MCUSR:EMCUCR:SPMCR]</LIST>
      <LINK>[SPH:SPL]</LINK>
      <ICON>io_cpu.bmp</ICON>
      <ID/>
      <TEXT/>
      <SREG>
        <NAME>SREG</NAME>
        <DESCRIPTION>Status Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$3F</IO_ADDR>
        <MEM_ADDR>$5F</MEM_ADDR>
        <ICON>io_sreg.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>I</NAME>
          <DESCRIPTION>Global Interrupt Enable</DESCRIPTION>
          <TEXT>The global interrupt enable bit must be set (one) for the interrupts to be enabled. The individual interrupt enable control is then performed in separate control registers. If the global interrupt enable bit is cleared (zero), none of the interrupts are enabled independent of the individual interrupt enable settings. The I-bit is cleared by hardware after an interrupt has occurred, and is set by the RETI instruction to enable subsequent interrupts.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>T</NAME>
          <DESCRIPTION>Bit Copy Storage</DESCRIPTION>
          <TEXT>The bit copy instructions BLD (Bit LoaD) and BST (Bit STore) use the T bit as source and destination for the operated bit. A bit from a register in the register file can be copied into T by the BST instruction, and a bit in T can be copied into a bit in a register in the register file by the BLD instruction.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>H</NAME>
          <DESCRIPTION>Half Carry Flag</DESCRIPTION>
          <TEXT>The half carry flag H indicates a half carry in some arithmetic operations. See the Instruction Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>S</NAME>
          <DESCRIPTION>Sign Bit</DESCRIPTION>
          <TEXT>The S-bit is always an exclusive or between the negative flag N and the two&#x2019;s complement overflow flag V. See the Instruc-tion Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>V</NAME>
          <DESCRIPTION>Two's Complement Overflow Flag</DESCRIPTION>
          <TEXT>The two&#x2019;s complement overflow flag V supports two&#x2019;s complement arithmetics. See the Instruction Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>N</NAME>
          <DESCRIPTION>Negative Flag</DESCRIPTION>
          <TEXT>The negative flag N indicates a negative result after the different arithmetic and logic operations. See the Instruction Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>Z</NAME>
          <DESCRIPTION>Zero Flag</DESCRIPTION>
          <TEXT>The zero flag Z indicates a zero result after the different arithmetic and logic operations. See the Instruction Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>C</NAME>
          <DESCRIPTION>Carry Flag</DESCRIPTION>
          <TEXT>The carry flag C indicates a carry in an arithmetic or logic operation. See the Instruction Set Description for detailed information. Note that the status register is not automatically stored when entering an interrupt routine and restored when returning from an interrupt routine. This must be handled by software.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SREG>
      <SPH>
        <NAME>SPH</NAME>
        <DESCRIPTION>Stack Pointer High</DESCRIPTION>
        <TEXT>The general AVR 16-bit Stack Pointer is effectively built up of two 8-bit registers in the I/O space locations $3E ($5E) and $3D ($5D). As the AT90S4414/8515 supports up to 64 kB external SRAM, all 16-bits are used. The Stack Pointer points to the data SRAM stack area where the Subroutine and Interrupt Stacks are located. This Stack space in the data SRAM must be defined by the program before any subroutine calls are executed or interrupts are enabled. The stack pointer must be set to point above $60. The Stack Pointer is decremented by one when data is pushed onto the Stack with the PUSH instruction, and it is decremented by two when an address is pushed onto the Stack with subroutine calls and interrupts. The Stack Pointer is incremented by one when data is popped from the Stack with the POP instruction, and it is incremented by two when an address is popped from the Stack with return from subroutine RET or return from interrupt R</TEXT>
        <IO_ADDR>$3E</IO_ADDR>
        <MEM_ADDR>$5E</MEM_ADDR>
        <ICON>io_sph.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>SP15</NAME>
          <DESCRIPTION>Stack pointer bit 15</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SP14</NAME>
          <DESCRIPTION>Stack pointer bit 14</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SP13</NAME>
          <DESCRIPTION>Stack pointer bit 13</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SP12</NAME>
          <DESCRIPTION>Stack pointer bit 12</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SP11</NAME>
          <DESCRIPTION>Stack pointer bit 11</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SP10</NAME>
          <DESCRIPTION>Stack pointer bit 10</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SP9</NAME>
          <DESCRIPTION>Stack pointer bit 9</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SP8</NAME>
          <DESCRIPTION>Stack pointer bit 8</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SPH>
      <SPL>
        <NAME>SPL</NAME>
        <DESCRIPTION>Stack Pointer Low</DESCRIPTION>
        <TEXT>The general AVR 16-bit Stack Pointer is effectively built up of two 8-bit registers in the I/O space locations $3E ($5E) and $3D ($5D). As the AT90S4414/8515 supports up to 64 kB external SRAM, all 16-bits are used. The Stack Pointer points to the data SRAM stack area where the Subroutine and Interrupt Stacks are located. This Stack space in the data SRAM must be defined by the program before any subroutine calls are executed or interrupts are enabled. The stack pointer must be set to point above $60. The Stack Pointer is decremented by one when data is pushed onto the Stack with the PUSH instruction, and it is decremented by two when an address is pushed onto the Stack with subroutine calls and interrupts. The Stack Pointer is incremented by one when data is popped from the Stack with the POP instruction, and it is incremented by two when an address is popped from the Stack with return from subroutine RET or return from interrupt </TEXT>
        <IO_ADDR>$3D</IO_ADDR>
        <MEM_ADDR>$5D</MEM_ADDR>
        <ICON>io_sph.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>SP7</NAME>
          <DESCRIPTION>Stack pointer bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SP6</NAME>
          <DESCRIPTION>Stack pointer bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SP5</NAME>
          <DESCRIPTION>Stack pointer bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SP4</NAME>
          <DESCRIPTION>Stack pointer bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SP3</NAME>
          <DESCRIPTION>Stack pointer bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SP2</NAME>
          <DESCRIPTION>Stack pointer bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SP1</NAME>
          <DESCRIPTION>Stack pointer bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SP0</NAME>
          <DESCRIPTION>Stack pointer bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SPL>
      <MCUCR>
        <NAME>MCUCR</NAME>
        <DESCRIPTION>MCU Control Register</DESCRIPTION>
        <TEXT>The MCU Control Register contains control bits for general MCU functions.</TEXT>
        <IO_ADDR>$35</IO_ADDR>
        <MEM_ADDR>$55</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SRE</NAME>
          <DESCRIPTION>External SRAM Enable</DESCRIPTION>
          <TEXT>Writing SRE to one enables the External Memory Interface.The pin functions AD7:0, A15:8, ALE, WR, and RD are acti-vated as the alternate pin functions. The SRE bit overrides any pin direction settings in the respective data direction regis-ters. Writing SRE to zero, disables the External Memory Interface and the normal pin and data direction settings are used.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SRW10</NAME>
          <DESCRIPTION>External SRAM Wait State Select</DESCRIPTION>
          <TEXT>For a detailed description in non ATmega103 Compatibility mode, see common description for the SRWn bits below (XMRA description). In ATmega103 Compatibility mode, writing SRW10 to one enables the wait state and one extra cycle is added during read/write strobe as shown in Figure 14.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SE</NAME>
          <DESCRIPTION>Sleep Enable</DESCRIPTION>
          <TEXT>The SE bit must be written to logic one to make the MCU enter the sleep mode when the SLEEP instruction is executed.To avoid the MCU entering the sleep mode unless it is the programmers purpose,it is recommended to write the Sleep Enable (SE)bit to one just before the execution of the SLEEP instruction and to clear it immediately after waking up.      </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SM1</NAME>
          <DESCRIPTION>Sleep Mode Select</DESCRIPTION>
          <TEXT>The description is to long for the tooltip help, please refer to the manual</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ISC11</NAME>
          <DESCRIPTION>Interrupt Sense Control 1 bit 1</DESCRIPTION>
          <TEXT>The External Interrupt 1 is activated by the external pin INT1 if the SREG I-bit and the corresponding interrupt mask in the GICR are set.The value on the INT1 pin is sampled before detecting edges.If edge or toggle interrupt is selected,pulses that last longer than one clock period will generate an interrupt.Shorter pulses are not guaranteed to generate an interrupt.If low level interrupt is selected,the low level must be held until the completion of the currently executing instruction to generate an interrupt.  </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ISC10</NAME>
          <DESCRIPTION>Interrupt Sense Control 1 bit 1</DESCRIPTION>
          <TEXT>The External Interrupt 1 is activated by the external pin INT1 if the SREG I-bit and the corresponding interrupt mask in the GICR are set.The value on the INT1 pin is sampled before detecting edges.If edge or toggle interrupt is selected,pulses that last longer than one clock period will generate an interrupt.Shorter pulses are not guaranteed to generate an interrupt.If low level interrupt is selected,the low level must be held until the completion of the currently executing instruction to generate an interrupt.  </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ISC01</NAME>
          <DESCRIPTION>Interrupt Sense Control 0 bit 1</DESCRIPTION>
          <TEXT>The External Interrupt 0 is activated by the external pin INT0 if the SREG I-flag and the corresponding interrupt mask are set.The value on the INT0 pin is sampled before detecting edges.If edge or toggle interrupt is selected,pulses that last longer than one clock period will generate an interrupt.Shorter pulses are not guaranteed to generate an interrupt.If low level interrupt is selected,the low level must be held until the completion of the currently executing instruction to generate an interrupt.     </TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>INTERRUPT_SENSE_CONTROL2</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ISC00</NAME>
          <DESCRIPTION>Interrupt Sense Control 0 bit 0</DESCRIPTION>
          <TEXT>The External Interrupt 0 is activated by the external pin INT0 if the SREG I-flag and the corresponding interrupt mask are set.The value on the INT0 pin is sampled before detecting edges.If edge or toggle interrupt is selected,pulses that last longer than one clock period will generate an interrupt.Shorter pulses are not guaranteed to generate an interrupt.If low level interrupt is selected,the low level must be held until the completion of the currently executing instruction to generate an interrupt.     </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </MCUCR>
      <MCUSR>
        <NAME>MCUSR</NAME>
        <DESCRIPTION>MCU Status Register</DESCRIPTION>
        <TEXT>The MCU Control And Status Register provides information on which reset source caused a MCU reset.</TEXT>
        <IO_ADDR>$34</IO_ADDR>
        <MEM_ADDR>$54</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT3>
          <NAME>WDRF</NAME>
          <DESCRIPTION>Watchdog Reset Flag</DESCRIPTION>
          <TEXT>This bit is set if a watchdog reset occurs. The bit is reset by a power-on reset, or by writing a logic zero to the flag.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>BORF</NAME>
          <DESCRIPTION>Brown-out Reset Flag</DESCRIPTION>
          <TEXT>This bit is set if a brown-out reset occurs. The bit is reset by a power-on reset, or by writing a logic zero to the flag.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>EXTRF</NAME>
          <DESCRIPTION>External Reset Flag</DESCRIPTION>
          <TEXT>This bit is set if an external reset occurs. The bit is reset by a power-on reset, or by writing a logic zero to the flag.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PORF</NAME>
          <DESCRIPTION>Power-on reset flag</DESCRIPTION>
          <TEXT>This bit is set if a power-on reset occurs. The bit is reset only by writing a logic zero to the flag. To make use of the reset flags to identify a reset condition, the user should read and then reset the MCUCSR as early as possible in the program. If the register is cleared before another reset occurs, the source of the reset can be found by examining the reset flags.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </MCUSR>
      <EMCUCR>
        <NAME>EMCUCR</NAME>
        <DESCRIPTION>Extended MCU Control Register</DESCRIPTION>
        <TEXT>The Extended MCU Control Register contains control bits for general MCU functions.</TEXT>
        <IO_ADDR>$36</IO_ADDR>
        <MEM_ADDR>$56</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SM0</NAME>
          <DESCRIPTION>Sleep mode Select Bit 0</DESCRIPTION>
          <TEXT>The Sleep Mode Select bits select between the five available sleep modes. See Datasheet.  </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SRL2</NAME>
          <DESCRIPTION>Wait State Sector Limit Bit 2</DESCRIPTION>
          <TEXT>It is possible to configure different wait-states for different external memory addresses. The external memory address space can be divided in two sectors that have separate wait-state bits.The SRL2,SRL1,and SRL0 bits select the splitting of these sectors. By default,the SRL2,SRL1,and SRL0 bits are set to zero and the entire external memory address space is treated as one sector.When the entire SRAM address space is configured as one sector,the wait-states are configured by the SRW11 and SRW10 bits.     </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SRL1</NAME>
          <DESCRIPTION>Wait State Sector Limit Bit 1</DESCRIPTION>
          <TEXT>It is possible to configure different wait-states for different external memory addresses. The external memory address space can be divided in two sectors that have separate wait-state bits.The SRL2,SRL1,and SRL0 bits select the splitting of these sectors. By default,the SRL2,SRL1,and SRL0 bits are set to zero and the entire external memory address space is treated as one sector.When the entire SRAM address space is configured as one sector,the wait-states are configured by the SRW11 and SRW10 bits.     </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SRL0</NAME>
          <DESCRIPTION>Wait State Sector Limit Bit 0</DESCRIPTION>
          <TEXT>It is possible to configure different wait-states for different external memory addresses. The external memory address space can be divided in two sectors that have separate wait-state bits.The SRL2,SRL1,and SRL0 bits select the splitting of these sectors. By default,the SRL2,SRL1,and SRL0 bits are set to zero and the entire external memory address space is treated as one sector.When the entire SRAM address space is configured as one sector,the wait-states are configured by the SRW11 and SRW10 bits.     </TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>CPU_SECTOR_LIMITS</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SRW01</NAME>
          <DESCRIPTION>Wait State Select Bit 1 for Lower Sector</DESCRIPTION>
          <TEXT>The SRW00 and SRW01 bits control the number of wait-states for the upper sector of the external memory address space.   </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SRW00</NAME>
          <DESCRIPTION>Wait State Select Bit 0 for Lower Sector</DESCRIPTION>
          <TEXT>The SRW00 and SRW01 bits control the number of wait-states for the upper sector of the external memory address space.   </TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>CPU_WAIT_STATES</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SRW11</NAME>
          <DESCRIPTION>Wait State Select Bit 1 for Upper Sector</DESCRIPTION>
          <TEXT>The SRW11 and SRW10 bits control the number of wait-states for the upper sector of the external memory address space.   </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ISC2</NAME>
          <DESCRIPTION>Interrupt Sense Control 2</DESCRIPTION>
          <TEXT>The asynchronous external interrupt 2 is activated by the external pin INT2 if the SREG I-bit and the corresponding interrupt mask in GICR are set.If ISC2 is written to zero,a falling edge on INT2 activates the interrupt.If ISC2 is written to one,a rising edge on INT2 activates the interrupt.Edges on INT2 are registered asynchronously.Pulses on INT2 wider than the minimum pulse given width will generate an interrupt. Shorter pulses are not guaranteed to generate an interrupt.When changing the ISC2 bit,an interrupt can occur.Therefore,it is recommended to first disable INT2 by clearing its Interrupt Enable bit in the GICR register.Then,the ISC2 bit can be changed.Finally, the INT2 interruptflag should becleared by writing a logical one to its Interrupt Flagbit (INTF2)in the GIFR register before the interrupt is re-enabled.    </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </EMCUCR>
      <SPMCR>
        <NAME>SPMCR</NAME>
        <DESCRIPTION>Store Program Memory Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$37</IO_ADDR>
        <MEM_ADDR>$57</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT3>
          <NAME>BLBSET</NAME>
          <DESCRIPTION>Boot Lock Bit Set</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PGWRT</NAME>
          <DESCRIPTION>Page Write</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PGERS</NAME>
          <DESCRIPTION>Page Erase</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SPMEN</NAME>
          <DESCRIPTION>Store Program Memory Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SPMCR>
    </CPU>
    <TIMER_COUNTER_0>
      <LIST>[TCCR0:TCNT0:OCR0:TIMSK:TIFR:SFIOR]</LIST>
      <LINK/>
      <ICON>io_timer.bmp</ICON>
      <ID>At8pwm0_01</ID>
      <TEXT/>
      <TCCR0>
        <NAME>TCCR0</NAME>
        <DESCRIPTION>Timer/Counter Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$33</IO_ADDR>
        <MEM_ADDR>$53</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>FOC0</NAME>
          <DESCRIPTION>Force Output Compare</DESCRIPTION>
          <TEXT>The FOC0 bit is only active when the WGM bits specifies a non-PWM mode. However, for ensuring compatibility with future devices, this bit must be set to zero when TCCR0 is written when operating in PWM mode. When writing a logical one to the FOC0 bit, an immediate compare match is forced on the waveform generation unit. The OC0 output is changed accord-ing to its COM01:0 bits setting. Note that the FOC0 bit is implemented as a strobe. Therefore it is the value present in the COM01:0 bits that determines the effect of the forced compare. A FOC0 strobe will not generate any interrupt, nor will it clear the timer in CTC mode using OCR0 as TOP. The FOC0 bit is always read as zero.</TEXT>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>WGM00</NAME>
          <DESCRIPTION>Waveform Generation Mode 0</DESCRIPTION>
          <TEXT>These bits control the counting sequence of the counter, the source for the maximum (TOP) counter value, and what type of waveform generation to be used. Modes of operation supported by the Timer/Counter unit are: Normal mode, Clear Timer on Compare match (CTC) mode, and two types of Pulse Width Modulation (PWM) modes. See Table 51 and &#x201C;Modes of Operation&#x201D; on page 80. </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>COM01</NAME>
          <DESCRIPTION>Compare Match Output Mode 1</DESCRIPTION>
          <TEXT>These bits control the output compare pin (OC0) behavior. If one or both of the COM01:0 bits are set, the OC0 output over-rides the normal port functionality of the I/O pin it is connected to. However, note that the Data Direction Register (DDR) bit corresponding to OC0 pin must be set in order to enable the output driver. When OC0 is connected to the pin, the function of the COM01:0 bits depends on the WGM01:0 bit setting. Table 52 shows the COM01:0 bit functionality when the WGM01:0 bits are set to a normal or CTC mode (non-PWM)</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>COM00</NAME>
          <DESCRIPTION>Compare match Output Mode 0</DESCRIPTION>
          <TEXT>These bits control the output compare pin (OC0) behavior. If one or both of the COM01:0 bits are set, the OC0 output over-rides the normal port functionality of the I/O pin it is connected to. However, note that the Data Direction Register (DDR) bit corresponding to OC0 pin must be set in order to enable the output driver. When OC0 is connected to the pin, the function of the COM01:0 bits depends on the WGM01:0 bit setting. Table 52 shows the COM01:0 bit functionality when the WGM01:0 bits are set to a normal or CTC mode (non-PWM)</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>CLK_COMP_MATCH_OUT_MODE</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>WGM01</NAME>
          <DESCRIPTION>Waveform Generation Mode 1</DESCRIPTION>
          <TEXT>These bits control the counting sequence of the counter, the source for the maximum (TOP) counter value, and what type of waveform generation to be used. Modes of operation supported by the Timer/Counter unit are: Normal mode, Clear Timer on Compare match (CTC) mode, and two types of Pulse Width Modulation (PWM) modes. See Table 51 and &#x201C;Modes of Operation&#x201D; on page 80. </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CS02</NAME>
          <DESCRIPTION>Clock Select 2</DESCRIPTION>
          <TEXT>The three clock select bits select the clock source to be used by the Timer/Counter,</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CS01</NAME>
          <DESCRIPTION>Clock Select 1</DESCRIPTION>
          <TEXT>The three clock select bits select the clock source to be used by the Timer/Counter,</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CS00</NAME>
          <DESCRIPTION>Clock Select 1</DESCRIPTION>
          <TEXT>The three clock select bits select the clock source to be used by the Timer/Counter,</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>CLK_SEL_3BIT_EXT</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCCR0>
      <TCNT0>
        <NAME>TCNT0</NAME>
        <DESCRIPTION>Timer/Counter Register </DESCRIPTION>
        <TEXT>The Timer/Counter Register gives direct access, both for read and write operations, to the Timer/Counter unit 8-bit counter. Writing to the TCNT0 register blocks (removes) the compare match on the following timer clock. Modifying the counter (TCNT0) while the counter is running, introduces a risk of missing a compare match between TCNT0 the OCR0 register.</TEXT>
        <IO_ADDR>$32</IO_ADDR>
        <MEM_ADDR>$52</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TCNT0_7</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TCNT0_6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TCNT0_5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TCNT0_4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TCNT0_3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TCNT0_2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TCNT0_1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TCNT0_0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCNT0>
      <OCR0>
        <NAME>OCR0</NAME>
        <DESCRIPTION>Output Compare Register</DESCRIPTION>
        <TEXT>The Output Compare Register contains an 8-bit value that is continuously compared with the counter value (TCNT0). A match can be used to generate an output compare interrupt, or to generate a waveform output on the OC0 pin.</TEXT>
        <IO_ADDR>$31</IO_ADDR>
        <MEM_ADDR>$51</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR0_7</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR0_6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR0_5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR0_4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR0_3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR0_2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR0_1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR0_0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCR0>
      <TIMSK>
        <NAME>TIMSK</NAME>
        <DESCRIPTION>Timer/Counter Interrupt Mask Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$39</IO_ADDR>
        <MEM_ADDR>$59</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT1>
          <NAME>TOIE0</NAME>
          <DESCRIPTION>Timer/Counter0 Overflow Interrupt Enable</DESCRIPTION>
          <TEXT>When the TOIE0 bit is written to one, and the I-bit in the Status Register is set (one), the Timer/Counter0 Overflow interrupt is enabled. The corresponding interrupt is executed if an overflow in Timer/Counter0 occurs, i.e. when the TOV0 bit is set in the Timer/Counter Interrupt Flag Register - TIFR.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCIE0</NAME>
          <DESCRIPTION>Timer/Counter0 Output Compare Match Interrupt register</DESCRIPTION>
          <TEXT>When the OCIE0 bit is written to one, and the I-bit in the Status Register is set (one), the Timer/Counter0 Compare Match interrupt is enabled. The corresponding interrupt is executed if a compare match in Timer/Counter0 occurs, i.e. when the OCF0 bit is set in the Timer/Counter Interrupt Flag Register - TIFR.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TIMSK>
      <TIFR>
        <NAME>TIFR</NAME>
        <DESCRIPTION>Timer/Counter Interrupt Flag register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$38</IO_ADDR>
        <MEM_ADDR>$58</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT1>
          <NAME>TOV0</NAME>
          <DESCRIPTION>Timer/Counter0 Overflow Flag</DESCRIPTION>
          <TEXT>The bit TOV0 is set (one) when an overflow occurs in Timer/Counter0. TOV0 is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, TOV0 is cleared by writing a logic one to the flag. When the SREG I-bit, TOIE0 (Timer/Counter0 Overflow Interrupt Enable), and TOV0 are set (one), the Timer/Counter0 Overflow interrupt is executed. In PWM mode, this bit is set when Timer/Counter0 changes counting direction at $00.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCF0</NAME>
          <DESCRIPTION>Output Compare Flag 0</DESCRIPTION>
          <TEXT>The OCF0 bit is set (one) when a compare match occurs between the Timer/Counter0 and the data in OCR0 - Output Compare Register0. OCF0 is cleared by hardware when executing the corresponding interrupt handling vector. Alterna-tively, OCF0 is cleared by writing a logic one to the flag. When the I-bit in SREG, OCIE0 (Timer/Counter0 Compare match Interrupt Enable), and OCF0 are set (one), the Timer/Counter0 Compare match Interrupt is executed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TIFR>
      <SFIOR>
        <NAME>SFIOR</NAME>
        <DESCRIPTION>Special Function IO Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$30</IO_ADDR>
        <MEM_ADDR>$50</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT0>
          <NAME>PSR10</NAME>
          <DESCRIPTION>Prescaler Reset Timer/Counter1 and Timer/Counter0</DESCRIPTION>
          <TEXT>When this bit is set (one)the Timer/Counter1 and Timer/Counter0 prescaler will be reset.The bit will be cleared by hard ware after the operation is performed.Writing a zero to this bit will have no effect.Note that Timer/Counter1 and Timer/Counter0 share the same prescaler and a reset of this prescaler will affect both timers.This bit will always be read as zero.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SFIOR>
    </TIMER_COUNTER_0>
    <TIMER_COUNTER_2>
      <LIST>[TIMSK:TIFR:TCCR2:TCNT2:OCR2:ASSR:SFIOR]</LIST>
      <LINK/>
      <ICON>io_timer.bmp</ICON>
      <ID>At8pwm2_02</ID>
      <TEXT>The 8-bit Timer/Counter2 can select clock source from CK, prescaled CK, or external crystal input TOSC1. It can also be	stopped as described in the section &#x201C;Timer/Counter2 Control Register - TCCR2&#x201D;.	The status flags (overflow and compare match) are found in the Timer/Counter Interrupt Flag Register - TIFR. Control signals	are found in the Timer/Counter Control Register TCCR2. The interrupt enable/disable settings are found in &#x201C;The	Timer/Counter Interrupt Mask Register - TIMSK&#x201D;.	When Timer/Counter2 is externally clocked, the external signal is synchronized with the oscillator frequency of the CPU. To	assure proper sampling of the external clock, the minimum time between two external clock transitions must be at least one	internal CPU clock period. The external clock signal is sampled on the rising edge of the internal CPU clock.	This module features a high resolution and a high accuracy usage with the lower prescaling opportunities. Similarly, the	high prescaling opportunities make this unit useful for lower 	speed functions or exact timing functions with infrequent actions. Timer/Counter2 can also be used as an 8-bit Pulse Width Modulator. In this mode, Timer/Counter2 and the output compare register serve as a glitch-free, stand-alone PWM with centered puls</TEXT>
      <TIMSK>
        <NAME>TIMSK</NAME>
        <DESCRIPTION>Timer/Counter Interrupt Mask register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$39</IO_ADDR>
        <MEM_ADDR>$59</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT4>
          <NAME>TOIE2</NAME>
          <DESCRIPTION>Timer/Counter2 Overflow Interrupt Enable</DESCRIPTION>
          <TEXT>When the TOIE2 bit is set (one) and the I-bit in the Status Register is set (one), the Timer/Counter2 Overflow interrupt is</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT2>
          <NAME>OCIE2</NAME>
          <DESCRIPTION>Timer/Counter2 Output Compare Match Interrupt Enable</DESCRIPTION>
          <TEXT>When the OCIE2 bit is set (one) and the I-bit in the Status Register is set (one), the Timer/Counter2 Compare Match interrupt	is enabled. The corresponding interrupt (at vector $006) is executed if a compare match in Timer/Counter2 occurs, i.e.	when the OCF2 bit is set in the Timer/Counter Interrupt Flag Register - TIFR.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
      </TIMSK>
      <TIFR>
        <NAME>TIFR</NAME>
        <DESCRIPTION>Timer/Counter Interrupt Flag Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$38</IO_ADDR>
        <MEM_ADDR>$58</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT4>
          <NAME>TOV2</NAME>
          <DESCRIPTION>Timer/Counter2 Overflow Flag</DESCRIPTION>
          <TEXT>The TOV2 bit is set (one) when an overflow occurs in Timer/Counter2. TOV2 is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, TOV2 is cleared by writing a logic one to the flag. When the SREG I-bit, and TOIE2 (Timer/Counter2 Overflow Interrupt Enable), and TOV2 are set (one), the Timer/Counter2 Overflow interrupt is executed. In up/down PWM mode, this bit is set when Timer/Counter2 changes counting direction at $00.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT2>
          <NAME>OCF2</NAME>
          <DESCRIPTION>Output Compare Flag 2</DESCRIPTION>
          <TEXT>The OCF2 bit is set (one) when a compare match occurs between the Timer/Counter2 and the data in OCR2 - Output Compare Register2. OCF2 is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, OCF2 is cleared by writing a logic one to the flag. When the I-bit in SREG, and OCIE2 (Timer/Counter2 Compare match Interrupt Enable), and the OCF2 are set (one), the Timer/Counter2 Compare match Interrupt is executed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
      </TIFR>
      <TCCR2>
        <NAME>TCCR2</NAME>
        <DESCRIPTION>Timer/Counter2 Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$27</IO_ADDR>
        <MEM_ADDR>$47</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>FOC2</NAME>
          <DESCRIPTION>Force Output Compare</DESCRIPTION>
          <TEXT>Writing a logical one to this bit, forces a change in the compare match output pin PD7 (OC2) according to the values already set in COM21 and COM20. If the COM21 and COM20 bits are written in the same cycle as FOC2, the new settings will not take effect until next compare match or forced output compare match occurs. The Force Output Compare bit can be used to change the output pin without waiting for a compare match in the timer. The automatic action programmed in COM21 and COM20 happens as if a Compare Match had occurred, but no interrupt is generated, and the Timer/Counter will not be cleared even if CTC2 is set. The corresponding I/O pin must be set as an output pin for the FOC2 bit to have effect on the pin. The FOC2 bit will always be read as zero. Setting the FOC2 bit has no effect in PWM mode</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PWM2</NAME>
          <DESCRIPTION>Pulse Width Modulator Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>COM21</NAME>
          <DESCRIPTION>Compare Output Mode bit 1</DESCRIPTION>
          <TEXT>The COM21 and COM20 control bits determine any output pin action following a compare match in Timer/Counter2. Output pin actions affect pin PD7(OC2). This is an alternative function to an I/O port, and the corresponding direction control bit must be set (one) to control an output pin. (COM21:COM20) description:	(0:0) = Timer/Counter disconnected from output pin OC2.	(0:1) = Toggle the OC2 output line. (1:0) = Clear the OC2 output line (to zero). (1:1) = Set the OC2 output line (to one). Note: In PWM mode, these bits have a different function</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>CLK_COMP_MATCH_OUT_MODE</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>COM20</NAME>
          <DESCRIPTION>Compare Output Mode bit 0</DESCRIPTION>
          <TEXT>The COM21 and COM20 control bits determine any output pin action following a compare match in Timer/Counter2. Output pin actions affect pin PD7(OC2). This is an alternative function to an I/O port, and the corresponding direction control bit must be set (one) to control an output pin. (COM21:COM20) description:	(0:0) = Timer/Counter disconnected from output pin OC2.	(0:1) = Toggle the OC2 output line. (1:0) = Clear the OC2 output line (to zero). (1:1) = Set the OC2 output line (to one). Note: In PWM mode, these bits have a different function</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>CTC2</NAME>
          <DESCRIPTION>Clear Timer/Counter2 on Compare Match</DESCRIPTION>
          <TEXT>These bits control the counting sequence of the counter,the source for hte maximum (TOP)counter value,and what type of waveform generation to be used.Modes of operation supported by the timer/counter unit are:Normal mode (counter), Clear Timer on Compare match (CTC)mode,and two types of Pulse Width Modulation (PWM)modes. Please refer to the manual for more information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CS22</NAME>
          <DESCRIPTION>Clock Select bit 2</DESCRIPTION>
          <TEXT>The Clock Select bits 2,1, and 0 define the prescaling source of Timer/Counter2. (CS22:CS21:CS20) Description. (0:0:0) Timer/Counter2 is stopped. (0:0:1) PCK2. (0:1:0) PCK2/8. (0:1:1) PCK2/32. (1:0:0) PCK2/64. (1:0:1) PCK2/128. (1:1:0) PCK2/256. (1:1:1) PCK2/1024. The Stop condition provides a Timer Enable/Disable function. The prescaled modes are scaled directly from the PCK2 clock.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CS21</NAME>
          <DESCRIPTION>Clock Select bit 1</DESCRIPTION>
          <TEXT>The Clock Select bits 2,1, and 0 define the prescaling source of Timer/Counter2. (CS22:CS21:CS20) Description. (0:0:0) Timer/Counter2 is stopped. (0:0:1) PCK2. (0:1:0) PCK2/8. (0:1:1) PCK2/32. (1:0:0) PCK2/64. (1:0:1) PCK2/128. (1:1:0) PCK2/256. (1:1:1) PCK2/1024. The Stop condition provides a Timer Enable/Disable function. The prescaled modes are scaled directly from the PCK2 clock.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CS20</NAME>
          <DESCRIPTION>Clock Select bit 0</DESCRIPTION>
          <TEXT>The Clock Select bits 2,1, and 0 define the prescaling source of Timer/Counter2. (CS22:CS21:CS20) Description. (0:0:0) Timer/Counter2 is stopped. (0:0:1) PCK2. (0:1:0) PCK2/8. (0:1:1) PCK2/32. (1:0:0) PCK2/64. (1:0:1) PCK2/128. (1:1:0) PCK2/256. (1:1:1) PCK2/1024. The Stop condition provides a Timer Enable/Disable function. The prescaled modes are scaled directly from the PCK2 clock.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>CLK_SEL_3BIT</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCCR2>
      <TCNT2>
        <NAME>TCNT2</NAME>
        <DESCRIPTION>Timer/Counter2</DESCRIPTION>
        <TEXT>This 8-bit register contains the value of Timer/Counter2. Timer/Counters2 is implemented as an up or up/down (in PWM mode) counter with read and write access. If the Timer/Counter2iswritten to and a clocksourceisselected,it continues counting in the timer clock cycle following the write operation.</TEXT>
        <IO_ADDR>$23</IO_ADDR>
        <MEM_ADDR>$43</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TCNT2-7</NAME>
          <DESCRIPTION>Timer/Counter 2 bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TCNT2-6</NAME>
          <DESCRIPTION>Timer/Counter 2 bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TCNT2-5</NAME>
          <DESCRIPTION>Timer/Counter 2 bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TCNT2-4</NAME>
          <DESCRIPTION>Timer/Counter 2 bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TCNT2-3</NAME>
          <DESCRIPTION>Timer/Counter 2 bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TCNT2-2</NAME>
          <DESCRIPTION>Timer/Counter 2 bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TCNT2-1</NAME>
          <DESCRIPTION>Timer/Counter 2 bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TCNT2-0</NAME>
          <DESCRIPTION>Timer/Counter 2 bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCNT2>
      <OCR2>
        <NAME>OCR2</NAME>
        <DESCRIPTION>Timer/Counter2 Output Compare Register</DESCRIPTION>
        <TEXT>The output compare register is an 8-bit read/write register. The Timer/Counter Output Compare Register contains the data to be continuously compared with Timer/Counter2. Actions on compare matches are specified in TCCR2. A compare match does only occur if Timer/Counter2 counts to the OCR2 value. A software write that sets TCNT2 and OCR2 to the same value does not generate a compare match. A compare match will set the compare interrupt flag in the CPU clock cycle following the compare event. Timer/Counter2 in PWM Mode When PWM mode is selected, the Timer/Counter2 either wraps (overflows) when it reaches $FF or it acts as an up/down counter. If the up/down mode is selected, the Timer/Counter2 and the Output Compare Register - OCR2 form an 8-bit, free-running, glitch-free, and phase correct PWM with outputs on the PD7(OC2) pin. If the overflow mode is selected, the Timer/Counter2 and the Output Compare Register - OCR2 form an 8-bit, free-running, and glitch-free PWM, operating with twice the speed of the up/down  counting mode. PWM Modes (Up/Down and Overflow). The two different PWM modes are selected by the CTC2 bit in the Timer/Counter Control Register - TCCR2. If CTC2 is cleared and PWM mode is selected, the Timer/Counter acts as an up/down counter, counting up from $00 to $FF, where it turns and counts down again to zero before the cycle is repeated. When the counter value matches the con-tents of the Output Compare Register, the PD7(OC2) pin is set or cleared according to the settings of the COM21/COM20 bits in the Timer/Counter Control Register TCCR2. If CTC2 is set and PWM mode is selected, the Timer/Counters will wrap and start counting from $00 after reaching $FF. The PD7(OC2) pin will be set or cleared according to the settings of COM21/COM20 on a Timer/Counter overflow or when the counter value matches the contents of the Output Compare Register. Note that in PWM mode, the value to be written to the Output Compare Register is first transferred to a temporary location, and then latched into OCR2 when the Timer/Counter reaches $FF. This prevents the occurrence of odd-length PWM pulses (glitches) in the event of an unsynchronized OCR2 write. (CTC2:COM21:COM20) Effect on Compare Pin Frequency: (0:0:0) = Not connected. (0:0:1) = Not connected. (0:1:0) = Cleared on compare match, up-counting. Set on compare match, down-counting (non-inverted PWM). f TCK0/2 /510. (0:1:1) = Cleared on compare match, down-counting. Set on compare match, up-counting (inverted PWM). f TCK0/2 /510. (1:0:0) = Not connected. (1:0:1) = Not connected. (1:1:0) = Cleared on compare match, set on overflow. f TCK0/2 /256. (1:1:1) = Set on compare match, cleared on overflow. f TCK0/2 /</TEXT>
        <IO_ADDR>$22</IO_ADDR>
        <MEM_ADDR>$42</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR2-7</NAME>
          <DESCRIPTION>Timer/Counter2 Output Compare Register Bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR2-6</NAME>
          <DESCRIPTION>Timer/Counter2 Output Compare Register Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR2-5</NAME>
          <DESCRIPTION>Timer/Counter2 Output Compare Register Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR2-4</NAME>
          <DESCRIPTION>Timer/Counter2 Output Compare Register Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR2-3</NAME>
          <DESCRIPTION>Timer/Counter2 Output Compare Register Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR2-2</NAME>
          <DESCRIPTION>Timer/Counter2 Output Compare Register Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR2-1</NAME>
          <DESCRIPTION>Timer/Counter2 Output Compare Register Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR2-0</NAME>
          <DESCRIPTION>Timer/Counter2 Output Compare Register Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCR2>
      <ASSR>
        <NAME>ASSR</NAME>
        <DESCRIPTION>Asynchronous Status Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$26</IO_ADDR>
        <MEM_ADDR>$46</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT3>
          <NAME>AS2</NAME>
          <DESCRIPTION>Asynchronous Timer/counter2</DESCRIPTION>
          <TEXT>When AS2 is cleared (zero), Timer/Counter2 is clocked from the internal system clock, CK. When AS2 is set (one), Timer/Counter2 is clocked from the PC6(TOSC1) pin. Pins PC6 and PC7 are connected to a crystal oscillator and cannot be used as general I/O pins. When the value of this bit is changed, the contents of TCNT2, OCR2, and TCCR2 might be corrupted.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TCN2UB</NAME>
          <DESCRIPTION>Timer/Counter2 Update Busy</DESCRIPTION>
          <TEXT>When Timer/Counter2 operates asynchronously and TCNT2 is written, this bit becomes set (one). When TCNT2 has been updated from the temporary storage register, this bit is cleared (zero) by hardware. A logical zero in this bit indicates that TCNT2 is ready to be updated with a new value.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR2UB</NAME>
          <DESCRIPTION>Output Compare Register2 Update Busy</DESCRIPTION>
          <TEXT>When Timer/Counter2 operates asynchronously and OCR2 is written, this bit becomes set (one). When OCR2 has been updated from the temporary storage register, this bit is cleared (zero) by hardware. A logical zero in this bit indicates that OCR2 is ready to be updated with a new value.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TCR2UB</NAME>
          <DESCRIPTION>Timer/counter Control Register2 Update Busy</DESCRIPTION>
          <TEXT>When Timer/Counter2 operates asynchronously and TCCR2 is written, this bit becomes set (one). When TCCR2 has been updated from the temporary storage register, this bit is cleared (zero) by hardware. A logical zero in this bit indicates that TCCR2 is ready to be updated with a new value. If a write is performed to any of the three Timer/Counter2 registers while its update busy flag is set (one), the updated value might get corrupted and cause an unintentional interrupt to occur. The mechanisms for reading TCNT2, OCR2, and TCCR2 are different. When reading TCNT2, the actual timer value is read. When reading OCR2 or TCCR2, the value in the temporary storage register is rea</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ASSR>
      <SFIOR>
        <NAME>SFIOR</NAME>
        <DESCRIPTION>Specil Function IO Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$30</IO_ADDR>
        <MEM_ADDR>$50</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT1>
          <NAME>PSR2</NAME>
          <DESCRIPTION>Prescaler Reset Timer/Counter2</DESCRIPTION>
          <TEXT>When this bit is set (one)the Timer/Counter2 prescaler will be reset.The bit will be cleared by hardware after the operation is performed.Writing a zero to this bit will have no effect.This bit will always be read as zero if Timer/Counter2 is clocked by the internal CPU clock.If this bit is written when Timer/Counter2 is operating in asynchronous mode,the bit will remain one until the prescaler has been reset.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
      </SFIOR>
    </TIMER_COUNTER_2>
    <TIMER_COUNTER_1>
      <LIST>[TIMSK:TIFR:TCCR1A:TCCR1B:TCNT1H:TCNT1L:OCR1AH:OCR1AL:OCR1BH:OCR1BL:ICR1H:ICR1L]</LIST>
      <LINK>[TCNT1H:TCNT1L];[OCR1AH:OCR1AL];[OCR1BH:OCR1BL];[ICR1H:ICR1L]</LINK>
      <ICON>io_timer.bmp</ICON>
      <ID>t16pwm1_05.xml</ID>
      <TEXT/>
      <TIMSK>
        <NAME>TIMSK</NAME>
        <DESCRIPTION>Timer/Counter Interrupt Mask Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$39</IO_ADDR>
        <MEM_ADDR>$59</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>TOIE1</NAME>
          <DESCRIPTION>Timer/Counter1 Overflow Interrupt Enable</DESCRIPTION>
          <TEXT>When the TOIE1 bit is set (one) and the I-bit in the Status Register is set (one), the Timer/Counter1 Overflow interrupt is enabled. The corresponding interrupt (at vector $006) is executed if an overflow in Timer/Counter1 occurs, i.e., when the TOV1 bit is set in the Timer/Counter Interrupt Flag Register - TIFR.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCIE1A</NAME>
          <DESCRIPTION>Timer/Counter1 Output CompareA Match Interrupt Enable</DESCRIPTION>
          <TEXT>When the OCIE1A bit is set (one) and the I-bit in the Status Register is set (one), the Timer/Counter1 CompareA Match interrupt is enabled. The corresponding interrupt (at vector $004) is executed if a CompareA match in Timer/Counter1 occurs, i.e., when the OCF1A bit is set in the Timer/Counter Interrupt Flag Register - TIFR.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCIE1B</NAME>
          <DESCRIPTION>Timer/Counter1 Output CompareB Match Interrupt Enable</DESCRIPTION>
          <TEXT>When the OCIE1B bit is set (one) and the I-bit in the Status Register is set (one), the Timer/Counter1 CompareB Match interrupt is enabled. The corresponding interrupt (at vector $005) is executed if a CompareB match in Timer/Counter1 occurs, i.e., when the OCF1B bit is set in the Timer/Counter Interrupt Flag Register - TIFR.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT3>
          <NAME>TICIE1</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Interrupt Enable</DESCRIPTION>
          <TEXT>When the TICIE1 bit is set (one) and the I-bit in the Status Register is set (one), the Timer/Counter1 Input Capture Event Interrupt is enabled. The corresponding interrupt (at vector $003) is executed if a capture-triggering event occurs on pin 31, ICP, i.e., when the ICF1 bit is set in the Timer/Counter Interrupt Flag Register - TIFR.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
      </TIMSK>
      <TIFR>
        <NAME>TIFR</NAME>
        <DESCRIPTION>Timer/Counter Interrupt Flag register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$38</IO_ADDR>
        <MEM_ADDR>$58</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>TOV1</NAME>
          <DESCRIPTION>Timer/Counter1 Overflow Flag</DESCRIPTION>
          <TEXT>The TOV1 is set (one) when an overflow occurs in Timer/Counter1. TOV1 is cleared by hardware when executing the cor-responding interrupt handling vector. Alternatively, TOV1 is cleared by writing a logic one to the flag. When the I-bit in SREG, and TOIE1 (Timer/Counter1 Overflow Interrupt Enable), and TOV1 are set (one), the Timer/Counter1 Overflow Interrupt is executed. In PWM mode, this bit is set when Timer/Counter1 changes counting direction at $0000.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCF1A</NAME>
          <DESCRIPTION>Output Compare Flag 1A</DESCRIPTION>
          <TEXT>The OCF1A bit is set (one) when compare match occurs between the Timer/Counter1 and the data in OCR1A - Output Compare Register 1A. OCF1A is cleared by hardware when executing the corresponding interrupt handling vector. Alterna-tively, OCF1A is cleared by writing a logic one to the flag. When the I-bit in SREG, and OCIE1A (Timer/Counter1 Compare match InterruptA Enable), and the OCF1A are set (one), the Timer/Counter1 Compare A match Interrupt is executed. </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCF1B</NAME>
          <DESCRIPTION>Output Compare Flag 1B</DESCRIPTION>
          <TEXT>The OCF1B bit is set (one) when compare match occurs between the Timer/Counter1 and the data in OCR1B - Output Compare Register 1B. OCF1B is cleared by hardware when executing the corresponding interrupt handling vector. Alterna-tively, OCF1B is cleared by writing a logic one to the flag. When the I-bit in SREG, and OCIE1B (Timer/Counter1 Compare match InterruptB Enable), and the OCF1B are set (one), the Timer/Counter1 Compare B match Interrupt is executed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT3>
          <NAME>ICF1</NAME>
          <DESCRIPTION>Input Capture Flag 1</DESCRIPTION>
          <TEXT>The ICF1 bit is set (one) to flag an input capture event, indicating that the Timer/Counter1 value has been transferred to the input capture register - ICR1. ICF1 is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, ICF1 is cleared by writing a logic one to the flag. When the SREG I-bit, and TICIE1 (Timer/Counter1 Input Capture Interrupt Enable), and ICF1 are set (one), the Timer/Counter1 Capture Interrupt is executed. </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
      </TIFR>
      <TCCR1A>
        <NAME>TCCR1A</NAME>
        <DESCRIPTION>Timer/Counter1 Control Register A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$2F</IO_ADDR>
        <MEM_ADDR>$4F</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>COM1A1</NAME>
          <DESCRIPTION>Compare Output Mode 1A, bit 1</DESCRIPTION>
          <TEXT>The COM1A1 and COM1A0 control bits determine any output pin action following a compare match in Timer/Counter1. Any output pin actions affect pin OC1A - Output CompareA. This is an alternative function to an I/O port, and the corresponding direction control bit must be set (one) to control an output pin. The control configuration is shown in Table 10.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>COM1A0</NAME>
          <DESCRIPTION>Comparet Ouput Mode 1A, bit 0</DESCRIPTION>
          <TEXT>The COM1A1 and COM1A0 control bits determine any output pin action following a compare match in Timer/Counter1. Any output pin actions affect pin OC1A - Output CompareA. This is an alternative function to an I/O port, and the corresponding direction control bit must be set (one) to control an output pin. The control configuration is shown in Table 10.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>CLK_COMP_MATCH_OUT_MODE</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>COM1B1</NAME>
          <DESCRIPTION>Compare Output Mode 1B, bit 1</DESCRIPTION>
          <TEXT>The COM1B1 and COM1B0 control bits determine any output pin action following a compare match in Timer/Counter1.	Any output pin actions affect pin OC1B - Output CompareB. This is an alternative function to an I/O port, and the corre-sponding direction control bit must be set (one) to control an output pin.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>COM1B0</NAME>
          <DESCRIPTION>Compare Output Mode 1B, bit 0</DESCRIPTION>
          <TEXT>The COM1B1 and COM1B0 control bits determine any output pin action following a compare match in Timer/Counter1.	Any output pin actions affect pin OC1B - Output CompareB. This is an alternative function to an I/O port, and the corre-sponding direction control bit must be set (one) to control an output pin.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>CLK_COMP_MATCH_OUT_MODE</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>FOC1A</NAME>
          <DESCRIPTION>Force Output Compare 1A</DESCRIPTION>
          <TEXT>Writing a logical one to this bit, forces a change in the compare match output pin PD5 according to the values already set in COM1A1 and COM1A0.If the COM1A1 and COM1A0 bits are written in the same cycle as FOC1A,the new settings will not take effect until next compare match or forced compare match occurs. The Force Output Compare bit can be used to change the output pin without waiting for a compare match in the timer. The automatic action programmed in COM1A1 and COM1A0 happens as if a Compare Match had occurred, but no interrupt is generated and it will not clear the timer even if CTC1 in TCCR1B is set. The corresponding I/O pin must be set as an output pin for the FOC1A bit to have effect on the pin. The FOC1A bit will always be read as zero. The setting of the FOC1A bit has no effect in PWM mod</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>FOC1B</NAME>
          <DESCRIPTION>Force Output Compare 1B</DESCRIPTION>
          <TEXT>Writing a logical one to this bit, forces a change in the compare match output pin PD4 according to the values already set in COM1B1 and COM1B0.If the COM1B1 and COM1B0 bits are written in the same cycle as FOC1B,the new settings will not take effect until next compare match or forced compare match occurs. The Force Output Compare bit can be used to change the output pin without waiting for a compare match in the timer. The automatic action programmed in COM1B1 and COM1B0 happens as if a Compare Match had occurred, but no interrupt is generated. The corresponding I/O pin must be set as an output pin for the FOC1B bit to have effect on the pin. The FOC1B bit will always be read as zero. The setting of the FOC1B bit has no effect in PWM mode</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>WGM11</NAME>
          <DESCRIPTION>Waveform Generation Mode</DESCRIPTION>
          <TEXT>Combined with the WGM13:2 bits found in the TCCR1B register,these bits control the counting sequence of the counter, the source for maximum (TOP)counter value,and what type of waveform generation to be used.Modes of operation supported by the timer/counter unit are:Normal mode (counter),Clear Timer on Compare match (CTC)mode,and three types of Pulse Width Modulation (PWM)modes. PLease refer to the manual for a Mode Bit Description Table.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>WGM10</NAME>
          <DESCRIPTION>Waveform Generation Mode</DESCRIPTION>
          <TEXT>Combined with the WGM13:2 bits found in the TCCR1B register,these bits control the counting sequence of the counter, the source for maximum (TOP)counter value,and what type of waveform generation to be used.Modes of operation supported by the timer/counter unit are:Normal mode (counter),Clear Timer on Compare match (CTC)mode,and three types of Pulse Width Modulation (PWM)modes. PLease refer to the manual for a Mode Bit Description Table.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCCR1A>
      <TCCR1B>
        <NAME>TCCR1B</NAME>
        <DESCRIPTION>Timer/Counter1 Control Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$2E</IO_ADDR>
        <MEM_ADDR>$4E</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>ICNC1</NAME>
          <DESCRIPTION>Input Capture 1 Noise Canceler</DESCRIPTION>
          <TEXT>When the ICNC1 bit is cleared (zero), the input capture trigger noise canceler function is disabled. The input capture is triggered at the first rising/falling edge sampled on the ICP - input capture pin - as specified. When the ICNC1 bit is set (one), four successive samples are measures on the ICP - input capture pin, and all samples must be high/low according to the input capture trigger specification in the ICES1 bit. The actual sampling frequency is XTAL clock frequency.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ICES1</NAME>
          <DESCRIPTION>Input Capture 1 Edge Select</DESCRIPTION>
          <TEXT>While the ICES1 bit is cleared (zero), the Timer/Counter1 contents are transferred to the Input Capture Register - ICR1 - on the falling edge of the input capture pin - ICP. While the ICES1 bit is set (one), the Timer/Counter1 contents are transferred to the Input Capture Register - ICR1 - on the rising edge of the input capture pin - ICP.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT3>
          <NAME>CTC1</NAME>
          <DESCRIPTION>Clear Timer/Counter1 on Compare Match</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CS12</NAME>
          <DESCRIPTION>Prescaler source of Timer/Counter 1</DESCRIPTION>
          <TEXT>Select Prescaling Clock Source of Timer/Counter1. (0:0:0) = Stop. (0:0:1) = CK. (0:1:0) = CK / 8. (0:1:1) = CK / 64. (1:0:0) = CK / 256. (1:0:1) = CK / 1024. (1:1:0) =  External Pin T1, falling edge. (1:1:1) = External Pin 1, rising edge.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CS11</NAME>
          <DESCRIPTION>Prescaler source of Timer/Counter 1</DESCRIPTION>
          <TEXT>Select Prescaling Clock Source of Timer/Counter1. (0:0:0) = Stop. (0:0:1) = CK. (0:1:0) = CK / 8. (0:1:1) = CK / 64. (1:0:0) = CK / 256. (1:0:1) = CK / 1024. (1:1:0) =  External Pin T1, falling edge. (1:1:1) = External Pin 1, rising edge.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CS10</NAME>
          <DESCRIPTION>Prescaler source of Timer/Counter 1</DESCRIPTION>
          <TEXT>Select Prescaling Clock Source of Timer/Counter1. (0:0:0) = Stop. (0:0:1) = CK. (0:1:0) = CK / 8. (0:1:1) = CK / 64. (1:0:0) = CK / 256. (1:0:1) = CK / 1024. (1:1:0) =  External Pin T1, falling edge. (1:1:1) = External Pin 1, rising edge.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>CLK_SEL_3BIT_EXT</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCCR1B>
      <TCNT1H>
        <NAME>TCNT1H</NAME>
        <DESCRIPTION>Timer/Counter1 High Byte</DESCRIPTION>
        <TEXT>This 16-bit register contains the prescaled value of the 16-bit Timer/Counter1. To ensure that both the high and low bytes are read and written simultaneously when the CPU accesses these registers, the access is performed using an 8-bit temporary register (TEMP). This temporary register is also used when accessing OCR1A, OCR1B and ICR1. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within interrupt rou</TEXT>
        <IO_ADDR>$2D</IO_ADDR>
        <MEM_ADDR>$4D</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TCNT1H7</NAME>
          <DESCRIPTION>Timer/Counter1 High Byte bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TCNT1H6</NAME>
          <DESCRIPTION>Timer/Counter1 High Byte bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TCNT1H5</NAME>
          <DESCRIPTION>Timer/Counter1 High Byte bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TCNT1H4</NAME>
          <DESCRIPTION>Timer/Counter1 High Byte bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TCNT1H3</NAME>
          <DESCRIPTION>Timer/Counter1 High Byte bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TCNT1H2</NAME>
          <DESCRIPTION>Timer/Counter1 High Byte bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TCNT1H1</NAME>
          <DESCRIPTION>Timer/Counter1 High Byte bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TCNT1H0</NAME>
          <DESCRIPTION>Timer/Counter1 High Byte bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCNT1H>
      <TCNT1L>
        <NAME>TCNT1L</NAME>
        <DESCRIPTION>Timer/Counter1 Low Byte</DESCRIPTION>
        <TEXT>This 16-bit register contains the prescaled value of the 16-bit Timer/Counter1. To ensure that both the high and low bytes are read and written simultaneously when the CPU accesses these registers, the access is performed using an 8-bit temporary register (TEMP). This temporary register is also used when accessing OCR1A, OCR1B and ICR1. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within interru</TEXT>
        <IO_ADDR>$2C</IO_ADDR>
        <MEM_ADDR>$4C</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TCNT1L7</NAME>
          <DESCRIPTION>Timer/Counter1 Low Byte bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TCNT1L6</NAME>
          <DESCRIPTION>Timer/Counter1 Low Byte bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TCNT1L5</NAME>
          <DESCRIPTION>Timer/Counter1 Low Byte bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TCNT1L4</NAME>
          <DESCRIPTION>Timer/Counter1 Low Byte bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TCNT1L3</NAME>
          <DESCRIPTION>Timer/Counter1 Low Byte bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TCNT1L2</NAME>
          <DESCRIPTION>Timer/Counter1 Low Byte bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TCNT1L1</NAME>
          <DESCRIPTION>Timer/Counter1 Low Byte bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TCNT1L0</NAME>
          <DESCRIPTION>Timer/Counter1 Low Byte bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCNT1L>
      <OCR1AH>
        <NAME>OCR1AH</NAME>
        <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte</DESCRIPTION>
        <TEXT>The output compare registers are 16-bit read/write registers. The Timer/Counter1 Output Compare Registers contain the data to be continuously compared with Timer/Counter1. Actions on compare matches are specified in the Timer/Counter1 Control and Status register.A compare match does only occur if Timer/Counter1 counts to the OCR value. A software write that sets TCNT1 and OCR1A or OCR1B to the same value does not generate a compare match. A compare match will set the compare interrupt flag in the CPU clock cycle following the compare event. Since the Output Compare Registers - OCR1A and OCR1B - are 16-bit registers, a temporary register TEMP is used when OCR1A/B are written to ensure that both bytes are updated simultaneously. When the CPU writes the high byte, OCR1AH or OCR1BH, the data is temporarily stored in the TEMP register. When the CPU writes the low byte, OCR1AL or OCR1BL, the TEMP register is simultaneously written to OCR1AH or OCR1BH. Consequently, the high byte OCR1AH or OCR1BH must be written first for a full 16-bit register write operation. The TEMP register is also used when accessing TCNT1, and ICR1. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within interru</TEXT>
        <IO_ADDR>$2B</IO_ADDR>
        <MEM_ADDR>$4B</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR1AH7</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR1AH6</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR1AH5</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR1AH4</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR1AH3</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR1AH2</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR1AH1</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR1AH0</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCR1AH>
      <OCR1AL>
        <NAME>OCR1AL</NAME>
        <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte</DESCRIPTION>
        <TEXT>The output compare registers are 16-bit read/write registers. The Timer/Counter1 Output Compare Registers contain the data to be continuously compared with Timer/Counter1. Actions on compare matches are specified in the Timer/Counter1 Control and Status register.A compare match does only occur if Timer/Counter1 counts to the OCR value. A software write that sets TCNT1 and OCR1A or OCR1B to the same value does not generate a compare match. A compare match will set the compare interrupt flag in the CPU clock cycle following the compare event. Since the Output Compare Registers - OCR1A and OCR1B - are 16-bit registers, a temporary register TEMP is used when OCR1A/B are written to ensure that both bytes are updated simultaneously. When the CPU writes the high byte, OCR1AH or OCR1BH, the data is temporarily stored in the TEMP register. When the CPU writes the low byte, OCR1AL or OCR1BL, the TEMP register is simultaneously written to OCR1AH or OCR1BH. Consequently, the high byte OCR1AH or OCR1BH must be written first for a full 16-bit register write operation. The TEMP register is also used when accessing TCNT1, and ICR1. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within interru</TEXT>
        <IO_ADDR>$2A</IO_ADDR>
        <MEM_ADDR>$4A</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR1AL7</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte Bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR1AL6</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR1AL5</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR1AL4</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR1AL3</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR1AL2</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR1AL1</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR1AL0</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCR1AL>
      <OCR1BH>
        <NAME>OCR1BH</NAME>
        <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte</DESCRIPTION>
        <TEXT>The output compare registers are 16-bit read/write registers. The Timer/Counter1 Output Compare Registers contain the data to be continuously compared with Timer/Counter1. Actions on compare matches are specified in the Timer/Counter1 Control and Status register.A compare match does only occur if Timer/Counter1 counts to the OCR value. A software write that sets TCNT1 and OCR1A or OCR1B to the same value does not generate a compare match. A compare match will set the compare interrupt flag in the CPU clock cycle following the compare event. Since the Output Compare Registers - OCR1A and OCR1B - are 16-bit registers, a temporary register TEMP is used when OCR1A/B are written to ensure that both bytes are updated simultaneously. When the CPU writes the high byte, OCR1AH or OCR1BH, the data is temporarily stored in the TEMP register. When the CPU writes the low byte, OCR1AL or OCR1BL, the TEMP register is simultaneously written to OCR1AH or OCR1BH. Consequently, the high byte OCR1AH or OCR1BH must be written first for a full 16-bit register write operation. The TEMP register is also used when accessing TCNT1, and ICR1. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within interrupt ro</TEXT>
        <IO_ADDR>$29</IO_ADDR>
        <MEM_ADDR>$49</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR1BH7</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR1BH6</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR1BH5</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR1BH4</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR1BH3</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR1BH2</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR1BH1</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR1BH0</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCR1BH>
      <OCR1BL>
        <NAME>OCR1BL</NAME>
        <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte</DESCRIPTION>
        <TEXT>The output compare registers are 16-bit read/write registers. The Timer/Counter1 Output Compare Registers contain the data to be continuously compared with Timer/Counter1. Actions on compare matches are specified in the Timer/Counter1 Control and Status register.A compare match does only occur if Timer/Counter1 counts to the OCR value. A software write that sets TCNT1 and OCR1A or OCR1B to the same value does not generate a compare match. A compare match will set the compare interrupt flag in the CPU clock cycle following the compare event. Since the Output Compare Registers - OCR1A and OCR1B - are 16-bit registers, a temporary register TEMP is used when OCR1A/B are written to ensure that both bytes are updated simultaneously. When the CPU writes the high byte, OCR1AH or OCR1BH, the data is temporarily stored in the TEMP register. When the CPU writes the low byte, OCR1AL or OCR1BL, the TEMP register is simultaneously written to OCR1AH or OCR1BH. Consequently, the high byte OCR1AH or OCR1BH must be written first for a full 16-bit register write operation. The TEMP register is also used when accessing TCNT1, and ICR1. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within interrupt rout</TEXT>
        <IO_ADDR>$28</IO_ADDR>
        <MEM_ADDR>$48</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR1BL7</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR1BL6</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR1BL5</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR1BL4</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR1BL3</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR1BL2</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR1BL1</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR1BL0</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCR1BL>
      <ICR1H>
        <NAME>ICR1H</NAME>
        <DESCRIPTION>Timer/Counter1 Input Capture Register High Byte</DESCRIPTION>
        <TEXT>The input capture register is a 16-bit read-only register. When the rising or falling edge (according to the input capture edge setting - ICES1) of the signal at the input capture pin -ICP - is detected, the current value of the Timer/Counter1 is transferred to the Input Capture Register - ICR1. At the same time, the input capture flag - ICF1 - is set (one). Since the Input Capture Register - ICR1 - is a 16-bit register, a temporary register TEMP is used when ICR1 is read to ensure that both bytes are read simultaneously. When the CPU reads the low byte ICR1L, the data is sent to the CPU and the data of the high byte ICR1H is placed in the TEMP register. When the CPU reads the data in the high byte ICR1H, the CPU receives the data in the TEMP register. Consequently, the low byte ICR1L must be accessed first for a full 16-bit register read operation. The TEMP register is also used when accessing TCNT1, OCR1A and OCR1B. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within interrupt</TEXT>
        <IO_ADDR>$25</IO_ADDR>
        <MEM_ADDR>$45</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>ICR1H7</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register High Byte bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ICR1H6</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register High Byte bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ICR1H5</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register High Byte bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ICR1H4</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register High Byte bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ICR1H3</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register High Byte bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ICR1H2</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register High Byte bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ICR1H1</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register High Byte bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ICR1H0</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register High Byte bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ICR1H>
      <ICR1L>
        <NAME>ICR1L</NAME>
        <DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte</DESCRIPTION>
        <TEXT>The input capture register is a 16-bit read-only register. When the rising or falling edge (according to the input capture edge setting - ICES1) of the signal at the input capture pin -ICP - is detected, the current value of the Timer/Counter1 is transferred to the Input Capture Register - ICR1. At the same time, the input capture flag - ICF1 - is set (one). Since the Input Capture Register - ICR1 - is a 16-bit register, a temporary register TEMP is used when ICR1 is read to ensure that both bytes are read simultaneously. When the CPU reads the low byte ICR1L, the data is sent to the CPU and the data of the high byte ICR1H is placed in the TEMP register. When the CPU reads the data in the high byte ICR1H, the CPU receives the data in the TEMP register. Consequently, the low byte ICR1L must be accessed first for a full 16-bit register read operation. The TEMP register is also used when accessing TCNT1, OCR1A and OCR1B. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within inter</TEXT>
        <IO_ADDR>$24</IO_ADDR>
        <MEM_ADDR>$44</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>ICR1L7</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ICR1L6</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ICR1L5</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ICR1L4</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ICR1L3</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ICR1L2</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ICR1L1</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ICR1L0</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ICR1L>
    </TIMER_COUNTER_1>
    <WATCHDOG>
      <LIST>[WDTCR]</LIST>
      <LINK/>
      <ICON>io_watch.bmp</ICON>
      <ID/>
      <TEXT/>
      <WDTCR>
        <NAME>WDTCR</NAME>
        <DESCRIPTION>Watchdog Timer Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$21</IO_ADDR>
        <MEM_ADDR>$41</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT4>
          <NAME>WDTOE</NAME>
          <ALIAS>WDDE</ALIAS>
          <DESCRIPTION>RW</DESCRIPTION>
          <TEXT>This bit must be set (one) when the WDE bit is cleared. Otherwise, the watchdog will not be disabled. Once set, hardware will clear this bit to zero after four clock cycles. Refer to the description of the WDE bit for a watchdog disable procedure.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>WDE</NAME>
          <DESCRIPTION>Watch Dog Enable</DESCRIPTION>
          <TEXT>When the WDE is set (one) the Watchdog Timer is enabled, and if the WDE is cleared (zero) the Watchdog Timer function is disabled. WDE can only be cleared if the WDTOE bit is set(one). To disable an enabled watchdog timer, the following procedure must be followed: 1. In the same operation, write a logical one to WDTOE and WDE. A logical one must be written to WDE even though it is set to one before the disable operation starts. 2. Within the next four clock cycles, write a logical 0 to WDE. This disables the watchdog</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>WDP2</NAME>
          <DESCRIPTION>Watch Dog Timer Prescaler bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <ENUM>WDOG_TIMER_PRESCALE_3BITS</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>WDP1</NAME>
          <DESCRIPTION>Watch Dog Timer Prescaler bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>WDP0</NAME>
          <DESCRIPTION>Watch Dog Timer Prescaler bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </WDTCR>
    </WATCHDOG>
  </IO_MODULE>
  <ICE_SETTINGS>
    <MODULE_LIST>[SIMULATOR:STK500:STK500_2]</MODULE_LIST>
    <SIMULATOR>
      <CoreID>AVRSimCoreV2.SimCoreV2</CoreID>
      <MemoryID>AVRSimMemory8bit.SimMemory8bit</MemoryID>
      <InterruptID>AVRSimInterrupt.SimInterrupt</InterruptID>
      <EEINTERRUPT>0x26</EEINTERRUPT>
      <EEAR_EXTRA_BIT>0</EEAR_EXTRA_BIT>
      <NmbIOModules>15</NmbIOModules>
      <PORTA>
        <ID>AVRSimIOPort.SimIOPort</ID>
        <TOGGLE_PIN>N</TOGGLE_PIN>
      </PORTA>
      <PORTB>
        <ID>AVRSimIOPort.SimIOPort</ID>
        <TOGGLE_PIN>N</TOGGLE_PIN>
      </PORTB>
      <PORTC>
        <ID>AVRSimIOPort.SimIOPort</ID>
        <TOGGLE_PIN>N</TOGGLE_PIN>
      </PORTC>
      <PORTD>
        <ID>AVRSimIOPort.SimIOPort</ID>
        <TOGGLE_PIN>N</TOGGLE_PIN>
      </PORTD>
      <PORTE>
        <ID>AVRSimIOPort.SimIOPort</ID>
        <TOGGLE_PIN>N</TOGGLE_PIN>
      </PORTE>
      <EXTINT0>
        <ID>AVRSimIOExtInterrupt.SimIOExtInterrupt</ID>
        <IntVector>0x02</IntVector>
        <EnableIOAdr>0x3B</EnableIOAdr>
        <EnableMask>0x40</EnableMask>
        <FlagIOAdr>0x3A</FlagIOAdr>
        <FlagMask>0x40</FlagMask>
        <ExtPinIOAdr>0x10</ExtPinIOAdr>
        <ExtPinMask>0x04</ExtPinMask>
        <SenseIOAdr>0x35</SenseIOAdr>
        <SenseMask>0x03</SenseMask>
      </EXTINT0>
      <EXTINT1>
        <ID>AVRSimIOExtInterrupt.SimIOExtInterrupt</ID>
        <IntVector>0x04</IntVector>
        <EnableIOAdr>0x3B</EnableIOAdr>
        <EnableMask>0x80</EnableMask>
        <FlagIOAdr>0x3A</FlagIOAdr>
        <FlagMask>0x80</FlagMask>
        <ExtPinIOAdr>0x10</ExtPinIOAdr>
        <ExtPinMask>0x08</ExtPinMask>
        <SenseIOAdr>0x35</SenseIOAdr>
        <SenseMask>0x0c</SenseMask>
      </EXTINT1>
      <EXTINT2>
        <ID>AVRSimIOExtInterrupt.SimIOExtInterrupt</ID>
        <IntVector>0x06</IntVector>
        <EnableIOAdr>0x3B</EnableIOAdr>
        <EnableMask>0x20</EnableMask>
        <FlagIOAdr>0x3A</FlagIOAdr>
        <FlagMask>0x20</FlagMask>
        <ExtPinIOAdr>0x05</ExtPinIOAdr>
        <ExtPinMask>0x01</ExtPinMask>
        <SenseIOAdr>0x36</SenseIOAdr>
        <SenseMask>0x01</SenseMask>
      </EXTINT2>
      <TIMER0>
        <ID>AVRSimIOTimert8pwm2.SimIOTimert8pwm2</ID>
        <CompVector>0x14</CompVector>
        <OvfVector>0x16</OvfVector>
        <OutputAdr>0x18</OutputAdr>
        <OutputMask>0x01</OutputMask>
        <CountAdr>0x16</CountAdr>
        <CountMask>0x01</CountMask>
      </TIMER0>
      <TIMER1>
        <ID>AVRSimIOTimert16pwm1.SimIOTimert16pwm1</ID>
        <IcpVector>0x0c</IcpVector>
        <CompAVector>0x0e</CompAVector>
        <CompBVector>0x10</CompBVector>
        <OvfVector>0x12</OvfVector>
        <CountPinAdr>0x16</CountPinAdr>
        <CountPinMask>0x02</CountPinMask>
        <IcpPinAdr>0x05</IcpPinAdr>
        <IcpPinMask>0x01</IcpPinMask>
        <OutputAAdr>0x12</OutputAAdr>
        <OutputAMask>0x20</OutputAMask>
        <OutputBAdr>0x07</OutputBAdr>
        <OutputBMask>0x02</OutputBMask>
      </TIMER1>
      <TIMER2>
        <ID>AVRSimIOTimerAt8pwm1.SimIOTimerAt8pwm1</ID>
        <CompVector>0x08</CompVector>
        <OvfVector>0x0a</OvfVector>
        <OutputAdr>0x18</OutputAdr>
        <OutputMask>0x02</OutputMask>
      </TIMER2>
      <SPM>
        <ID>AVRSimIOSPM.SimIOSPM</ID>
      </SPM>
      <SPI>
        <ID>AVRSimIOSpi.SimIOSpi</ID>
        <IntVector>0x18</IntVector>
        <SCKAddress>0x16</SCKAddress>
        <SCKMask>0x80</SCKMask>
        <MISOAddress>0x16</MISOAddress>
        <MISOMask>0x40</MISOMask>
        <MOSIAddress>0x16</MOSIAddress>
        <MOSIMask>0x20</MOSIMask>
        <SSAddress>0x16</SSAddress>
        <DIRAddress>0x17</DIRAddress>
        <SSMask>0x10</SSMask>
      </SPI>
      <UART0>
        <ID>AVRSimIOUart.SimIOUart</ID>
        <RXVector>0x1a</RXVector>
        <TXVector>0x22</TXVector>
        <UDREVector>0x1e</UDREVector>
        <TXPinAddress>0x10</TXPinAddress>
        <TXPinMask>0x02</TXPinMask>
        <RXPinAddress>0x10</RXPinAddress>
        <RXPinMask>0x01</RXPinMask>
      </UART0>
      <UART1>
        <ID>AVRSimIOUart.SimIOUart</ID>
        <RXVector>0x1c</RXVector>
        <TXVector>0x24</TXVector>
        <UDREVector>0x20</UDREVector>
        <TXPinAddress>0x16</TXPinAddress>
        <TXPinMask>0x08</TXPinMask>
        <RXPinAddress>0x16</RXPinAddress>
        <RXPinMask>0x04</RXPinMask>
      </UART1>
      <DEFAULT_SETTINGS>
        <HighFuse>0x0</HighFuse>
        <ExtendedFuse>0x0</ExtendedFuse>
        <LowFuse>0x0</LowFuse>
        <Lockbit>0x0</Lockbit>
      </DEFAULT_SETTINGS>
      <ANALOGCOMP>
        <ID>AVRSimAC.SimIOAC</ID>
        <IntVector>0x28</IntVector>
      </ANALOGCOMP>
    </SIMULATOR>
    <STK500>
      <DeviceId>0x80</DeviceId>
      <SelfTimed>1</SelfTimed>
      <FullParallel>1</FullParallel>
      <Polled>1</Polled>
      <FPoll>0xFF</FPoll>
      <EPol1>0xFF</EPol1>
      <EPol2>0xFF</EPol2>
      <ComLockFuseRead>0</ComLockFuseRead>
    </STK500>
    <STK500_2>
      <IspEnterProgMode>
        <timeout>200</timeout>
        <stabDelay>100</stabDelay>
        <cmdexeDelay>25</cmdexeDelay>
        <synchLoops>32</synchLoops>
        <byteDelay>0</byteDelay>
        <pollIndex>3</pollIndex>
        <pollValue>0x53</pollValue>
      </IspEnterProgMode>
      <IspLeaveProgMode>
        <preDelay>1</preDelay>
        <postDelay>1</postDelay>
      </IspLeaveProgMode>
      <IspChipErase>
        <eraseDelay>30</eraseDelay>
        <pollMethod>0</pollMethod>
      </IspChipErase>
      <IspProgramFlash>
        <mode>0x21</mode>
        <blockSize>128</blockSize>
        <delay>16</delay>
        <cmd1>0x40</cmd1>
        <cmd2>0x4C</cmd2>
        <cmd3>0x20</cmd3>
        <pollVal1>0xFF</pollVal1>
        <pollVal2>0x00</pollVal2>
      </IspProgramFlash>
      <IspProgramEeprom>
        <mode>0x04</mode>
        <blockSize>128</blockSize>
        <delay>20</delay>
        <cmd1>0xC0</cmd1>
        <cmd2>0x00</cmd2>
        <cmd3>0xA0</cmd3>
        <pollVal1>0xFF</pollVal1>
        <pollVal2>0xFF</pollVal2>
      </IspProgramEeprom>
      <IspReadFlash>
        <blockSize>256</blockSize>
      </IspReadFlash>
      <IspReadEeprom>
        <blockSize>256</blockSize>
      </IspReadEeprom>
      <IspReadFuse>
        <pollIndex>4</pollIndex>
      </IspReadFuse>
      <IspReadLock>
        <pollIndex>4</pollIndex>
      </IspReadLock>
      <IspReadSign>
        <pollIndex>4</pollIndex>
      </IspReadSign>
      <IspReadOsccal>
        <pollIndex>4</pollIndex>
      </IspReadOsccal>
      <PPControlStack>0x0E 0x1E 0x0F 0x1F 0x2E 0x3E 0x2F 0x3F 0x4E 0x5E 0x4F 0x5F 0x6E 0x7E 0x6F 0x7F 0x66 0x76 0x67 0x77 0x6A 0x7A 0x6B 0x7B 0xBE 0xFD 0x00 0x01 0x00 0x00 0x00 0x00</PPControlStack>
      <PpEnterProgMode>
        <stabDelay>100</stabDelay>
        <progModeDelay>0</progModeDelay>
        <latchCycles>0</latchCycles>
        <toggleVtg>0</toggleVtg>
        <powerOffDelay>0</powerOffDelay>
        <resetDelayMs>0</resetDelayMs>
        <resetDelayUs>0</resetDelayUs>
      </PpEnterProgMode>
      <PpLeaveProgMode>
        <stabDelay>15</stabDelay>
        <resetDelay>15</resetDelay>
      </PpLeaveProgMode>
      <PpChipErase>
        <pulseWidth>0</pulseWidth>
        <pollTimeout>30</pollTimeout>
      </PpChipErase>
      <PpProgramFlash>
        <pollTimeout>15</pollTimeout>
        <mode>0x0F</mode>
        <blockSize>256</blockSize>
      </PpProgramFlash>
      <PpReadFlash>
        <blockSize>256</blockSize>
      </PpReadFlash>
      <PpProgramEeprom>
        <pollTimeout>5</pollTimeout>
        <mode>0x00</mode>
        <blockSize>256</blockSize>
      </PpProgramEeprom>
      <PpReadEeprom>
        <blockSize>256</blockSize>
      </PpReadEeprom>
      <PpProgramFuse>
        <pulseWidth>0</pulseWidth>
        <pollTimeout>2</pollTimeout>
      </PpProgramFuse>
      <PpProgramLock>
        <pulseWidth>0</pulseWidth>
        <pollTimeout>2</pollTimeout>
      </PpProgramLock>
    </STK500_2>
  </ICE_SETTINGS>
  <V2>
    <templates>
      <module class="FUSE">
        <registers name="FUSE" memspace="FUSE">
          <reg size="1" name="LOW" offset="0x00">
            <bitfield name="BOOTRST" mask="0x20" text="Boot Reset Vector Enabled" icon=""/>
            <bitfield name="SPIEN" mask="0x10" text="Serial program downloading (SPI) enabled" icon=""/>
            <bitfield name="SUT" mask="0x08" text="Start-up time" icon=""/>
            <bitfield name="CKSEL" mask="0x07" text="Select Clock Source" icon="" enum="ENUM_CKSEL"/>
          </reg>
        </registers>
        <enumerator name="ENUM_CKSEL">
          <enum val="0x00" text="Ext Clock; fast rising power" constname="EXTCLK_FASTPWR"/>
          <enum val="0x01" text="Ext Clock; BOD Enabled or power-on reset" constname="EXTCLK_BODEN_POR"/>
          <enum val="0x02" text="Crystal Osc; slowly rising power ; default value" constname="XOSC_SLOWPWR_DEFAULT"/>
          <enum val="0x03" text="Crystal Osc; fast rising power" constname="XOSC_FASTPWR"/>
          <enum val="0x04" text="Crystal Osc; BOD Enabled or power-on reset" constname="XOSC_BODEN_POR"/>
          <enum val="0x05" text="Ceramic Resonator / External Clock; Slowly rising power" constname="CRES_EXTCLK_SLOWPWR"/>
          <enum val="0x06" text="Ceramic Resonator; fast rising power" constname="CRES_FASTPWR"/>
          <enum val="0x07" text="Ceramic Resonator; BOD Enabled or power-on reset" constname="CRES_BODEN_POR"/>
        </enumerator>
      </module>
      <module class="LOCKBIT">
        <registers name="LOCKBIT" memspace="LOCKBIT">
          <reg size="1" name="LOCKBIT" offset="0x00">
            <bitfield name="LB" mask="0x03" text="Memory Lock" icon="" enum="ENUM_LB"/>
            <bitfield name="BLB0" mask="0x0C" text="Boot Loader Protection Mode" icon="" enum="ENUM_BLB"/>
            <bitfield name="BLB1" mask="0x30" text="Boot Loader Protection Mode" icon="" enum="ENUM_BLB2"/>
          </reg>
        </registers>
        <enumerator name="ENUM_LB">
          <enum val="0x00" text="Further programming and verification disabled" constname="PROG_VER_DISABLED"/>
          <enum val="0x02" text="Further programming disabled" constname="PROG_DISABLED"/>
          <enum val="0x03" text="No memory lock features enabled" constname="NO_LOCK"/>
        </enumerator>
        <enumerator name="ENUM_BLB">
          <enum val="0x00" text="LPM and SPM prohibited in Application Section" constname="LPM_SPM_DISABLE"/>
          <enum val="0x01" text="LPM prohibited in Application Section" constname="LPM_DISABLE"/>
          <enum val="0x02" text="SPM prohibited in Application Section" constname="SPM_DISABLE"/>
          <enum val="0x03" text="No lock on SPM and LPM in Application Section" constname="NO_LOCK"/>
        </enumerator>
        <enumerator name="ENUM_BLB2">
          <enum val="0x00" text="LPM and SPM prohibited in Boot Section" constname="LPM_SPM_DISABLE"/>
          <enum val="0x01" text="LPM prohibited in Boot Section" constname="LPM_DISABLE"/>
          <enum val="0x02" text="SPM prohibited in Boot Section" constname="SPM_DISABLE"/>
          <enum val="0x03" text="No lock on SPM and LPM in Boot Section" constname="NO_LOCK"/>
        </enumerator>
      </module>
      <module class="ANALOG_COMPARATOR" text="">
        <registers name="ANALOG_COMPARATOR" memspace="DATAMEM" text="" icon="io_analo.bmp">
          <reg size="1" name="ACSR" offset="0x28" text="Analog Comparator Control And Status Register" icon="io_analo.bmp">
            <bitfield name="ACD" mask="0x80" text="Analog Comparator Disable" icon=""/>
            <bitfield name="AINBG" mask="0x40" text="Analog Comparator Bandgap Select" icon=""/>
            <bitfield name="ACO" mask="0x20" text="Analog Compare Output" icon=""/>
            <bitfield name="ACI" mask="0x10" text="Analog Comparator Interrupt Flag" icon=""/>
            <bitfield name="ACIE" mask="0x08" text="Analog Comparator Interrupt Enable" icon=""/>
            <bitfield name="ACIC" mask="0x04" text="Analog Comparator Input Capture Enable" icon=""/>
            <bitfield name="ACIS" mask="0x03" text="Analog Comparator Interrupt Mode Select bits" icon="" enum="ANALOG_COMP_INTERRUPT"/>
          </reg>
        </registers>
        <enumerator name="ANALOG_COMP_INTERRUPT">
          <enum val="0x00" text="Interrupt on Toggle"/>
          <enum val="0x01" text="Reserved"/>
          <enum val="0x02" text="Interrupt on Falling Edge"/>
          <enum val="0x03" text="Interrupt on Rising Edge"/>
        </enumerator>
      </module>
      <module class="SPI" text="">
        <registers name="SPI" memspace="DATAMEM" text="" icon="io_com.bmp">
          <reg size="1" name="SPDR" offset="0x2F" text="SPI Data Register" icon="io_com.bmp" mask="0xFF"/>
          <reg size="1" name="SPSR" offset="0x2E" text="SPI Status Register" icon="io_flag.bmp">
            <bitfield name="SPIF" mask="0x80" text="SPI Interrupt Flag" icon=""/>
            <bitfield name="WCOL" mask="0x40" text="Write Collision Flag" icon=""/>
            <bitfield name="SPI2X" mask="0x01" text="Double SPI Speed Bit" icon=""/>
          </reg>
          <reg size="1" name="SPCR" offset="0x2D" text="SPI Control Register" icon="io_flag.bmp">
            <bitfield name="SPIE" mask="0x80" text="SPI Interrupt Enable" icon=""/>
            <bitfield name="SPE" mask="0x40" text="SPI Enable" icon=""/>
            <bitfield name="DORD" mask="0x20" text="Data Order" icon=""/>
            <bitfield name="MSTR" mask="0x10" text="Master/Slave Select" icon=""/>
            <bitfield name="CPOL" mask="0x08" text="Clock polarity" icon=""/>
            <bitfield name="CPHA" mask="0x04" text="Clock Phase" icon=""/>
            <bitfield name="SPR" mask="0x03" text="SPI Clock Rate Selects" icon="" enum="COMM_SCK_RATE_3BIT"/>
          </reg>
        </registers>
        <enumerator name="COMM_SCK_RATE_3BIT">
          <enum val="0x00" text="fosc/4"/>
          <enum val="0x01" text="fosc/16"/>
          <enum val="0x02" text="fosc/64"/>
          <enum val="0x03" text="fosc/128"/>
          <enum val="0x04" text="fosc/2"/>
          <enum val="0x05" text="fosc/8"/>
          <enum val="0x06" text="fosc/32"/>
          <enum val="0x07" text="fosc/64"/>
        </enumerator>
      </module>
      <module class="USART0" text="">
        <registers name="USART0" memspace="DATAMEM" text="" icon="io_com.bmp">
          <reg size="1" name="UDR0" offset="0x2C" text="USART I/O Data Register" icon="io_com.bmp" mask="0xFF"/>
          <reg size="1" name="UCSR0A" offset="0x2B" text="USART Control and Status Register A" icon="io_flag.bmp">
            <bitfield name="RXC0" mask="0x80" text="USART Receive Complete" icon=""/>
            <bitfield name="TXC0" mask="0x40" text="USART Transmitt Complete" icon=""/>
            <bitfield name="UDRE0" mask="0x20" text="USART Data Register Empty" icon=""/>
            <bitfield name="FE0" mask="0x10" text="Framing Error" icon=""/>
            <bitfield name="OR0" mask="0x08" text="Data overRun" icon=""/>
            <bitfield name="U2X0" mask="0x02" text="Double the USART transmission speed" icon=""/>
            <bitfield name="MPCM0" mask="0x01" text="Multi-processor Communication Mode" icon=""/>
          </reg>
          <reg size="1" name="UCSR0B" offset="0x2A" text="USART Control and Status Register B" icon="io_flag.bmp">
            <bitfield name="RXCIE0" mask="0x80" text="RX Complete Interrupt Enable" icon=""/>
            <bitfield name="TXCIE0" mask="0x40" text="TX Complete Interrupt Enable" icon=""/>
            <bitfield name="UDR0IE0" mask="0x20" text="USART Data register Empty Interrupt Enable" icon=""/>
            <bitfield name="RXEN0" mask="0x10" text="Receiver Enable" icon=""/>
            <bitfield name="TXEN0" mask="0x08" text="Transmitter Enable" icon=""/>
            <bitfield name="CHR90" mask="0x04" text="9-Bit Character" icon=""/>
            <bitfield name="RXB80" mask="0x02" text="Receive Data Bit 8" icon=""/>
            <bitfield name="TXB80" mask="0x01" text="Transmit Data Bit 8" icon=""/>
          </reg>
          <reg size="1" name="UBRR0" offset="0x29" text="USART Baud Rate Register Byte" icon="io_com.bmp" mask="0xFF"/>
          <reg size="1" name="UBRRHI" offset="0x40" text="High Byte Baud Rate Register" icon="io_com.bmp" mask="0x0F"/>
        </registers>
      </module>
      <module class="USART1" text="">
        <registers name="USART1" memspace="DATAMEM" text="" icon="io_com.bmp">
          <reg size="1" name="UDR1" offset="0x23" text="USART I/O Data Register" icon="io_com.bmp" mask="0xFF"/>
          <reg size="1" name="UCSR1A" offset="0x22" text="USART Control and Status Register A" icon="io_flag.bmp">
            <bitfield name="RXC1" mask="0x80" text="USART Receive Complete" icon=""/>
            <bitfield name="TXC1" mask="0x40" text="USART Transmitt Complete" icon=""/>
            <bitfield name="UDRE1" mask="0x20" text="USART Data Register Empty" icon=""/>
            <bitfield name="FE1" mask="0x10" text="Framing Error" icon=""/>
            <bitfield name="OR1" mask="0x08" text="Data overRun" icon=""/>
            <bitfield name="U2X1" mask="0x02" text="Double the USART transmission speed" icon=""/>
            <bitfield name="MPCM1" mask="0x01" text="Multi-processor Communication Mode" icon=""/>
          </reg>
          <reg size="1" name="UCSR1B" offset="0x21" text="USART Control and Status Register B" icon="io_flag.bmp">
            <bitfield name="RXCIE1" mask="0x80" text="RX Complete Interrupt Enable" icon=""/>
            <bitfield name="TXCIE1" mask="0x40" text="TX Complete Interrupt Enable" icon=""/>
            <bitfield name="UDR1IE1" mask="0x20" text="USART Data register Empty Interrupt Enable" icon=""/>
            <bitfield name="RXEN1" mask="0x10" text="Receiver Enable" icon=""/>
            <bitfield name="TXEN1" mask="0x08" text="Transmitter Enable" icon=""/>
            <bitfield name="CHR91" mask="0x04" text="9-Bit Character" icon=""/>
            <bitfield name="RXB81" mask="0x02" text="Receive Data Bit 8" icon=""/>
            <bitfield name="TXB81" mask="0x01" text="Transmit Data Bit 8" icon=""/>
          </reg>
          <reg size="1" name="UBRR1" offset="0x20" text="USART Baud Rate Register Byte" icon="io_com.bmp" mask="0xFF"/>
          <reg size="1" name="UBRRHI" offset="0x40" text="high Byte Baud Rate Register" icon="io_com.bmp" mask="0xF0"/>
        </registers>
      </module>
      <module class="PORTA" text="">
        <registers name="PORTA" memspace="DATAMEM" text="" icon="io_port.bmp">
          <reg size="1" name="PORTA" offset="0x3B" text="Port A Data Register" icon="io_port.bmp" mask="0xFF"/>
          <reg size="1" name="DDRA" offset="0x3A" text="Port A Data Direction Register" icon="io_flag.bmp" mask="0xFF"/>
          <reg size="1" name="PINA" offset="0x39" text="Port A Input Pins" icon="io_port.bmp" mask="0xFF"/>
        </registers>
      </module>
      <module class="PORTB" text="">
        <registers name="PORTB" memspace="DATAMEM" text="" icon="io_port.bmp">
          <reg size="1" name="PORTB" offset="0x38" text="Port B Data Register" icon="io_port.bmp" mask="0xFF"/>
          <reg size="1" name="DDRB" offset="0x37" text="Port B Data Direction Register" icon="io_flag.bmp" mask="0xFF"/>
          <reg size="1" name="PINB" offset="0x36" text="Port B Input Pins" icon="io_port.bmp" mask="0xFF"/>
        </registers>
      </module>
      <module class="PORTC" text="">
        <registers name="PORTC" memspace="DATAMEM" text="" icon="io_port.bmp">
          <reg size="1" name="PORTC" offset="0x35" text="Port C Data Register" icon="io_port.bmp" mask="0xFF"/>
          <reg size="1" name="DDRC" offset="0x34" text="Port C Data Direction Register" icon="io_flag.bmp" mask="0xFF"/>
          <reg size="1" name="PINC" offset="0x33" text="Port C Input Pins" icon="io_port.bmp" mask="0xFF"/>
        </registers>
      </module>
      <module class="PORTD" text="">
        <registers name="PORTD" memspace="DATAMEM" text="" icon="io_port.bmp">
          <reg size="1" name="PORTD" offset="0x32" text="Port D Data Register" icon="io_port.bmp" mask="0xFF"/>
          <reg size="1" name="DDRD" offset="0x31" text="Port D Data Direction Register" icon="io_flag.bmp" mask="0xFF"/>
          <reg size="1" name="PIND" offset="0x30" text="Port D Input Pins" icon="io_port.bmp" mask="0xFF"/>
        </registers>
      </module>
      <module class="PORTE" text="">
        <registers name="PORTE" memspace="DATAMEM" text="" icon="io_port.bmp">
          <reg size="1" name="PORTE" offset="0x27" text="Port E Data Register" icon="io_port.bmp" mask="0x07"/>
          <reg size="1" name="DDRE" offset="0x26" text="Port E Data Direction Register" icon="io_flag.bmp" mask="0x07"/>
          <reg size="1" name="PINE" offset="0x25" text="Port E Input Pins" icon="io_port.bmp" mask="0x07"/>
        </registers>
      </module>
      <module class="EEPROM" text="">
        <registers name="EEPROM" memspace="DATAMEM" text="" icon="io_cpu.bmp">
          <reg size="2" name="EEAR" offset="0x3E" text="EEPROM Address Register  Bytes" icon="io_cpu.bmp" mask="0x01FF"/>
          <reg size="1" name="EEDR" offset="0x3D" text="EEPROM Data Register" icon="io_cpu.bmp" mask="0xFF"/>
          <reg size="1" name="EECR" offset="0x3C" text="EEPROM Control Register" icon="io_flag.bmp">
            <bitfield name="EERIE" mask="0x08" text="EEPROM Ready Interrupt Enable" icon=""/>
            <bitfield name="EEMWE" mask="0x04" text="EEPROM Master Write Enable" icon=""/>
            <bitfield name="EEWE" mask="0x02" text="EEPROM Write Enable" icon=""/>
            <bitfield name="EERE" mask="0x01" text="EEPROM Read Enable" icon=""/>
          </reg>
        </registers>
      </module>
      <module class="EXTERNAL_INTERRUPT" text="">
        <registers name="EXTERNAL_INTERRUPT" memspace="DATAMEM" text="" icon="io_ext.bmp">
          <reg size="1" name="GIMSK" offset="0x5B" text="General Interrupt Mask Register" icon="io_flag.bmp">
            <bitfield name="INT" mask="0xC0" text="External Interrupt Request 1 Enable" icon=""/>
            <bitfield name="INT2" mask="0x20" text="External Interrupt Request 2 Enable" icon=""/>
          </reg>
          <reg size="1" name="GIFR" offset="0x5A" text="General Interrupt Flag Register" icon="io_flag.bmp">
            <bitfield name="INTF" mask="0xC0" text="External Interrupt Flags" icon=""/>
            <bitfield name="INTF2" mask="0x20" text="External Interrupt Flag 2" icon=""/>
          </reg>
        </registers>
      </module>
      <module class="CPU" text="">
        <registers name="CPU" memspace="DATAMEM" text="" icon="io_cpu.bmp">
          <reg size="1" name="SREG" offset="0x5F" text="Status Register" icon="io_sreg.bmp">
            <bitfield name="I" mask="0x80" text="Global Interrupt Enable" icon=""/>
            <bitfield name="T" mask="0x40" text="Bit Copy Storage" icon=""/>
            <bitfield name="H" mask="0x20" text="Half Carry Flag" icon=""/>
            <bitfield name="S" mask="0x10" text="Sign Bit" icon=""/>
            <bitfield name="V" mask="0x08" text="Two's Complement Overflow Flag" icon=""/>
            <bitfield name="N" mask="0x04" text="Negative Flag" icon=""/>
            <bitfield name="Z" mask="0x02" text="Zero Flag" icon=""/>
            <bitfield name="C" mask="0x01" text="Carry Flag" icon=""/>
          </reg>
          <reg size="2" name="SP" offset="0x5D" text="Stack Pointer " icon="io_sph.bmp" mask="0xFFFF"/>
          <reg size="1" name="MCUCR" offset="0x55" text="MCU Control Register" icon="io_flag.bmp">
            <bitfield name="SRE" mask="0x80" text="External SRAM Enable" icon=""/>
            <bitfield name="SRW10" mask="0x40" text="External SRAM Wait State Select" icon=""/>
            <bitfield name="SE" mask="0x20" text="Sleep Enable" icon=""/>
            <bitfield name="SM1" mask="0x10" text="Sleep Mode Select" icon=""/>
            <bitfield name="ISC1" mask="0x0C" text="Interrupt Sense Control 1 bits" icon=""/>
            <bitfield name="ISC0" mask="0x03" text="Interrupt Sense Control 0 bits" icon="" enum="INTERRUPT_SENSE_CONTROL2"/>
          </reg>
          <reg size="1" name="MCUSR" offset="0x54" text="MCU Status Register" icon="io_flag.bmp">
            <bitfield name="WDRF" mask="0x08" text="Watchdog Reset Flag" icon=""/>
            <bitfield name="BORF" mask="0x04" text="Brown-out Reset Flag" icon=""/>
            <bitfield name="EXTRF" mask="0x02" text="External Reset Flag" icon=""/>
            <bitfield name="PORF" mask="0x01" text="Power-on reset flag" icon=""/>
          </reg>
          <reg size="1" name="EMCUCR" offset="0x56" text="Extended MCU Control Register" icon="io_flag.bmp">
            <bitfield name="SM0" mask="0x80" text="Sleep mode Select Bit 0" icon=""/>
            <bitfield name="SRL" mask="0x70" text="Wait State Sector Limit Bits" icon="" enum="CPU_SECTOR_LIMITS"/>
            <bitfield name="SRW0" mask="0x0C" text="Wait State Select Bit 1 for Lower Sector" icon="" enum="CPU_WAIT_STATES"/>
            <bitfield name="SRW11" mask="0x02" text="Wait State Select Bit 1 for Upper Sector" icon=""/>
            <bitfield name="ISC2" mask="0x01" text="Interrupt Sense Control 2" icon=""/>
          </reg>
          <reg size="1" name="SPMCR" offset="0x57" text="Store Program Memory Control Register" icon="io_flag.bmp">
            <bitfield name="BLBSET" mask="0x08" text="Boot Lock Bit Set" icon=""/>
            <bitfield name="PGWRT" mask="0x04" text="Page Write" icon=""/>
            <bitfield name="PGERS" mask="0x02" text="Page Erase" icon=""/>
            <bitfield name="SPMEN" mask="0x01" text="Store Program Memory Enable" icon=""/>
          </reg>
        </registers>
        <enumerator name="INTERRUPT_SENSE_CONTROL2">
          <enum val="0x00" text="Low Level of INTX"/>
          <enum val="0x01" text="Any Logical Change in INTX"/>
          <enum val="0x02" text="Falling Edge of INTX"/>
          <enum val="0x03" text="Rising Edge of INTX"/>
        </enumerator>
        <enumerator name="CPU_SECTOR_LIMITS">
          <enum val="0x00" text="LS = N/A, US = 0x1100 - 0xFFFF"/>
          <enum val="0x01" text="LS = 0x1100 - 0x1FFF, US = 0x2000 - 0xFFFF"/>
          <enum val="0x02" text="LS = 0x1100 - 0x3FFF, US = 0x4000 - 0xFFFF"/>
          <enum val="0x03" text="LS = 0x1100 - 0x5FFF, US = 0x6000 - 0xFFFF"/>
          <enum val="0x04" text="LS = 0x1100 - 0x7FFF, US = 0x8000 - 0xFFFF"/>
          <enum val="0x05" text="LS = 0x1100 - 0x9FFF, US = 0xA000 - 0xFFFF"/>
          <enum val="0x06" text="LS = 0x1100 - 0xBFFF, US = 0xC000 - 0xFFFF"/>
          <enum val="0x07" text="LS = 0x1100 - 0xDFFF, US = 0xE000 - 0xFFFF"/>
        </enumerator>
        <enumerator name="CPU_WAIT_STATES">
          <enum val="0x00" text="No wait-states"/>
          <enum val="0x01" text="Wait one cycle during read/write strobe"/>
          <enum val="0x02" text="Wait two cycles during read/write strobe"/>
          <enum val="0x03" text="Wait two cycles during read/write and wait one cycle before driving out new address"/>
        </enumerator>
      </module>
      <module class="TIMER_COUNTER_0" text="">
        <registers name="TIMER_COUNTER_0" memspace="DATAMEM" text="" icon="io_timer.bmp">
          <reg size="1" name="TCCR0" offset="0x53" text="Timer/Counter Control Register" icon="io_flag.bmp">
            <bitfield name="FOC0" mask="0x80" text="Force Output Compare" icon=""/>
            <bitfield name="WGM00" mask="0x40" text="Waveform Generation Mode 0" icon=""/>
            <bitfield name="COM0" mask="0x30" text="Compare Match Output Modes" icon="" enum="CLK_COMP_MATCH_OUT_MODE"/>
            <bitfield name="WGM01" mask="0x08" text="Waveform Generation Mode 1" icon=""/>
            <bitfield name="CS0" mask="0x07" text="Clock Selects" icon="" enum="CLK_SEL_3BIT_EXT"/>
          </reg>
          <reg size="1" name="TCNT0" offset="0x52" text="Timer/Counter Register" icon="io_timer.bmp" mask="0xFF"/>
          <reg size="1" name="OCR0" offset="0x51" text="Output Compare Register" icon="io_timer.bmp" mask="0xFF"/>
          <reg size="1" name="TIMSK" offset="0x59" text="Timer/Counter Interrupt Mask Register" icon="io_flag.bmp">
            <bitfield name="TOIE0" mask="0x02" text="Timer/Counter0 Overflow Interrupt Enable" icon=""/>
            <bitfield name="OCIE0" mask="0x01" text="Timer/Counter0 Output Compare Match Interrupt register" icon=""/>
          </reg>
          <reg size="1" name="TIFR" offset="0x58" text="Timer/Counter Interrupt Flag register" icon="io_flag.bmp">
            <bitfield name="TOV0" mask="0x02" text="Timer/Counter0 Overflow Flag" icon=""/>
            <bitfield name="OCF0" mask="0x01" text="Output Compare Flag 0" icon=""/>
          </reg>
          <reg size="1" name="SFIOR" offset="0x50" text="Special Function IO Register" icon="io_cpu.bmp">
            <bitfield name="PSR10" mask="0x01" text="Prescaler Reset Timer/Counter1 and Timer/Counter0" icon=""/>
          </reg>
        </registers>
        <enumerator name="CLK_COMP_MATCH_OUT_MODE">
          <enum val="0x00" text="Disconnected from OCn/PWMn"/>
          <enum val="0x01" text="Toggle OCn/PWMn output line"/>
          <enum val="0x02" text="Clear OCn/PWMn output line"/>
          <enum val="0x03" text="set OCn/PWMn output line"/>
        </enumerator>
        <enumerator name="CLK_SEL_3BIT_EXT">
          <enum val="0x00" text="No Clock Source (Stopped)"/>
          <enum val="0x01" text="Running, No Prescaling"/>
          <enum val="0x02" text="Running, CLK/8"/>
          <enum val="0x03" text="Running, CLK/64"/>
          <enum val="0x04" text="Running, CLK/256"/>
          <enum val="0x05" text="Running, CLK/1024"/>
          <enum val="0x06" text="Running, ExtClk Tx Falling Edge"/>
          <enum val="0x07" text="Running, ExtClk Tx Rising Edge"/>
        </enumerator>
      </module>
      <module class="TIMER_COUNTER_2" text="">
        <registers name="TIMER_COUNTER_2" memspace="DATAMEM" text="" icon="io_timer.bmp">
          <reg size="1" name="TIMSK" offset="0x59" text="Timer/Counter Interrupt Mask register" icon="io_flag.bmp">
            <bitfield name="TOIE2" mask="0x10" text="Timer/Counter2 Overflow Interrupt Enable" icon=""/>
            <bitfield name="OCIE2" mask="0x04" text="Timer/Counter2 Output Compare Match Interrupt Enable" icon=""/>
          </reg>
          <reg size="1" name="TIFR" offset="0x58" text="Timer/Counter Interrupt Flag Register" icon="io_flag.bmp">
            <bitfield name="TOV2" mask="0x10" text="Timer/Counter2 Overflow Flag" icon=""/>
            <bitfield name="OCF2" mask="0x04" text="Output Compare Flag 2" icon=""/>
          </reg>
          <reg size="1" name="TCCR2" offset="0x47" text="Timer/Counter2 Control Register" icon="io_flag.bmp">
            <bitfield name="FOC2" mask="0x80" text="Force Output Compare" icon=""/>
            <bitfield name="PWM2" mask="0x40" text="Pulse Width Modulator Enable" icon=""/>
            <bitfield name="COM2" mask="0x30" text="Compare Output Mode bits" icon="" enum="CLK_COMP_MATCH_OUT_MODE"/>
            <bitfield name="CTC2" mask="0x08" text="Clear Timer/Counter2 on Compare Match" icon=""/>
            <bitfield name="CS2" mask="0x07" text="Clock Select bits" icon="" enum="CLK_SEL_3BIT"/>
          </reg>
          <reg size="1" name="TCNT2" offset="0x43" text="Timer/Counter2" icon="io_timer.bmp" mask="0xFF"/>
          <reg size="1" name="OCR2" offset="0x42" text="Timer/Counter2 Output Compare Register" icon="io_timer.bmp" mask="0xFF"/>
          <reg size="1" name="ASSR" offset="0x46" text="Asynchronous Status Register" icon="io_flag.bmp">
            <bitfield name="AS2" mask="0x08" text="Asynchronous Timer/counter2" icon=""/>
            <bitfield name="TCN2UB" mask="0x04" text="Timer/Counter2 Update Busy" icon=""/>
            <bitfield name="OCR2UB" mask="0x02" text="Output Compare Register2 Update Busy" icon=""/>
            <bitfield name="TCR2UB" mask="0x01" text="Timer/counter Control Register2 Update Busy" icon=""/>
          </reg>
          <reg size="1" name="SFIOR" offset="0x50" text="Specil Function IO Register" icon="io_cpu.bmp">
            <bitfield name="PSR2" mask="0x02" text="Prescaler Reset Timer/Counter2" icon=""/>
          </reg>
        </registers>
        <enumerator name="CLK_COMP_MATCH_OUT_MODE">
          <enum val="0x00" text="Disconnected from OCn/PWMn"/>
          <enum val="0x01" text="Toggle OCn/PWMn output line"/>
          <enum val="0x02" text="Clear OCn/PWMn output line"/>
          <enum val="0x03" text="set OCn/PWMn output line"/>
        </enumerator>
        <enumerator name="CLK_SEL_3BIT">
          <enum val="0x00" text="No Clock Source (Stopped)"/>
          <enum val="0x01" text="Running, No Prescaling"/>
          <enum val="0x02" text="Running, CLK/8"/>
          <enum val="0x03" text="Running, CLK/32"/>
          <enum val="0x04" text="Running, CLK/64"/>
          <enum val="0x05" text="Running, CLK/128"/>
          <enum val="0x06" text="Running, CLK/256"/>
          <enum val="0x07" text="Running, CLK/1024"/>
        </enumerator>
      </module>
      <module class="TIMER_COUNTER_1" text="">
        <registers name="TIMER_COUNTER_1" memspace="DATAMEM" text="" icon="io_timer.bmp">
          <reg size="1" name="TIMSK" offset="0x59" text="Timer/Counter Interrupt Mask Register" icon="io_flag.bmp">
            <bitfield name="TOIE1" mask="0x80" text="Timer/Counter1 Overflow Interrupt Enable" icon=""/>
            <bitfield name="OCIE1A" mask="0x40" text="Timer/Counter1 Output CompareA Match Interrupt Enable" icon=""/>
            <bitfield name="OCIE1B" mask="0x20" text="Timer/Counter1 Output CompareB Match Interrupt Enable" icon=""/>
            <bitfield name="TICIE1" mask="0x08" text="Timer/Counter1 Input Capture Interrupt Enable" icon=""/>
          </reg>
          <reg size="1" name="TIFR" offset="0x58" text="Timer/Counter Interrupt Flag register" icon="io_flag.bmp">
            <bitfield name="TOV1" mask="0x80" text="Timer/Counter1 Overflow Flag" icon=""/>
            <bitfield name="OCF1A" mask="0x40" text="Output Compare Flag 1A" icon=""/>
            <bitfield name="OCF1B" mask="0x20" text="Output Compare Flag 1B" icon=""/>
            <bitfield name="ICF1" mask="0x08" text="Input Capture Flag 1" icon=""/>
          </reg>
          <reg size="1" name="TCCR1A" offset="0x4F" text="Timer/Counter1 Control Register A" icon="io_flag.bmp">
            <bitfield name="COM1A" mask="0xC0" text="Compare Output Mode 1A, bits" icon="" enum="CLK_COMP_MATCH_OUT_MODE"/>
            <bitfield name="COM1B" mask="0x30" text="Compare Output Mode 1B, bits" icon="" enum="CLK_COMP_MATCH_OUT_MODE"/>
            <bitfield name="FOC1A" mask="0x08" text="Force Output Compare 1A" icon=""/>
            <bitfield name="FOC1B" mask="0x04" text="Force Output Compare 1B" icon=""/>
            <bitfield name="WGM1" mask="0x03" text="Waveform Generation Mode" icon=""/>
          </reg>
          <reg size="1" name="TCCR1B" offset="0x4E" text="Timer/Counter1 Control Register B" icon="io_flag.bmp">
            <bitfield name="ICNC1" mask="0x80" text="Input Capture 1 Noise Canceler" icon=""/>
            <bitfield name="ICES1" mask="0x40" text="Input Capture 1 Edge Select" icon=""/>
            <bitfield name="CTC1" mask="0x08" text="Clear Timer/Counter1 on Compare Match" icon=""/>
            <bitfield name="CS1" mask="0x07" text="Prescaler source of Timer/Counter 1" icon="" enum="CLK_SEL_3BIT_EXT"/>
          </reg>
          <reg size="2" name="TCNT1" offset="0x4C" text="Timer/Counter1  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="2" name="OCR1A" offset="0x4A" text="Timer/Counter1 Output Compare Register  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="2" name="OCR1B" offset="0x48" text="Timer/Counter1 Output Compare Register  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="2" name="ICR1" offset="0x44" text="Timer/Counter1 Input Capture Register  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
        </registers>
        <enumerator name="CLK_COMP_MATCH_OUT_MODE">
          <enum val="0x00" text="Disconnected from OCn/PWMn"/>
          <enum val="0x01" text="Toggle OCn/PWMn output line"/>
          <enum val="0x02" text="Clear OCn/PWMn output line"/>
          <enum val="0x03" text="set OCn/PWMn output line"/>
        </enumerator>
        <enumerator name="CLK_SEL_3BIT_EXT">
          <enum val="0x00" text="No Clock Source (Stopped)"/>
          <enum val="0x01" text="Running, No Prescaling"/>
          <enum val="0x02" text="Running, CLK/8"/>
          <enum val="0x03" text="Running, CLK/64"/>
          <enum val="0x04" text="Running, CLK/256"/>
          <enum val="0x05" text="Running, CLK/1024"/>
          <enum val="0x06" text="Running, ExtClk Tx Falling Edge"/>
          <enum val="0x07" text="Running, ExtClk Tx Rising Edge"/>
        </enumerator>
      </module>
      <module class="WATCHDOG" text="">
        <registers name="WATCHDOG" memspace="DATAMEM" text="" icon="io_watch.bmp">
          <reg size="1" name="WDTCR" offset="0x41" text="Watchdog Timer Control Register" icon="io_flag.bmp">
            <bitfield name="WDTOE" mask="0x10" text="RW" icon=""/>
            <bitfield name="WDE" mask="0x08" text="Watch Dog Enable" icon=""/>
            <bitfield name="WDP" mask="0x07" text="Watch Dog Timer Prescaler bits" icon="" enum="WDOG_TIMER_PRESCALE_3BITS"/>
          </reg>
        </registers>
        <enumerator name="WDOG_TIMER_PRESCALE_3BITS">
          <enum val="0x00" text="Oscillator Cycles 16K"/>
          <enum val="0x01" text="Oscillator Cycles 32K"/>
          <enum val="0x02" text="Oscillator Cycles 64K"/>
          <enum val="0x03" text="Oscillator Cycles 128K"/>
          <enum val="0x04" text="Oscillator Cycles 256K"/>
          <enum val="0x05" text="Oscillator Cycles 512K"/>
          <enum val="0x06" text="Oscillator Cycles 1024K"/>
          <enum val="0x07" text="Oscillator Cycles 2048K"/>
        </enumerator>
      </module>
    </templates>
    <modules>
      <module implements="ANALOG_COMPARATOR" name="ANALOG_COMPARATOR">
        <registers implements="ANALOG_COMPARATOR" name="ANALOG_COMPARATOR" offset="0x00" text=""/>
      </module>
      <module implements="SPI" name="SPI">
        <registers implements="SPI" name="SPI" offset="0x00" text=""/>
      </module>
      <module implements="USART0" name="USART0">
        <registers implements="USART0" name="USART0" offset="0x00" text=""/>
      </module>
      <module implements="USART1" name="USART1">
        <registers implements="USART1" name="USART1" offset="0x00" text=""/>
      </module>
      <module implements="PORTA" name="PORTA">
        <registers implements="PORTA" name="PORTA" offset="0x00" text=""/>
      </module>
      <module implements="PORTB" name="PORTB">
        <registers implements="PORTB" name="PORTB" offset="0x00" text=""/>
      </module>
      <module implements="PORTC" name="PORTC">
        <registers implements="PORTC" name="PORTC" offset="0x00" text=""/>
      </module>
      <module implements="PORTD" name="PORTD">
        <registers implements="PORTD" name="PORTD" offset="0x00" text=""/>
      </module>
      <module implements="PORTE" name="PORTE">
        <registers implements="PORTE" name="PORTE" offset="0x00" text=""/>
      </module>
      <module implements="EEPROM" name="EEPROM">
        <registers implements="EEPROM" name="EEPROM" offset="0x00" text=""/>
      </module>
      <module implements="EXTERNAL_INTERRUPT" name="EXTERNAL_INTERRUPT">
        <registers implements="EXTERNAL_INTERRUPT" name="EXTERNAL_INTERRUPT" offset="0x00" text=""/>
      </module>
      <module implements="CPU" name="CPU">
        <registers implements="CPU" name="CPU" offset="0x00" text=""/>
      </module>
      <module implements="TIMER_COUNTER_0" name="TIMER_COUNTER_0">
        <registers implements="TIMER_COUNTER_0" name="TIMER_COUNTER_0" offset="0x00" text=""/>
      </module>
      <module implements="TIMER_COUNTER_2" name="TIMER_COUNTER_2">
        <registers implements="TIMER_COUNTER_2" name="TIMER_COUNTER_2" offset="0x00" text=""/>
      </module>
      <module implements="TIMER_COUNTER_1" name="TIMER_COUNTER_1">
        <registers implements="TIMER_COUNTER_1" name="TIMER_COUNTER_1" offset="0x00" text=""/>
      </module>
      <module implements="WATCHDOG" name="WATCHDOG">
        <registers implements="WATCHDOG" name="WATCHDOG" offset="0x00" text=""/>
      </module>
    </modules>
    <fuses>
      <fuse implements="FUSE" name="FUSE">
        <registers implements="FUSE" name="FUSE"/>
      </fuse>
    </fuses>
    <lockbits>
      <lockbit implements="LOCKBIT" name="LOCKBIT">
        <registers implements="LOCKBIT" name="LOCKBIT"/>
      </lockbit>
    </lockbits>
  </V2>
</AVRPART>

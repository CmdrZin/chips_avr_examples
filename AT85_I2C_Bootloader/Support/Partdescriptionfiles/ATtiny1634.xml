<?xml version="1.0"?>
<AVRPART>
  <MODULE_LIST>[LOCKBIT:CORE:PROGRAMMING:MEMORY:FUSE:ADMIN:PACKAGE:INTERRUPT_VECTOR:IO_MODULE:ICE_SETTINGS]</MODULE_LIST>
  <LOCKBIT>
    <ICON/>
    <ID/>
    <TEXT>[LB1 = 1 :  LB2 = 1] No memory lock features enabled. [LB1 = 0 :  LB2 = 1] Further programming of Flash and EEPROM is enabled. [LB1 = 0 :  LB2 = 0] Same as previous, but verify is also disabled</TEXT>
    <NMB_TEXT>3</NMB_TEXT>
    <NMB_LOCK_BITS>2</NMB_LOCK_BITS>
    <TEXT1>
      <MASK>0x03</MASK>
      <VALUE>0x03</VALUE>
      <TEXT>Mode 1: No memory lock features enabled</TEXT>
    </TEXT1>
    <TEXT2>
      <MASK>0x03</MASK>
      <VALUE>0x02</VALUE>
      <TEXT>Mode 2: Further programming disabled</TEXT>
    </TEXT2>
    <TEXT3>
      <MASK>0x03</MASK>
      <VALUE>0x00</VALUE>
      <TEXT>Mode 3: Further programming and verification disabled</TEXT>
    </TEXT3>
    <LOCKBIT0>
      <NAME>LB1</NAME>
      <TEXT>Lockbit</TEXT>
    </LOCKBIT0>
    <LOCKBIT1>
      <NAME>LB2</NAME>
      <TEXT>Lockbit</TEXT>
    </LOCKBIT1>
  </LOCKBIT>
  <CORE>
    <CORE_VERSION>V2</CORE_VERSION>
    <ID>AVRSimCoreV2.SimCoreV2</ID>
    <NEW_INSTRUCTIONS>[lpm rd,z+]</NEW_INSTRUCTIONS>
    <INSTRUCTIONS_NOT_SUPPORTED>[]</INSTRUCTIONS_NOT_SUPPORTED>
    <RAMP_REGISTERS>[]</RAMP_REGISTERS>
    <GP_REG_FILE>
      <NMB_REG>32</NMB_REG>
      <START_ADDR>$00</START_ADDR>
      <X_REG_HIGH>$1B</X_REG_HIGH>
      <X_REG_LOW>$1A</X_REG_LOW>
      <Y_REG_HIGH>$1D</Y_REG_HIGH>
      <Y_REG_LOW>$1C</Y_REG_LOW>
      <Z_REG_HIGH>$1F</Z_REG_HIGH>
      <Z_REG_LOW>$1E</Z_REG_LOW>
    </GP_REG_FILE>
  </CORE>
  <PROGRAMMING>
    <ISPInterface>
      <FuseReadMask>0xff,0xdf,0xff</FuseReadMask>
      <FuseProgMask>0xff,0xdf,0xff</FuseProgMask>
      <FuseWarning>1,0x20,0x20,WARNING! These fuse settings will disable the ISP interface!</FuseWarning>
      <FuseWarning>1,0x80,0x00,WARNING! Disabling external reset will make the ISP interface inaccessible!</FuseWarning>
      <FuseWarning>1,0x40,0x00,WARNING! Enabling DEBUGWIRE will make the ISP interface inaccessible!</FuseWarning>
      <FuseWarning>0,0x0F,0x04,WARNING! Using this clock option will require a slow ISP speed!</FuseWarning>
    </ISPInterface>
    <HVInterface>
      <FuseWarning>1,0x20,0x20,WARNING! These fuse settings will disable the ISP interface!</FuseWarning>
      <FuseWarning>1,0x80,0x00,WARNING! Disabling external reset will make the ISP interface inaccessible!</FuseWarning>
      <FuseWarning>1,0x40,0x00,WARNING! Enabling DEBUGWIRE will make the ISP interface inaccessible!</FuseWarning>
      <FuseWarning>0,0x0F,0x04,WARNING! Using this clock option will require a slow ISP speed!</FuseWarning>
    </HVInterface>
    <OscCal>
      <OCEntry>0x00,8.0 MHz</OCEntry>
    </OscCal>
    <FlashPageSize>32</FlashPageSize>
    <EepromPageSize>4</EepromPageSize>
  </PROGRAMMING>
  <MEMORY>
    <ID>AVRSimMemory8bit.SimMemory8bit</ID>
    <PROG_FLASH>16384</PROG_FLASH>
    <EEPROM>256</EEPROM>
    <INT_SRAM>
      <SIZE>1024</SIZE>
      <START_ADDR>$100</START_ADDR>
    </INT_SRAM>
    <EXT_SRAM>
      <SIZE>0</SIZE>
      <START_ADDR>NA</START_ADDR>
    </EXT_SRAM>
    <IO_MEMORY>
      <IO_START_ADDR>$00</IO_START_ADDR>
      <IO_STOP_ADDR>$3F</IO_STOP_ADDR>
      <EXT_IO_START_ADDR>$60</EXT_IO_START_ADDR>
      <EXT_IO_STOP_ADDR>$FF</EXT_IO_STOP_ADDR>
      <MEM_START_ADDR>$20</MEM_START_ADDR>
      <MEM_STOP_ADDR>$FF</MEM_STOP_ADDR>
      <TWSCRA>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x7F</MEM_ADDR>
        <TWSME_MASK>0x01</TWSME_MASK>
        <TWPME_MASK>0x02</TWPME_MASK>
        <TWSIE_MASK>0x04</TWSIE_MASK>
        <TWEN_MASK>0x08</TWEN_MASK>
        <TWASIE_MASK>0x10</TWASIE_MASK>
        <TWDIE_MASK>0x20</TWDIE_MASK>
      </TWSCRA>
      <TWSCRB>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x7E</MEM_ADDR>
        <TWCMD0_MASK>0x01</TWCMD0_MASK>
        <TWCMD1_MASK>0x02</TWCMD1_MASK>
        <TWAA_MASK>0x04</TWAA_MASK>
      </TWSCRB>
      <TWSSRA>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x7D</MEM_ADDR>
        <TWAS_MASK>0x01</TWAS_MASK>
        <TWDIR_MASK>0x02</TWDIR_MASK>
        <TWBE_MASK>0x04</TWBE_MASK>
        <TWC_MASK>0x08</TWC_MASK>
        <TWRA_MASK>0x10</TWRA_MASK>
        <TWCH_MASK>0x20</TWCH_MASK>
        <TWASIF_MASK>0x40</TWASIF_MASK>
        <TWDIF_MASK>0x80</TWDIF_MASK>
      </TWSSRA>
      <TWSA>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x7C</MEM_ADDR>
        <TWSA0_MASK>0x01</TWSA0_MASK>
        <TWSA1_MASK>0x02</TWSA1_MASK>
        <TWSA2_MASK>0x04</TWSA2_MASK>
        <TWSA3_MASK>0x08</TWSA3_MASK>
        <TWSA4_MASK>0x10</TWSA4_MASK>
        <TWSA5_MASK>0x20</TWSA5_MASK>
        <TWSA6_MASK>0x40</TWSA6_MASK>
        <TWSA7_MASK>0x80</TWSA7_MASK>
      </TWSA>
      <TWSAM>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x7B</MEM_ADDR>
        <TWAE_MASK>0x01</TWAE_MASK>
        <TWSAM1_MASK>0x02</TWSAM1_MASK>
        <TWSAM2_MASK>0x04</TWSAM2_MASK>
        <TWSAM3_MASK>0x08</TWSAM3_MASK>
        <TWSAM4_MASK>0x10</TWSAM4_MASK>
        <TWSAM5_MASK>0x20</TWSAM5_MASK>
        <TWSAM6_MASK>0x40</TWSAM6_MASK>
        <TWSAM7_MASK>0x80</TWSAM7_MASK>
      </TWSAM>
      <TWSD>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x7A</MEM_ADDR>
        <TWSD0_MASK>0x01</TWSD0_MASK>
        <TWSD1_MASK>0x02</TWSD1_MASK>
        <TWSD2_MASK>0x04</TWSD2_MASK>
        <TWSD3_MASK>0x08</TWSD3_MASK>
        <TWSD4_MASK>0x10</TWSD4_MASK>
        <TWSD5_MASK>0x20</TWSD5_MASK>
        <TWSD6_MASK>0x40</TWSD6_MASK>
        <TWSD7_MASK>0x80</TWSD7_MASK>
      </TWSD>
      <UCSR1A>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x79</MEM_ADDR>
        <MPCM1_MASK>0x01</MPCM1_MASK>
        <U2X1_MASK>0x02</U2X1_MASK>
        <UPE1_MASK>0x04</UPE1_MASK>
        <DOR1_MASK>0x08</DOR1_MASK>
        <FE1_MASK>0x10</FE1_MASK>
        <UDRE1_MASK>0x20</UDRE1_MASK>
        <TXC1_MASK>0x40</TXC1_MASK>
        <RXC1_MASK>0x80</RXC1_MASK>
      </UCSR1A>
      <UCSR1B>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x78</MEM_ADDR>
        <TXB81_MASK>0x01</TXB81_MASK>
        <RXB81_MASK>0x02</RXB81_MASK>
        <UCSZ12_MASK>0x04</UCSZ12_MASK>
        <TXEN1_MASK>0x08</TXEN1_MASK>
        <RXEN1_MASK>0x10</RXEN1_MASK>
        <UDRIE1_MASK>0x20</UDRIE1_MASK>
        <TXCIE1_MASK>0x40</TXCIE1_MASK>
        <RXCIE1_MASK>0x80</RXCIE1_MASK>
      </UCSR1B>
      <UCSR1C>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x77</MEM_ADDR>
        <UCPOL1_MASK>0x01</UCPOL1_MASK>
        <UCSZ10_MASK>0x02</UCSZ10_MASK>
        <UCSZ11_MASK>0x04</UCSZ11_MASK>
        <USBS1_MASK>0x08</USBS1_MASK>
        <UPM10_MASK>0x10</UPM10_MASK>
        <UPM11_MASK>0x20</UPM11_MASK>
        <UMSEL10_MASK>0x40</UMSEL10_MASK>
        <UMSEL11_MASK>0x80</UMSEL11_MASK>
      </UCSR1C>
      <UCSR1D>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x76</MEM_ADDR>
        <SFDE1_MASK>0x20</SFDE1_MASK>
        <RXS1_MASK>0x40</RXS1_MASK>
        <RXSIE1_MASK>0x80</RXSIE1_MASK>
      </UCSR1D>
      <UBRR1H>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x75</MEM_ADDR>
        <UBRR_8_MASK>0x01</UBRR_8_MASK>
        <UBRR_9_MASK>0x02</UBRR_9_MASK>
        <UBRR_10_MASK>0x04</UBRR_10_MASK>
        <UBRR_11_MASK>0x08</UBRR_11_MASK>
      </UBRR1H>
      <UBRR1L>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x74</MEM_ADDR>
        <UBRR_0_MASK>0x01</UBRR_0_MASK>
        <UBRR_1_MASK>0x02</UBRR_1_MASK>
        <UBRR_2_MASK>0x04</UBRR_2_MASK>
        <UBRR_3_MASK>0x08</UBRR_3_MASK>
        <UBRR_4_MASK>0x10</UBRR_4_MASK>
        <UBRR_5_MASK>0x20</UBRR_5_MASK>
        <UBRR_6_MASK>0x40</UBRR_6_MASK>
        <UBRR_7_MASK>0x80</UBRR_7_MASK>
      </UBRR1L>
      <UDR1>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x73</MEM_ADDR>
        <UDR1_0_MASK>0x01</UDR1_0_MASK>
        <UDR1_1_MASK>0x02</UDR1_1_MASK>
        <UDR1_2_MASK>0x04</UDR1_2_MASK>
        <UDR1_3_MASK>0x08</UDR1_3_MASK>
        <UDR1_4_MASK>0x10</UDR1_4_MASK>
        <UDR1_5_MASK>0x20</UDR1_5_MASK>
        <UDR1_6_MASK>0x40</UDR1_6_MASK>
        <UDR1_7_MASK>0x80</UDR1_7_MASK>
      </UDR1>
      <TCCR1A>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x72</MEM_ADDR>
        <WGM10_MASK>0x01</WGM10_MASK>
        <WGM11_MASK>0x02</WGM11_MASK>
        <COM1B0_MASK>0x10</COM1B0_MASK>
        <COM1B1_MASK>0x20</COM1B1_MASK>
        <COM1A0_MASK>0x40</COM1A0_MASK>
        <COM1A1_MASK>0x80</COM1A1_MASK>
      </TCCR1A>
      <TCCR1B>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x71</MEM_ADDR>
        <CS10_MASK>0x01</CS10_MASK>
        <CS11_MASK>0x02</CS11_MASK>
        <CS12_MASK>0x04</CS12_MASK>
        <WGM12_MASK>0x08</WGM12_MASK>
        <WGM13_MASK>0x10</WGM13_MASK>
        <ICES1_MASK>0x40</ICES1_MASK>
        <ICNC1_MASK>0x80</ICNC1_MASK>
      </TCCR1B>
      <TCCR1C>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x70</MEM_ADDR>
        <FOC1B_MASK>0x40</FOC1B_MASK>
        <FOC1A_MASK>0x80</FOC1A_MASK>
      </TCCR1C>
      <TCNT1H>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x6F</MEM_ADDR>
        <TCNT1H0_MASK>0x01</TCNT1H0_MASK>
        <TCNT1H1_MASK>0x02</TCNT1H1_MASK>
        <TCNT1H2_MASK>0x04</TCNT1H2_MASK>
        <TCNT1H3_MASK>0x08</TCNT1H3_MASK>
        <TCNT1H4_MASK>0x10</TCNT1H4_MASK>
        <TCNT1H5_MASK>0x20</TCNT1H5_MASK>
        <TCNT1H6_MASK>0x40</TCNT1H6_MASK>
        <TCNT1H7_MASK>0x80</TCNT1H7_MASK>
      </TCNT1H>
      <TCNT1L>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x6E</MEM_ADDR>
        <TCNT1L0_MASK>0x01</TCNT1L0_MASK>
        <TCNT1L1_MASK>0x02</TCNT1L1_MASK>
        <TCNT1L2_MASK>0x04</TCNT1L2_MASK>
        <TCNT1L3_MASK>0x08</TCNT1L3_MASK>
        <TCNT1L4_MASK>0x10</TCNT1L4_MASK>
        <TCNT1L5_MASK>0x20</TCNT1L5_MASK>
        <TCNT1L6_MASK>0x40</TCNT1L6_MASK>
        <TCNT1L7_MASK>0x80</TCNT1L7_MASK>
      </TCNT1L>
      <OCR1AH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x6D</MEM_ADDR>
        <OCR1AH0_MASK>0x01</OCR1AH0_MASK>
        <OCR1AH1_MASK>0x02</OCR1AH1_MASK>
        <OCR1AH2_MASK>0x04</OCR1AH2_MASK>
        <OCR1AH3_MASK>0x08</OCR1AH3_MASK>
        <OCR1AH4_MASK>0x10</OCR1AH4_MASK>
        <OCR1AH5_MASK>0x20</OCR1AH5_MASK>
        <OCR1AH6_MASK>0x40</OCR1AH6_MASK>
        <OCR1AH7_MASK>0x80</OCR1AH7_MASK>
      </OCR1AH>
      <OCR1AL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x6C</MEM_ADDR>
        <OCR1AL0_MASK>0x01</OCR1AL0_MASK>
        <OCR1AL1_MASK>0x02</OCR1AL1_MASK>
        <OCR1AL2_MASK>0x04</OCR1AL2_MASK>
        <OCR1AL3_MASK>0x08</OCR1AL3_MASK>
        <OCR1AL4_MASK>0x10</OCR1AL4_MASK>
        <OCR1AL5_MASK>0x20</OCR1AL5_MASK>
        <OCR1AL6_MASK>0x40</OCR1AL6_MASK>
        <OCR1AL7_MASK>0x80</OCR1AL7_MASK>
      </OCR1AL>
      <OCR1BH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x6B</MEM_ADDR>
        <OCR1BH0_MASK>0x01</OCR1BH0_MASK>
        <OCR1BH1_MASK>0x02</OCR1BH1_MASK>
        <OCR1BH2_MASK>0x04</OCR1BH2_MASK>
        <OCR1BH3_MASK>0x08</OCR1BH3_MASK>
        <OCR1BH4_MASK>0x10</OCR1BH4_MASK>
        <OCR1BH5_MASK>0x20</OCR1BH5_MASK>
        <OCR1BH6_MASK>0x40</OCR1BH6_MASK>
        <OCR1BH7_MASK>0x80</OCR1BH7_MASK>
      </OCR1BH>
      <OCR1BL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x6A</MEM_ADDR>
        <OCR1BL0_MASK>0x01</OCR1BL0_MASK>
        <OCR1BL1_MASK>0x02</OCR1BL1_MASK>
        <OCR1BL2_MASK>0x04</OCR1BL2_MASK>
        <OCR1BL3_MASK>0x08</OCR1BL3_MASK>
        <OCR1BL4_MASK>0x10</OCR1BL4_MASK>
        <OCR1BL5_MASK>0x20</OCR1BL5_MASK>
        <OCR1BL6_MASK>0x40</OCR1BL6_MASK>
        <OCR1BL7_MASK>0x80</OCR1BL7_MASK>
      </OCR1BL>
      <ICR1H>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x69</MEM_ADDR>
        <ICR1H0_MASK>0x01</ICR1H0_MASK>
        <ICR1H1_MASK>0x02</ICR1H1_MASK>
        <ICR1H2_MASK>0x04</ICR1H2_MASK>
        <ICR1H3_MASK>0x08</ICR1H3_MASK>
        <ICR1H4_MASK>0x10</ICR1H4_MASK>
        <ICR1H5_MASK>0x20</ICR1H5_MASK>
        <ICR1H6_MASK>0x40</ICR1H6_MASK>
        <ICR1H7_MASK>0x80</ICR1H7_MASK>
      </ICR1H>
      <ICR1L>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x68</MEM_ADDR>
        <ICR1L0_MASK>0x01</ICR1L0_MASK>
        <ICR1L1_MASK>0x02</ICR1L1_MASK>
        <ICR1L2_MASK>0x04</ICR1L2_MASK>
        <ICR1L3_MASK>0x08</ICR1L3_MASK>
        <ICR1L4_MASK>0x10</ICR1L4_MASK>
        <ICR1L5_MASK>0x20</ICR1L5_MASK>
        <ICR1L6_MASK>0x40</ICR1L6_MASK>
        <ICR1L7_MASK>0x80</ICR1L7_MASK>
      </ICR1L>
      <GTCCR>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x67</MEM_ADDR>
      </GTCCR>
      <OSCCAL1>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x66</MEM_ADDR>
        <CAL10_MASK>0x01</CAL10_MASK>
        <CAL11_MASK>0x02</CAL11_MASK>
      </OSCCAL1>
      <OSCTCAL0B>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x65</MEM_ADDR>
        <TCAL0B0_MASK>0x01</TCAL0B0_MASK>
        <TCAL0B1_MASK>0x02</TCAL0B1_MASK>
        <TCAL0B2_MASK>0x04</TCAL0B2_MASK>
        <TCAL0B3_MASK>0x08</TCAL0B3_MASK>
        <TCAL0B4_MASK>0x10</TCAL0B4_MASK>
        <TCAL0B5_MASK>0x20</TCAL0B5_MASK>
        <TCAL0B6_MASK>0x40</TCAL0B6_MASK>
        <TCAL0B7_MASK>0x80</TCAL0B7_MASK>
      </OSCTCAL0B>
      <OSCTCAL0A>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x64</MEM_ADDR>
        <TCAL0A0_MASK>0x01</TCAL0A0_MASK>
        <TCAL0A1_MASK>0x02</TCAL0A1_MASK>
        <TCAL0A2_MASK>0x04</TCAL0A2_MASK>
        <TCAL0A3_MASK>0x08</TCAL0A3_MASK>
        <TCAL0A4_MASK>0x10</TCAL0A4_MASK>
        <TCAL0A5_MASK>0x20</TCAL0A5_MASK>
        <TCAL0A6_MASK>0x40</TCAL0A6_MASK>
        <TCAL0A7_MASK>0x80</TCAL0A7_MASK>
      </OSCTCAL0A>
      <OSCCAL0>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x63</MEM_ADDR>
        <CAL00_MASK>0x01</CAL00_MASK>
        <CAL01_MASK>0x02</CAL01_MASK>
        <CAL02_MASK>0x04</CAL02_MASK>
        <CAL03_MASK>0x08</CAL03_MASK>
        <CAL04_MASK>0x10</CAL04_MASK>
        <CAL05_MASK>0x20</CAL05_MASK>
        <CAL06_MASK>0x40</CAL06_MASK>
        <CAL07_MASK>0x80</CAL07_MASK>
      </OSCCAL0>
      <DIDR2>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x62</MEM_ADDR>
        <ADC9D_MASK>0x01</ADC9D_MASK>
        <ADC10D_MASK>0x02</ADC10D_MASK>
        <ADC11D_MASK>0x04</ADC11D_MASK>
      </DIDR2>
      <DIDR1>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x61</MEM_ADDR>
        <ADC5D_MASK>0x01</ADC5D_MASK>
        <ADC6D_MASK>0x02</ADC6D_MASK>
        <ADC7D_MASK>0x04</ADC7D_MASK>
        <ADC8D_MASK>0x08</ADC8D_MASK>
      </DIDR1>
      <DIDR0>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x60</MEM_ADDR>
        <AREFD_MASK>0x01</AREFD_MASK>
        <AIN0D_MASK>0x02</AIN0D_MASK>
        <AIN1D_MASK>0x04</AIN1D_MASK>
        <ADC0D_MASK>0x08</ADC0D_MASK>
        <ADC1D_MASK>0x10</ADC1D_MASK>
        <ADC2D_MASK>0x20</ADC2D_MASK>
        <ADC3D_MASK>0x40</ADC3D_MASK>
        <ADC4D_MASK>0x80</ADC4D_MASK>
      </DIDR0>
      <SREG>
        <IO_ADDR>0x3F</IO_ADDR>
        <MEM_ADDR>0x5F</MEM_ADDR>
        <C_MASK>0x01</C_MASK>
        <Z_MASK>0x02</Z_MASK>
        <N_MASK>0x04</N_MASK>
        <V_MASK>0x08</V_MASK>
        <S_MASK>0x10</S_MASK>
        <H_MASK>0x20</H_MASK>
        <T_MASK>0x40</T_MASK>
        <I_MASK>0x80</I_MASK>
      </SREG>
      <SPH>
        <IO_ADDR>0x3E</IO_ADDR>
        <MEM_ADDR>0x5E</MEM_ADDR>
        <INIT>0x02</INIT>
        <SP8_MASK>0x01</SP8_MASK>
        <SP9_MASK>0x02</SP9_MASK>
        <SP10_MASK>0x04</SP10_MASK>
      </SPH>
      <SPL>
        <IO_ADDR>0x3D</IO_ADDR>
        <MEM_ADDR>0x5D</MEM_ADDR>
        <INIT>0xFF</INIT>
        <SP0_MASK>0x01</SP0_MASK>
        <SP1_MASK>0x02</SP1_MASK>
        <SP2_MASK>0x04</SP2_MASK>
        <SP3_MASK>0x08</SP3_MASK>
        <SP4_MASK>0x10</SP4_MASK>
        <SP5_MASK>0x20</SP5_MASK>
        <SP6_MASK>0x40</SP6_MASK>
        <SP7_MASK>0x80</SP7_MASK>
      </SPL>
      <GIMSK>
        <IO_ADDR>0x3C</IO_ADDR>
        <MEM_ADDR>0x5C</MEM_ADDR>
        <PCIE0_MASK>0x08</PCIE0_MASK>
        <PCIE1_MASK>0x10</PCIE1_MASK>
        <PCIE2_MASK>0x20</PCIE2_MASK>
        <INT0_MASK>0x40</INT0_MASK>
      </GIMSK>
      <GIFR>
        <IO_ADDR>0x3B</IO_ADDR>
        <MEM_ADDR>0x5B</MEM_ADDR>
        <PCIF0_MASK>0x08</PCIF0_MASK>
        <PCIF1_MASK>0x10</PCIF1_MASK>
        <PCIF2_MASK>0x20</PCIF2_MASK>
        <INTF0_MASK>0x40</INTF0_MASK>
      </GIFR>
      <TIMSK>
        <IO_ADDR>0x3A</IO_ADDR>
        <MEM_ADDR>0x5A</MEM_ADDR>
        <ICIE1_MASK>0x08</ICIE1_MASK>
        <OCIE1B_MASK>0x20</OCIE1B_MASK>
        <OCIE1A_MASK>0x40</OCIE1A_MASK>
        <TOIE1_MASK>0x80</TOIE1_MASK>
        <OCIE0A_MASK>0x01</OCIE0A_MASK>
        <TOIE0_MASK>0x02</TOIE0_MASK>
        <OCIE0B_MASK>0x04</OCIE0B_MASK>
      </TIMSK>
      <TIFR>
        <IO_ADDR>0x39</IO_ADDR>
        <MEM_ADDR>0x59</MEM_ADDR>
        <ICF1_MASK>0x08</ICF1_MASK>
        <OCF1B_MASK>0x20</OCF1B_MASK>
        <OCF1A_MASK>0x40</OCF1A_MASK>
        <TOV1_MASK>0x80</TOV1_MASK>
        <OCF0A_MASK>0x01</OCF0A_MASK>
        <TOV0_MASK>0x02</TOV0_MASK>
        <OCF0B_MASK>0x04</OCF0B_MASK>
      </TIFR>
      <SPMCSR>
        <IO_ADDR>0x37</IO_ADDR>
        <MEM_ADDR>0x57</MEM_ADDR>
        <SPMEN_MASK>0x01</SPMEN_MASK>
        <PGERS_MASK>0x02</PGERS_MASK>
        <PGWRT_MASK>0x04</PGWRT_MASK>
        <RFLB_MASK>0x08</RFLB_MASK>
        <CTPB_MASK>0x10</CTPB_MASK>
        <RSIG_MASK>0x20</RSIG_MASK>
      </SPMCSR>
      <MCUCR>
        <IO_ADDR>0x36</IO_ADDR>
        <MEM_ADDR>0x56</MEM_ADDR>
        <ISC00_MASK>0x01</ISC00_MASK>
        <ISC01_MASK>0x02</ISC01_MASK>
        <SE_MASK>0x10</SE_MASK>
        <SM0_MASK>0x20</SM0_MASK>
        <SM1_MASK>0x40</SM1_MASK>
      </MCUCR>
      <MCUSR>
        <IO_ADDR>0x35</IO_ADDR>
        <MEM_ADDR>0x55</MEM_ADDR>
        <PORF_MASK>0x01</PORF_MASK>
        <EXTRF_MASK>0x02</EXTRF_MASK>
        <BORF_MASK>0x04</BORF_MASK>
        <WDRF_MASK>0x08</WDRF_MASK>
      </MCUSR>
      <PRR>
        <IO_ADDR>0x34</IO_ADDR>
        <MEM_ADDR>0x54</MEM_ADDR>
        <PRADC_MASK>0x01</PRADC_MASK>
        <PRUSART0_MASK>0x02</PRUSART0_MASK>
        <PRUSART1_MASK>0x04</PRUSART1_MASK>
        <PRUSI_MASK>0x08</PRUSI_MASK>
        <PRTIM0_MASK>0x10</PRTIM0_MASK>
        <PRTIM1_MASK>0x20</PRTIM1_MASK>
        <PRTWI_MASK>0x40</PRTWI_MASK>
      </PRR>
      <CLKPR>
        <IO_ADDR>0x33</IO_ADDR>
        <MEM_ADDR>0x53</MEM_ADDR>
        <CLKPS0_MASK>0x01</CLKPS0_MASK>
        <CLKPS1_MASK>0x02</CLKPS1_MASK>
        <CLKPS2_MASK>0x04</CLKPS2_MASK>
        <CLKPS3_MASK>0x08</CLKPS3_MASK>
      </CLKPR>
      <CLKSR>
        <IO_ADDR>0x32</IO_ADDR>
        <MEM_ADDR>0x52</MEM_ADDR>
        <CKSEL0_MASK>0x01</CKSEL0_MASK>
        <CKSEL1_MASK>0x02</CKSEL1_MASK>
        <CKSEL2_MASK>0x04</CKSEL2_MASK>
        <CKSEL3_MASK>0x08</CKSEL3_MASK>
        <SUT_MASK>0x10</SUT_MASK>
        <CKOUT_IO_MASK>0x20</CKOUT_IO_MASK>
        <CSTR_MASK>0x40</CSTR_MASK>
        <OSCRDY_MASK>0x80</OSCRDY_MASK>
      </CLKSR>
      <WDTCSR>
        <IO_ADDR>0x30</IO_ADDR>
        <MEM_ADDR>0x50</MEM_ADDR>
        <WDP0_MASK>0x01</WDP0_MASK>
        <WDP1_MASK>0x02</WDP1_MASK>
        <WDP2_MASK>0x04</WDP2_MASK>
        <WDE_MASK>0x08</WDE_MASK>
        <WDP3_MASK>0x20</WDP3_MASK>
        <WDIE_MASK>0x40</WDIE_MASK>
        <WDIF_MASK>0x80</WDIF_MASK>
      </WDTCSR>
      <CCP>
        <IO_ADDR>0x2F</IO_ADDR>
        <MEM_ADDR>0x4F</MEM_ADDR>
        <CCP0_MASK>0x01</CCP0_MASK>
        <CCP1_MASK>0x02</CCP1_MASK>
        <CCP2_MASK>0x04</CCP2_MASK>
        <CCP3_MASK>0x08</CCP3_MASK>
        <CCP4_MASK>0x10</CCP4_MASK>
        <CCP5_MASK>0x20</CCP5_MASK>
        <CCP6_MASK>0x40</CCP6_MASK>
        <CCP7_MASK>0x80</CCP7_MASK>
      </CCP>
      <USISR>
        <IO_ADDR>0x2B</IO_ADDR>
        <MEM_ADDR>0x4B</MEM_ADDR>
        <USICNT0_MASK>0x01</USICNT0_MASK>
        <USICNT1_MASK>0x02</USICNT1_MASK>
        <USICNT2_MASK>0x04</USICNT2_MASK>
        <USICNT3_MASK>0x08</USICNT3_MASK>
        <USIDC_MASK>0x10</USIDC_MASK>
        <USIPF_MASK>0x20</USIPF_MASK>
        <USIOIF_MASK>0x40</USIOIF_MASK>
        <USISIF_MASK>0x80</USISIF_MASK>
      </USISR>
      <USICR>
        <IO_ADDR>0x2A</IO_ADDR>
        <MEM_ADDR>0x4A</MEM_ADDR>
        <USITC_MASK>0x01</USITC_MASK>
        <USICLK_MASK>0x02</USICLK_MASK>
        <USICS0_MASK>0x04</USICS0_MASK>
        <USICS1_MASK>0x08</USICS1_MASK>
        <USIWM0_MASK>0x10</USIWM0_MASK>
        <USIWM1_MASK>0x20</USIWM1_MASK>
        <USIOIE_MASK>0x40</USIOIE_MASK>
        <USISIE_MASK>0x80</USISIE_MASK>
      </USICR>
      <USIDR>
        <IO_ADDR>0x2C</IO_ADDR>
        <MEM_ADDR>0x4C</MEM_ADDR>
        <USIDR0_MASK>0x01</USIDR0_MASK>
        <USIDR1_MASK>0x02</USIDR1_MASK>
        <USIDR2_MASK>0x04</USIDR2_MASK>
        <USIDR3_MASK>0x08</USIDR3_MASK>
        <USIDR4_MASK>0x10</USIDR4_MASK>
        <USIDR5_MASK>0x20</USIDR5_MASK>
        <USIDR6_MASK>0x40</USIDR6_MASK>
        <USIDR7_MASK>0x80</USIDR7_MASK>
      </USIDR>
      <USIBR>
        <IO_ADDR>0x2D</IO_ADDR>
        <MEM_ADDR>0x4D</MEM_ADDR>
        <USIBR0_MASK>0x01</USIBR0_MASK>
        <USIBR1_MASK>0x02</USIBR1_MASK>
        <USIBR2_MASK>0x04</USIBR2_MASK>
        <USIBR3_MASK>0x08</USIBR3_MASK>
        <USIBR4_MASK>0x10</USIBR4_MASK>
        <USIBR5_MASK>0x20</USIBR5_MASK>
        <USIBR6_MASK>0x40</USIBR6_MASK>
        <USIBR7_MASK>0x80</USIBR7_MASK>
      </USIBR>
      <PCMSK2>
        <IO_ADDR>0x29</IO_ADDR>
        <MEM_ADDR>0x49</MEM_ADDR>
        <PCINT12_MASK>0x01</PCINT12_MASK>
        <PCINT13_MASK>0x02</PCINT13_MASK>
        <PCINT14_MASK>0x04</PCINT14_MASK>
        <PCINT15_MASK>0x08</PCINT15_MASK>
        <PCINT16_MASK>0x10</PCINT16_MASK>
        <PCINT17_MASK>0x20</PCINT17_MASK>
      </PCMSK2>
      <PCMSK1>
        <IO_ADDR>0x28</IO_ADDR>
        <MEM_ADDR>0x48</MEM_ADDR>
        <PCINT8_MASK>0x01</PCINT8_MASK>
        <PCINT9_MASK>0x02</PCINT9_MASK>
        <PCINT10_MASK>0x04</PCINT10_MASK>
        <PCINT11_MASK>0x08</PCINT11_MASK>
      </PCMSK1>
      <PCMSK0>
        <IO_ADDR>0x27</IO_ADDR>
        <MEM_ADDR>0x47</MEM_ADDR>
        <PCINT0_MASK>0x01</PCINT0_MASK>
        <PCINT1_MASK>0x02</PCINT1_MASK>
        <PCINT2_MASK>0x04</PCINT2_MASK>
        <PCINT3_MASK>0x08</PCINT3_MASK>
        <PCINT4_MASK>0x10</PCINT4_MASK>
        <PCINT5_MASK>0x20</PCINT5_MASK>
        <PCINT6_MASK>0x40</PCINT6_MASK>
        <PCINT7_MASK>0x80</PCINT7_MASK>
      </PCMSK0>
      <UCSR0A>
        <IO_ADDR>0x26</IO_ADDR>
        <MEM_ADDR>0x46</MEM_ADDR>
        <MPCM0_MASK>0x01</MPCM0_MASK>
        <U2X0_MASK>0x02</U2X0_MASK>
        <UPE0_MASK>0x04</UPE0_MASK>
        <DOR0_MASK>0x08</DOR0_MASK>
        <FE0_MASK>0x10</FE0_MASK>
        <UDRE0_MASK>0x20</UDRE0_MASK>
        <TXC0_MASK>0x40</TXC0_MASK>
        <RXC0_MASK>0x80</RXC0_MASK>
      </UCSR0A>
      <UCSR0B>
        <IO_ADDR>0x25</IO_ADDR>
        <MEM_ADDR>0x45</MEM_ADDR>
        <TXB80_MASK>0x01</TXB80_MASK>
        <RXB80_MASK>0x02</RXB80_MASK>
        <UCSZ02_MASK>0x04</UCSZ02_MASK>
        <TXEN0_MASK>0x08</TXEN0_MASK>
        <RXEN0_MASK>0x10</RXEN0_MASK>
        <UDRIE0_MASK>0x20</UDRIE0_MASK>
        <TXCIE0_MASK>0x40</TXCIE0_MASK>
        <RXCIE0_MASK>0x80</RXCIE0_MASK>
      </UCSR0B>
      <UCSR0C>
        <IO_ADDR>0x24</IO_ADDR>
        <MEM_ADDR>0x44</MEM_ADDR>
        <UCPOL0_MASK>0x01</UCPOL0_MASK>
        <UCSZ00_MASK>0x02</UCSZ00_MASK>
        <UCSZ01_MASK>0x04</UCSZ01_MASK>
        <USBS0_MASK>0x08</USBS0_MASK>
        <UPM00_MASK>0x10</UPM00_MASK>
        <UPM01_MASK>0x20</UPM01_MASK>
        <UMSEL00_MASK>0x40</UMSEL00_MASK>
        <UMSEL01_MASK>0x80</UMSEL01_MASK>
      </UCSR0C>
      <UCSR0D>
        <IO_ADDR>0x23</IO_ADDR>
        <MEM_ADDR>0x43</MEM_ADDR>
        <SFDE0_MASK>0x20</SFDE0_MASK>
        <RXS0_MASK>0x40</RXS0_MASK>
        <RXSIE0_MASK>0x80</RXSIE0_MASK>
      </UCSR0D>
      <UBRR0H>
        <IO_ADDR>0x22</IO_ADDR>
        <MEM_ADDR>0x42</MEM_ADDR>
        <UBRR8_MASK>0x01</UBRR8_MASK>
        <UBRR9_MASK>0x02</UBRR9_MASK>
        <UBRR10_MASK>0x04</UBRR10_MASK>
        <UBRR11_MASK>0x08</UBRR11_MASK>
      </UBRR0H>
      <UBRR0L>
        <IO_ADDR>0x21</IO_ADDR>
        <MEM_ADDR>0x41</MEM_ADDR>
        <_UBRR0_MASK>0x01</_UBRR0_MASK>
        <_UBRR1_MASK>0x02</_UBRR1_MASK>
        <UBRR2_MASK>0x04</UBRR2_MASK>
        <UBRR3_MASK>0x08</UBRR3_MASK>
        <UBRR4_MASK>0x10</UBRR4_MASK>
        <UBRR5_MASK>0x20</UBRR5_MASK>
        <UBRR6_MASK>0x40</UBRR6_MASK>
        <UBRR7_MASK>0x80</UBRR7_MASK>
      </UBRR0L>
      <UDR0>
        <IO_ADDR>0x20</IO_ADDR>
        <MEM_ADDR>0x40</MEM_ADDR>
        <UDR0_0_MASK>0x01</UDR0_0_MASK>
        <UDR0_1_MASK>0x02</UDR0_1_MASK>
        <UDR0_2_MASK>0x04</UDR0_2_MASK>
        <UDR0_3_MASK>0x08</UDR0_3_MASK>
        <UDR0_4_MASK>0x10</UDR0_4_MASK>
        <UDR0_5_MASK>0x20</UDR0_5_MASK>
        <UDR0_6_MASK>0x40</UDR0_6_MASK>
        <UDR0_7_MASK>0x80</UDR0_7_MASK>
      </UDR0>
      <EEAR>
        <IO_ADDR>0x1E</IO_ADDR>
        <MEM_ADDR>0x3E</MEM_ADDR>
        <EEAR0_MASK>0x01</EEAR0_MASK>
        <EEAR1_MASK>0x02</EEAR1_MASK>
        <EEAR2_MASK>0x04</EEAR2_MASK>
        <EEAR3_MASK>0x08</EEAR3_MASK>
        <EEAR4_MASK>0x10</EEAR4_MASK>
        <EEAR5_MASK>0x20</EEAR5_MASK>
        <EEAR6_MASK>0x40</EEAR6_MASK>
        <EEAR7_MASK>0x80</EEAR7_MASK>
      </EEAR>
      <EEDR>
        <IO_ADDR>0x1D</IO_ADDR>
        <MEM_ADDR>0x3D</MEM_ADDR>
        <EEDR0_MASK>0x01</EEDR0_MASK>
        <EEDR1_MASK>0x02</EEDR1_MASK>
        <EEDR2_MASK>0x04</EEDR2_MASK>
        <EEDR3_MASK>0x08</EEDR3_MASK>
        <EEDR4_MASK>0x10</EEDR4_MASK>
        <EEDR5_MASK>0x20</EEDR5_MASK>
        <EEDR6_MASK>0x40</EEDR6_MASK>
        <EEDR7_MASK>0x80</EEDR7_MASK>
      </EEDR>
      <EECR>
        <IO_ADDR>0x1C</IO_ADDR>
        <MEM_ADDR>0x3C</MEM_ADDR>
        <EERE_MASK>0x01</EERE_MASK>
        <EEPE_MASK>0x02</EEPE_MASK>
        <EEMPE_MASK>0x04</EEMPE_MASK>
        <EERIE_MASK>0x08</EERIE_MASK>
        <EEPM0_MASK>0x10</EEPM0_MASK>
        <EEPM1_MASK>0x20</EEPM1_MASK>
      </EECR>
      <TCCR0A>
        <IO_ADDR>0x1B</IO_ADDR>
        <MEM_ADDR>0x3B</MEM_ADDR>
        <WGM00_MASK>0x01</WGM00_MASK>
        <WGM01_MASK>0x02</WGM01_MASK>
        <COM0B0_MASK>0x10</COM0B0_MASK>
        <COM0B1_MASK>0x20</COM0B1_MASK>
        <COM0A0_MASK>0x40</COM0A0_MASK>
        <COM0A1_MASK>0x80</COM0A1_MASK>
      </TCCR0A>
      <TCCR0B>
        <IO_ADDR>0x1A</IO_ADDR>
        <MEM_ADDR>0x3A</MEM_ADDR>
        <CS00_MASK>0x01</CS00_MASK>
        <CS01_MASK>0x02</CS01_MASK>
        <CS02_MASK>0x04</CS02_MASK>
        <WGM02_MASK>0x08</WGM02_MASK>
        <FOC0B_MASK>0x40</FOC0B_MASK>
        <FOC0A_MASK>0x80</FOC0A_MASK>
      </TCCR0B>
      <TCNT0>
        <IO_ADDR>0x19</IO_ADDR>
        <MEM_ADDR>0x39</MEM_ADDR>
        <TCNT0_0_MASK>0x01</TCNT0_0_MASK>
        <TCNT0_1_MASK>0x02</TCNT0_1_MASK>
        <TCNT0_2_MASK>0x04</TCNT0_2_MASK>
        <TCNT0_3_MASK>0x08</TCNT0_3_MASK>
        <TCNT0_4_MASK>0x10</TCNT0_4_MASK>
        <TCNT0_5_MASK>0x20</TCNT0_5_MASK>
        <TCNT0_6_MASK>0x40</TCNT0_6_MASK>
        <TCNT0_7_MASK>0x80</TCNT0_7_MASK>
      </TCNT0>
      <OCR0A>
        <IO_ADDR>0x18</IO_ADDR>
        <MEM_ADDR>0x38</MEM_ADDR>
        <OCR0A_0_MASK>0x01</OCR0A_0_MASK>
        <OCR0A_1_MASK>0x02</OCR0A_1_MASK>
        <OCR0A_2_MASK>0x04</OCR0A_2_MASK>
        <OCR0A_3_MASK>0x08</OCR0A_3_MASK>
        <OCR0A_4_MASK>0x10</OCR0A_4_MASK>
        <OCR0A_5_MASK>0x20</OCR0A_5_MASK>
        <OCR0A_6_MASK>0x40</OCR0A_6_MASK>
        <OCR0A_7_MASK>0x80</OCR0A_7_MASK>
      </OCR0A>
      <OCR0B>
        <IO_ADDR>0x17</IO_ADDR>
        <MEM_ADDR>0x37</MEM_ADDR>
        <OCR0_0_MASK>0x01</OCR0_0_MASK>
        <OCR0_1_MASK>0x02</OCR0_1_MASK>
        <OCR0_2_MASK>0x04</OCR0_2_MASK>
        <OCR0_3_MASK>0x08</OCR0_3_MASK>
        <OCR0_4_MASK>0x10</OCR0_4_MASK>
        <OCR0_5_MASK>0x20</OCR0_5_MASK>
        <OCR0_6_MASK>0x40</OCR0_6_MASK>
        <OCR0_7_MASK>0x80</OCR0_7_MASK>
      </OCR0B>
      <GPIOR2>
        <IO_ADDR>0x16</IO_ADDR>
        <MEM_ADDR>0x36</MEM_ADDR>
        <GPIOR20_MASK>0x01</GPIOR20_MASK>
        <GPIOR21_MASK>0x02</GPIOR21_MASK>
        <GPIOR22_MASK>0x04</GPIOR22_MASK>
        <GPIOR23_MASK>0x08</GPIOR23_MASK>
        <GPIOR24_MASK>0x10</GPIOR24_MASK>
        <GPIOR25_MASK>0x20</GPIOR25_MASK>
        <GPIOR26_MASK>0x40</GPIOR26_MASK>
        <GPIOR27_MASK>0x80</GPIOR27_MASK>
      </GPIOR2>
      <GPIOR1>
        <IO_ADDR>0x15</IO_ADDR>
        <MEM_ADDR>0x35</MEM_ADDR>
        <GPIOR10_MASK>0x01</GPIOR10_MASK>
        <GPIOR11_MASK>0x02</GPIOR11_MASK>
        <GPIOR12_MASK>0x04</GPIOR12_MASK>
        <GPIOR13_MASK>0x08</GPIOR13_MASK>
        <GPIOR14_MASK>0x10</GPIOR14_MASK>
        <GPIOR15_MASK>0x20</GPIOR15_MASK>
        <GPIOR16_MASK>0x40</GPIOR16_MASK>
        <GPIOR17_MASK>0x80</GPIOR17_MASK>
      </GPIOR1>
      <GPIOR0>
        <IO_ADDR>0x14</IO_ADDR>
        <MEM_ADDR>0x35</MEM_ADDR>
        <GPIOR00_MASK>0x01</GPIOR00_MASK>
        <GPIOR01_MASK>0x02</GPIOR01_MASK>
        <GPIOR02_MASK>0x04</GPIOR02_MASK>
        <GPIOR03_MASK>0x08</GPIOR03_MASK>
        <GPIOR04_MASK>0x10</GPIOR04_MASK>
        <GPIOR05_MASK>0x20</GPIOR05_MASK>
        <GPIOR06_MASK>0x40</GPIOR06_MASK>
        <GPIOR07_MASK>0x80</GPIOR07_MASK>
      </GPIOR0>
      <PORTCR>
        <IO_ADDR>0x13</IO_ADDR>
        <MEM_ADDR>0x33</MEM_ADDR>
        <BBMB_MASK>0x02</BBMB_MASK>
        <BBMC_MASK>0x04</BBMC_MASK>
        <BBMA_MASK>0x01</BBMA_MASK>
      </PORTCR>
      <PUEA>
        <IO_ADDR>0x12</IO_ADDR>
        <MEM_ADDR>0x32</MEM_ADDR>
        <PUEA0_MASK>0x01</PUEA0_MASK>
        <PUEA1_MASK>0x02</PUEA1_MASK>
        <PUEA2_MASK>0x04</PUEA2_MASK>
        <PUEA3_MASK>0x08</PUEA3_MASK>
        <PUEA4_MASK>0x10</PUEA4_MASK>
        <PUEA5_MASK>0x20</PUEA5_MASK>
        <PUEA6_MASK>0x40</PUEA6_MASK>
        <PUEA7_MASK>0x80</PUEA7_MASK>
      </PUEA>
      <PORTA>
        <IO_ADDR>0x11</IO_ADDR>
        <MEM_ADDR>0x31</MEM_ADDR>
        <PORTA0_MASK>0x01</PORTA0_MASK>
        <PORTA1_MASK>0x02</PORTA1_MASK>
        <PORTA2_MASK>0x04</PORTA2_MASK>
        <PORTA3_MASK>0x08</PORTA3_MASK>
        <PORTA4_MASK>0x10</PORTA4_MASK>
        <PORTA5_MASK>0x20</PORTA5_MASK>
        <PORTA6_MASK>0x40</PORTA6_MASK>
        <PORTA7_MASK>0x80</PORTA7_MASK>
      </PORTA>
      <DDRA>
        <IO_ADDR>0x10</IO_ADDR>
        <MEM_ADDR>0x30</MEM_ADDR>
        <DDA0_MASK>0x01</DDA0_MASK>
        <DDA1_MASK>0x02</DDA1_MASK>
        <DDA2_MASK>0x04</DDA2_MASK>
        <DDA3_MASK>0x08</DDA3_MASK>
        <DDA4_MASK>0x10</DDA4_MASK>
        <DDA5_MASK>0x20</DDA5_MASK>
        <DDA6_MASK>0x40</DDA6_MASK>
        <DDA7_MASK>0x80</DDA7_MASK>
      </DDRA>
      <PINA>
        <IO_ADDR>0x0F</IO_ADDR>
        <MEM_ADDR>0x2F</MEM_ADDR>
        <PINA0_MASK>0x01</PINA0_MASK>
        <PINA1_MASK>0x02</PINA1_MASK>
        <PINA2_MASK>0x04</PINA2_MASK>
        <PINA3_MASK>0x08</PINA3_MASK>
        <PINA4_MASK>0x10</PINA4_MASK>
        <PINA5_MASK>0x20</PINA5_MASK>
        <PINA6_MASK>0x40</PINA6_MASK>
        <PINA7_MASK>0x80</PINA7_MASK>
      </PINA>
      <PUEB>
        <IO_ADDR>0x0E</IO_ADDR>
        <MEM_ADDR>0x2E</MEM_ADDR>
        <PUEB0_MASK>0x01</PUEB0_MASK>
        <PUEB1_MASK>0x02</PUEB1_MASK>
        <PUEB2_MASK>0x04</PUEB2_MASK>
        <PUEB3_MASK>0x08</PUEB3_MASK>
      </PUEB>
      <PORTB>
        <IO_ADDR>0x0D</IO_ADDR>
        <MEM_ADDR>0x2D</MEM_ADDR>
        <PORTB0_MASK>0x01</PORTB0_MASK>
        <PORTB1_MASK>0x02</PORTB1_MASK>
        <PORTB2_MASK>0x04</PORTB2_MASK>
        <PORTB3_MASK>0x08</PORTB3_MASK>
      </PORTB>
      <DDRB>
        <IO_ADDR>0x0C</IO_ADDR>
        <MEM_ADDR>0x2C</MEM_ADDR>
        <DDB0_MASK>0x01</DDB0_MASK>
        <DDB1_MASK>0x02</DDB1_MASK>
        <DDB2_MASK>0x04</DDB2_MASK>
        <DDB3_MASK>0x08</DDB3_MASK>
      </DDRB>
      <PINB>
        <IO_ADDR>0x0B</IO_ADDR>
        <MEM_ADDR>0x2B</MEM_ADDR>
        <PINB0_MASK>0x01</PINB0_MASK>
        <PINB1_MASK>0x02</PINB1_MASK>
        <PINB2_MASK>0x04</PINB2_MASK>
        <PINB3_MASK>0x08</PINB3_MASK>
      </PINB>
      <PUEC>
        <IO_ADDR>0x0A</IO_ADDR>
        <MEM_ADDR>0x2A</MEM_ADDR>
        <PUEC0_MASK>0x01</PUEC0_MASK>
        <PUEC1_MASK>0x02</PUEC1_MASK>
        <PUEC2_MASK>0x04</PUEC2_MASK>
        <PUEC3_MASK>0x08</PUEC3_MASK>
        <PUEC4_MASK>0x10</PUEC4_MASK>
        <PUEC5_MASK>0x20</PUEC5_MASK>
      </PUEC>
      <PORTC>
        <IO_ADDR>0x09</IO_ADDR>
        <MEM_ADDR>0x29</MEM_ADDR>
        <PORTC0_MASK>0x01</PORTC0_MASK>
        <PORTC1_MASK>0x02</PORTC1_MASK>
        <PORTC2_MASK>0x04</PORTC2_MASK>
        <PORTC3_MASK>0x08</PORTC3_MASK>
        <PORTC4_MASK>0x10</PORTC4_MASK>
        <PORTC5_MASK>0x20</PORTC5_MASK>
      </PORTC>
      <DDRC>
        <IO_ADDR>0x08</IO_ADDR>
        <MEM_ADDR>0x28</MEM_ADDR>
        <DDC0_MASK>0x01</DDC0_MASK>
        <DDC1_MASK>0x02</DDC1_MASK>
        <DDC2_MASK>0x04</DDC2_MASK>
        <DDC3_MASK>0x08</DDC3_MASK>
        <DDC4_MASK>0x10</DDC4_MASK>
        <DDC5_MASK>0x20</DDC5_MASK>
      </DDRC>
      <PINC>
        <IO_ADDR>0x07</IO_ADDR>
        <MEM_ADDR>0x27</MEM_ADDR>
        <PINC0_MASK>0x01</PINC0_MASK>
        <PINC1_MASK>0x02</PINC1_MASK>
        <PINC2_MASK>0x04</PINC2_MASK>
        <PINC3_MASK>0x08</PINC3_MASK>
        <PINC4_MASK>0x10</PINC4_MASK>
        <PINC5_MASK>0x20</PINC5_MASK>
      </PINC>
      <ACSRA>
        <IO_ADDR>0x06</IO_ADDR>
        <MEM_ADDR>0x26</MEM_ADDR>
        <ACIS0_MASK>0x01</ACIS0_MASK>
        <ACIS1_MASK>0x02</ACIS1_MASK>
        <ACIC_MASK>0x04</ACIC_MASK>
        <ACIE_MASK>0x08</ACIE_MASK>
        <ACI_MASK>0x10</ACI_MASK>
        <ACO_MASK>0x20</ACO_MASK>
        <ACBG_MASK>0x40</ACBG_MASK>
        <ACD_MASK>0x80</ACD_MASK>
      </ACSRA>
      <ACSRB>
        <IO_ADDR>0x05</IO_ADDR>
        <MEM_ADDR>0x25</MEM_ADDR>
        <ACME_MASK>0x04</ACME_MASK>
        <HLEV_MASK>0x40</HLEV_MASK>
        <HSEL_MASK>0x80</HSEL_MASK>
      </ACSRB>
      <ADMUX>
        <IO_ADDR>0x04</IO_ADDR>
        <MEM_ADDR>0x24</MEM_ADDR>
        <MUX0_MASK>0x01</MUX0_MASK>
        <MUX1_MASK>0x02</MUX1_MASK>
        <MUX2_MASK>0x04</MUX2_MASK>
        <MUX3_MASK>0x08</MUX3_MASK>
        <REFS0_MASK>0x40</REFS0_MASK>
        <REFS1_MASK>0x80</REFS1_MASK>
      </ADMUX>
      <ADCSRA>
        <IO_ADDR>0x03</IO_ADDR>
        <MEM_ADDR>0x23</MEM_ADDR>
        <ADPS0_MASK>0x01</ADPS0_MASK>
        <ADPS1_MASK>0x02</ADPS1_MASK>
        <ADPS2_MASK>0x04</ADPS2_MASK>
        <ADIE_MASK>0x08</ADIE_MASK>
        <ADIF_MASK>0x10</ADIF_MASK>
        <ADATE_MASK>0x20</ADATE_MASK>
        <ADSC_MASK>0x40</ADSC_MASK>
        <ADEN_MASK>0x80</ADEN_MASK>
      </ADCSRA>
      <ADCSRB>
        <IO_ADDR>0x02</IO_ADDR>
        <MEM_ADDR>0x22</MEM_ADDR>
        <ADTS0_MASK>0x01</ADTS0_MASK>
        <ADTS1_MASK>0x02</ADTS1_MASK>
        <ADTS2_MASK>0x04</ADTS2_MASK>
        <ADLAR_MASK>0x08</ADLAR_MASK>
      </ADCSRB>
      <ADCH>
        <IO_ADDR>0x01</IO_ADDR>
        <MEM_ADDR>0x21</MEM_ADDR>
        <ADCH0_MASK>0x01</ADCH0_MASK>
        <ADCH1_MASK>0x02</ADCH1_MASK>
        <ADCH2_MASK>0x04</ADCH2_MASK>
        <ADCH3_MASK>0x08</ADCH3_MASK>
        <ADCH4_MASK>0x10</ADCH4_MASK>
        <ADCH5_MASK>0x20</ADCH5_MASK>
        <ADCH6_MASK>0x40</ADCH6_MASK>
        <ADCH7_MASK>0x80</ADCH7_MASK>
      </ADCH>
      <ADCL>
        <IO_ADDR>0x00</IO_ADDR>
        <MEM_ADDR>0x20</MEM_ADDR>
        <ADCL0_MASK>0x01</ADCL0_MASK>
        <ADCL1_MASK>0x02</ADCL1_MASK>
        <ADCL2_MASK>0x04</ADCL2_MASK>
        <ADCL3_MASK>0x08</ADCL3_MASK>
        <ADCL4_MASK>0x10</ADCL4_MASK>
        <ADCL5_MASK>0x20</ADCL5_MASK>
        <ADCL6_MASK>0x40</ADCL6_MASK>
        <ADCL7_MASK>0x80</ADCL7_MASK>
      </ADCL>
    </IO_MEMORY>
    <BOOT_CONFIG>
      <NRWW_START_ADDR>$0</NRWW_START_ADDR>
      <NRWW_STOP_ADDR>$1FFF</NRWW_STOP_ADDR>
      <RWW_START_ADDR>$0</RWW_START_ADDR>
      <RWW_STOP_ADDR>$0</RWW_STOP_ADDR>
      <PAGESIZE>16</PAGESIZE>
    </BOOT_CONFIG>
  </MEMORY>
  <FUSE>
    <LIST>[LOW:HIGH:EXTENDED]</LIST>
    <ID/>
    <ICON/>
    <TEXT/>
    <LOW>
      <NMB_FUSE_BITS>7</NMB_FUSE_BITS>
      <FUSE7>
        <NAME>CKDIV8</NAME>
        <TEXT>Divide clock by 8</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE7>
      <FUSE6>
        <NAME>CKOUT</NAME>
        <TEXT>Clock output</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE6>
      <FUSE4>
        <NAME>SUT</NAME>
        <TEXT>Select start-up time</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE4>
      <FUSE3>
        <NAME>CKSEL3</NAME>
        <TEXT>Select Clock Source</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE3>
      <FUSE2>
        <NAME>CKSEL2</NAME>
        <TEXT>Select Clock Source</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE2>
      <FUSE1>
        <NAME>CKSEL1</NAME>
        <TEXT>Select Clock Source</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE1>
      <FUSE0>
        <NAME>CKSEL0</NAME>
        <TEXT>Select Clock Source</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE0>
      <NMB_TEXT>17</NMB_TEXT>
      <TEXT1>
        <MASK>0x80</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Divide clock by 8 internally; [CKDIV8=0]</TEXT>
      </TEXT1>
      <TEXT2>
        <MASK>0x40</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Clock output on PORTC2; [CKOUT=0]</TEXT>
      </TEXT2>
      <TEXT3>
        <MASK>0x0F</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Ext. Clock; Start-up time PWRDWN/RESET: 6 CK/16 CK + 16 ms;   [CKSEL=0000]</TEXT>
      </TEXT3>
      <TEXT4>
        <MASK>0x0F</MASK>
        <VALUE>0x02</VALUE>
        <TEXT>Int. RC Osc. 8 MHz; Start-up time PWRDWN/RESET: 6 CK/16 CK + 16 ms;   [CKSEL=0010]</TEXT>
      </TEXT4>
      <TEXT5>
        <MASK>0x0F</MASK>
        <VALUE>0x04</VALUE>
        <TEXT>Int. ULP Osc. 32kHz; Start-up time PWRDWN/RESET: 6 CK/16 CK + 16 ms;   [CKSEL=0100]</TEXT>
      </TEXT5>
      <TEXT6>
        <MASK>0x1F</MASK>
        <VALUE>0x08</VALUE>
        <TEXT>Ext. Ceramic Res.; Frequency 0.4-0.9 MHz; Start-up time PWRDWN/RESET: 258 CK/16 CK + 16 ms; [CKSEL=1000 SUT=0]</TEXT>
      </TEXT6>
      <TEXT7>
        <MASK>0x1F</MASK>
        <VALUE>0x18</VALUE>
        <TEXT>Ext. Ceramic Res.; Frequency 0.4-0.9 MHz; Start-up time PWRDWN/RESET: 1K CK/16 CK + 16 ms; [CKSEL=1000 SUT=1]</TEXT>
      </TEXT7>
      <TEXT8>
        <MASK>0x1F</MASK>
        <VALUE>0x09</VALUE>
        <TEXT>Ext. Crystal Osc.; Frequency 0.4-0.9 MHz; Start-up time PWRDWN/RESET: 16K CK/16 CK + 16 ms; [CKSEL=1001 SUT=0]</TEXT>
      </TEXT8>
      <TEXT9>
        <MASK>0x1F</MASK>
        <VALUE>0x0A</VALUE>
        <TEXT>Ext. Ceramic Res.; Frequency 0.9-3.0 MHz; Start-up time PWRDWN/RESET: 258 CK/16 CK + 16 ms; [CKSEL=1010 SUT=0]</TEXT>
      </TEXT9>
      <TEXT10>
        <MASK>0x1F</MASK>
        <VALUE>0x1A</VALUE>
        <TEXT>Ext. Ceramic Res.; Frequency 0.9-3.0 MHz; Start-up time PWRDWN/RESET: 1K CK/16 CK + 16 ms; [CKSEL=1010 SUT=1]</TEXT>
      </TEXT10>
      <TEXT11>
        <MASK>0x1F</MASK>
        <VALUE>0x0B</VALUE>
        <TEXT>Ext. Crystal Osc.; Frequency 0.9-3.0 MHz; Start-up time PWRDWN/RESET: 16K CK/16 CK + 16 ms; [CKSEL=1011 SUT=0]</TEXT>
      </TEXT11>
      <TEXT12>
        <MASK>0x1F</MASK>
        <VALUE>0x0C</VALUE>
        <TEXT>Ext. Ceramic Res.; Frequency 3.0-8.0 MHz; Start-up time PWRDWN/RESET: 258 CK/16 CK + 16 ms; [CKSEL=1100 SUT=0]</TEXT>
      </TEXT12>
      <TEXT13>
        <MASK>0x1F</MASK>
        <VALUE>0x1C</VALUE>
        <TEXT>Ext. Ceramic Res.; Frequency 3.0-8.0 MHz; Start-up time PWRDWN/RESET: 1K CK/16 CK + 16 ms; [CKSEL=1100 SUT=1]</TEXT>
      </TEXT13>
      <TEXT14>
        <MASK>0x1F</MASK>
        <VALUE>0x0D</VALUE>
        <TEXT>Ext. Crystal Osc.; Frequency 3.0-8.0 MHz; Start-up time PWRDWN/RESET: 16K CK/16 CK + 16 ms; [CKSEL=1101 SUT=0]</TEXT>
      </TEXT14>
      <TEXT15>
        <MASK>0x1F</MASK>
        <VALUE>0x0E</VALUE>
        <TEXT>Ext. Ceramic Res.; Frequency 8.0- MHz; Start-up time PWRDWN/RESET: 258 CK/16 CK + 16 ms; [CKSEL=1110 SUT=0]</TEXT>
      </TEXT15>
      <TEXT16>
        <MASK>0x1F</MASK>
        <VALUE>0x1E</VALUE>
        <TEXT>Ext. Ceramic Res.; Frequency 8.0- MHz; Start-up time PWRDWN/RESET: 1K CK/16 CK + 16 ms; [CKSEL=1110 SUT=1]</TEXT>
      </TEXT16>
      <TEXT17>
        <MASK>0x1F</MASK>
        <VALUE>0x0F</VALUE>
        <TEXT>Ext. Crystal Osc.; Frequency 8.0- MHz; Start-up time PWRDWN/RESET: 16K CK/16 CK + 16 ms; [CKSEL=1111 SUT=0]</TEXT>
      </TEXT17>
    </LOW>
    <HIGH>
      <NMB_FUSE_BITS>8</NMB_FUSE_BITS>
      <FUSE7>
        <NAME>RSTDISBL</NAME>
        <TEXT>External reset disable</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE7>
      <FUSE6>
        <NAME>DWEN</NAME>
        <TEXT>debugWIRE Enable</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE6>
      <FUSE5>
        <NAME>SPIEN</NAME>
        <TEXT>Enable Serial programming and Data Downloading</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE5>
      <FUSE4>
        <NAME>WDTON</NAME>
        <TEXT>Watchdog Timer Always On</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE4>
      <FUSE3>
        <NAME>EESAVE</NAME>
        <TEXT>EEPROM memory is preserved through chip erase</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE3>
      <FUSE2>
        <NAME>BODLEVEL2</NAME>
        <TEXT>Brown-out Detector trigger level</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE2>
      <FUSE1>
        <NAME>BODLEVEL1</NAME>
        <TEXT>Brown-out Detector trigger level</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE1>
      <FUSE0>
        <NAME>BODLEVEL0</NAME>
        <TEXT>Brown-out Detector trigger level</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE0>
      <NMB_TEXT>9</NMB_TEXT>
      <TEXT1>
        <MASK>0x80</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Reset Disabled (Enable PC3 as i/o pin); [RSTDISBL=0]</TEXT>
      </TEXT1>
      <TEXT2>
        <MASK>0x40</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Debug Wire enable; [DWEN=0]</TEXT>
      </TEXT2>
      <TEXT3>
        <MASK>0x20</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Serial program downloading (SPI) enabled; [SPIEN=0]</TEXT>
      </TEXT3>
      <TEXT4>
        <MASK>0x10</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Watch-dog Timer always on; [WDTON=0]</TEXT>
      </TEXT4>
      <TEXT5>
        <MASK>0x08</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Preserve EEPROM memory through the Chip Erase cycle; [EESAVE=0]</TEXT>
      </TEXT5>
      <TEXT6>
        <MASK>0x07</MASK>
        <VALUE>0x04</VALUE>
        <TEXT>Brown-out detection level at VCC=4.3 V; [BODLEVEL=100] </TEXT>
      </TEXT6>
      <TEXT7>
        <MASK>0x07</MASK>
        <VALUE>0x05</VALUE>
        <TEXT>Brown-out detection level at VCC=2.7 V; [BODLEVEL=101] </TEXT>
      </TEXT7>
      <TEXT8>
        <MASK>0x07</MASK>
        <VALUE>0x06</VALUE>
        <TEXT>Brown-out detection level at VCC=1.8 V; [BODLEVEL=110] </TEXT>
      </TEXT8>
      <TEXT9>
        <MASK>0x07</MASK>
        <VALUE>0x07</VALUE>
        <TEXT>Brown-out detection disabled; [BODLEVEL=111]                              </TEXT>
      </TEXT9>
    </HIGH>
    <EXTENDED>
      <NMB_FUSE_BITS>5</NMB_FUSE_BITS>
      <FUSE0>
        <NAME>SELFPRGEN</NAME>
        <TEXT>Self Programming Enable</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE0>
      <FUSE1>
        <NAME>BODACT0</NAME>
        <TEXT>Brown-out detector mode</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE1>
      <FUSE2>
        <NAME>BODACT1</NAME>
        <TEXT>Brown-out detector mode</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE2>
      <FUSE3>
        <NAME>BODPD0</NAME>
        <TEXT>Brown-out detector mode</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE3>
      <FUSE4>
        <NAME>BODPD1</NAME>
        <TEXT>Brown-out detector mode</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE4>
      <NMB_TEXT>1</NMB_TEXT>
      <TEXT1>
        <MASK>0x01</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Self Programming enable; [SELFPRGEN=0]</TEXT>
      </TEXT1>
    </EXTENDED>
  </FUSE>
  <ADMIN>
    <PART_NAME>ATtiny1634</PART_NAME>
    <SPEED>12MHZ</SPEED>
    <BUILD>1</BUILD>
    <RELEASE_STATUS>RELEASED</RELEASE_STATUS>
    <SIGNATURE>
      <ADDR000>$1E</ADDR000>
      <ADDR001>$94</ADDR001>
      <ADDR002>$12</ADDR002>
    </SIGNATURE>
    <OCD_PARAMETERS>
      <OCD_REVISION>1</OCD_REVISION>
      <OCD_REGISTER_ADDRESS>0x2E</OCD_REGISTER_ADDRESS>
      <CACHE_TYPE>0</CACHE_TYPE>
      <USE_JTAGID>0</USE_JTAGID>
      <DW_BASE_PC>0x00</DW_BASE_PC>
    </OCD_PARAMETERS>
  </ADMIN>
  <PACKAGE>
    <PACKAGES>[SOIC:MLF]</PACKAGES>
    <SOIC>
      <NMB_PIN>20</NMB_PIN>
      <PIN1>
        <NAME>[PB0:ADC5:TXD0:PCINT8]</NAME>
        <TEXT/>
      </PIN1>
      <PIN2>
        <NAME>[PA7:ADC4:RXD0:PCINT7]</NAME>
        <TEXT/>
      </PIN2>
      <PIN3>
        <NAME>[PA6:ADC3:OC1B:PCINT6]</NAME>
        <TEXT/>
      </PIN3>
      <PIN4>
        <NAME>[PA5:ADC2:OC0B:PCINT5]</NAME>
        <TEXT/>
      </PIN4>
      <PIN5>
        <NAME>[PA4:ADC1:T0:PCINT4]</NAME>
        <TEXT/>
      </PIN5>
      <PIN6>
        <NAME>[PA3:ADC0:T1:PCINT3]</NAME>
        <TEXT/>
      </PIN6>
      <PIN7>
        <NAME>[PA2:AIN1:PCINT2]</NAME>
        <TEXT/>
      </PIN7>
      <PIN8>
        <NAME>[PA1:AIN0:PCINT1]</NAME>
        <TEXT/>
      </PIN8>
      <PIN9>
        <NAME>[PA0:AREF:PCINT0]</NAME>
        <TEXT/>
      </PIN9>
      <PIN10>
        <NAME>[GND]</NAME>
        <TEXT/>
      </PIN10>
      <PIN11>
        <NAME>[VCC]</NAME>
        <TEXT/>
      </PIN11>
      <PIN12>
        <NAME>[PC5:XTAL1:CLKI:PCINT17]</NAME>
        <TEXT/>
      </PIN12>
      <PIN13>
        <NAME>[PC4:XTAL2:PCINT16]</NAME>
        <TEXT/>
      </PIN13>
      <PIN14>
        <NAME>[PC3:'RESET:PCINT15]</NAME>
        <TEXT/>
      </PIN14>
      <PIN15>
        <NAME>[PC2:ADC11:CLKO:INT0:PCINT14]</NAME>
        <TEXT/>
      </PIN15>
      <PIN16>
        <NAME>[PC1:ADC10:ICP1:XCK1:SCL:USCK:PCINT13]</NAME>
        <TEXT/>
      </PIN16>
      <PIN17>
        <NAME>[PC0:ADC9:OC0A:XCK0:PCINT12]</NAME>
        <TEXT/>
      </PIN17>
      <PIN18>
        <NAME>[PB3:ADC8:OC1A:PCINT11]</NAME>
        <TEXT/>
      </PIN18>
      <PIN19>
        <NAME>[PB2:ADC7:TXD1:DO:PCINT10]</NAME>
        <TEXT/>
      </PIN19>
      <PIN20>
        <NAME>[PB1:ADC6:RXD1:SDA:DI:PCINT9]</NAME>
        <TEXT/>
      </PIN20>
    </SOIC>
    <MLF>
      <NMB_PIN>20</NMB_PIN>
      <PIN1>
        <NAME>[PA6:ADC3:OC1B:PCINT6]</NAME>
        <TEXT/>
      </PIN1>
      <PIN2>
        <NAME>[PA5:ADC2:OC0B:PCINT5]</NAME>
        <TEXT/>
      </PIN2>
      <PIN3>
        <NAME>[PA4:ADC1:T0:PCINT4]</NAME>
        <TEXT/>
      </PIN3>
      <PIN4>
        <NAME>[PA3:ADC0:T1:PCINT3]</NAME>
        <TEXT/>
      </PIN4>
      <PIN5>
        <NAME>[PA2:AIN1:PCINT2]</NAME>
        <TEXT/>
      </PIN5>
      <PIN6>
        <NAME>[PA1:AIN0:PCINT1]</NAME>
        <TEXT/>
      </PIN6>
      <PIN7>
        <NAME>[PA0:AREF:PCINT0]</NAME>
        <TEXT/>
      </PIN7>
      <PIN8>
        <NAME>[GND]</NAME>
        <TEXT/>
      </PIN8>
      <PIN9>
        <NAME>[VCC]</NAME>
        <TEXT/>
      </PIN9>
      <PIN10>
        <NAME>[PC5:XTAL1:CLKI:PCINT17]</NAME>
        <TEXT/>
      </PIN10>
      <PIN11>
        <NAME>[PC4:XTAL2:PCINT16]</NAME>
        <TEXT/>
      </PIN11>
      <PIN12>
        <NAME>[PC3:'RESET:PCINT15]</NAME>
        <TEXT/>
      </PIN12>
      <PIN13>
        <NAME>[PC2:ADC11:CLKO:INT0:PCINT14]</NAME>
        <TEXT/>
      </PIN13>
      <PIN14>
        <NAME>[PC1:ADC10:ICP1:XCK1:SCL:USCK:PCINT13]</NAME>
        <TEXT/>
      </PIN14>
      <PIN15>
        <NAME>[PC0:ADC9:OC0A:XCK0:PCINT12]</NAME>
        <TEXT/>
      </PIN15>
      <PIN16>
        <NAME>[PB3:ADC8:OC1A:PCINT11]</NAME>
        <TEXT/>
      </PIN16>
      <PIN17>
        <NAME>[PB2:ADC7:TXD1:DO:PCINT10]</NAME>
        <TEXT/>
      </PIN17>
      <PIN18>
        <NAME>[PB1:ADC6:RXD1:SDA:DI:PCINT9]</NAME>
        <TEXT/>
      </PIN18>
      <PIN19>
        <NAME>[PB0:ADC5:TXD0:PCINT8]</NAME>
        <TEXT/>
      </PIN19>
      <PIN20>
        <NAME>[PA7:ADC4:RXD0:PCINT7]</NAME>
        <TEXT/>
      </PIN20>
    </MLF>
  </PACKAGE>
  <INTERRUPT_VECTOR>
    <NMB_VECTORS>28</NMB_VECTORS>
    <ID>AVRSimInterrupt.SimInterrupt</ID>
    <VECTOR1>
      <PROGRAM_ADDRESS>$000</PROGRAM_ADDRESS>
      <SOURCE>RESET</SOURCE>
      <DEFINITION>External Pin, Power-on Reset, Brown-out Reset and Watchdog Reset</DEFINITION>
    </VECTOR1>
    <VECTOR2>
      <PROGRAM_ADDRESS>$002</PROGRAM_ADDRESS>
      <SOURCE>INT0</SOURCE>
      <DEFINITION>External Interrupt Request 0</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR2>
    <VECTOR3>
      <PROGRAM_ADDRESS>$004</PROGRAM_ADDRESS>
      <SOURCE>PCINT0</SOURCE>
      <DEFINITION>Pin Change Interrupt Request 0</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR3>
    <VECTOR4>
      <PROGRAM_ADDRESS>$006</PROGRAM_ADDRESS>
      <SOURCE>PCINT1</SOURCE>
      <DEFINITION>Pin Change Interrupt Request 1</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR4>
    <VECTOR5>
      <PROGRAM_ADDRESS>$008</PROGRAM_ADDRESS>
      <SOURCE>PCINT2</SOURCE>
      <DEFINITION>Pin Change Interrupt Request 2</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR5>
    <VECTOR6>
      <PROGRAM_ADDRESS>$00A</PROGRAM_ADDRESS>
      <SOURCE>WDT</SOURCE>
      <DEFINITION>Watchdog Time-out Interrupt</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR6>
    <VECTOR7>
      <PROGRAM_ADDRESS>$00C</PROGRAM_ADDRESS>
      <SOURCE>TIMER1 CAPT</SOURCE>
      <DEFINITION>Timer/Counter1 Capture Event</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR7>
    <VECTOR8>
      <PROGRAM_ADDRESS>$00E</PROGRAM_ADDRESS>
      <SOURCE>TIMER1 COMPA</SOURCE>
      <DEFINITION>Timer/Counter1 Compare Match A</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR8>
    <VECTOR9>
      <PROGRAM_ADDRESS>$010</PROGRAM_ADDRESS>
      <SOURCE>TIMER1 COMPB</SOURCE>
      <DEFINITION>Timer/Counter1 Compare Match B</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR9>
    <VECTOR10>
      <PROGRAM_ADDRESS>$012</PROGRAM_ADDRESS>
      <SOURCE>TIMER1 OVF</SOURCE>
      <DEFINITION>Timer/Counter1 Overflow</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR10>
    <VECTOR11>
      <PROGRAM_ADDRESS>$014</PROGRAM_ADDRESS>
      <SOURCE>TIMER0 COMPA</SOURCE>
      <DEFINITION>TimerCounter0 Compare Match A</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR11>
    <VECTOR12>
      <PROGRAM_ADDRESS>$016</PROGRAM_ADDRESS>
      <SOURCE>TIMER0 COMPB</SOURCE>
      <DEFINITION>TimerCounter0 Compare Match B</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR12>
    <VECTOR13>
      <PROGRAM_ADDRESS>$018</PROGRAM_ADDRESS>
      <SOURCE>TIMER0 OVF</SOURCE>
      <DEFINITION>Timer/Couner0 Overflow</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR13>
    <VECTOR14>
      <PROGRAM_ADDRESS>$01A</PROGRAM_ADDRESS>
      <SOURCE>ANA_COMP</SOURCE>
      <DEFINITION>Analog Comparator</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR14>
    <VECTOR15>
      <PROGRAM_ADDRESS>$01C</PROGRAM_ADDRESS>
      <SOURCE>ADC</SOURCE>
      <DEFINITION>ADC Conversion Complete</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR15>
    <VECTOR16>
      <PROGRAM_ADDRESS>$01E</PROGRAM_ADDRESS>
      <SOURCE>USART0, START</SOURCE>
      <DEFINITION>USART0, Start</DEFINITION>
    </VECTOR16>
    <VECTOR17>
      <PROGRAM_ADDRESS>$020</PROGRAM_ADDRESS>
      <SOURCE>USART0, RX</SOURCE>
      <DEFINITION>USART0, Rx Complete</DEFINITION>
    </VECTOR17>
    <VECTOR18>
      <PROGRAM_ADDRESS>$022</PROGRAM_ADDRESS>
      <SOURCE>USART0, UDRE</SOURCE>
      <DEFINITION>USART0 Data Register Empty</DEFINITION>
    </VECTOR18>
    <VECTOR19>
      <PROGRAM_ADDRESS>$024</PROGRAM_ADDRESS>
      <SOURCE>USART0, TX</SOURCE>
      <DEFINITION>USART0, Tx Complete</DEFINITION>
    </VECTOR19>
    <VECTOR20>
      <PROGRAM_ADDRESS>$026</PROGRAM_ADDRESS>
      <SOURCE>USART1, START</SOURCE>
      <DEFINITION>USART1, Start</DEFINITION>
    </VECTOR20>
    <VECTOR21>
      <PROGRAM_ADDRESS>$028</PROGRAM_ADDRESS>
      <SOURCE>USART1, RX</SOURCE>
      <DEFINITION>USART1, Rx Complete</DEFINITION>
    </VECTOR21>
    <VECTOR22>
      <PROGRAM_ADDRESS>$02A</PROGRAM_ADDRESS>
      <SOURCE>USART1, UDRE</SOURCE>
      <DEFINITION>USART1 Data Register Empty</DEFINITION>
    </VECTOR22>
    <VECTOR23>
      <PROGRAM_ADDRESS>$02C</PROGRAM_ADDRESS>
      <SOURCE>USART1, TX</SOURCE>
      <DEFINITION>USART1, Tx Complete</DEFINITION>
    </VECTOR23>
    <VECTOR24>
      <PROGRAM_ADDRESS>$02E</PROGRAM_ADDRESS>
      <SOURCE>USI START</SOURCE>
      <DEFINITION>USI Start Condition</DEFINITION>
    </VECTOR24>
    <VECTOR25>
      <PROGRAM_ADDRESS>$030</PROGRAM_ADDRESS>
      <SOURCE>USI OVERFLOW</SOURCE>
      <DEFINITION>USI Overflow</DEFINITION>
    </VECTOR25>
    <VECTOR26>
      <PROGRAM_ADDRESS>$032</PROGRAM_ADDRESS>
      <SOURCE>TWI_SLAVE</SOURCE>
      <DEFINITION>Two-wire Serial Interface</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR26>
    <VECTOR27>
      <PROGRAM_ADDRESS>$034</PROGRAM_ADDRESS>
      <SOURCE>EE_RDY</SOURCE>
      <DEFINITION>EEPROM Ready</DEFINITION>
      <ENABLEADDRESS/>
      <ENABLEMASK/>
      <FLAGADDRESS/>
      <FLAGMASK/>
      <FLAGVALUE/>
    </VECTOR27>
    <VECTOR28>
      <PROGRAM_ADDRESS>$036</PROGRAM_ADDRESS>
      <SOURCE>QTRIP</SOURCE>
      <DEFINITION>Touch Sensing</DEFINITION>
    </VECTOR28>
  </INTERRUPT_VECTOR>
  <IO_MODULE>
    <MODULE_LIST>[TWI:PORTB:PORTC:PORTA:AD_CONVERTER:ANALOG_COMPARATOR:EEPROM:TIMER_COUNTER_1:TIMER_COUNTER_0:EXTERNAL_INTERRUPT:CPU:USI:USART0:USART1:WATCHDOG]</MODULE_LIST>
    <TWI>
      <LIST>[TWSCRA:TWSCRB:TWSSRA:TWSA:TWSD:TWSAM]</LIST>
      <LINK/>
      <ICON>io_com.bmp</ICON>
      <ID/>
      <TEXT>TWI: Simple yet powerful and flexible communications interface, only two bus lines needed. Both master and slave operation supported. Device can operate as transmitter or receiver. 7-bit address space allows up to 128 different slave addresses.  Multi-master arbitration support  Up to 400 kHz data transfer speed  Slew-rate limited output drivers  Noise suppression circuitry rejects spikes on bus lines  Fully programmable slave address with general call support  Address recognition causes wake-up when AVR is in sleep mode The Two-Wire Serial Interface (TWI) is ideally suited to typical microcontroller applications. The TWI protocol allows the systems designer to interconnect up to 128 different devices using only two bidirectional bus lines, one for clock (SCL) andone for data (SDA). The only external hardware needed to implement the bus is a single pull-up resistor for each of the TWI bus lines. All devices connected to the bus have individual addresses, and mechanisms for resolving bus contention are inherent in the TWI </TEXT>
      <TWSCRA>
        <NAME>TWSCRA</NAME>
        <DESCRIPTION>TWI Slave Control Register A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x7F</MEM_ADDR>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT5>
          <NAME>TWDIE</NAME>
          <DESCRIPTION>TWI Data Interrupt Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TWASIE</NAME>
          <DESCRIPTION>TWI Address/Stop Interrupt Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TWEN</NAME>
          <DESCRIPTION>Two-Wire Interface Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TWSIE</NAME>
          <DESCRIPTION>TWI Stop Interrupt Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TWPME</NAME>
          <DESCRIPTION>TWI Promiscuous Mode Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TWSME</NAME>
          <DESCRIPTION>TWI Smart Mode Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TWSCRA>
      <TWSCRB>
        <NAME>TWSCRB</NAME>
        <DESCRIPTION>TWI Slave Control Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x7E</MEM_ADDR>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT2>
          <NAME>TWAA</NAME>
          <DESCRIPTION>TWI Acknowledge Action</DESCRIPTION>
          <TEXT>This bit defines the slave's acknowledge behavior after an address or data byte has been received from the master. Depending on the TWSME bit in TWSCRA the Acknowledge Action is executed either when a valid command has been written to TWCMDn bits, or when the data register has been read.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TWCMD1</NAME>
          <DESCRIPTION/>
          <TEXT>Writing these bits triggers the slave operation as defined by Table 17-2. The type of operation depends on the TWI slave interrupt flags, TWDIF and TWASIF. The Acknowledge Action is only executed when the slave receives data bytes or address byte from the master.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TWCMD0</NAME>
          <DESCRIPTION/>
          <TEXT>Writing these bits triggers the slave operation as defined by Table 17-2. The type of operation depends on the TWI slave interrupt flags, TWDIF and TWASIF. The Acknowledge Action is only executed when the slave receives data bytes or address byte from the master.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TWSCRB>
      <TWSSRA>
        <NAME>TWSSRA</NAME>
        <DESCRIPTION>TWI Slave Status Register A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x7D</MEM_ADDR>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TWDIF</NAME>
          <DESCRIPTION>TWI Data Interrupt Flag.</DESCRIPTION>
          <TEXT>This flag is set when a data byte has been successfully received, i.e. no bus errors or collisions have occurred during the operation. When this flag is set the slave forces the SCL line low, stretching the TWI clock period. The SCL line is released by clearing the interrupt flags. Writing a one to this bit will clear the flag. This flag is also automatically cleared when writing a valid command to the TWCMDn bits in TWSCRB.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TWASIF</NAME>
          <DESCRIPTION>TWI Address/Stop Interrupt Flag</DESCRIPTION>
          <TEXT>This flag is set when the slave detects that a valid address has been received, or when a transmit collision has been detected. When this flag is set the slave forces the SCL line low, stretching the TWI clock period. The SCL line is released by clearing the interrupt flags. If TWASIE in TWSCRA is set a STOP condition on the bus will also set TWASIF.Writing a one to this bit will clear the flag. This flag is also automatically cleared when writing a valid command to the TWCMDn bits in TWSCRB.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5><NAME>TWCH</NAME><DESCRIPTION>TWI Clock Hold</DESCRIPTION><TEXT/>This bit is set when the slave is holding the SCL line low. This bit is read-only, and set when TWDIF or TWASIF is set. The bit can be cleared indirectly by clearing the interrupt flags and releasing the SCL line.<TEXT/><ACCESS>RW</ACCESS><INIT_VAL>0</INIT_VAL></BIT5>
        <BIT4><NAME>TWRA</NAME><DESCRIPTION>TWI Receive Acknowledge</DESCRIPTION><TEXT/>This bit contains the most recently received acknowledge bit from the master. This bit is read-only. When zero, the most recent acknowledge bit from the maser was ACK and, when one, the most recent acknowledge bit was NACK.<TEXT/><ACCESS>RW</ACCESS><INIT_VAL>0</INIT_VAL></BIT4>
        <BIT3><NAME>TWC</NAME><DESCRIPTION>TWI Collision</DESCRIPTION><TEXT/>This bit is set when the slave was not able to transfer a high data bit or a NACK bit. When a collision is detected, the slave will commence its normal operation, and disable data and acknowledge output. No low values are shifted out onto the SDA line.This bit is cleared by writing a one to it. The bit is also cleared automatically when a START or Repeated START condition is detected.<TEXT/><ACCESS>RW</ACCESS><INIT_VAL>0</INIT_VAL></BIT3>
        <BIT2><NAME>TWBE</NAME><DESCRIPTION>TWI Bus Error</DESCRIPTION><TEXT/>This bit is set when an illegal bus condition has occured during a transfer. An illegal bus condition occurs if a Repeated START or STOP condition is detected, and the number of bits from the previous START condition is not a multiple of nine.This bit is cleared by writing a one to it.<TEXT/><ACCESS>RW</ACCESS><INIT_VAL>0</INIT_VAL></BIT2>
        <BIT1><NAME>TWDIR</NAME><DESCRIPTION>TWI Read/Write Direction</DESCRIPTION><TEXT/>This bit indicates the direction bit from the last address packet received from a master. When this bit is one, a master read operation is in progress. When the bit is zero a master write operation is in progress.<TEXT/><ACCESS>RW</ACCESS><INIT_VAL>0</INIT_VAL></BIT1>
        <BIT0><NAME>TWAS</NAME><DESCRIPTION>TWI Address or Stop</DESCRIPTION><TEXT/>This bit indicates why the TWASIF bit was last set. If zero, a stop condition caused TWASIF to be set. If one, address detection caused TWASIF to be set.<TEXT/><ACCESS>RW</ACCESS><INIT_VAL>0</INIT_VAL></BIT0>
      </TWSSRA>
      <TWSA>
        <NAME>TWSA</NAME>
        <DESCRIPTION>TWI Slave Address Register</DESCRIPTION>
        <TEXT>The slave address register contains the TWI slave address used by the slave address match logic to determine if a master has addressed the slave. When using 7-bit or 10-bit address recognition mode, the high seven bits of the address register (TWSA[7:1]) represent the slave address. The least significant bit (TWSA[0]) is used for general call address recognition. Setting TWSA[0] enables general call address recognition logic.When using 10-bit addressing the address match logic only support hardware address recognition of the first byte of a 10-bit address. If TWSA[7:1] is set to "0b11110nn", 'nn' will represent bits 9 and 8 ot the slave address. The next byte received is then bits 7 to 0 in the 10-bit address, but this must be handled by software. When the address match logic detects that a valid address byte has been received, the TWASIF is set and the TWDIR flag is updated. If TWPME in TWSCRA is set, the address match logic responds to all addresses transmitted on the TWI bus. TWSA is not used in this mode.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x7C</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>TWSA7</NAME>
          <DESCRIPTION>TWI slave address bit</DESCRIPTION>
          <TEXT>The slave address register contains the TWI slave address used by the slave address match logic to determine if a master has addressed the slave. When using 7-bit or 10-bit address recognition mode, the high seven bits of the address register (TWSA[7:1]) represent the slave address. The least significant bit (TWSA[0]) is used for general call address recognition. Setting TWSA[0] enables general call address recognition logic.When using 10-bit addressing the address match logic only support hardware address recognition of the first byte of a 10-bit address. If TWSA[7:1] is set to "0b11110nn", 'nn' will represent bits 9 and 8 ot the slave address. The next byte received is then bits 7 to 0 in the 10-bit address, but this must be handled by software. When the address match logic detects that a valid address byte has been received, the TWASIF is set and the TWDIR flag is updated. If TWPME in TWSCRA is set, the address match logic responds to all addresses transmitted on the TWI bus. TWSA is not used in this mode.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TWSA6</NAME>
          <DESCRIPTION>TWI slave address bit</DESCRIPTION>
          <TEXT>The slave address register contains the TWI slave address used by the slave address match logic to determine if a master has addressed the slave. When using 7-bit or 10-bit address recognition mode, the high seven bits of the address register (TWSA[7:1]) represent the slave address. The least significant bit (TWSA[0]) is used for general call address recognition. Setting TWSA[0] enables general call address recognition logic.When using 10-bit addressing the address match logic only support hardware address recognition of the first byte of a 10-bit address. If TWSA[7:1] is set to "0b11110nn", 'nn' will represent bits 9 and 8 ot the slave address. The next byte received is then bits 7 to 0 in the 10-bit address, but this must be handled by software. When the address match logic detects that a valid address byte has been received, the TWASIF is set and the TWDIR flag is updated. If TWPME in TWSCRA is set, the address match logic responds to all addresses transmitted on the TWI bus. TWSA is not used in this mode.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TWSA5</NAME>
          <DESCRIPTION>TWI slave address bit</DESCRIPTION>
          <TEXT>The slave address register contains the TWI slave address used by the slave address match logic to determine if a master has addressed the slave. When using 7-bit or 10-bit address recognition mode, the high seven bits of the address register (TWSA[7:1]) represent the slave address. The least significant bit (TWSA[0]) is used for general call address recognition. Setting TWSA[0] enables general call address recognition logic.When using 10-bit addressing the address match logic only support hardware address recognition of the first byte of a 10-bit address. If TWSA[7:1] is set to "0b11110nn", 'nn' will represent bits 9 and 8 ot the slave address. The next byte received is then bits 7 to 0 in the 10-bit address, but this must be handled by software. When the address match logic detects that a valid address byte has been received, the TWASIF is set and the TWDIR flag is updated. If TWPME in TWSCRA is set, the address match logic responds to all addresses transmitted on the TWI bus. TWSA is not used in this mode.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TWSA4</NAME>
          <DESCRIPTION>TWI slave address bit</DESCRIPTION>
          <TEXT>The slave address register contains the TWI slave address used by the slave address match logic to determine if a master has addressed the slave. When using 7-bit or 10-bit address recognition mode, the high seven bits of the address register (TWSA[7:1]) represent the slave address. The least significant bit (TWSA[0]) is used for general call address recognition. Setting TWSA[0] enables general call address recognition logic.When using 10-bit addressing the address match logic only support hardware address recognition of the first byte of a 10-bit address. If TWSA[7:1] is set to "0b11110nn", 'nn' will represent bits 9 and 8 ot the slave address. The next byte received is then bits 7 to 0 in the 10-bit address, but this must be handled by software. When the address match logic detects that a valid address byte has been received, the TWASIF is set and the TWDIR flag is updated. If TWPME in TWSCRA is set, the address match logic responds to all addresses transmitted on the TWI bus. TWSA is not used in this mode.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TWSA3</NAME>
          <DESCRIPTION>TWI slave address bit</DESCRIPTION>
          <TEXT>The slave address register contains the TWI slave address used by the slave address match logic to determine if a master has addressed the slave. When using 7-bit or 10-bit address recognition mode, the high seven bits of the address register (TWSA[7:1]) represent the slave address. The least significant bit (TWSA[0]) is used for general call address recognition. Setting TWSA[0] enables general call address recognition logic.When using 10-bit addressing the address match logic only support hardware address recognition of the first byte of a 10-bit address. If TWSA[7:1] is set to "0b11110nn", 'nn' will represent bits 9 and 8 ot the slave address. The next byte received is then bits 7 to 0 in the 10-bit address, but this must be handled by software. When the address match logic detects that a valid address byte has been received, the TWASIF is set and the TWDIR flag is updated. If TWPME in TWSCRA is set, the address match logic responds to all addresses transmitted on the TWI bus. TWSA is not used in this mode.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TWSA2</NAME>
          <DESCRIPTION>TWI slave address bit</DESCRIPTION>
          <TEXT>The slave address register contains the TWI slave address used by the slave address match logic to determine if a master has addressed the slave. When using 7-bit or 10-bit address recognition mode, the high seven bits of the address register (TWSA[7:1]) represent the slave address. The least significant bit (TWSA[0]) is used for general call address recognition. Setting TWSA[0] enables general call address recognition logic.When using 10-bit addressing the address match logic only support hardware address recognition of the first byte of a 10-bit address. If TWSA[7:1] is set to "0b11110nn", 'nn' will represent bits 9 and 8 ot the slave address. The next byte received is then bits 7 to 0 in the 10-bit address, but this must be handled by software. When the address match logic detects that a valid address byte has been received, the TWASIF is set and the TWDIR flag is updated. If TWPME in TWSCRA is set, the address match logic responds to all addresses transmitted on the TWI bus. TWSA is not used in this mode.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TWSA1</NAME>
          <DESCRIPTION>TWI slave address bit</DESCRIPTION>
          <TEXT>The slave address register contains the TWI slave address used by the slave address match logic to determine if a master has addressed the slave. When using 7-bit or 10-bit address recognition mode, the high seven bits of the address register (TWSA[7:1]) represent the slave address. The least significant bit (TWSA[0]) is used for general call address recognition. Setting TWSA[0] enables general call address recognition logic.When using 10-bit addressing the address match logic only support hardware address recognition of the first byte of a 10-bit address. If TWSA[7:1] is set to "0b11110nn", 'nn' will represent bits 9 and 8 ot the slave address. The next byte received is then bits 7 to 0 in the 10-bit address, but this must be handled by software. When the address match logic detects that a valid address byte has been received, the TWASIF is set and the TWDIR flag is updated. If TWPME in TWSCRA is set, the address match logic responds to all addresses transmitted on the TWI bus. TWSA is not used in this mode.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TWSA0</NAME>
          <DESCRIPTION>TWI slave address bit</DESCRIPTION>
          <TEXT>The slave address register contains the TWI slave address used by the slave address match logic to determine if a master has addressed the slave. When using 7-bit or 10-bit address recognition mode, the high seven bits of the address register (TWSA[7:1]) represent the slave address. The least significant bit (TWSA[0]) is used for general call address recognition. Setting TWSA[0] enables general call address recognition logic.When using 10-bit addressing the address match logic only support hardware address recognition of the first byte of a 10-bit address. If TWSA[7:1] is set to "0b11110nn", 'nn' will represent bits 9 and 8 ot the slave address. The next byte received is then bits 7 to 0 in the 10-bit address, but this must be handled by software. When the address match logic detects that a valid address byte has been received, the TWASIF is set and the TWDIR flag is updated. If TWPME in TWSCRA is set, the address match logic responds to all addresses transmitted on the TWI bus. TWSA is not used in this mode.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TWSA>
      <TWSD>
        <NAME>TWSD</NAME>
        <DESCRIPTION>TWI Slave Data Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x7A</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>TWSD7</NAME>
          <DESCRIPTION>TWI slave data bit</DESCRIPTION>
          <TEXT>The data register is used when transmitting and received data. During transfer, data is shifted from/to the TWSD register and to/from the bus. Therefore, the data register cannot be accessed during byte transfers. This is protected in hardware. The data register can only be accessed when the SCL line is held low by the slave, i.e. when TWCH is set. When a master reads data from a slave, the data to be sent must be written to the TWSD register. The byte transfer is started when the master starts to clock the data byte from the slave. It is followed by the slave receiving the acknowledge bit from the master. The TWDIF and the TWCH bits are then set. When a master writes data to a slave, the TWDIF and the TWCH flags are set when one byte has been received in the data register. If Smart Mode is enabled, reading the data register will trigger the bus operation, as set by the TWAA bit in TWSCRB. Accessing TWSD will clear the slave interrupt flags and the TWCH bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TWSD6</NAME>
          <DESCRIPTION>TWI slave data bit</DESCRIPTION>
          <TEXT>The data register is used when transmitting and received data. During transfer, data is shifted from/to the TWSD register and to/from the bus. Therefore, the data register cannot be accessed during byte transfers. This is protected in hardware. The data register can only be accessed when the SCL line is held low by the slave, i.e. when TWCH is set. When a master reads data from a slave, the data to be sent must be written to the TWSD register. The byte transfer is started when the master starts to clock the data byte from the slave. It is followed by the slave receiving the acknowledge bit from the master. The TWDIF and the TWCH bits are then set. When a master writes data to a slave, the TWDIF and the TWCH flags are set when one byte has been received in the data register. If Smart Mode is enabled, reading the data register will trigger the bus operation, as set by the TWAA bit in TWSCRB. Accessing TWSD will clear the slave interrupt flags and the TWCH bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TWSD5</NAME>
          <DESCRIPTION>TWI slave data bit</DESCRIPTION>
          <TEXT>The data register is used when transmitting and received data. During transfer, data is shifted from/to the TWSD register and to/from the bus. Therefore, the data register cannot be accessed during byte transfers. This is protected in hardware. The data register can only be accessed when the SCL line is held low by the slave, i.e. when TWCH is set. When a master reads data from a slave, the data to be sent must be written to the TWSD register. The byte transfer is started when the master starts to clock the data byte from the slave. It is followed by the slave receiving the acknowledge bit from the master. The TWDIF and the TWCH bits are then set. When a master writes data to a slave, the TWDIF and the TWCH flags are set when one byte has been received in the data register. If Smart Mode is enabled, reading the data register will trigger the bus operation, as set by the TWAA bit in TWSCRB. Accessing TWSD will clear the slave interrupt flags and the TWCH bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TWSD4</NAME>
          <DESCRIPTION>TWI slave data bit</DESCRIPTION>
          <TEXT>The data register is used when transmitting and received data. During transfer, data is shifted from/to the TWSD register and to/from the bus. Therefore, the data register cannot be accessed during byte transfers. This is protected in hardware. The data register can only be accessed when the SCL line is held low by the slave, i.e. when TWCH is set. When a master reads data from a slave, the data to be sent must be written to the TWSD register. The byte transfer is started when the master starts to clock the data byte from the slave. It is followed by the slave receiving the acknowledge bit from the master. The TWDIF and the TWCH bits are then set. When a master writes data to a slave, the TWDIF and the TWCH flags are set when one byte has been received in the data register. If Smart Mode is enabled, reading the data register will trigger the bus operation, as set by the TWAA bit in TWSCRB. Accessing TWSD will clear the slave interrupt flags and the TWCH bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TWSD3</NAME>
          <DESCRIPTION>TWI slave data bit</DESCRIPTION>
          <TEXT>The data register is used when transmitting and received data. During transfer, data is shifted from/to the TWSD register and to/from the bus. Therefore, the data register cannot be accessed during byte transfers. This is protected in hardware. The data register can only be accessed when the SCL line is held low by the slave, i.e. when TWCH is set. When a master reads data from a slave, the data to be sent must be written to the TWSD register. The byte transfer is started when the master starts to clock the data byte from the slave. It is followed by the slave receiving the acknowledge bit from the master. The TWDIF and the TWCH bits are then set. When a master writes data to a slave, the TWDIF and the TWCH flags are set when one byte has been received in the data register. If Smart Mode is enabled, reading the data register will trigger the bus operation, as set by the TWAA bit in TWSCRB. Accessing TWSD will clear the slave interrupt flags and the TWCH bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TWSD2</NAME>
          <DESCRIPTION>TWI slave data bit</DESCRIPTION>
          <TEXT>The data register is used when transmitting and received data. During transfer, data is shifted from/to the TWSD register and to/from the bus. Therefore, the data register cannot be accessed during byte transfers. This is protected in hardware. The data register can only be accessed when the SCL line is held low by the slave, i.e. when TWCH is set. When a master reads data from a slave, the data to be sent must be written to the TWSD register. The byte transfer is started when the master starts to clock the data byte from the slave. It is followed by the slave receiving the acknowledge bit from the master. The TWDIF and the TWCH bits are then set. When a master writes data to a slave, the TWDIF and the TWCH flags are set when one byte has been received in the data register. If Smart Mode is enabled, reading the data register will trigger the bus operation, as set by the TWAA bit in TWSCRB. Accessing TWSD will clear the slave interrupt flags and the TWCH bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TWSD1</NAME>
          <DESCRIPTION>TWI slave data bit</DESCRIPTION>
          <TEXT>The data register is used when transmitting and received data. During transfer, data is shifted from/to the TWSD register and to/from the bus. Therefore, the data register cannot be accessed during byte transfers. This is protected in hardware. The data register can only be accessed when the SCL line is held low by the slave, i.e. when TWCH is set. When a master reads data from a slave, the data to be sent must be written to the TWSD register. The byte transfer is started when the master starts to clock the data byte from the slave. It is followed by the slave receiving the acknowledge bit from the master. The TWDIF and the TWCH bits are then set. When a master writes data to a slave, the TWDIF and the TWCH flags are set when one byte has been received in the data register. If Smart Mode is enabled, reading the data register will trigger the bus operation, as set by the TWAA bit in TWSCRB. Accessing TWSD will clear the slave interrupt flags and the TWCH bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TWSD0</NAME>
          <DESCRIPTION>TWI slave data bit</DESCRIPTION>
          <TEXT>The data register is used when transmitting and received data. During transfer, data is shifted from/to the TWSD register and to/from the bus. Therefore, the data register cannot be accessed during byte transfers. This is protected in hardware. The data register can only be accessed when the SCL line is held low by the slave, i.e. when TWCH is set. When a master reads data from a slave, the data to be sent must be written to the TWSD register. The byte transfer is started when the master starts to clock the data byte from the slave. It is followed by the slave receiving the acknowledge bit from the master. The TWDIF and the TWCH bits are then set. When a master writes data to a slave, the TWDIF and the TWCH flags are set when one byte has been received in the data register. If Smart Mode is enabled, reading the data register will trigger the bus operation, as set by the TWAA bit in TWSCRB. Accessing TWSD will clear the slave interrupt flags and the TWCH bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TWSD>
      <TWSAM>
        <NAME>TWSAM</NAME>
        <DESCRIPTION>TWI Slave Address Mask Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x7B</MEM_ADDR>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TWSAM7</NAME>
          <DESCRIPTION>TWI Address Mask Bit 7</DESCRIPTION>
          <TEXT>These bits can act as a second address match register, or an address mask register, depending on the TWAE setting. If TWAE is set to zero, TWSAM can be loaded with a 7-bit slave address mask. Each bit in TWSAM can mask (disable) the corresponding address bit in the TWSA register. If the mask bit is one the address match between the incoming address bit and the corresponding bit in TWSA is ignored. In other words, masked bits will always match. If TWAE is set to one, TWSAM can be loaded with a second slave address in addition to the TWSA register. In this mode, the slave will match on 2 unique addresses, one in TWSA and the other in TWSAM.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TWSAM6</NAME>
          <DESCRIPTION>TWI Address Mask Bit 6</DESCRIPTION>
          <TEXT>These bits can act as a second address match register, or an address mask register, depending on the TWAE setting. If TWAE is set to zero, TWSAM can be loaded with a 7-bit slave address mask. Each bit in TWSAM can mask (disable) the corresponding address bit in the TWSA register. If the mask bit is one the address match between the incoming address bit and the corresponding bit in TWSA is ignored. In other words, masked bits will always match. If TWAE is set to one, TWSAM can be loaded with a second slave address in addition to the TWSA register. In this mode, the slave will match on 2 unique addresses, one in TWSA and the other in TWSAM.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TWSAM5</NAME>
          <DESCRIPTION>TWI Address Mask Bit 5</DESCRIPTION>
          <TEXT>These bits can act as a second address match register, or an address mask register, depending on the TWAE setting. If TWAE is set to zero, TWSAM can be loaded with a 7-bit slave address mask. Each bit in TWSAM can mask (disable) the corresponding address bit in the TWSA register. If the mask bit is one the address match between the incoming address bit and the corresponding bit in TWSA is ignored. In other words, masked bits will always match. If TWAE is set to one, TWSAM can be loaded with a second slave address in addition to the TWSA register. In this mode, the slave will match on 2 unique addresses, one in TWSA and the other in TWSAM.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TWSAM4</NAME>
          <DESCRIPTION>TWI Address Mask Bit 4</DESCRIPTION>
          <TEXT>These bits can act as a second address match register, or an address mask register, depending on the TWAE setting. If TWAE is set to zero, TWSAM can be loaded with a 7-bit slave address mask. Each bit in TWSAM can mask (disable) the corresponding address bit in the TWSA register. If the mask bit is one the address match between the incoming address bit and the corresponding bit in TWSA is ignored. In other words, masked bits will always match. If TWAE is set to one, TWSAM can be loaded with a second slave address in addition to the TWSA register. In this mode, the slave will match on 2 unique addresses, one in TWSA and the other in TWSAM.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TWSAM3</NAME>
          <DESCRIPTION>TWI Address Mask Bit 3</DESCRIPTION>
          <TEXT>These bits can act as a second address match register, or an address mask register, depending on the TWAE setting. If TWAE is set to zero, TWSAM can be loaded with a 7-bit slave address mask. Each bit in TWSAM can mask (disable) the corresponding address bit in the TWSA register. If the mask bit is one the address match between the incoming address bit and the corresponding bit in TWSA is ignored. In other words, masked bits will always match. If TWAE is set to one, TWSAM can be loaded with a second slave address in addition to the TWSA register. In this mode, the slave will match on 2 unique addresses, one in TWSA and the other in TWSAM.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TWSAM2</NAME>
          <DESCRIPTION>TWI Address Mask Bit 2</DESCRIPTION>
          <TEXT>These bits can act as a second address match register, or an address mask register, depending on the TWAE setting. If TWAE is set to zero, TWSAM can be loaded with a 7-bit slave address mask. Each bit in TWSAM can mask (disable) the corresponding address bit in the TWSA register. If the mask bit is one the address match between the incoming address bit and the corresponding bit in TWSA is ignored. In other words, masked bits will always match. If TWAE is set to one, TWSAM can be loaded with a second slave address in addition to the TWSA register. In this mode, the slave will match on 2 unique addresses, one in TWSA and the other in TWSAM.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TWSAM1</NAME>
          <DESCRIPTION>TWI Address Mask Bit 1</DESCRIPTION>
          <TEXT>These bits can act as a second address match register, or an address mask register, depending on the TWAE setting. If TWAE is set to zero, TWSAM can be loaded with a 7-bit slave address mask. Each bit in TWSAM can mask (disable) the corresponding address bit in the TWSA register. If the mask bit is one the address match between the incoming address bit and the corresponding bit in TWSA is ignored. In other words, masked bits will always match. If TWAE is set to one, TWSAM can be loaded with a second slave address in addition to the TWSA register. In this mode, the slave will match on 2 unique addresses, one in TWSA and the other in TWSAM.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TWAE</NAME>
          <DESCRIPTION>TWI Address Enable</DESCRIPTION>
          <TEXT>By default, this bit is zero and the TWSAM bits acts as an address mask to the TWSA register. If this bit is set to one, the slave address match logic responds to the two unique addresses in TWSA and TWSAM</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT0>
      </TWSAM>
    </TWI>
    <PORTB>
      <LIST>[PORTCR:PUEB:PORTB:DDRB:PINB]</LIST>
      <LINK/>
      <ICON>io_port.bmp</ICON>
      <ID>AVRSimIOPort.SimIOPort</ID>
      <TEXT/>
      <PORTCR>
        <NAME>PORTCR</NAME>
        <DESCRIPTION>Port Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x13</IO_ADDR>
        <MEM_ADDR>0x33</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT1>
          <NAME>BBMB</NAME>
          <DESCRIPTION>Break-Before-Make Mode Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
      </PORTCR>
      <PUEB>
        <NAME>PUEB</NAME>
        <DESCRIPTION>Pull-up Enable Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x0E</IO_ADDR>
        <MEM_ADDR>0x2E</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT3>
          <NAME>PUEB3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PUEB2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PUEB1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PUEB0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PUEB>
      <DDRB>
        <NAME>DDRB</NAME>
        <DESCRIPTION>Data Direction Register, Port B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x0C</IO_ADDR>
        <MEM_ADDR>0x2C</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT3>
          <NAME>DDB3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>DDB2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>DDB1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>DDB0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </DDRB>
      <PINB>
        <NAME>PINB</NAME>
        <DESCRIPTION>Port B Data register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x0B</IO_ADDR>
        <MEM_ADDR>0x2B</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT3>
          <NAME>PINB3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PINB2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PINB1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PINB0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PINB>
      <PORTB>
        <NAME>PORTB</NAME>
        <DESCRIPTION>Input Pins, Port B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x0D</IO_ADDR>
        <MEM_ADDR>0x2D</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT3>
          <NAME>PORTB3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PORTB2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PORTB1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PORTB0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PORTB>
    </PORTB>
    <PORTC>
      <LIST>[PORTCR:PUEC:PORTC:DDRC:PINC]</LIST>
      <LINK/>
      <ICON>io_port.bmp</ICON>
      <ID>AVRSimIOPort.SimIOPort</ID>
      <TEXT/>
      <PORTCR>
        <NAME>PORTCR</NAME>
        <DESCRIPTION>Port Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x13</IO_ADDR>
        <MEM_ADDR>0x33</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT2>
          <NAME>BBMC</NAME>
          <DESCRIPTION>Break-Before-Make Mode Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
      </PORTCR>
      <PUEC>
        <NAME>PUEC</NAME>
        <DESCRIPTION>Pull-up Enable Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x0A</IO_ADDR>
        <MEM_ADDR>0x2A</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT5>
          <NAME>PUEC5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PUEC4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PUEC3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PUEC2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PUEC1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PUEC0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PUEC>
      <PORTC>
        <NAME>PORTC</NAME>
        <DESCRIPTION>Port C Data Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x09</IO_ADDR>
        <MEM_ADDR>0x29</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT5>
          <NAME>PORTC5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PORTC4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PORTC3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PORTC2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PORTC1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PORTC0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PORTC>
      <DDRC>
        <NAME>DDRC</NAME>
        <DESCRIPTION>Data Direction Register, Port C</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x08</IO_ADDR>
        <MEM_ADDR>0x28</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT5>
          <NAME>DDC5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>DDC4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>DDC3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>DDC2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>DDC1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>DDC0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </DDRC>
      <PINC>
        <NAME>PINC</NAME>
        <DESCRIPTION>Port C Input Pins</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x07</IO_ADDR>
        <MEM_ADDR>0x27</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT5>
          <NAME>PINC5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PINC4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PINC3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PINC2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PINC1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PINC0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PINC>
    </PORTC>
    <PORTA>
      <LIST>[PORTCR:PUEA:PORTA:DDRA:PINA]</LIST>
      <LINK/>
      <ICON>io_port.bmp</ICON>
      <ID>AVRSimIOPort.SimIOPort</ID>
      <TEXT/>
      <PORTCR>
        <NAME>PORTCR</NAME>
        <DESCRIPTION>Port Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x13</IO_ADDR>
        <MEM_ADDR>0x33</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT0>
          <NAME>BBMA</NAME>
          <DESCRIPTION>Break-Before-Make Mode Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PORTCR>
      <PUEA>
        <NAME>PUEA</NAME>
        <DESCRIPTION>Pull-up Enable Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x12</IO_ADDR>
        <MEM_ADDR>0x32</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PUEA7</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PUEA6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PUEA5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PUEA4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PUEA3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PUEA2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PUEA1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PUEA0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PUEA>
      <PORTA>
        <NAME>PORTA</NAME>
        <DESCRIPTION>Port A Data Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x11</IO_ADDR>
        <MEM_ADDR>0x31</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PORTA7</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PORTA6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PORTA5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PORTA4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PORTA3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PORTA2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PORTA1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PORTA0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PORTA>
      <DDRA>
        <NAME>DDRA</NAME>
        <DESCRIPTION>Data Direction Register, Port A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x10</IO_ADDR>
        <MEM_ADDR>0x30</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>DDA7</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>DDA6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>DDA5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>DDA4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>DDA3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>DDA2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>DDA1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>DDA0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </DDRA>
      <PINA>
        <NAME>PINA</NAME>
        <DESCRIPTION>Port A Input Pins</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x0F</IO_ADDR>
        <MEM_ADDR>0x2F</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PINA7</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PINA6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PINA5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PINA4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PINA3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PINA2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PINA1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PINA0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PINA>
    </PORTA>
    <AD_CONVERTER>
      <LIST>[ADMUX:ADCSRA:ADCH:ADCL:ADCSRB:DIDR2:DIDR1:DIDR0]</LIST>
      <LINK/>
      <RULES>((IF ADMUX.ADLAR = 1) LINK [ADCH(1:0):ADCL(7:0)]); (IF ADMUX.ADLAR = 0) LINK [ADCH(7:0):ADCL(7:6)]);</RULES>
      <ICON>io_analo.bmp</ICON>
      <ID/>
      <TEXT>AD Converter Feature list: 10-bit Resolution, 1 LSB Integral Non-linearity, &#xB1; 2 LSB Absolute Accuracy, 13&#x3BC;s Conversion Time, 15 kSPS at Maximum Resolution, Eight Multiplexed Single Ended Input Channels, Temperature Sensor Input Channel, Optional Left Adjustment for ADC Result Readout, 0 - VCC ADC Input Voltage Range, 1.1V ADC Reference Voltage, Free Running or Single Conversion Mode, ADC Start Conversion by Auto Triggering on Interrupt Sources, Interrupt on ADC Conversion Complete, Sleep Mode Noise Canceler</TEXT>
      <ADMUX>
        <NAME>ADMUX</NAME>
        <DESCRIPTION>The ADC multiplexer Selection Register</DESCRIPTION>
        <TEXT>These bits select the voltage reference for the ADC, as shown in Table 15-3. If these bits are changed during a conversion, the change will not go in effect until this conversion is complete (ADIF in ADCSR is set). If differential channels are used, the selected reference should not be closer to AV CC than indicated in Table 94 on page 200. The internal voltage reference options may not be used if an external reference voltage is being applied to the AREF pin.</TEXT>
        <IO_ADDR>0x04</IO_ADDR>
        <MEM_ADDR>0x24</MEM_ADDR>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>REFS1</NAME>
          <DESCRIPTION>Reference Selection Bit</DESCRIPTION>
          <TEXT>If this bit is changed during a conversion, the change will not go in effect until this conversion is complete (ADIF in ADCSR is set). Also note, that when these bits are changed, the next conversion will take 25 ADC clock cycles.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>REFS0</NAME>
          <DESCRIPTION>Reference Selection Bit</DESCRIPTION>
          <TEXT>If this bit is changed during a conversion, the change will not go in effect until this conversion is complete (ADIF in ADCSR is set). Also note, that when these bits are changed, the next conversion will take 25 ADC clock cycles.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT3>
          <NAME>MUX3</NAME>
          <DESCRIPTION>Analog Channel and Gain Selection Bits</DESCRIPTION>
          <TEXT>The value of these bits selects which combination of analog inputs are connected to the ADC. These bits also select the gain for the differential channels. See Table 92 for details. If these bits are changed during a conversion, the change will not go in effect until this conversion is complete (ADIF in ADCSR is set).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>MUX2</NAME>
          <DESCRIPTION>Analog Channel and Gain Selection Bits</DESCRIPTION>
          <TEXT>The value of these bits selects which combination of analog inputs are connected to the ADC. These bits also select the gain for the differential channels. See Table 92 for details. If these bits are changed during a conversion, the change will not go in effect until this conversion is complete (ADIF in ADCSR is set).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>MUX1</NAME>
          <DESCRIPTION>Analog Channel and Gain Selection Bits</DESCRIPTION>
          <TEXT>The value of these bits selects which combination of analog inputs are connected to the ADC. These bits also select the gain for the differential channels. See Table 92 for details. If these bits are changed during a conversion, the change will not go in effect until this conversion is complete (ADIF in ADCSR is set).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>MUX0</NAME>
          <DESCRIPTION>Analog Channel and Gain Selection Bits</DESCRIPTION>
          <TEXT>The value of these bits selects which combination of analog inputs are connected to the ADC. These bits also select the gain for the differential channels. See Table 92 for details. If these bits are changed during a conversion, the change will not go in effect until this conversion is complete (ADIF in ADCSR is set).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ADMUX>
      <ADCSRA>
        <NAME>ADCSRA</NAME>
        <DESCRIPTION>The ADC Control and Status register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x03</IO_ADDR>
        <MEM_ADDR>0x23</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>ADEN</NAME>
          <DESCRIPTION>ADC Enable</DESCRIPTION>
          <TEXT>Writing a logical &#x2018;1&#x2019; to this bit enables the ADC. By clearing this bit to zero, the ADC is turned off. Turning the ADC off while a conversion is in progress, will terminate this conversion.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ADSC</NAME>
          <DESCRIPTION>ADC Start Conversion</DESCRIPTION>
          <TEXT>In Single Conversion Mode, a logical &#x2018;1&#x2019; must be written to this bit to start each conversion. In Free Running Mode, a logical &#x2018;1&#x2019; must be written to this bit to start the first conversion. The first time ADSC has been written after the ADC has been enabled, or if ADSC is written at the same time as the ADC is enabled, an extended conversion will result. This extended conversion performs initialization of the ADC. ADSC will read as one as long as a conversion is in progress. When the conversion is complete, it returns to zero. When a dummy conversion precedes a real conversion, ADSC will stay high until the real conversion completes. Writing a 0 to this bit has no effect</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ADATE</NAME>
          <DESCRIPTION>ADC Auto Trigger Enable</DESCRIPTION>
          <TEXT>When this bit is written to one,Auto Triggering of the ADC is enabled.The ADC will start a conversion on a positive edge of the selected trigger signal.The trigger source is selected by setting the ADC Trigger Select bits,ADTS in ADCSRB.     </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ADIF</NAME>
          <DESCRIPTION>ADC Interrupt Flag</DESCRIPTION>
          <TEXT>This bit is set (one) when an ADC conversion completes and the data registers are updated. The ADC Conversion Complete Interrupt is executed if the ADIE bit and the I-bit in SREG are set (one). ADIF is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, ADIF is cleared by writing a logical one to the flag. Beware that if doing a read-modify-write on ADCSR, a pending interrupt can be disabled. This also applies if the SBI and CBI instructions are used.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ADIE</NAME>
          <DESCRIPTION>ADC Interrupt Enable</DESCRIPTION>
          <TEXT>When this bit is set (one) and the I-bit in SREG is set (one), the ADC Conversion Complete Interrupt is activated.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ADPS2</NAME>
          <DESCRIPTION>ADC Prescaler Select Bits</DESCRIPTION>
          <TEXT>These bits determine the division factor between the XTAL frequency and the input clock to the ADC.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ADPS1</NAME>
          <DESCRIPTION>ADC Prescaler Select Bits</DESCRIPTION>
          <TEXT>These bits determine the division factor between the XTAL frequency and the input clock to the ADC.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ADPS0</NAME>
          <DESCRIPTION>ADC Prescaler Select Bits</DESCRIPTION>
          <TEXT>These bits determine the division factor between the XTAL frequency and the input clock to the ADC.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>ANALIG_ADC_PRESCALER</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ADCSRA>
      <ADCH>
        <NAME>ADCH</NAME>
        <DESCRIPTION>ADC Data Register High Byte</DESCRIPTION>
        <TEXT>When an ADC conversion is complete, the result is found in these two registers. If differential channels are used, the result is presented in two&#x2019;s complement form. The selected channel is differential if MUX4..0 are between &#x2018;01000&#x2019; and &#x2018;11101&#x2019;, otherwise the selected channel is single ended. When ADCL is read, the ADC Data Register is not updated until ADCH is read. Consequently, if the result is left adjusted and no more than 8 bit precision (7 bit + sign bit for differential input channels) is required, it is sufficient to read ADCH. Otherwise, ADCL must be read first, then ADCH. The ADLAR bit in ADMUX, and the MUX4..0 bits in ADMUX affect the way the result is read from the registers. If ADLAR is set, the result is left adjusted. If ADLAR is cleared (default), the result is right </TEXT>
        <IO_ADDR>0x01</IO_ADDR>
        <MEM_ADDR>0x21</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>ADCH7</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ADCH6</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ADCH5</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ADCH4</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ADCH3</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ADCH2</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ADCH1</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ADCH0</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ADCH>
      <ADCL>
        <NAME>ADCL</NAME>
        <DESCRIPTION>ADC Data Register Low Byte</DESCRIPTION>
        <TEXT>When an ADC conversion is complete, the result is found in these two registers. If differential channels are used, the result is presented in two&#x2019;s complement form. The selected channel is differential if MUX4..0 are between &#x2018;01000&#x2019; and &#x2018;11101&#x2019;, otherwise the selected channel is single ended. When ADCL is read, the ADC Data Register is not updated until ADCH is read. Consequently, if the result is left adjusted and no more than 8 bit precision (7 bit + sign bit for differential input channels) is required, it is sufficient to read ADCH. Otherwise, ADCL must be read first, then ADCH. The ADLAR bit in ADMUX, and the MUX4..0 bits in ADMUX affect the way the result is read from the registers. If ADLAR is set, the result is left adjusted. If ADLAR is cleared (default), the result is right</TEXT>
        <IO_ADDR>0x00</IO_ADDR>
        <MEM_ADDR>0x20</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>ADCL7</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ADCL6</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ADCL5</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ADCL4</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ADCL3</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ADCL2</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ADCL1</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ADCL0</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ADCL>
      <ADCSRB>
        <NAME>ADCSRB</NAME>
        <DESCRIPTION>ADC Control and Status Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x02</IO_ADDR>
        <MEM_ADDR>0x22</MEM_ADDR>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT3><NAME>ADLAR</NAME><DESCRIPTION/>ADC Left Adjust Result
              <TEXT>The ADLAR bit affects the presentation of the ADC conversion result in the ADC Data Register. Write one to ADLAR to left adjust the result. Otherwise, the result is right adjusted. Changing the ADLAR bit will affect the ADC Data Register immediately, regardless of any ongoing conversions.</TEXT><ACCESS>R</ACCESS><INIT_VAL>0</INIT_VAL></BIT3>
        <BIT2>
          <NAME>ADTS2</NAME>
          <DESCRIPTION>ADC Auto Trigger Source 2</DESCRIPTION>
          <TEXT>If ADATE in ADCSRA is written to one,the value of these bits selects which source will trigger an ADC conversion.If ADATE is cleared,the ADTS2:0 settings will have no effect.A conversion will be triggered by the rising edge of the selected interrupt flag.Note that switching from a trigger source that is cleared to a trigger source that is set,will generate a positive edge on the trigger signal.If ADEN in ADCSRA is set,this will start a conversion.Switching to Free Running Mode (ADTS [2:0 ]=0)will not cause a trigger event,even if the ADC Interrupt Flag is set .   </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ADTS1</NAME>
          <DESCRIPTION>ADC Auto Trigger Source 1</DESCRIPTION>
          <TEXT>If ADATE in ADCSRA is written to one,the value of these bits selects which source will trigger an ADC conversion.If ADATE is cleared,the ADTS2:0 settings will have no effect.A conversion will be triggered by the rising edge of the selected interrupt flag.Note that switching from a trigger source that is cleared to a trigger source that is set,will generate a positive edge on the trigger signal.If ADEN in ADCSRA is set,this will start a conversion.Switching to Free Running Mode (ADTS [2:0 ]=0)will not cause a trigger event,even if the ADC Interrupt Flag is set .    </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ADTS0</NAME>
          <DESCRIPTION>ADC Auto Trigger Source 0</DESCRIPTION>
          <TEXT>If ADATE in ADCSRA is written to one,the value of these bits selects which source will trigger an ADC conversion.If ADATE is cleared,the ADTS2:0 settings will have no effect.A conversion will be triggered by the rising edge of the selected interrupt flag.Note that switching from a trigger source that is cleared to a trigger source that is set,will generate a positive edge on the trigger signal.If ADEN in ADCSRA is set,this will start a conversion.Switching to Free Running Mode (ADTS [2:0 ]=0)will not cause a trigger event,even if the ADC Interrupt Flag is set .   </TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>ANALIG_ADC_AUTO_TRIGGER</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ADCSRB>
      <DIDR2>
        <NAME>DIDR2</NAME>
        <DESCRIPTION>Digital Input Disable Register 2</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x62</MEM_ADDR>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT2>
          <NAME>ADC11D</NAME>
          <DESCRIPTION>ADC11 Digital input Disable</DESCRIPTION>
          <TEXT>When a bit is written logic one, the digital input buffer on the corresponding ADC pin is disabled. The corresponding PIN register bit will always read as zero when this bit is set. When an analog signal is applied to the pin and the digital input from this pin is not needed, this bit should be written logic one to reduce power consumption in the digital input buffer</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ADC10D</NAME>
          <DESCRIPTION>ADC10 Digital input Disable</DESCRIPTION>
          <TEXT>When a bit is written logic one, the digital input buffer on the corresponding ADC pin is disabled. The corresponding PIN register bit will always read as zero when this bit is set. When an analog signal is applied to the pin and the digital input from this pin is not needed, this bit should be written logic one to reduce power consumption in the digital input buffer</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ADC9D</NAME>
          <DESCRIPTION>ADC9 Digital input Disable</DESCRIPTION>
          <TEXT>When a bit is written logic one, the digital input buffer on the corresponding ADC pin is disabled. The corresponding PIN register bit will always read as zero when this bit is set. When an analog signal is applied to the pin and the digital input from this pin is not needed, this bit should be written logic one to reduce power consumption in the digital input buffer</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </DIDR2>
      <DIDR1>
        <NAME>DIDR1</NAME>
        <DESCRIPTION>Digital Input Disable Register 1</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x61</MEM_ADDR>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT3>
          <NAME>ADC8D</NAME>
          <DESCRIPTION>ADC8 Digital Input Disable</DESCRIPTION>
          <TEXT>When a bit is written logic one, the digital input buffer on the corresponding ADC pin is disabled. The corresponding PIN register bit will always read as zero when this bit is set. When an analog signal is applied to the ADC7..0 pin and the digital input from this pin is not needed, this bit should be written logic one to reduce power consumption in the digital input buffer</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ADC7D</NAME>
          <DESCRIPTION>ADC7 Digital input Disable</DESCRIPTION>
          <TEXT>When a bit is written logic one, the digital input buffer on the corresponding ADC pin is disabled. The corresponding PIN register bit will always read as zero when this bit is set. When an analog signal is applied to the pin and the digital input from this pin is not needed, this bit should be written logic one to reduce power consumption in the digital input buffer</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ADC6D</NAME>
          <DESCRIPTION>ADC6 Digital input Disable</DESCRIPTION>
          <TEXT>When a bit is written logic one, the digital input buffer on the corresponding ADC pin is disabled. The corresponding PIN register bit will always read as zero when this bit is set. When an analog signal is applied to the pin and the digital input from this pin is not needed, this bit should be written logic one to reduce power consumption in the digital input buffer</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ADC5D</NAME>
          <DESCRIPTION>ADC5 Digital input Disable</DESCRIPTION>
          <TEXT>When a bit is written logic one, the digital input buffer on the corresponding ADC pin is disabled. The corresponding PIN register bit will always read as zero when this bit is set. When an analog signal is applied to the pin and the digital input from this pin is not needed, this bit should be written logic one to reduce power consumption in the digital input buffer</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </DIDR1>
      <DIDR0>
        <NAME>DIDR0</NAME>
        <DESCRIPTION>Digital Input Disable Register 0</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x60</MEM_ADDR>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>ADC4D</NAME>
          <DESCRIPTION>ADC4 Digital input Disable</DESCRIPTION>
          <TEXT>When a bit is written logic one, the digital input buffer on the corresponding ADC pin is disabled. The corresponding PIN register bit will always read as zero when this bit is set. When an analog signal is applied to the pin and the digital input from this pin is not needed, this bit should be written logic one to reduce power consumption in the digital input buffer</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ADC3D</NAME>
          <DESCRIPTION>ADC3 Digital input Disable</DESCRIPTION>
          <TEXT>When a bit is written logic one, the digital input buffer on the corresponding ADC pin is disabled. The corresponding PIN register bit will always read as zero when this bit is set. When an analog signal is applied to the pin and the digital input from this pin is not needed, this bit should be written logic one to reduce power consumption in the digital input buffer</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ADC2D</NAME>
          <DESCRIPTION>ADC2 Digital input Disable</DESCRIPTION>
          <TEXT>When a bit is written logic one, the digital input buffer on the corresponding ADC pin is disabled. The corresponding PIN register bit will always read as zero when this bit is set. When an analog signal is applied to the pin and the digital input from this pin is not needed, this bit should be written logic one to reduce power consumption in the digital input buffer</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ADC1D</NAME>
          <DESCRIPTION>ADC1 Digital input Disable</DESCRIPTION>
          <TEXT>When a bit is written logic one, the digital input buffer on the corresponding ADC pin is disabled. The corresponding PIN register bit will always read as zero when this bit is set. When an analog signal is applied to the pin and the digital input from this pin is not needed, this bit should be written logic one to reduce power consumption in the digital input buffer</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ADC0D</NAME>
          <DESCRIPTION>ADC0 Digital Input Disable</DESCRIPTION>
          <TEXT>When a bit is written logic one, the digital input buffer on the corresponding ADC pin is disabled. The corresponding PIN register bit will always read as zero when this bit is set. When an analog signal is applied to the pin and the digital input from this pin is not needed, this bit should be written logic one to reduce power consumption in the digital input buffer</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>AIN1D</NAME>
          <DESCRIPTION>AIN1 Digital input Disable</DESCRIPTION>
          <TEXT>When a bit is written logic one, the digital input buffer on the corresponding pin is disabled. The corresponding PIN register bit will always read as zero when this bit is set. When an analog signal is applied to the pin and the digital input from this pin is not needed, this bit should be written logic one to reduce power consumption in the digital input buffer</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>AIN0D</NAME>
          <DESCRIPTION>AIN0 Digital input Disable</DESCRIPTION>
          <TEXT>When a bit is written logic one, the digital input buffer on the corresponding pin is disabled. The corresponding PIN register bit will always read as zero when this bit is set. When an analog signal is applied to the pin and the digital input from this pin is not needed, this bit should be written logic one to reduce power consumption in the digital input buffer</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>AREFD</NAME>
          <DESCRIPTION>AREF Digital input Disable</DESCRIPTION>
          <TEXT>When a bit is written logic one, the digital input buffer on the corresponding pin is disabled. The corresponding PIN register bit will always read as zero when this bit is set. When an analog signal is applied to the pin and the digital input from this pin is not needed, this bit should be written logic one to reduce power consumption in the digital input buffer</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </DIDR0>
    </AD_CONVERTER>
    <ANALOG_COMPARATOR>
      <LIST>[ACSRA:ACSRB]</LIST>
      <LINK/>
      <ICON>io_analo.bmp</ICON>
      <ID>AlgComp_01</ID>
      <TEXT/>
      <ACSRB>
        <NAME>ACSRB</NAME>
        <DESCRIPTION>Analog Comparator Control And Status Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x05</IO_ADDR>
        <MEM_ADDR>0x25</MEM_ADDR>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>HSEL</NAME>
          <DESCRIPTION>Hysteresis Select</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>HLEV</NAME>
          <DESCRIPTION>Hysteresis Level</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT2>
          <NAME>ACME</NAME>
          <DESCRIPTION>Analog Comparator Multiplexer Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
      </ACSRB>
      <ACSRA>
        <NAME>ACSRA</NAME>
        <DESCRIPTION>Analog Comparator Control And Status Register A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x06</IO_ADDR>
        <MEM_ADDR>0x26</MEM_ADDR>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>ACD</NAME>
          <DESCRIPTION>Analog Comparator Disable</DESCRIPTION>
          <TEXT>When this bit is written logic one, the power to the analog comparator is switched off. This bit can be set at any time to turn off the analog comparator. This will reduce power consumption in active and idle mode. When changing the ACD bit, the Analog Comparator Interrupt must be disabled by clearing the ACIE bit in ACSR. Otherwise an interrupt can occur when the bit is changed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ACBG</NAME>
          <DESCRIPTION>Analog Comparator Bandgap Select</DESCRIPTION>
          <TEXT>When this bit is set, a fixed bandgap reference voltage replaces the positive input to the Analog Comparator. When this bit is cleared, AIN0 is applied to the positive input of the Analog Comparator. See &#x201C;Internal Voltage Reference&#x201D; on page 42.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ACO</NAME>
          <DESCRIPTION>Analog Compare Output</DESCRIPTION>
          <TEXT>The output of the analog comparator is synchronized and then directly connected to ACO. The synchronization introduces a delay of 1-2 clock cycles.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>NA</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ACI</NAME>
          <DESCRIPTION>Analog Comparator Interrupt Flag</DESCRIPTION>
          <TEXT>This bit is set by hardware when a comparator output event triggers the interrupt mode defined by ACIS1 and ACIS0. The Analog Comparator Interrupt routine is executed if the ACIE bit is set and the I-bit in SREG is set. ACI is cleared by hard-ware when executing the corresponding interrupt handling vector. Alternatively, ACI is cleared by writing a logic one to the flag.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ACIE</NAME>
          <DESCRIPTION>Analog Comparator Interrupt Enable</DESCRIPTION>
          <TEXT>When the ACIE bit is written logic one and the I-bit in the Status Register is set, the analog comparator interrupt is acti-vated. When written logic zero, the interrupt is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ACIC</NAME>
          <DESCRIPTION>Analog Comparator Input Capture Enable</DESCRIPTION>
          <TEXT>When written logic one, this bit enables the input capture function in Timer/Counter1 to be triggered by the Analog Comparator. The comparator output is then directly connected to the input capture front-end logic, making the comparator utilize the noise canceler and edge select features of the Timer/Counter1 Input Capture interrupt. When written logic zero, no connection between the Analog Comparator and the input capture function exists. To make the comparator trigger the Timer/Counter1 Input Capture inter-rupt, the ICIE1 bit in the Timer Interrupt Mask Register (TIMSK1) must be set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ACIS1</NAME>
          <DESCRIPTION>Analog Comparator Interrupt Mode Select bit 1</DESCRIPTION>
          <TEXT>These bits determine which comparator events that trigger the Analog Comparator interrupt.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ACIS0</NAME>
          <DESCRIPTION>Analog Comparator Interrupt Mode Select bit 0</DESCRIPTION>
          <TEXT>These bits determine which comparator events that trigger the Analog Comparator interrupt.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>ANALOG_COMP_INTERRUPT</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ACSRA>
    </ANALOG_COMPARATOR>
    <EEPROM>
      <LIST>[EEAR:EEDR:EECR]</LIST>
      <LINK/>
      <ICON>io_cpu.bmp</ICON>
      <ID>EEPROM_tiny1634.xml</ID>
      <TEXT/>
      <EEAR>
        <NAME>EEAR</NAME>
        <ALIAS>EEARL</ALIAS>
        <DESCRIPTION>EEPROM Read/Write Access</DESCRIPTION>
        <TEXT>The EEPROM access register is accessible in the I/O space. The write access time is in the range of 2.5 - 4ms, depending on the V CC voltages. A self-timing function, however, lets the user software detect when the next byte can be written. If the user code contains code that writes the EEPROM, some pre-caution must be taken. In heavily filtered power supplies, V CC is likely to rise or fall slowly on power-up/down. This causes the device for some period of time to run at a voltage lower than specified as minimum for the clock frequency used. CPU operation under these conditions is likely cause the program counter to perform unintentional jumps and eventually execute the EEPROM write code. To secure EEPROM integrity, the user is advised to use an external under-voltage reset circuit in this case. In order to prevent unintentional EEPROM writes, a specific write procedure must be followed. Refer to the description of the EEPROM Control Register for details on this. When the EEPROM is written, the CPU is halted for two clock cycles before the next instruction is executed. When the EEPROM is read, the CPU is halted for four clock cycles before the next instruction</TEXT>
        <IO_ADDR>0x1E</IO_ADDR>
        <MEM_ADDR>0x3E</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>EEAR7</NAME>
          <DESCRIPTION>EEPROM Read/Write Access bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>EEAR6</NAME>
          <DESCRIPTION>EEPROM Read/Write Access bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>EEAR5</NAME>
          <DESCRIPTION>EEPROM Read/Write Access bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>EEAR4</NAME>
          <DESCRIPTION>EEPROM Read/Write Access bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>EEAR3</NAME>
          <DESCRIPTION>EEPROM Read/Write Access bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>EEAR2</NAME>
          <DESCRIPTION>EEPROM Read/Write Access bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>EEAR1</NAME>
          <DESCRIPTION>EEPROM Read/Write Access bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>EEAR0</NAME>
          <DESCRIPTION>EEPROM Read/Write Access bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </EEAR>
      <EEDR>
        <NAME>EEDR</NAME>
        <DESCRIPTION>EEPROM Data Register</DESCRIPTION>
        <TEXT>For the EEPROM write operation, the EEDR register contains the data to be written to the EEPROM in the address given by the EEAR register. For the EEPROM read operation, the EEDR contains the data read out from the EEPROM at the address given by EEAR.</TEXT>
        <IO_ADDR>0x1D</IO_ADDR>
        <MEM_ADDR>0x3D</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>EEDR7</NAME>
          <DESCRIPTION>EEPROM Data Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>EEDR6</NAME>
          <DESCRIPTION>EEPROM Data Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>EEDR5</NAME>
          <DESCRIPTION>EEPROM Data Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>EEDR4</NAME>
          <DESCRIPTION>EEPROM Data Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>EEDR3</NAME>
          <DESCRIPTION>EEPROM Data Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>EEDR2</NAME>
          <DESCRIPTION>EEPROM Data Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>EEDR1</NAME>
          <DESCRIPTION>EEPROM Data Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>EEDR0</NAME>
          <DESCRIPTION>EEPROM Data Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </EEDR>
      <EECR>
        <NAME>EECR</NAME>
        <DESCRIPTION>EEPROM Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x1C</IO_ADDR>
        <MEM_ADDR>0x3C</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT5>
          <NAME>EEPM1</NAME>
          <DESCRIPTION>EEPROM Programming Mode Bit 1</DESCRIPTION>
          <TEXT>The EEPROM Programming mode bit setting defines which programming action that will be triggered when writing EEPE. It is possible to program data in one atomic operation (erase the old value and program the new value) or to split the Erase and Write operations in two different operations. The Programming times for the different modes are shown in Table 2. While EEPE is set, any write to EEPMn will be ignored. During reset, the EEPMn bits will be reset to 0b00 unless the EEPROM is busy programming.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>EEPM0</NAME>
          <DESCRIPTION>EEPROM Programming Mode Bit 0</DESCRIPTION>
          <TEXT>The EEPROM Programming mode bit setting defines which programming action that will be triggered when writing EEPE. It is possible to program data in one atomic operation (erase the old value and program the new value) or to split the Erase and Write operations in two different operations. The Programming times for the different modes are shown in Table 2. While EEPE is set, any write to EEPMn will be ignored. During reset, the EEPMn bits will be reset to 0b00 unless the EEPROM is busy programming.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>EEP_MODE</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>EERIE</NAME>
          <DESCRIPTION>EEProm Ready Interrupt Enable</DESCRIPTION>
          <TEXT>When the I-bit in SREG and EERIE are set (one), the EEPROM Ready Interrupt is enabled. When cleared (zero), the interrupt is disabled. The EEPROM Ready Interrupt generates a constant interrupt when EEWE is cleared (zero).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>EEMPE</NAME>
          <ALIAS>EEMWE</ALIAS>
          <DESCRIPTION>EEPROM Master Write Enable</DESCRIPTION>
          <TEXT>The EEMWE bit determines whether setting EEWE to one causes the EEPROM to be written. When EEMWE is set(one) setting EEWE will write data to the EEPROM at the selected address If EEMWE is zero, setting EEWE will have no effect. When EEMWE has been set (one) by software, hardware clears the bit to zero after four clock cycles. See the description of the EEWE bit for a EEPROM write procedure.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>EEPE</NAME>
          <ALIAS>EEWE</ALIAS>
          <DESCRIPTION>EEPROM Write Enable</DESCRIPTION>
          <TEXT>The EEPROM Write Enable Signal EEWE is the write strobe to the EEPROM. When address and data are correctly set up, the EEWE bit must be set to write the value into the EEPROM. The EEMWE bit must be set when the logical one is written to EEWE, otherwise no EEPROM write takes place. The following procedure should be followed when writing the EEPROM (the order of steps 2 and 3 is unessential): 1. Wait until EEWE becomes zero. 2. Write new EEPROM address to EEARL and EEARH (optional). 3. Write new EEPROM data to EEDR (optional). 4. Write a logical one to the EEMWE bit in EECR (to be able to write a logical one to the EEMWE bit, the EEWE bit mustbewritten to zero in thesamecycle). 5. Within four clock cycles after setting EEMWE, write a logical one to EEWE. When the write access time (typically 2.5 ms at V CC =5Vor 4msatV CC = 2.7V) has elapsed, the EEWE bit is cleared (zero) by hardware. The user software can poll this bit and wait for a zero before writing the next byte. When EEWE has been set, the CPU is halted or two cycles before the next instruction is executed. Caution: An interrupt between step 4 and step 5 will make the write cycle fail, since the EEPROM Master Write Enable will time-out. If an interrupt routine accessing the EEPROM is interrupting another EEPROM access, the EEAR or EEDR regis-ter will be modified, causing the interrupted EEPROM access to fail. It is recommended to have the global interrupt flag cleared during the 4 last steps to avoid these problems.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>EERE</NAME>
          <DESCRIPTION>EEPROM Read Enable</DESCRIPTION>
          <TEXT>The EEPROM Read Enable Signal EERE is the read strobe to the EEPROM. When the correct address is set up in the EEAR register, the EERE bit must be set. When the EERE bit is cleared (zero) by hardware, requested data is found in the EEDR register. The EEPROM read access takes one instruction and there is no need to poll the EERE bit. When EERE has been set, the CPU is halted for four cycles before the next instruction is executed. The user should poll the EEWE bit before starting the read operation. If a write operation is in progress when new data or address is written to the EEPROM I/O registers, the write operation will be interrupted, and the result is undefined.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </EECR>
    </EEPROM>
    <TIMER_COUNTER_1>
      <LIST>[TIMSK:TIFR:TCCR1A:TCCR1B:TCCR1C:TCNT1H:TCNT1L:OCR1AH:OCR1AL:OCR1BH:OCR1BL:ICR1H:ICR1L]</LIST>
      <LINK>[TCNT1H:TCNT1L];[OCR1AH:OCR1AL];[OCR1BH:OCR1BL];[ICR1H:ICR1L]</LINK>
      <ICON>io_timer.bmp</ICON>
      <ID>t16pwm1_13.xml</ID>
      <TEXT/>
      <TIMSK>
        <NAME>TIMSK</NAME>
        <DESCRIPTION>Timer/Counter Interrupt Mask Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x3A</IO_ADDR>
        <MEM_ADDR>0x5A</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>TOIE1</NAME>
          <DESCRIPTION>Timer/Counter1 Overflow Interrupt Enable</DESCRIPTION>
          <TEXT>When the TOIE1 bit is set (one) and the I-bit in the Status Register is set (one), the Timer/Counter1 Overflow interrupt is enabled. The corresponding interrupt  is executed if an overflow in Timer/Counter1 occurs, i.e., when the TOV1 bit is set in the Timer/Counter Interrupt Flag Register - TIFR.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCIE1A</NAME>
          <DESCRIPTION>Timer/Counter1 Output CompareA Match Interrupt Enable</DESCRIPTION>
          <TEXT>When the OCIE1A bit is set (one) and the I-bit in the Status Register is set (one), the Timer/Counter1 CompareA Match interrupt is enabled. The corresponding interrupt (at vector $004) is executed if a CompareA match in Timer/Counter1 occurs, i.e., when the OCF1A bit is set in the Timer/Counter Interrupt Flag Register - TIFR.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCIE1B</NAME>
          <DESCRIPTION>Timer/Counter1 Output CompareB Match Interrupt Enable</DESCRIPTION>
          <TEXT>When the OCIE1B bit is set (one) and the I-bit in the Status Register is set (one), the Timer/Counter1 CompareB Match interrupt is enabled. The corresponding interrupt  is executed if a CompareB match in Timer/Counter1 occurs, i.e., when the OCF1B bit is set in the Timer/Counter Interrupt Flag Register - TIFR.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT3>
          <NAME>ICIE1</NAME>
          <ALIAS>TICIE</ALIAS>
          <DESCRIPTION>Timer/Counter1 Input Capture Interrupt Enable</DESCRIPTION>
          <TEXT>When the TICIE1 bit is set (one) and the I-bit in the Status Register is set (one), the Timer/Counter1 Input Capture Event Interrupt is enabled. The corresponding interrupt (at vector $003) is executed if a capture-triggering event occurs on pin  ICP, i.e., when the ICF1 bit is set in the Timer/Counter Interrupt Flag Register - TIFR.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
      </TIMSK>
      <TIFR>
        <NAME>TIFR</NAME>
        <DESCRIPTION>Timer/Counter Interrupt Flag register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x39</IO_ADDR>
        <MEM_ADDR>0x59</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>TOV1</NAME>
          <DESCRIPTION>Timer/Counter1 Overflow Flag</DESCRIPTION>
          <TEXT>The TOV1 is set (one) when an overflow occurs in Timer/Counter1. TOV1 is cleared by hardware when executing the cor-responding interrupt handling vector. Alternatively, TOV1 is cleared by writing a logic one to the flag. When the I-bit in SREG, and TOIE1 (Timer/Counter1 Overflow Interrupt Enable), and TOV1 are set (one), the Timer/Counter1 Overflow Interrupt is executed. In PWM mode, this bit is set when Timer/Counter1 changes counting direction at $0000.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCF1A</NAME>
          <DESCRIPTION>Output Compare Flag 1A</DESCRIPTION>
          <TEXT>The OCF1A bit is set (one) when compare match occurs between the Timer/Counter1 and the data in OCR1A - Output Compare Register 1A. OCF1A is cleared by hardware when executing the corresponding interrupt handling vector. Alterna-tively, OCF1A is cleared by writing a logic one to the flag. When the I-bit in SREG, and OCIE1A (Timer/Counter1 Compare match InterruptA Enable), and the OCF1A are set (one), the Timer/Counter1 Compare A match Interrupt is executed. </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCF1B</NAME>
          <DESCRIPTION>Output Compare Flag 1B</DESCRIPTION>
          <TEXT>The OCF1B bit is set (one) when compare match occurs between the Timer/Counter1 and the data in OCR1B - Output Compare Register 1B. OCF1B is cleared by hardware when executing the corresponding interrupt handling vector. Alterna-tively, OCF1B is cleared by writing a logic one to the flag. When the I-bit in SREG, and OCIE1A (Timer/Counter1 Compare match InterruptB Enable), and the OCF1B are set (one), the Timer/Counter1 Compare B match Interrupt is executed. </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT3>
          <NAME>ICF1</NAME>
          <DESCRIPTION>Input Capture Flag 1</DESCRIPTION>
          <TEXT>The ICF1 bit is set (one) to flag an input capture event, indicating that the Timer/Counter1 value has been transferred to the input capture register - ICR1. ICF1 is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, ICF1 is cleared by writing a logic one to the flag. When the SREG I-bit, and TICIE1 (Timer/Counter1 Input Capture Interrupt Enable), and ICF1 are set (one), the Timer/Counter1 Capture Interrupt is executed. </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
      </TIFR>
      <TCCR1A>
        <NAME>TCCR1A</NAME>
        <DESCRIPTION>Timer/Counter1 Control Register A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x72</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>COM1A1</NAME>
          <DESCRIPTION>Compare Output Mode 1A, bit 1</DESCRIPTION>
          <TEXT>The COM1A1 and COM1A0 control bits determine any output pin action following a compare match in Timer/Counter1. Any output pin actions affect pin OC1A - Output CompareA pin 1. This is an alternative function to an I/O port and the corresponding direction control bit must be set (one) to control the output pin. The control configuration is shown in the databook. </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>COM1A0</NAME>
          <DESCRIPTION>Comparet Ouput Mode 1A, bit 0</DESCRIPTION>
          <TEXT>The COM1A1 and COM1A0 control bits determine any output pin action following a compare match in Timer/Counter1. Any output pin actions affect pin OC1A - Output CompareA pin 1. This is an alternative function to an I/O port and the corresponding direction control bit must be set (one) to control the output pin. The control configuration is shown in the databook. </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>COM1B1</NAME>
          <DESCRIPTION>Compare Output Mode 1B, bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>COM1B0</NAME>
          <DESCRIPTION>Comparet Ouput Mode 1B, bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT1>
          <NAME>WGM11</NAME>
          <ALIAS>PWM11</ALIAS>
          <DESCRIPTION>Pulse Width Modulator Select Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>WGM10</NAME>
          <ALIAS>PWM10</ALIAS>
          <DESCRIPTION>Pulse Width Modulator Select Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCCR1A>
      <TCCR1B>
        <NAME>TCCR1B</NAME>
        <DESCRIPTION>Timer/Counter1 Control Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x71</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>ICNC1</NAME>
          <DESCRIPTION>Input Capture 1 Noise Canceler</DESCRIPTION>
          <TEXT>When the ICNC1 bit is cleared (zero), the input capture trigger noise canceler function is disabled. The input capture is triggered at the first rising/falling edge sampled on the ICP - input capture pin - as specified. When the ICNC1 bit is set (one), four successive samples are measures on the ICP - input capture pin, and all samples must be high/low according to the input capture trigger specification in the ICES1 bit. The actual sampling frequency is XTAL clock frequency.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ICES1</NAME>
          <DESCRIPTION>Input Capture 1 Edge Select</DESCRIPTION>
          <TEXT>While the ICES1 bit is cleared (zero), the Timer/Counter1 contents are transferred to the Input Capture Register - ICR1 - on the falling edge of the input capture pin - ICP. While the ICES1 bit is set (one), the Timer/Counter1 contents are transferred to the Input Capture Register - ICR1 - on the rising edge of the input capture pin - ICP.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT4>
          <NAME>WGM13</NAME>
          <DESCRIPTION>Waveform Generation Mode Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>WGM12</NAME>
          <ALIAS>CTC1</ALIAS>
          <DESCRIPTION>Waveform Generation Mode Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CS12</NAME>
          <DESCRIPTION>Clock Select1 bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CS11</NAME>
          <DESCRIPTION>Clock Select 1 bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CS10</NAME>
          <DESCRIPTION>Clock Select bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <ENUM>CLK_SEL_3BIT_EXT</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCCR1B>
      <TCCR1C>
        <NAME>TCCR1C</NAME>
        <DESCRIPTION>Timer/Counter1 Control Register C</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x70</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>FOC1A</NAME>
          <DESCRIPTION>Force Output Compare for Channel A</DESCRIPTION>
          <TEXT>The FOC1A/FOC1B bits are only active when the WGM13:0 bits specifies a non-PWM mode. However, for ensuring compatibility with future devices, these bits must be set to zero when TCCR1A is written when operating in a PWM mode. When writing a logical one to the FOC1A/FOC1B bit, an immediate compare match is forced on the Waveform Generation unit. The OC1A/OC1B output is changed according to its COM1x1:0 bits setting. Note that the FOC1A/FOC1B bits are implemented as strobes. Therefore it is the value present in the COM1x1:0 bits that determine the effect of the forced compare. A FOC1A/FOC1B strobe will not generate any interrupt nor will it clear the timer in Clear Timer on Compare match (CTC) mode using OCR1A as TOP. The FOC1A/FOC1B bits are always read as zero</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>FOC1B</NAME>
          <DESCRIPTION>Force Output Compare for Channel B</DESCRIPTION>
          <TEXT>The FOC1A/FOC1B bits are only active when the WGM13:0 bits specifies a non-PWM mode. However, for ensuring compatibility with future devices, these bits must be set to zero when TCCR1A is written when operating in a PWM mode. When writing a logical one to the FOC1A/FOC1B bit, an immediate compare match is forced on the Waveform Generation unit. The OC1A/OC1B output is changed according to its COM1x1:0 bits setting. Note that the FOC1A/FOC1B bits are implemented as strobes. Therefore it is the value present in the COM1x1:0 bits that determine the effect of the forced compare. A FOC1A/FOC1B strobe will not generate any interrupt nor will it clear the timer in Clear Timer on Compare match (CTC) mode using OCR1A as TOP. The FOC1A/FOC1B bits are always read as zero</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
      </TCCR1C>
      <TCNT1H>
        <NAME>TCNT1H</NAME>
        <DESCRIPTION>Timer/Counter1 High Byte</DESCRIPTION>
        <TEXT>This 16-bit register contains the prescaled value of the 16-bit Timer/Counter1. To ensure that both the high and low bytes are read and written simultaneously when the CPU accesses these registers, the access is performed using an 8-bit temporary register (TEMP). This temporary register is also used when accessing OCR1A, OCR1B and ICR1. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within interrupt ro</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x6F</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TCNT1H7</NAME>
          <DESCRIPTION>Timer/Counter1 High Byte bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TCNT1H6</NAME>
          <DESCRIPTION>Timer/Counter1 High Byte bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TCNT1H5</NAME>
          <DESCRIPTION>Timer/Counter1 High Byte bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TCNT1H4</NAME>
          <DESCRIPTION>Timer/Counter1 High Byte bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TCNT1H3</NAME>
          <DESCRIPTION>Timer/Counter1 High Byte bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TCNT1H2</NAME>
          <DESCRIPTION>Timer/Counter1 High Byte bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TCNT1H1</NAME>
          <DESCRIPTION>Timer/Counter1 High Byte bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TCNT1H0</NAME>
          <DESCRIPTION>Timer/Counter1 High Byte bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCNT1H>
      <TCNT1L>
        <NAME>TCNT1L</NAME>
        <DESCRIPTION>Timer/Counter1 Low Byte</DESCRIPTION>
        <TEXT>This 16-bit register contains the prescaled value of the 16-bit Timer/Counter1. To ensure that both the high and low bytes are read and written simultaneously when the CPU accesses these registers, the access is performed using an 8-bit temporary register (TEMP). This temporary register is also used when accessing OCR1A, OCR1B and ICR1. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within interrup</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x6E</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TCNT1L7</NAME>
          <DESCRIPTION>Timer/Counter1 Low Byte bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TCNT1L6</NAME>
          <DESCRIPTION>Timer/Counter1 Low Byte bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TCNT1L5</NAME>
          <DESCRIPTION>Timer/Counter1 Low Byte bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TCNT1L4</NAME>
          <DESCRIPTION>Timer/Counter1 Low Byte bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TCNT1L3</NAME>
          <DESCRIPTION>Timer/Counter1 Low Byte bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TCNT1L2</NAME>
          <DESCRIPTION>Timer/Counter1 Low Byte bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TCNT1L1</NAME>
          <DESCRIPTION>Timer/Counter1 Low Byte bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TCNT1L0</NAME>
          <DESCRIPTION>Timer/Counter1 Low Byte bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCNT1L>
      <OCR1AH>
        <NAME>OCR1AH</NAME>
        <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte</DESCRIPTION>
        <TEXT>The output compare registers are 16-bit read/write registers. The Timer/Counter1 Output Compare Registers contain the data to be continuously compared with Timer/Counter1. Actions on compare matches are specified in the Timer/Counter1 Control and Status register.A compare match does only occur if Timer/Counter1 counts to the OCR value. A software write that sets TCNT1 and OCR1A or OCR1B to the same value does not generate a compare match. A compare match will set the compare interrupt flag in the CPU clock cycle following the compare event. Since the Output Compare Registers - OCR1A and OCR1B - are 16-bit registers, a temporary register TEMP is used when OCR1A/B are written to ensure that both bytes are updated simultaneously. When the CPU writes the high byte, OCR1AH or OCR1BH, the data is temporarily stored in the TEMP register. When the CPU writes the low byte, OCR1AL or OCR1BL, the TEMP register is simultaneously written to OCR1AH or OCR1BH. Consequently, the high byte OCR1AH or OCR1BH must be written first for a full 16-bit register write operation. The TEMP register is also used when accessing TCNT1, and ICR1. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within interrupt</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x6D</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR1AH7</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR1AH6</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR1AH5</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR1AH4</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR1AH3</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR1AH2</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR1AH1</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR1AH0</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCR1AH>
      <OCR1AL>
        <NAME>OCR1AL</NAME>
        <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte</DESCRIPTION>
        <TEXT>The output compare registers are 16-bit read/write registers. The Timer/Counter1 Output Compare Registers contain the data to be continuously compared with Timer/Counter1. Actions on compare matches are specified in the Timer/Counter1 Control and Status register.A compare match does only occur if Timer/Counter1 counts to the OCR value. A software write that sets TCNT1 and OCR1A or OCR1B to the same value does not generate a compare match. A compare match will set the compare interrupt flag in the CPU clock cycle following the compare event. Since the Output Compare Registers - OCR1A and OCR1B - are 16-bit registers, a temporary register TEMP is used when OCR1A/B are written to ensure that both bytes are updated simultaneously. When the CPU writes the high byte, OCR1AH or OCR1BH, the data is temporarily stored in the TEMP register. When the CPU writes the low byte, OCR1AL or OCR1BL, the TEMP register is simultaneously written to OCR1AH or OCR1BH. Consequently, the high byte OCR1AH or OCR1BH must be written first for a full 16-bit register write operation. The TEMP register is also used when accessing TCNT1, and ICR1. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within interru</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x6C</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR1AL7</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte Bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR1AL6</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR1AL5</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR1AL4</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR1AL3</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR1AL2</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR1AL1</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR1AL0</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCR1AL>
      <OCR1BH>
        <NAME>OCR1BH</NAME>
        <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte</DESCRIPTION>
        <TEXT>The output compare registers are 16-bit read/write registers. The Timer/Counter1 Output Compare Registers contain the data to be continuously compared with Timer/Counter1. Actions on compare matches are specified in the Timer/Counter1 Control and Status register.A compare match does only occur if Timer/Counter1 counts to the OCR value. A software write that sets TCNT1 and OCR1A or OCR1B to the same value does not generate a compare match. A compare match will set the compare interrupt flag in the CPU clock cycle following the compare event. Since the Output Compare Registers - OCR1A and OCR1B - are 16-bit registers, a temporary register TEMP is used when OCR1A/B are written to ensure that both bytes are updated simultaneously. When the CPU writes the high byte, OCR1AH or OCR1BH, the data is temporarily stored in the TEMP register. When the CPU writes the low byte, OCR1AL or OCR1BL, the TEMP register is simultaneously written to OCR1AH or OCR1BH. Consequently, the high byte OCR1AH or OCR1BH must be written first for a full 16-bit register write operation. The TEMP register is also used when accessing TCNT1, and ICR1. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within interrup</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x6B</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR1BH7</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR1BH6</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR1BH5</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR1BH4</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR1BH3</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR1BH2</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR1BH1</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR1BH0</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCR1BH>
      <OCR1BL>
        <NAME>OCR1BL</NAME>
        <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte</DESCRIPTION>
        <TEXT>The output compare registers are 16-bit read/write registers. The Timer/Counter1 Output Compare Registers contain the data to be continuously compared with Timer/Counter1. Actions on compare matches are specified in the Timer/Counter1 Control and Status register.A compare match does only occur if Timer/Counter1 counts to the OCR value. A software write that sets TCNT1 and OCR1A or OCR1B to the same value does not generate a compare match. A compare match will set the compare interrupt flag in the CPU clock cycle following the compare event. Since the Output Compare Registers - OCR1A and OCR1B - are 16-bit registers, a temporary register TEMP is used when OCR1A/B are written to ensure that both bytes are updated simultaneously. When the CPU writes the high byte, OCR1AH or OCR1BH, the data is temporarily stored in the TEMP register. When the CPU writes the low byte, OCR1AL or OCR1BL, the TEMP register is simultaneously written to OCR1AH or OCR1BH. Consequently, the high byte OCR1AH or OCR1BH must be written first for a full 16-bit register write operation. The TEMP register is also used when accessing TCNT1, and ICR1. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within interru</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x6A</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR1BL7</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte Bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR1BL6</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR1BL5</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR1BL4</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR1BL3</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR1BL2</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR1BL1</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR1BL0</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCR1BL>
      <ICR1H>
        <NAME>ICR1H</NAME>
        <DESCRIPTION>Timer/Counter1 Input Capture Register High Byte</DESCRIPTION>
        <TEXT>The input capture register is a 16-bit read-only register. When the rising or falling edge (according to the input capture edge setting - ICES1) of the signal at the input capture pin -ICP - is detected, the current value of the Timer/Counter1 is transferred to the Input Capture Register - ICR1. At the same time, the input capture flag - ICF1 - is set (one). Since the Input Capture Register - ICR1 - is a 16-bit register, a temporary register TEMP is used when ICR1 is read to ensure that both bytes are read simultaneously. When the CPU reads the low byte ICR1L, the data is sent to the CPU and the data of the high byte ICR1H is placed in the TEMP register. When the CPU reads the data in the high byte ICR1H, the CPU receives the data in the TEMP register. Consequently, the low byte ICR1L must be accessed first for a full 16-bit register read operation. The TEMP register is also used when accessing TCNT1, OCR1A and OCR1B. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within interrup</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x69</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>ICR1H7</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register High Byte bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ICR1H6</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register High Byte bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ICR1H5</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register High Byte bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ICR1H4</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register High Byte bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ICR1H3</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register High Byte bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ICR1H2</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register High Byte bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ICR1H1</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register High Byte bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ICR1H0</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register High Byte bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ICR1H>
      <ICR1L>
        <NAME>ICR1L</NAME>
        <DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte</DESCRIPTION>
        <TEXT>The input capture register is a 16-bit read-only register. When the rising or falling edge (according to the input capture edge setting - ICES1) of the signal at the input capture pin -ICP - is detected, the current value of the Timer/Counter1 is transferred to the Input Capture Register - ICR1. At the same time, the input capture flag - ICF1 - is set (one). Since the Input Capture Register - ICR1 - is a 16-bit register, a temporary register TEMP is used when ICR1 is read to ensure that both bytes are read simultaneously. When the CPU reads the low byte ICR1L, the data is sent to the CPU and the data of the high byte ICR1H is placed in the TEMP register. When the CPU reads the data in the high byte ICR1H, the CPU receives the data in the TEMP register. Consequently, the low byte ICR1L must be accessed first for a full 16-bit register read operation. The TEMP register is also used when accessing TCNT1, OCR1A and OCR1B. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within inte</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x68</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>ICR1L7</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ICR1L6</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ICR1L5</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ICR1L4</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ICR1L3</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ICR1L2</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ICR1L1</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ICR1L0</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ICR1L>
    </TIMER_COUNTER_1>
    <TIMER_COUNTER_0>
      <LIST>[TIMSK:TIFR:OCR0B:OCR0A:TCCR0A:TCNT0:TCCR0B]</LIST>
      <LINK/>
      <ICON>io_timer.bmp</ICON>
      <ID>At8pwm0_11</ID>
      <TEXT/>
      <TIMSK>
        <NAME>TIMSK</NAME>
        <DESCRIPTION>Timer/Counter Interrupt Mask Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x3A</IO_ADDR>
        <MEM_ADDR>0x5A</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT2>
          <NAME>OCIE0B</NAME>
          <DESCRIPTION>Timer/Counter0 Output Compare Match B Interrupt Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TOIE0</NAME>
          <DESCRIPTION>Timer/Counter0 Overflow Interrupt Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCIE0A</NAME>
          <DESCRIPTION>Timer/Counter0 Output Compare Match A Interrupt Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TIMSK>
      <TIFR>
        <NAME>TIFR</NAME>
        <DESCRIPTION>Timer/Counter Interrupt Flag register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x39</IO_ADDR>
        <MEM_ADDR>0x59</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT2>
          <NAME>OCF0B</NAME>
          <DESCRIPTION>Timer/Counter0 Output Compare Flag 0B</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TOV0</NAME>
          <DESCRIPTION>Timer/Counter0 Overflow Flag</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCF0A</NAME>
          <DESCRIPTION>Timer/Counter0 Output Compare Flag 0A</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TIFR>
      <OCR0B>
        <NAME>OCR0B</NAME>
        <DESCRIPTION>Timer/Counter0 Output Compare Register</DESCRIPTION>
        <TEXT>The Output Compare Register contains an 8-bit value that is continuously compared with the counter value (TCNT0). A match can be used to generate an output compare interrupt, or to generate a waveform output on the OC0 pin.</TEXT>
        <IO_ADDR>0x17</IO_ADDR>
        <MEM_ADDR>0x37</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR0_7</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR0_6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR0_5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR0_4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR0_3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR0_2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR0_1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR0_0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCR0B>
      <OCR0A>
        <NAME>OCR0A</NAME>
        <DESCRIPTION>Timer/Counter0 Output Compare Register</DESCRIPTION>
        <TEXT>The Output Compare Register contains an 8-bit value that is continuously compared with the counter value (TCNT0). A match can be used to generate an output compare interrupt, or to generate a waveform output on the OC0 pin.</TEXT>
        <IO_ADDR>0x18</IO_ADDR>
        <MEM_ADDR>0x38</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR0A_7</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR0A_6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR0A_5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR0A_4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR0A_3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR0A_2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR0A_1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR0A_0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCR0A>
      <TCCR0A>
        <NAME>TCCR0A</NAME>
        <DESCRIPTION>Timer/Counter  Control Register A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x1B</IO_ADDR>
        <MEM_ADDR>0x3B</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>COM0A1</NAME>
          <DESCRIPTION>Compare Match Output A Mode</DESCRIPTION>
          <TEXT>Controls Output Compare Pin A behaviour. Please refer to datasheet.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>COM0A0</NAME>
          <DESCRIPTION>Compare Match Output A Mode</DESCRIPTION>
          <TEXT>Controls Output Compare Pin A behaviour. Please refer to datasheet.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>COM0B1</NAME>
          <DESCRIPTION>Compare Match Output B Mode</DESCRIPTION>
          <TEXT>Controls Output Compare Pin B behaviour. Please refer to datasheet.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>COM0B0</NAME>
          <DESCRIPTION>Compare Match Output B Mode</DESCRIPTION>
          <TEXT>Controls Output Compare Pin B behaviour. Please refer to datasheet.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT1>
          <NAME>WGM01</NAME>
          <DESCRIPTION>Waveform Generation Mode</DESCRIPTION>
          <TEXT>Controls the Waveform Generation Mode, please refer to datasheet for further details.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>WGM00</NAME>
          <DESCRIPTION>Waveform Generation Mode</DESCRIPTION>
          <TEXT>Controls the Waveform Generation Mode, please refer to datasheet for further details.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCCR0A>
      <TCNT0>
        <NAME>TCNT0</NAME>
        <DESCRIPTION>Timer/Counter0</DESCRIPTION>
        <TEXT>The Timer/Counter Register gives direct access, both for read and write operations, to the Timer/Counter unit 8-bit counter. Writing to the TCNT0 register blocks (removes) the compare match on the following timer clock. Modifying the counter (TCNT0) while the counter is running, introduces a risk of missing a compare match between TCNT0 the OCR0 register.</TEXT>
        <IO_ADDR>0x19</IO_ADDR>
        <MEM_ADDR>0x39</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TCNT0_7</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TCNT0_6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TCNT0_5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TCNT0_4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TCNT0_3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TCNT0_2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TCNT0_1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TCNT0_0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCNT0>
      <TCCR0B>
        <NAME>TCCR0B</NAME>
        <ALIAS>TCCR0</ALIAS>
        <DESCRIPTION>Timer/Counter Control Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x1A</IO_ADDR>
        <MEM_ADDR>0x3A</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>FOC0A</NAME>
          <DESCRIPTION>Force Output Compare B</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>FOC0B</NAME>
          <DESCRIPTION>Force Output Compare B</DESCRIPTION>
          <TEXT/>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT3>
          <NAME>WGM02</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACESS>RW</ACESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CS02</NAME>
          <DESCRIPTION>Clock Select</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CS01</NAME>
          <DESCRIPTION>Clock Select</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CS00</NAME>
          <DESCRIPTION>Clock Select</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <ENUM>CLK_SEL_3BIT_EXT</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCCR0B>
    </TIMER_COUNTER_0>
    <EXTERNAL_INTERRUPT>
      <LIST>[PCMSK2:PCMSK1:PCMSK0:GIFR:GIMSK]</LIST>
      <LINK/>
      <ICON>io_ext.bmp</ICON>
      <ID/>
      <TEXT/>
      <PCMSK2>
        <NAME>PCMSK1</NAME>
        <DESCRIPTION>Pin Change Mask Register 1</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x29</IO_ADDR>
        <MEM_ADDR>0x49</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT5>
          <NAME>PCINT17</NAME>
          <DESCRIPTION>Pin Change Enable Mask 17</DESCRIPTION>
          <TEXT>Each PCINT17..12 bit selects whether pin change interrupt is enabled on the corresponding I/O pin. If PCINT17..12 is set and the PCIE1 bit in GIMSK is set, pin change interrupt is enabled on the corresponding I/O pin. If PCINT17..12 is cleared, pin change interrupt on the corresponding I/O pin is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PCINT16</NAME>
          <DESCRIPTION>Pin Change Enable Mask 16</DESCRIPTION>
          <TEXT>Each PCINT17..12 bit selects whether pin change interrupt is enabled on the corresponding I/O pin. If PCINT17..12 is set and the PCIE1 bit in GIMSK is set, pin change interrupt is enabled on the corresponding I/O pin. If PCINT17..12 is cleared, pin change interrupt on the corresponding I/O pin is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PCINT15</NAME>
          <DESCRIPTION>Pin Change Enable Mask 15</DESCRIPTION>
          <TEXT>Each PCINT17..12 bit selects whether pin change interrupt is enabled on the corresponding I/O pin. If PCINT17..12 is set and the PCIE1 bit in GIMSK is set, pin change interrupt is enabled on the corresponding I/O pin. If PCINT17..12 is cleared, pin change interrupt on the corresponding I/O pin is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PCINT14</NAME>
          <DESCRIPTION>Pin Change Enable Mask 14</DESCRIPTION>
          <TEXT>Each PCINT17..12 bit selects whether pin change interrupt is enabled on the corresponding I/O pin. If PCINT17..12 is set and the PCIE1 bit in GIMSK is set, pin change interrupt is enabled on the corresponding I/O pin. If PCINT17..12 is cleared, pin change interrupt on the corresponding I/O pin is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PCINT13</NAME>
          <DESCRIPTION>Pin Change Enable Mask 13</DESCRIPTION>
          <TEXT>Each PCINT17..12 bit selects whether pin change interrupt is enabled on the corresponding I/O pin. If PCINT17..12 is set and the PCIE1 bit in GIMSK is set, pin change interrupt is enabled on the corresponding I/O pin. If PCINT17..12 is cleared, pin change interrupt on the corresponding I/O pin is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PCINT12</NAME>
          <DESCRIPTION>Pin Change Enable Mask 12</DESCRIPTION>
          <TEXT>Each PCINT17..12 bit selects whether pin change interrupt is enabled on the corresponding I/O pin. If PCINT17..12 is set and the PCIE1 bit in GIMSK is set, pin change interrupt is enabled on the corresponding I/O pin. If PCINT17..12 is cleared, pin change interrupt on the corresponding I/O pin is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PCMSK2>
      <PCMSK1>
        <NAME>PCMSK1</NAME>
        <DESCRIPTION>Pin Change Mask Register 1</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x28</IO_ADDR>
        <MEM_ADDR>0x48</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT3>
          <NAME>PCINT11</NAME>
          <DESCRIPTION>Pin Change Enable Mask 11</DESCRIPTION>
          <TEXT>Each PCINT11..8 bit selects whether pin change interrupt is enabled on the corresponding I/O pin. If PCINT11..8 is set and the PCIE1 bit in GIMSK is set, pin change interrupt is enabled on the corresponding I/O pin. If PCINT11..8 is cleared, pin change interrupt on the corresponding I/O pin is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PCINT10</NAME>
          <DESCRIPTION>Pin Change Enable Mask 10</DESCRIPTION>
          <TEXT>Each PCINT11..8 bit selects whether pin change interrupt is enabled on the corresponding I/O pin. If PCINT11..8 is set and the PCIE1 bit in GIMSK is set, pin change interrupt is enabled on the corresponding I/O pin. If PCINT11..8 is cleared, pin change interrupt on the corresponding I/O pin is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PCINT9</NAME>
          <DESCRIPTION>Pin Change Enable Mask 9</DESCRIPTION>
          <TEXT>Each PCINT11..8 bit selects whether pin change interrupt is enabled on the corresponding I/O pin. If PCINT11..8 is set and the PCIE1 bit in GIMSK is set, pin change interrupt is enabled on the corresponding I/O pin. If PCINT11..8 is cleared, pin change interrupt on the corresponding I/O pin is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PCINT8</NAME>
          <DESCRIPTION>Pin Change Enable Mask 8</DESCRIPTION>
          <TEXT>Each PCINT11..8 bit selects whether pin change interrupt is enabled on the corresponding I/O pin. If PCINT11..8 is set and the PCIE1 bit in GIMSK is set, pin change interrupt is enabled on the corresponding I/O pin. If PCINT11..8 is cleared, pin change interrupt on the corresponding I/O pin is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PCMSK1>
      <PCMSK0>
        <NAME>PCMSK0</NAME>
        <DESCRIPTION>Pin Change Mask Register 0</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x27</IO_ADDR>
        <MEM_ADDR>0x47</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>PCINT7</NAME>
          <DESCRIPTION>Pin Change Enable Mask 7</DESCRIPTION>
          <TEXT>Each PCINT7..0 bit selects whether pin change interrupt is enabled on the corresponding I/O pin. If PCINT7..0 is set and the PCIE0 bit in GIMSK is set, pin change interrupt is enabled on the corresponding I/O pin. If PCINT7..0 is cleared, pin change interrupt on the corresponding I/O pin is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PCINT6</NAME>
          <DESCRIPTION>Pin Change Enable Mask 6</DESCRIPTION>
          <TEXT>Each PCINT7..0 bit selects whether pin change interrupt is enabled on the corresponding I/O pin. If PCINT7..0 is set and the PCIE0 bit in GIMSK is set, pin change interrupt is enabled on the corresponding I/O pin. If PCINT7..0 is cleared, pin change interrupt on the corresponding I/O pin is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PCINT5</NAME>
          <DESCRIPTION>Pin Change Enable Mask 5</DESCRIPTION>
          <TEXT>Each PCINT7..0 bit selects whether pin change interrupt is enabled on the corresponding I/O pin. If PCINT7..0 is set and the PCIE0 bit in GIMSK is set, pin change interrupt is enabled on the corresponding I/O pin. If PCINT7..0 is cleared, pin change interrupt on the corresponding I/O pin is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PCINT4</NAME>
          <DESCRIPTION>Pin Change Enable Mask 4</DESCRIPTION>
          <TEXT>Each PCINT7..0 bit selects whether pin change interrupt is enabled on the corresponding I/O pin. If PCINT7..0 is set and the PCIE0 bit in GIMSK is set, pin change interrupt is enabled on the corresponding I/O pin. If PCINT7..0 is cleared, pin change interrupt on the corresponding I/O pin is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PCINT3</NAME>
          <DESCRIPTION>Pin Change Enable Mask 3</DESCRIPTION>
          <TEXT>Each PCINT7..0 bit selects whether pin change interrupt is enabled on the corresponding I/O pin. If PCINT7..0 is set and the PCIE0 bit in GIMSK is set, pin change interrupt is enabled on the corresponding I/O pin. If PCINT7..0 is cleared, pin change interrupt on the corresponding I/O pin is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PCINT2</NAME>
          <DESCRIPTION>Pin Change Enable Mask 2</DESCRIPTION>
          <TEXT>Each PCINT7..0 bit selects whether pin change interrupt is enabled on the corresponding I/O pin. If PCINT7..0 is set and the PCIE0 bit in GIMSK is set, pin change interrupt is enabled on the corresponding I/O pin. If PCINT7..0 is cleared, pin change interrupt on the corresponding I/O pin is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PCINT1</NAME>
          <DESCRIPTION>Pin Change Enable Mask 1</DESCRIPTION>
          <TEXT>Each PCINT7..0 bit selects whether pin change interrupt is enabled on the corresponding I/O pin. If PCINT7..0 is set and the PCIE0 bit in GIMSK is set, pin change interrupt is enabled on the corresponding I/O pin. If PCINT7..0 is cleared, pin change interrupt on the corresponding I/O pin is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PCINT0</NAME>
          <DESCRIPTION>Pin Change Enable Mask 0</DESCRIPTION>
          <TEXT>Each PCINT7..0 bit selects whether pin change interrupt is enabled on the corresponding I/O pin. If PCINT7..0 is set and the PCIE0 bit in GIMSK is set, pin change interrupt is enabled on the corresponding I/O pin. If PCINT7..0 is cleared, pin change interrupt on the corresponding I/O pin is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PCMSK0>
      <GIFR>
        <NAME>GIFR</NAME>
        <DESCRIPTION>General Interrupt Flag Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x3B</IO_ADDR>
        <MEM_ADDR>0x5B</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT6>
          <NAME>INTF0</NAME>
          <DESCRIPTION>External Interrupt Flag 0</DESCRIPTION>
          <TEXT>When an edge or logic change on the INT0 pin triggers an interrupt request, INTF0 becomes set (one). If the I-bit in SREG and the INT0 bit in GIMSK are set (one), the MCU will jump to the corresponding Interrupt Vector. The flag is cleared when the interrupt routine is executed. Alternatively, the flag can be cleared by writing a logical one to it. This flag is always cleared when INT0 is configured as a level interrupt.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PCIF2</NAME>
          <DESCRIPTION>Pin Change Interrupt Flag 2</DESCRIPTION>
          <TEXT>When a logic change on any PCINT17..12 pin triggers an interrupt request, PCIF1 becomes set (one). If the I-bit in SREG and the PCIE2 bit in GIMSK are set (one), the MCU will jump to the corresponding Interrupt Vector. The flag is cleared when the interrupt routine is executed. Alternatively, the flag can be cleared by writing a logical one to it.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PCIF1</NAME>
          <DESCRIPTION>Pin Change Interrupt Flag 1</DESCRIPTION>
          <TEXT>When a logic change on any PCINT11..8 pin triggers an interrupt request, PCIF1 becomes set (one). If the I-bit in SREG and the PCIE1 bit in GIMSK are set (one), the MCU will jump to the corresponding Interrupt Vector. The flag is cleared when the interrupt routine is executed. Alternatively, the flag can be cleared by writing a logical one to it.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PCIF0</NAME>
          <DESCRIPTION>Pin Change Interrupt Flag 0</DESCRIPTION>
          <TEXT>When a logic change on any PCINT7..0 pin triggers an interrupt request, PCIF becomes set(one). If the I-bit in SREG and the PCIE0 bit in GIMSK are set (one), the MCU will jump to the corresponding Interrupt Vector. The flag is cleared when the interrupt routine is executed. Alternatively, the flag can be cleared by writing a logical one to it.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
      </GIFR>
      <GIMSK>
        <NAME>GIMSK</NAME>
        <DESCRIPTION>General Interrupt Mask Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x3C</IO_ADDR>
        <MEM_ADDR>0x5C</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT6>
          <NAME>INT0</NAME>
          <DESCRIPTION>External Interrupt Request 0 Enable</DESCRIPTION>
          <TEXT>When the INT0 bit is set (one) and the I-bit in the Status Register (SREG) is set (one), the external pin interrupt is enabled. The Interrupt Sense Control bits (ISC01 and ISC00) in the MCU Control Register (MCUCR) define whether the external interrupt is activated on rising and/or falling edge of the INT0 pin or level sensed. Activity on the pin will cause an interrupt request even if INT0 is configured as an output. The corresponding interrupt of External Interrupt Request 0 is executed from the INT0 Interrupt Vector.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PCIE2</NAME>
          <DESCRIPTION>Pin Change Interrupt Enable 2</DESCRIPTION>
          <TEXT>When the PCIE2 bit is set (one) and the I-bit in the Status Register (SREG) is set (one), pin change interrupt 2 is enabled. Any change on any enabled PCINT17..12 pin will cause an interrupt. The corresponding interrupt of Pin Change Interrupt Request is executed from the PCI2 Interrupt Vector. PCINT17..12 pins are enabled individually by the PCMSK2 Register.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PCIE1</NAME>
          <DESCRIPTION>Pin Change Interrupt Enable 1</DESCRIPTION>
          <TEXT>When the PCIE1 bit is set (one) and the I-bit in the Status Register (SREG) is set (one), pin change interrupt 1 is enabled. Any change on any enabled PCINT11..8 pin will cause an interrupt. The corresponding interrupt of Pin Change Interrupt Request is executed from the PCI1 Interrupt Vector. PCINT11..8 pins are enabled individually by the PCMSK1 Register.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PCIE0</NAME>
          <DESCRIPTION>Pin Change Interrupt Enable 0</DESCRIPTION>
          <TEXT>When the PCIE0 bit is set (one) and the I-bit in the Status Register (SREG) is set (one), pin change interrupt 0 is enabled. Any change on any enabled PCINT7..0 pin will cause an interrupt. The corresponding interrupt of Pin Change Interrupt Request is executed from the PCI0 Interrupt Vector. PCINT7..0 pins are enabled individually by the PCMSK0 Register.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
      </GIMSK>
    </EXTERNAL_INTERRUPT>
    <CPU>
      <LIST>[SREG:SPH:SPL:MCUCR:MCUSR:OSCCAL0:OSCCAL1:OSCTCAL0A:OSCTCAL0B:GPIOR2:GPIOR1:GPIOR0:PRR:CLKPR:CLKSR:CCP:SPMCSR]</LIST>
      <LINK>[SPH:SPL]</LINK>
      <ICON>io_cpu.bmp</ICON>
      <ID/>
      <TEXT/>
      <PRR>
        <NAME>PRR</NAME>
        <DESCRIPTION>Power Reduction Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x34</IO_ADDR>
        <MEM_ADDR>0x54</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT6>
          <NAME>PRTWI</NAME>
          <DESCRIPTION>Power Reduction TWI</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PRTIM1</NAME>
          <DESCRIPTION>Power Reduction Timer/Counter1</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PRTIM0</NAME>
          <DESCRIPTION>Power Reduction Timer/Counter0</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PRUSI</NAME>
          <DESCRIPTION>Power Reduction USI</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PRUSART1</NAME>
          <DESCRIPTION>Power Reduction USART 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PRUSART0</NAME>
          <DESCRIPTION>Power Reduction USART 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PRADC</NAME>
          <DESCRIPTION>Power Reduction ADC</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PRR>
      <CCP>
        <NAME>CCP</NAME>
        <DESCRIPTION>Configuration Change Protection</DESCRIPTION>
        <TEXT>In order to enable changing the contents of an I/O register the CCP register must first be written with the correct signature. After CCP is written the protected I/O registers may be written to during the next four CPU instruction cycles. All interrupts are ignored during these cycles. After these cycles interrupts are automatically handled again by the CPU, and any pending interrupts will be executed according to their level and priority.When the protected I/O register signature is written, CCP[0] will read as one as long as the protected feature is enabled. CCP[7:1] will always read as zero.</TEXT>
        <IO_ADDR>0x2F</IO_ADDR>
        <MEM_ADDR>0x4F</MEM_ADDR>
        <ICON>io_sph.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>CCP7</NAME>
          <DESCRIPTION>Configuration Change Protection bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>CCP6</NAME>
          <DESCRIPTION>Configuration Change Protection bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>CCP5</NAME>
          <DESCRIPTION>Configuration Change Protection bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>CCP4</NAME>
          <DESCRIPTION>Configuration Change Protection bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>CCP3</NAME>
          <DESCRIPTION>Configuration Change Protection bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CCP2</NAME>
          <DESCRIPTION>Configuration Change Protection bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CCP1</NAME>
          <DESCRIPTION>Configuration Change Protection bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CCP0</NAME>
          <DESCRIPTION>Configuration Change Protection bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </CCP>
      <OSCCAL0>
        <NAME>OSCCAL0</NAME>
        <DESCRIPTION>Oscillator Calibration Value</DESCRIPTION>
        <TEXT>Writing the calibration byte to this address will trim the internal oscillator to remove process variations from the oscillator frequency. This is done automatically during chip reset. When OSCCAL is zero, the lowest available frequency is chosen. Writing non-zero values to this register will increase the frequency of the internal oscillator. Writing $FF to the register gives the highest available frequency. The calibrated oscillator is used to time EEPROM and Flash access. If EEPROM or Flash is written, do not calibrate to more than 10% above the nominal frequency. Otherwise, the EEPROM or Flash write may fail. Note that the Oscillator is intended for calibration to 1.0 MHz, 2.0 MHz, 4.0 MHz, or 8.0MHz. Tuning to other values is not guaranteed, as indicated in Table 14</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x63</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>CAL07</NAME>
          <DESCRIPTION>Oscillator Calibration Value Bit7</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>CAL06</NAME>
          <DESCRIPTION>Oscillator Calibration Value Bit6</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>CAL05</NAME>
          <DESCRIPTION>Oscillator Calibration Value Bit5</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>CAL04</NAME>
          <DESCRIPTION>Oscillator Calibration Value Bit4</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>CAL03</NAME>
          <DESCRIPTION>Oscillator Calibration Value Bit3</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CAL02</NAME>
          <DESCRIPTION>Oscillator Calibration Value Bit2</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CAL01</NAME>
          <DESCRIPTION>Oscillator Calibration Value Bit1</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CAL00</NAME>
          <DESCRIPTION>Oscillator Calibration Value Bit0</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OSCCAL0>
      <OSCCAL1>
        <NAME>OSCCAL1</NAME>
        <DESCRIPTION/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x66</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT1>
          <NAME>CAL11</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CAL10</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OSCCAL1>
      <OSCTCAL0A>
        <NAME>OSCTCAL0A</NAME>
        <DESCRIPTION/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x64</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TCAL0A7</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TCAL0A6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TCAL0A5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TCAL0A4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TCAL0A3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TCAL0A2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TCAL0A1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TCAL0A0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OSCTCAL0A>
      <OSCTCAL0B>
        <NAME>OSCTCAL0B</NAME>
        <DESCRIPTION/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x65</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TCAL0B7</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TCAL0B6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TCAL0B5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TCAL0B4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TCAL0B3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TCAL0B2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TCAL0B1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TCAL0B0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OSCTCAL0B>
      <CLKPR>
        <NAME>CLKPR</NAME>
        <DESCRIPTION>Clock Prescale Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x33</IO_ADDR>
        <MEM_ADDR>0x53</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT3>
          <NAME>CLKPS3</NAME>
          <DESCRIPTION>Clock Prescaler Select Bit 3</DESCRIPTION>
          <TEXT>These bits define the division factor between the selected clock source and the internal system clock. These bits can be written run-time to vary the clock frequency to suit the application requirements. As the divider divides the master clock input to the MCU, the speed of all synchronous peripherals is reduced when a division factor is used.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CLKPS2</NAME>
          <DESCRIPTION>Clock Prescaler Select Bit 2</DESCRIPTION>
          <TEXT>These bits define the division factor between the selected clock source and the internal system clock. These bits can be written run-time to vary the clock frequency to suit the application requirements. As the divider divides the master clock input to the MCU, the speed of all synchronous peripherals is reduced when a division factor is used.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CLKPS1</NAME>
          <DESCRIPTION>Clock Prescaler Select Bit 1</DESCRIPTION>
          <TEXT>These bits define the division factor between the selected clock source and the internal system clock. These bits can be written run-time to vary the clock frequency to suit the application requirements. As the divider divides the master clock input to the MCU, the speed of all synchronous peripherals is reduced when a division factor is used.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CLKPS0</NAME>
          <DESCRIPTION>Clock Prescaler Select Bit 0</DESCRIPTION>
          <TEXT>These bits define the division factor between the selected clock source and the internal system clock. These bits can be written run-time to vary the clock frequency to suit the application requirements. As the divider divides the master clock input to the MCU, the speed of all synchronous peripherals is reduced when a division factor is used.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>CPU_CLK_PRESCALE_4_BITS_SMALL</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </CLKPR>
      <CLKSR>
        <NAME>CLKSR</NAME>
        <DESCRIPTION>Clock Setting Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x32</IO_ADDR>
        <MEM_ADDR>0x52</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>OSCRDY</NAME>
          <DESCRIPTION>Oscillator Ready</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>CSTR</NAME>
          <DESCRIPTION>Clock Switch Trigger</DESCRIPTION>
          <TEXT/>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>CKOUT_IO</NAME>
          <DESCRIPTION>Clock Output (active low)</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SUT</NAME>
          <DESCRIPTION>Start-up Time</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>CKSEL3</NAME>
          <DESCRIPTION>Clock Select Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CKSEL2</NAME>
          <DESCRIPTION>Clock Select Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CKSEL1</NAME>
          <DESCRIPTION>Clock Select Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CKSEL0</NAME>
          <DESCRIPTION>Clock Select Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </CLKSR>
      <SREG>
        <NAME>SREG</NAME>
        <DESCRIPTION>Status Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x3F</IO_ADDR>
        <MEM_ADDR>0x5F</MEM_ADDR>
        <ICON>io_sreg.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>I</NAME>
          <DESCRIPTION>Global Interrupt Enable</DESCRIPTION>
          <TEXT>The global interrupt enable bit must be set (one) for the interrupts to be enabled. The individual interrupt enable control is then performed in separate control registers. If the global interrupt enable bit is cleared (zero), none of the interrupts are enabled independent of the individual interrupt enable settings. The I-bit is cleared by hardware after an interrupt has occurred, and is set by the RETI instruction to enable subsequent interrupts.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>T</NAME>
          <DESCRIPTION>Bit Copy Storage</DESCRIPTION>
          <TEXT>The bit copy instructions BLD (Bit LoaD) and BST (Bit STore) use the T bit as source and destination for the operated bit. A bit from a register in the register file can be copied into T by the BST instruction, and a bit in T can be copied into a bit in a register in the register file by the BLD instruction.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>H</NAME>
          <DESCRIPTION>Half Carry Flag</DESCRIPTION>
          <TEXT>The half carry flag H indicates a half carry in some arithmetic operations. See the Instruction Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>S</NAME>
          <DESCRIPTION>Sign Bit</DESCRIPTION>
          <TEXT>The S-bit is always an exclusive or between the negative flag N and the two&#x2019;s complement overflow flag V. See the Instruc-tion Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>V</NAME>
          <DESCRIPTION>Two's Complement Overflow Flag</DESCRIPTION>
          <TEXT>The two&#x2019;s complement overflow flag V supports two&#x2019;s complement arithmetics. See the Instruction Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>N</NAME>
          <DESCRIPTION>Negative Flag</DESCRIPTION>
          <TEXT>The negative flag N indicates a negative result after the different arithmetic and logic operations. See the Instruction Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>Z</NAME>
          <DESCRIPTION>Zero Flag</DESCRIPTION>
          <TEXT>The zero flag Z indicates a zero result after the different arithmetic and logic operations. See the Instruction Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>C</NAME>
          <DESCRIPTION>Carry Flag</DESCRIPTION>
          <TEXT>The carry flag C indicates a carry in an arithmetic or logic operation. See the Instruction Set Description for detailed information. Note that the status register is not automatically stored when entering an interrupt routine and restored when returning from an interrupt routine. This must be handled by software.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SREG>
      <SPH>
        <NAME>SPH</NAME>
        <DESCRIPTION>Stack Pointer High</DESCRIPTION>
        <TEXT>The general AVR 16-bit Stack Pointer is effectively built up of two 8-bit registers in the I/O space locations $3E ($5E) and $3D ($5D). As the AT90S4414/8515 supports up to 64 kB external SRAM, all 16-bits are used. The Stack Pointer points to the data SRAM stack area where the Subroutine and Interrupt Stacks are located. This Stack space in the data SRAM must be defined by the program before any subroutine calls are executed or interrupts are enabled. The stack pointer must be set to point above $60. The Stack Pointer is decremented by one when data is pushed onto the Stack with the PUSH instruction, and it is decremented by two when an address is pushed onto the Stack with subroutine calls and interrupts. The Stack Pointer is incremented by one when data is popped from the Stack with the POP instruction, and it is incremented by two when an address is popped from the Stack with return from subroutine RET or return from interrupt R</TEXT>
        <IO_ADDR>0x3E</IO_ADDR>
        <MEM_ADDR>0x5E</MEM_ADDR>
        <ICON>io_sph.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT2>
          <NAME>SP10</NAME>
          <DESCRIPTION>Stack pointer bit 10</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SP9</NAME>
          <DESCRIPTION>Stack pointer bit 9</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SP8</NAME>
          <DESCRIPTION>Stack pointer bit 8</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SPH>
      <SPL>
        <NAME>SPL</NAME>
        <DESCRIPTION>Stack Pointer Low</DESCRIPTION>
        <TEXT>The general AVR 16-bit Stack Pointer is effectively built up of two 8-bit registers in the I/O space locations $3E ($5E) and $3D ($5D). As the AT90S4414/8515 supports up to 64 kB external SRAM, all 16-bits are used. The Stack Pointer points to the data SRAM stack area where the Subroutine and Interrupt Stacks are located. This Stack space in the data SRAM must be defined by the program before any subroutine calls are executed or interrupts are enabled. The stack pointer must be set to point above $60. The Stack Pointer is decremented by one when data is pushed onto the Stack with the PUSH instruction, and it is decremented by two when an address is pushed onto the Stack with subroutine calls and interrupts. The Stack Pointer is incremented by one when data is popped from the Stack with the POP instruction, and it is incremented by two when an address is popped from the Stack with return from subroutine RET or return from interrupt </TEXT>
        <IO_ADDR>0x3D</IO_ADDR>
        <MEM_ADDR>0x5D</MEM_ADDR>
        <ICON>io_sph.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>SP7</NAME>
          <DESCRIPTION>Stack pointer bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SP6</NAME>
          <DESCRIPTION>Stack pointer bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SP5</NAME>
          <DESCRIPTION>Stack pointer bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SP4</NAME>
          <DESCRIPTION>Stack pointer bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SP3</NAME>
          <DESCRIPTION>Stack pointer bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SP2</NAME>
          <DESCRIPTION>Stack pointer bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SP1</NAME>
          <DESCRIPTION>Stack pointer bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SP0</NAME>
          <DESCRIPTION>Stack pointer bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SPL>
      <MCUCR>
        <NAME>MCUCR</NAME>
        <DESCRIPTION>MCU Control Register</DESCRIPTION>
        <TEXT>The MCU Control Register contains control bits for general MCU functions.</TEXT>
        <IO_ADDR>0x36</IO_ADDR>
        <MEM_ADDR>0x56</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT6>
          <NAME>SM1</NAME>
          <DESCRIPTION>Sleep Mode Select Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SM0</NAME>
          <DESCRIPTION>Sleep Mode Select Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <ENUM>CPU_SLEEP_MODE</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SE</NAME>
          <DESCRIPTION>Sleep Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT1>
          <NAME>ISC01</NAME>
          <DESCRIPTION>Interrupt Sense Control 0 bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ISC00</NAME>
          <DESCRIPTION>Interrupt Sense Control 0 bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </MCUCR>
      <MCUSR>
        <NAME>MCUSR</NAME>
        <DESCRIPTION>MCU Status Register</DESCRIPTION>
        <TEXT>The MCU Status Register provides information on which reset source caused an MCU reset.</TEXT>
        <IO_ADDR>0x35</IO_ADDR>
        <MEM_ADDR>0x55</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT3>
          <NAME>WDRF</NAME>
          <DESCRIPTION>Watchdog Reset Flag</DESCRIPTION>
          <TEXT>This bit is set if a watchdog reset occurs. The bit is reset by a power-on reset, or by writing a logic zero to the flag.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>BORF</NAME>
          <DESCRIPTION>Brown-out Reset Flag</DESCRIPTION>
          <TEXT>This bit is set if a brown-out reset occurs. The bit is reset by a power-on reset, or by writing a logic zero to the flag.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>EXTRF</NAME>
          <DESCRIPTION>External Reset Flag</DESCRIPTION>
          <TEXT>This bit is set if an external reset occurs. The bit is reset by a power-on reset, or by writing a logic zero to the flag.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PORF</NAME>
          <DESCRIPTION>Power-on reset flag</DESCRIPTION>
          <TEXT>This bit is set if a power-on reset occurs. The bit is reset only by writing a logic zero to the flag. To make use of the reset flags to identify a reset condition, the user should read and then reset the MCUCSR as early as possible in the program. If the register is cleared before another reset occurs, the source of the reset can be found by examining the reset flags.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </MCUSR>
      <GPIOR2>
        <NAME>GPIOR2</NAME>
        <DESCRIPTION>General Purpose I/O Register 2</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x16</IO_ADDR>
        <MEM_ADDR>0x36</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>GPIOR27</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>GPIOR26</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>GPIOR25</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>GPIOR24</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>GPIOR23</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS/>
          <INIT_VAL/>
        </BIT3>
        <BIT2>
          <NAME>GPIOR22</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>GPIOR21</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>GPIOR20</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </GPIOR2>
      <GPIOR1>
        <NAME>GPIOR1</NAME>
        <DESCRIPTION>General Purpose I/O Register 1</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x15</IO_ADDR>
        <MEM_ADDR>0x35</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>GPIOR17</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>GPIOR16</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>GPIOR15</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>GPIOR14</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>GPIOR13</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS/>
          <INIT_VAL/>
        </BIT3>
        <BIT2>
          <NAME>GPIOR12</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>GPIOR11</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>GPIOR10</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </GPIOR1>
      <GPIOR0>
        <NAME>GPIOR0</NAME>
        <DESCRIPTION>General Purpose I/O Register 0</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x14</IO_ADDR>
        <MEM_ADDR>0x35</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>GPIOR07</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>GPIOR06</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>GPIOR05</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>GPIOR04</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>GPIOR03</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS/>
          <INIT_VAL/>
        </BIT3>
        <BIT2>
          <NAME>GPIOR02</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>GPIOR01</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>GPIOR00</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </GPIOR0>
      <SPMCSR>
        <NAME>SPMCSR</NAME>
        <DESCRIPTION>Store Program Memory Control and Status Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x37</IO_ADDR>
        <MEM_ADDR>0x57</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_sreg.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT5>
          <NAME>RSIG</NAME>
          <DESCRIPTION>Read Device Signature Imprint Table</DESCRIPTION>
          <TEXT>Issuing an LPM instruction within three cycles after RSIG and SPMEN bits have been set in SPMCSR will return the selected data (depending on Z-pointer value) from the device signature imprint table into the destination register.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>CTPB</NAME>
          <DESCRIPTION>Clear Temporary Page Buffer</DESCRIPTION>
          <TEXT>If the CTPB bit is written while filling the temporary page buffer, the temporary page buffer will be cleared and the data will be lost.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>RFLB</NAME>
          <DESCRIPTION>Read Fuse and Lock Bits</DESCRIPTION>
          <TEXT>An LPM instruction within three cycles after RFLB and SPMEN are set in the SPMCSR Register, will read either the Lock bits or the Fuse bits (depending on Z0 in the Zpointer) into the destination register. See &#x201C;EEPROM Write Prevents Writing to SPMCSR&#x201D; on page 98 in the data sheet for details.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PGWRT</NAME>
          <DESCRIPTION>Page Write</DESCRIPTION>
          <TEXT>If this bit is written to one at the same time as SPMEN, the next SPM instruction within four clock cycles executes Page Write, with the data stored in the temporary buffer. The page address is taken from the high part of the Z-pointer. The data in R1 and R0 are ignored. The PGWRT bit will auto-clear upon completion of a Page Write, or if no SPM instruction is executed within four clock cycles. The CPU is halted during the entire Page Write operation.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PGERS</NAME>
          <DESCRIPTION>Page Erase</DESCRIPTION>
          <TEXT>If this bit is written to one at the same time as SPMEN, the next SPM instruction within four clock cycles executes Page Erase. The page address is taken from the high part of the Z-pointer. The data in R1 and R0 are ignored. The PGERS bit will auto-clear upon completion of a Page Erase, or if no SPM instruction is executed within four clock cycles. The CPU is halted during the entire Page Write operation.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SPMEN</NAME>
          <DESCRIPTION>Store program Memory Enable</DESCRIPTION>
          <TEXT>This bit enables the SPM instruction for the next four clock cycles. If written to one together with either CTPB, RFLB, PGWRT, or PGERS, the following SPM instruction will have a special meaning, see description above. If only SPMEN is written, the following SPM instruction will store the value in R1:R0 in the temporary page buffer addressed by the Z-pointer. The LSB of the Z-pointer is ignored. The SPMEN bit will auto-clear upon completion of an SPM instruction, or if no SPM instruction is executed within four clock cycles. During Page Erase and Page Write, the SPMEN bit remains high until the operation is completed. Writing any other combination than &#x201C;10001&#x201D;, &#x201C;01001&#x201D;, &#x201C;00101&#x201D;, &#x201C;00011&#x201D; or &#x201C;00001&#x201D; in the lower five bits will have no effect</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SPMCSR>
    </CPU>
    <USI>
      <LIST>[USIBR:USIDR:USISR:USICR]</LIST>
      <LINK/>
      <ICON>io_com.bmp</ICON>
      <ID/>
      <TEXT>Universal Serial Interface</TEXT>
      <USIBR>
        <NAME>USIBR</NAME>
        <DESCRIPTION>USI Buffer Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x2D</IO_ADDR>
        <MEM_ADDR>0x4D</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>USIBR7</NAME>
          <DESCRIPTION>USI Buffer Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>USIBR6</NAME>
          <DESCRIPTION>USI Buffer Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>USIBR5</NAME>
          <DESCRIPTION>USI Buffer Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>USIBR4</NAME>
          <DESCRIPTION>USI Buffer Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>USIBR3</NAME>
          <DESCRIPTION>USI Buffer Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>USIBR2</NAME>
          <DESCRIPTION>USI Buffer Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>USIBR1</NAME>
          <DESCRIPTION>USI Buffer Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>USIBR0</NAME>
          <DESCRIPTION>USI Buffer Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </USIBR>
      <USIDR>
        <NAME>USIDR</NAME>
        <DESCRIPTION>USI Data Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x2C</IO_ADDR>
        <MEM_ADDR>0x4C</MEM_ADDR>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>USIDR7</NAME>
          <DESCRIPTION>USI Data Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>USIDR6</NAME>
          <DESCRIPTION>USI Data Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>USIDR5</NAME>
          <DESCRIPTION>USI Data Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>USIDR4</NAME>
          <DESCRIPTION>USI Data Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>USIDR3</NAME>
          <DESCRIPTION>USI Data Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>USIDR2</NAME>
          <DESCRIPTION>USI Data Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>USIDR1</NAME>
          <DESCRIPTION>USI Data Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>USIDR0</NAME>
          <DESCRIPTION>USI Data Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </USIDR>
      <USISR>
        <NAME>USISR</NAME>
        <DESCRIPTION>USI Status Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x2B</IO_ADDR>
        <MEM_ADDR>0x4B</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>USISIF</NAME>
          <DESCRIPTION>Start Condition Interrupt Flag</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>USIOIF</NAME>
          <DESCRIPTION>Counter Overflow Interrupt Flag</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>USIPF</NAME>
          <DESCRIPTION>Stop Condition Flag</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>USIDC</NAME>
          <DESCRIPTION>Data Output Collision</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>USICNT3</NAME>
          <DESCRIPTION>USI Counter Value Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>USICNT2</NAME>
          <DESCRIPTION>USI Counter Value Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>USICNT1</NAME>
          <DESCRIPTION>USI Counter Value Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>USICNT0</NAME>
          <DESCRIPTION>USI Counter Value Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </USISR>
      <USICR>
        <NAME>USICR</NAME>
        <DESCRIPTION>USI Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x2A</IO_ADDR>
        <MEM_ADDR>0x4A</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>USISIE</NAME>
          <DESCRIPTION>Start Condition Interrupt Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>USIOIE</NAME>
          <DESCRIPTION>Counter Overflow Interrupt Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>USIWM1</NAME>
          <DESCRIPTION>USI Wire Mode Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>USIWM0</NAME>
          <DESCRIPTION>USI Wire Mode Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <ENUM>COMM_USI_OP</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>USICS1</NAME>
          <DESCRIPTION>USI Clock Source Select Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>USICS0</NAME>
          <DESCRIPTION>USI Clock Source Select Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>USICLK</NAME>
          <DESCRIPTION>Clock Strobe</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>USITC</NAME>
          <DESCRIPTION>Toggle Clock Port Pin</DESCRIPTION>
          <TEXT/>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </USICR>
    </USI>
    <USART0>
      <LIST>[UDR0:UCSR0A:UCSR0B:UCSR0C:UCSR0D:UBRR0H:UBRR0L]</LIST>
      <LINK>[UBRR0H:UBRR0L]</LINK>
      <ICON>io_com.bmp</ICON>
      <ID/>
      <TEXT>The Universal Synchronous and Asynchronous serial Receiver and Transmitter (USART) is a highly flexible serial communication device. The main features are: &#x2022; Full Duplex Operation (Independent Serial Receive and Transmit Registers) &#x2022; Asynchronous or Synchronous Operation &#x2022; Master or Slave Clocked Synchronous Operation &#x2022; High Resolution Baud Rate Generator &#x2022; Supports Serial Frames with 5, 6, 7, 8 or 9 Data Bits and 1 or 2 Stop Bits &#x2022; Odd or Even Parity Generation and Parity Check Supported by Hardware &#x2022; Data OverRun Detection &#x2022; Framing Error Detection &#x2022; Noise Filtering Includes False Start Bit Detection and Digital Low Pass Filter &#x2022; Three Separate Interrupts on TX Complete, TX Data Register Empty and RX Complete &#x2022; Multi-processor Communication Mode &#x2022; Double Speed Asynchronous Communica</TEXT>
      <UDR0>
        <NAME>UDR0</NAME>
        <DESCRIPTION>USART I/O Data Register</DESCRIPTION>
        <TEXT>The UDR0 register is actually two physically separate registers sharing the same I/O address. When writing to the register, the USART Transmit Data register is written. When reading from UDR0, the USART Receive Data register is read.</TEXT>
        <IO_ADDR>0x20</IO_ADDR>
        <MEM_ADDR>0x40</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <READ_INTRUSIVE/>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>UDR0_7</NAME>
          <DESCRIPTION>USART I/O Data Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>UDR0_6</NAME>
          <DESCRIPTION>USART I/O Data Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UDR0_5</NAME>
          <DESCRIPTION>USART I/O Data Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>UDR0_4</NAME>
          <DESCRIPTION>USART I/O Data Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>UDR0_3</NAME>
          <DESCRIPTION>USART I/O Data Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UDR0_2</NAME>
          <DESCRIPTION>USART I/O Data Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>UDR0_1</NAME>
          <DESCRIPTION>USART I/O Data Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>UDR0_0</NAME>
          <DESCRIPTION>USART I/O Data Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </UDR0>
      <UCSR0A>
        <NAME>UCSR0A</NAME>
        <DESCRIPTION>USART Control and Status Register A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x26</IO_ADDR>
        <MEM_ADDR>0x46</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>RXC0</NAME>
          <DESCRIPTION>USART Receive Complete</DESCRIPTION>
          <TEXT>This bit is set (one) when a received character is transferred from the Receiver Shift register to UDR0. The bit is set regard-less of any detected framing errors. When the RXCIE bit in UCR is set, the USART Receive Complete interrupt will be executed when RXC is set(one). RXC is cleared by reading UDR0. When interrupt-driven data reception is used, the USART Receive Complete Interrupt routine must read UDRin order to clear RXC, otherwise a new interrupt will occur once the interrupt routine terminates.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TXC0</NAME>
          <DESCRIPTION>USART Transmitt Complete</DESCRIPTION>
          <TEXT>This bit is set (one) when the entire character (including the stop bit) in the Transmit Shift register has been shifted out and no new data has been written to UDR0. This flag is especially useful in half-duplex communications interfaces, where a transmitting application must enter receive mode and free the communications bus immediately after completing the transmission. When the TXCIE bit in UCR is set, setting of TXC causes the USART Transmit Complete interrupt to be executed. TXC is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, the TXC bit is cleared (zero) by writing a logical one to the b</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UDRE0</NAME>
          <DESCRIPTION>USART Data Register Empty</DESCRIPTION>
          <TEXT>This bit is set (one) when a character written to UDRis transferred to the Transmit shift register. Setting of this bit indicates that the transmitter is ready to receive a new character for transmission. When the UDR0IE bit in UCR is set, the USART Transmit Complete interrupt to be executed as long as UDR0E is set. UDR0E is cleared by writing UDR0. When interrupt-driven data transmittal is used, the USART Data Register Empty Interrupt routine must write UDRin order to clear UDR0E, otherwise a new interrupt will occur once the interrupt routine terminates. UDR0E is set (one) during reset to indicate that the transmitter is re</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>FE0</NAME>
          <DESCRIPTION>Framing Error</DESCRIPTION>
          <TEXT>This bit is set if a Framing Error condition is detected, i.e. when the stop bit of an incoming character is zero. The FE bit is cleared when the stop bit of received data is one.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>DOR0</NAME>
          <DESCRIPTION>Data overRun</DESCRIPTION>
          <TEXT>This bit is set if an Overrun condition is detected, i.e. when a character already present in the UDRregister is not read before the next character has been shifted into the Receiver Shift register. The OR bit is buffered, which means that it will be set once the valid data still in UDR0E is read. The OR bit is cleared (zero) when data is received and transferred to UDR0. </TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UPE0</NAME>
          <DESCRIPTION>Parity Error</DESCRIPTION>
          <TEXT>This bit is set if the next character in the receive buffer had a Parity Error when received and the parity checking was enabled at that point (UPM1 = 1). This bit is valid until the receive buffer (UDR0) is read. Always set this bit to zero when writing to UCSR0A.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>U2X0</NAME>
          <DESCRIPTION>Double the USART transmission speed</DESCRIPTION>
          <TEXT>This bit only has effect for the asynchronous operation. Write this bit to zero when using synchronous operation. Writing this bit to one will reduce the divisor of the baud rate divider from 16 to 8 effectively doubling the transfer rate for asynchronous communication.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>MPCM0</NAME>
          <DESCRIPTION>Multi-processor Communication Mode</DESCRIPTION>
          <TEXT>This bit enables the Multi-processor Communication Mode. When the MPCM bit is written to one, all the incoming frames received by the USART receiver that do not contain address information will be ignored. The transmitter is unaffected by the MPCM setting. For more detailed information see &#x201C;Multi-processor Communication Mode&#x201D; on page 152.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </UCSR0A>
      <UCSR0B>
        <NAME>UCSR0B</NAME>
        <DESCRIPTION>USART Control and Status Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x25</IO_ADDR>
        <MEM_ADDR>0x45</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>RXCIE0</NAME>
          <DESCRIPTION>RX Complete Interrupt Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables interrupt on the RXC flag. A USART Receive Complete interrupt will be generated only if the RXCIE bit is written to one, the global interrupt flag in SREG is written to one and the RXC bit in UCSR0A is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TXCIE0</NAME>
          <DESCRIPTION>TX Complete Interrupt Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables interrupt on the TXC flag. A USART Transmit Complete interrupt will be generated only if the TXCIE bit is written to one, the global interrupt flag in SREG is written to one and the TXC bit in UCSR0A is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UDRIE0</NAME>
          <DESCRIPTION>USART Data register Empty Interrupt Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables interrupt on the UDR0E flag. A Data Register Empty interrupt will be generated only if the UDR0IE bit is written to one, the global interrupt flag in SREG is written to one and the UDR0E bit in UCSR0A is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>RXEN0</NAME>
          <DESCRIPTION>Receiver Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables the USART receiver. The receiver will override normal port operation for the RxD pin when enabled. Disabling the receiver will flush the receive buffer invalidating the FE, DOR and PE flags.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TXEN0</NAME>
          <DESCRIPTION>Transmitter Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables the USART transmitter. The transmitter will override normal port operation for the TxD pin when enabled. The disabling of the transmitter (writing TXEN to zero) will not become effective until ongoing and pending transmissions are completed, i.e. when the transmit shift register and transmit buffer register does not contain data to be transmitted. When disabled, the transmitter will no longer override the TxD port.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UCSZ02</NAME>
          <DESCRIPTION>Character Size</DESCRIPTION>
          <TEXT>The UCSZ2 bits combined with the UCSZ1:0 bit in UCSR0C sets the number of data bits (character size) in a frame the receiver and transmitter use.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>RXB80</NAME>
          <DESCRIPTION>Receive Data Bit 8</DESCRIPTION>
          <TEXT>RXB8 is the 9th data bit of the received character when operating with serial frames with 9 data bits. Must be read before reading the low bits from UDR0.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TXB80</NAME>
          <DESCRIPTION>Transmit Data Bit 8</DESCRIPTION>
          <TEXT>TXB8 is the 9th data bit in the character to be transmitted when operating with serial frames with 9 data bits. Must be writ-ten before writing the low bits to UDR0.</TEXT>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </UCSR0B>
      <UCSR0C>
        <NAME>UCSR0C</NAME>
        <DESCRIPTION>USART Control and Status Register C</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x24</IO_ADDR>
        <MEM_ADDR>0x44</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>UMSEL01</NAME>
          <ALIAS>UMSEL1</ALIAS>
          <DESCRIPTION>USART Mode Select</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>UMSEL00</NAME>
          <ALIAS>UMSEL0</ALIAS>
          <DESCRIPTION>USART Mode Select</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <ENUM>COMM_USART_MODE</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UPM01</NAME>
          <DESCRIPTION>Parity Mode Bit 1</DESCRIPTION>
          <TEXT>This bit enable and set type of parity generation and check. If enabled, the transmitter will automatically generate and send the parity of the transmitted data bits within each frame. The receiver will generate a parity value for the incoming data and compare it to the UPM0 setting. If a mismatch is detected, the PE flag in UCSR0A will be set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>UPM00</NAME>
          <DESCRIPTION>Parity Mode Bit 0</DESCRIPTION>
          <TEXT>This bit enable and set type of parity generation and check. If enabled, the transmitter will automatically generate and send the parity of the transmitted data bits within each frame. The receiver will generate a parity value for the incoming data and compare it to the UPM0 setting. If a mismatch is detected, the PE flag in UCSR0A will be set.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>COMM_UPM_PARITY_MODE</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>USBS0</NAME>
          <DESCRIPTION>Stop Bit Select</DESCRIPTION>
          <TEXT>0: 1-bit.  1: 2-bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>COMM_STOP_BIT_SEL</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UCSZ01</NAME>
          <ALIAS>UDORD0</ALIAS>
          <DESCRIPTION>Character Size</DESCRIPTION>
          <TEXT>Character Size: 0 0 0 = 5-bit. 0 0 1 = 6-bit. 0 1 0 = 7 bit. 0 1 1 = 8-bit. 1 1 1 = 9 bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>UCSZ00</NAME>
          <ALIAS>UCPHA0</ALIAS>
          <DESCRIPTION>Character Size</DESCRIPTION>
          <TEXT>Character Size: 0 0 0 = 5-bit. 0 0 1 = 6-bit. 0 1 0 = 7 bit. 0 1 1 = 8-bit. 1 1 1 = 9 bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>UCPOL0</NAME>
          <DESCRIPTION>Clock Polarity</DESCRIPTION>
          <TEXT>This bit is used for synchronous mode only. Write this bit to zero when asynchronous mode is used. The UCPOL bit sets the relationship between data output change and data input sample, and the synchronous clock (XCK).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </UCSR0C>
      <UCSR0D>
        <NAME>UCSR0D</NAME>
        <DESCRIPTION>USART Control and Status Register D</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x23</IO_ADDR>
        <MEM_ADDR>0x43</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>RXSIE0</NAME>
          <ALIAS>RXSIE</ALIAS>
          <DESCRIPTION>USART RX Start Interrupt Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>RXS0</NAME>
          <ALIAS>RXS</ALIAS>
          <DESCRIPTION>USART RX Start Flag</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SFDE0</NAME>
          <DESCRIPTION>USART RX Start Frame Detection Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
      </UCSR0D>
      <UBRR0H>
        <NAME>UBRR0H</NAME>
        <DESCRIPTION>USART Baud Rate Register High Byte</DESCRIPTION>
        <TEXT>This is a 12-bit register which contains the USART baud rate. The UBRR0H contains the 4 most significant bits, and the UBRR0L contains the 8 least significant bits of the USART baud rate. Ongoing transmissions by the transmitter and receiver will be corrupted if the baud rate is changed. Writing UBRR0L will trigger an immediate update of the baud rate prescaler.</TEXT>
        <IO_ADDR>0x22</IO_ADDR>
        <MEM_ADDR>0x42</MEM_ADDR>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT3>
          <NAME>UBRR11</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 11</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UBRR10</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 10</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>UBRR9</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 9</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>UBRR8</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 8</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </UBRR0H>
      <UBRR0L>
        <NAME>UBRR0L</NAME>
        <DESCRIPTION>USART Baud Rate Register Low Byte</DESCRIPTION>
        <TEXT>This is a 12-bit register which contains the USART baud rate. The UBRR0H contains the 4 most significant bits, and the UBRR0L contains the 8 least significant bits of the USART baud rate. Ongoing transmissions by the transmitter and receiver will be corrupted if the baud rate is changed. Writing UBRR0L will trigger an immediate update of the baud rate prescaler.</TEXT>
        <IO_ADDR>0x21</IO_ADDR>
        <MEM_ADDR>0x41</MEM_ADDR>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>UBRR7</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>UBRR6</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UBRR5</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>UBRR4</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>UBRR3</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UBRR2</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>_UBRR1</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>_UBRR0</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </UBRR0L>
    </USART0>
    <USART1>
      <LIST>[UDR1:UCSR1A:UCSR1B:UCSR1C:UCSR1D:UBRR1H:UBRR1L]</LIST>
      <LINK>[UBRR1H:UBRR1L]</LINK>
      <ICON>io_com.bmp</ICON>
      <ID/>
      <TEXT>The Universal Synchronous and Asynchronous serial Receiver and Transmitter (USART) is a highly flexible serial communication device. The main features are: &#x2022; Full Duplex Operation (Independent Serial Receive and Transmit Registers) &#x2022; Asynchronous or Synchronous Operation &#x2022; Master or Slave Clocked Synchronous Operation &#x2022; High Resolution Baud Rate Generator &#x2022; Supports Serial Frames with 5, 6, 7, 8 or 9 Data Bits and 1 or 2 Stop Bits &#x2022; Odd or Even Parity Generation and Parity Check Supported by Hardware &#x2022; Data OverRun Detection &#x2022; Framing Error Detection &#x2022; Noise Filtering Includes False Start Bit Detection and Digital Low Pass Filter &#x2022; Three Separate Interrupts on TX Complete, TX Data Register Empty and RX Complete &#x2022; Multi-processor Communication Mode &#x2022; Double Speed Asynchronous Communica</TEXT>
      <UDR1>
        <NAME>UDR1</NAME>
        <DESCRIPTION>USART I/O Data Register</DESCRIPTION>
        <TEXT>The UDR1 register is actually two physically separate registers sharing the same I/O address. When writing to the register, the USART Transmit Data register is written. When reading from UDR0, the USART Receive Data register is read.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x73</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <READ_INTRUSIVE/>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>UDR1_7</NAME>
          <DESCRIPTION>USART I/O Data Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>UDR1_6</NAME>
          <DESCRIPTION>USART I/O Data Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UDR1_5</NAME>
          <DESCRIPTION>USART I/O Data Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>UDR1_4</NAME>
          <DESCRIPTION>USART I/O Data Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>UDR1_3</NAME>
          <DESCRIPTION>USART I/O Data Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UDR1_2</NAME>
          <DESCRIPTION>USART I/O Data Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>UDR1_1</NAME>
          <DESCRIPTION>USART I/O Data Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>UDR1_0</NAME>
          <DESCRIPTION>USART I/O Data Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </UDR1>
      <UCSR1A>
        <NAME>UCSR1A</NAME>
        <DESCRIPTION>USART Control and Status Register A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x79</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>RXC1</NAME>
          <DESCRIPTION>USART Receive Complete</DESCRIPTION>
          <TEXT>This bit is set (one) when a received character is transferred from the Receiver Shift register to UDR0. The bit is set regard-less of any detected framing errors. When the RXCIE bit in UCR is set, the USART Receive Complete interrupt will be executed when RXC is set(one). RXC is cleared by reading UDR0. When interrupt-driven data reception is used, the USART Receive Complete Interrupt routine must read UDRin order to clear RXC, otherwise a new interrupt will occur once the interrupt routine terminates.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TXC1</NAME>
          <DESCRIPTION>USART Transmitt Complete</DESCRIPTION>
          <TEXT>This bit is set (one) when the entire character (including the stop bit) in the Transmit Shift register has been shifted out and no new data has been written to UDR0. This flag is especially useful in half-duplex communications interfaces, where a transmitting application must enter receive mode and free the communications bus immediately after completing the transmission. When the TXCIE bit in UCR is set, setting of TXC causes the USART Transmit Complete interrupt to be executed. TXC is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, the TXC bit is cleared (zero) by writing a logical one to the b</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UDRE1</NAME>
          <DESCRIPTION>USART Data Register Empty</DESCRIPTION>
          <TEXT>This bit is set (one) when a character written to UDRis transferred to the Transmit shift register. Setting of this bit indicates that the transmitter is ready to receive a new character for transmission. When the UDR0IE bit in UCR is set, the USART Transmit Complete interrupt to be executed as long as UDR0E is set. UDR0E is cleared by writing UDR0. When interrupt-driven data transmittal is used, the USART Data Register Empty Interrupt routine must write UDRin order to clear UDR0E, otherwise a new interrupt will occur once the interrupt routine terminates. UDR0E is set (one) during reset to indicate that the transmitter is re</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>FE1</NAME>
          <DESCRIPTION>Framing Error</DESCRIPTION>
          <TEXT>This bit is set if a Framing Error condition is detected, i.e. when the stop bit of an incoming character is zero. The FE bit is cleared when the stop bit of received data is one.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>DOR1</NAME>
          <DESCRIPTION>Data overRun</DESCRIPTION>
          <TEXT>This bit is set if an Overrun condition is detected, i.e. when a character already present in the UDRregister is not read before the next character has been shifted into the Receiver Shift register. The OR bit is buffered, which means that it will be set once the valid data still in UDR0E is read. The OR bit is cleared (zero) when data is received and transferred to UDR0. </TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UPE1</NAME>
          <DESCRIPTION>Parity Error</DESCRIPTION>
          <TEXT>This bit is set if the next character in the receive buffer had a Parity Error when received and the parity checking was enabled at that point (UPM1 = 1). This bit is valid until the receive buffer (UDR0) is read. Always set this bit to zero when writing to UCSR0A.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>U2X1</NAME>
          <DESCRIPTION>Double the USART transmission speed</DESCRIPTION>
          <TEXT>This bit only has effect for the asynchronous operation. Write this bit to zero when using synchronous operation. Writing this bit to one will reduce the divisor of the baud rate divider from 16 to 8 effectively doubling the transfer rate for asynchronous communication.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>MPCM1</NAME>
          <DESCRIPTION>Multi-processor Communication Mode</DESCRIPTION>
          <TEXT>This bit enables the Multi-processor Communication Mode. When the MPCM bit is written to one, all the incoming frames received by the USART receiver that do not contain address information will be ignored. The transmitter is unaffected by the MPCM setting. For more detailed information see &#x201C;Multi-processor Communication Mode&#x201D; on page 152.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </UCSR1A>
      <UCSR1B>
        <NAME>UCSR1B</NAME>
        <DESCRIPTION>USART Control and Status Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x78</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>RXCIE1</NAME>
          <DESCRIPTION>RX Complete Interrupt Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables interrupt on the RXC flag. A USART Receive Complete interrupt will be generated only if the RXCIE bit is written to one, the global interrupt flag in SREG is written to one and the RXC bit in UCSR0A is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TXCIE1</NAME>
          <DESCRIPTION>TX Complete Interrupt Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables interrupt on the TXC flag. A USART Transmit Complete interrupt will be generated only if the TXCIE bit is written to one, the global interrupt flag in SREG is written to one and the TXC bit in UCSR0A is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UDRIE1</NAME>
          <DESCRIPTION>USART Data register Empty Interrupt Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables interrupt on the UDR0E flag. A Data Register Empty interrupt will be generated only if the UDR0IE bit is written to one, the global interrupt flag in SREG is written to one and the UDR0E bit in UCSR0A is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>RXEN1</NAME>
          <DESCRIPTION>Receiver Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables the USART receiver. The receiver will override normal port operation for the RxD pin when enabled. Disabling the receiver will flush the receive buffer invalidating the FE, DOR and PE flags.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TXEN1</NAME>
          <DESCRIPTION>Transmitter Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables the USART transmitter. The transmitter will override normal port operation for the TxD pin when enabled. The disabling of the transmitter (writing TXEN to zero) will not become effective until ongoing and pending transmissions are completed, i.e. when the transmit shift register and transmit buffer register does not contain data to be transmitted. When disabled, the transmitter will no longer override the TxD port.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UCSZ12</NAME>
          <DESCRIPTION>Character Size</DESCRIPTION>
          <TEXT>The UCSZ2 bits combined with the UCSZ1:0 bit in UCSR0C sets the number of data bits (character size) in a frame the receiver and transmitter use.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>RXB81</NAME>
          <DESCRIPTION>Receive Data Bit 8</DESCRIPTION>
          <TEXT>RXB8 is the 9th data bit of the received character when operating with serial frames with 9 data bits. Must be read before reading the low bits from UDR0.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TXB81</NAME>
          <DESCRIPTION>Transmit Data Bit 8</DESCRIPTION>
          <TEXT>TXB8 is the 9th data bit in the character to be transmitted when operating with serial frames with 9 data bits. Must be writ-ten before writing the low bits to UDR0.</TEXT>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </UCSR1B>
      <UCSR1C>
        <NAME>UCSR1C</NAME>
        <DESCRIPTION>USART Control and Status Register C</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x77</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>UMSEL11</NAME>
          <DESCRIPTION>USART Mode Select</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>UMSEL10</NAME>
          <DESCRIPTION>USART Mode Select</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <ENUM>COMM_USART_MODE_2BIT</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UPM11</NAME>
          <DESCRIPTION>Parity Mode Bit 1</DESCRIPTION>
          <TEXT>This bit enable and set type of parity generation and check. If enabled, the transmitter will automatically generate and send the parity of the transmitted data bits within each frame. The receiver will generate a parity value for the incoming data and compare it to the UPM0 setting. If a mismatch is detected, the PE flag in UCSR0A will be set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>UPM10</NAME>
          <DESCRIPTION>Parity Mode Bit 0</DESCRIPTION>
          <TEXT>This bit enable and set type of parity generation and check. If enabled, the transmitter will automatically generate and send the parity of the transmitted data bits within each frame. The receiver will generate a parity value for the incoming data and compare it to the UPM0 setting. If a mismatch is detected, the PE flag in UCSR0A will be set.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>COMM_UPM_PARITY_MODE</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>USBS1</NAME>
          <DESCRIPTION>Stop Bit Select</DESCRIPTION>
          <TEXT>0: 1-bit.  1: 2-bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>COMM_STOP_BIT_SEL</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UCSZ11</NAME>
          <ALIAS>UDORD1</ALIAS>
          <DESCRIPTION>Character Size</DESCRIPTION>
          <TEXT>Character Size: 0 0 0 = 5-bit. 0 0 1 = 6-bit. 0 1 0 = 7 bit. 0 1 1 = 8-bit. 1 1 1 = 9 bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>UCSZ10</NAME>
          <ALIAS>UCPHA1</ALIAS>
          <DESCRIPTION>Character Size</DESCRIPTION>
          <TEXT>Character Size: 0 0 0 = 5-bit. 0 0 1 = 6-bit. 0 1 0 = 7 bit. 0 1 1 = 8-bit. 1 1 1 = 9 bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>UCPOL1</NAME>
          <DESCRIPTION>Clock Polarity</DESCRIPTION>
          <TEXT>This bit is used for synchronous mode only. Write this bit to zero when asynchronous mode is used. The UCPOL bit sets the relationship between data output change and data input sample, and the synchronous clock (XCK).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </UCSR1C>
      <UCSR1D>
        <NAME>UCSR1D</NAME>
        <DESCRIPTION>USART Control and Status Register D</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x76</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>RXSIE1</NAME>
          <ALIAS>RXSIE</ALIAS>
          <DESCRIPTION>USART RX Start Interrupt Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>RXS1</NAME>
          <ALIAS>RXS</ALIAS>
          <DESCRIPTION>USART RX Start Flag</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SFDE1</NAME>
          <DESCRIPTION>USART RX Start Frame Detection Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
      </UCSR1D>
      <UBRR1H>
        <NAME>UBRR1H</NAME>
        <DESCRIPTION>USART Baud Rate Register High Byte</DESCRIPTION>
        <TEXT>This is a 12-bit register which contains the USART baud rate. The UBRR0H contains the 4 most significant bits, and the UBRR0L contains the 8 least significant bits of the USART baud rate. Ongoing transmissions by the transmitter and receiver will be corrupted if the baud rate is changed. Writing UBRR0L will trigger an immediate update of the baud rate prescaler.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x75</MEM_ADDR>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT3>
          <NAME>UBRR_11</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 11</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UBRR_10</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 10</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>UBRR_9</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 9</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>UBRR_8</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 8</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </UBRR1H>
      <UBRR1L>
        <NAME>UBRR1L</NAME>
        <DESCRIPTION>USART Baud Rate Register Low Byte</DESCRIPTION>
        <TEXT>This is a 12-bit register which contains the USART baud rate. The UBRR0H contains the 4 most significant bits, and the UBRR0L contains the 8 least significant bits of the USART baud rate. Ongoing transmissions by the transmitter and receiver will be corrupted if the baud rate is changed. Writing UBRR0L will trigger an immediate update of the baud rate prescaler.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>0x74</MEM_ADDR>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>UBRR_7</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>UBRR_6</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UBRR_5</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>UBRR_4</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>UBRR_3</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UBRR_2</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>UBRR_1</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>UBRR_0</NAME>
          <DESCRIPTION>USART Baud Rate Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </UBRR1L>
    </USART1>
    <WATCHDOG>
      <LIST>[WDTCSR]</LIST>
      <LINK/>
      <ICON>io_watch.bmp</ICON>
      <ID/>
      <TEXT/>
      <WDTCSR>
        <NAME>WDTCSR</NAME>
        <DESCRIPTION>Watchdog Timer Control and Status Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>0x30</IO_ADDR>
        <MEM_ADDR>0x50</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>WDIF</NAME>
          <DESCRIPTION>Watchdog Timer Interrupt Flag</DESCRIPTION>
          <TEXT>This bit is set when a time-out occurs in the Watchdog Timer and the Watchdog Timer is configured for interrupt. WDTIF is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, WDTIF is cleared by writing a logic one to the flag. When the WDTIE is set, the Watchdog Time-out Interrupt is requested.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>WDIE</NAME>
          <DESCRIPTION>Watchdog Timer Interrupt Enable</DESCRIPTION>
          <TEXT>When this bit is written to one, the Watchdog interrupt request is enabled. If WDE is cleared in combination with this setting, the Watchdog Timer is in Interrupt Mode, and the corresponding interrupt is requested if time-out in the Watchdog Timer occurs. If WDE is set, the Watchdog Timer is in Interrupt and System Reset Mode. The first time-out in the Watchdog Timer will set WDTIF. Executing the corresponding interrupt vector will clear WDTIE and WDTIF automatically by hardware (the Watchdog goes to System Reset Mode). This is useful for keeping the Watchdog Timer security while using the interrupt. To stay in Interrupt and System Reset Mode, WDTIE must be set after each interrupt. This should however not be done within the interrupt service routine itself, as this might compromise the safety-function of the Watchdog System Reset mode. If the interrupt is not executed before the next time-out, a System Reset will be applied</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>WDP3</NAME>
          <DESCRIPTION>Watchdog Timer Prescaler Bit 3</DESCRIPTION>
          <TEXT>The WDP3..0 bits determine the Watchdog Timer prescaling when the Watchdog Timer is running.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT3>
          <NAME>WDE</NAME>
          <DESCRIPTION>Watch Dog Enable</DESCRIPTION>
          <TEXT>WDE is overridden by WDRF in MCUSR. This means that WDE is always set when WDRF is set. To clear WDE, WDRF must be cleared first. This feature ensures multiple resets during conditions causing failure, and a safe start-up after the failure.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>WDP2</NAME>
          <DESCRIPTION>Watch Dog Timer Prescaler bit 2</DESCRIPTION>
          <TEXT>The WDP3..0 bits determine the Watchdog Timer prescaling when the Watchdog Timer is running.</TEXT>
          <ENUM>WDOG_TIMER_PRESCALE_4BITS_32KHZ</ENUM>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>WDP1</NAME>
          <DESCRIPTION>Watch Dog Timer Prescaler bit 1</DESCRIPTION>
          <TEXT>The WDP3..0 bits determine the Watchdog Timer prescaling when the Watchdog Timer is running.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>WDP0</NAME>
          <DESCRIPTION>Watch Dog Timer Prescaler bit 0</DESCRIPTION>
          <TEXT>The WDP3..0 bits determine the Watchdog Timer prescaling when the Watchdog Timer is running.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </WDTCSR>
    </WATCHDOG>
  </IO_MODULE>
  <ICE_SETTINGS>
    <MODULE_LIST>[STK500:AVRISPmkII:SIMULATOR2:STK500_2:STK600]</MODULE_LIST>
    <STK500>
      <DeviceId>0x59</DeviceId>
      <SelfTimed>1</SelfTimed>
      <FullParallel>1</FullParallel>
      <Polled>1</Polled>
      <FPoll>0xFF</FPoll>
      <EPol1>0xFF</EPol1>
      <EPol2>0xFF</EPol2>
      <ComLockFuseRead>0</ComLockFuseRead>
      <ResetDisable>1</ResetDisable>
    </STK500>
    <AVRISPmkII/>
    <SIMULATOR2>
      <MODEL>libATtiny3234.dll</MODEL>
    </SIMULATOR2>
    <STK500_2>
      <IspEnterProgMode>
        <timeout>200</timeout>
        <stabDelay>100</stabDelay>
        <cmdexeDelay>25</cmdexeDelay>
        <synchLoops>32</synchLoops>
        <byteDelay>0</byteDelay>
        <pollIndex>3</pollIndex>
        <pollValue>0x53</pollValue>
      </IspEnterProgMode>
      <IspLeaveProgMode>
        <preDelay>1</preDelay>
        <postDelay>1</postDelay>
      </IspLeaveProgMode>
      <IspChipErase>
        <eraseDelay>45</eraseDelay>
        <pollMethod>1</pollMethod>
      </IspChipErase>
      <IspProgramFlash>
        <mode>0x41</mode>
        <blockSize>32</blockSize>
        <delay>10</delay>
        <cmd1>0x40</cmd1>
        <cmd2>0x4C</cmd2>
        <cmd3>0x00</cmd3>
        <pollVal1>0x00</pollVal1>
        <pollVal2>0x00</pollVal2>
      </IspProgramFlash>
      <IspProgramEeprom>
        <mode>0x41</mode>
        <blockSize>4</blockSize>
        <delay>20</delay>
        <cmd1>0xC1</cmd1>
        <cmd2>0xC2</cmd2>
        <cmd3>0x00</cmd3>
        <pollVal1>0x00</pollVal1>
        <pollVal2>0x00</pollVal2>
      </IspProgramEeprom>
      <IspReadFlash>
        <blockSize>256</blockSize>
      </IspReadFlash>
      <IspReadEeprom>
        <blockSize>256</blockSize>
      </IspReadEeprom>
      <IspReadFuse>
        <pollIndex>4</pollIndex>
      </IspReadFuse>
      <IspReadLock>
        <pollIndex>4</pollIndex>
      </IspReadLock>
      <IspReadSign>
        <pollIndex>4</pollIndex>
      </IspReadSign>
      <IspReadOsccal>
        <pollIndex>4</pollIndex>
      </IspReadOsccal>
      <PPControlStack>0x0E 0x1E 0x0F 0x1F 0x2E 0x3E 0x2F 0x3F 0x4E 0x5E 0x4F 0x5F 0x6E 0x7E 0x6F 0x7F 0x66 0x76 0x67 0x77 0x6A 0x7A 0x6B 0x7B 0xBE 0xFD 0x00 0x01 0x00 0x00 0x00 0x00</PPControlStack>
      <PpEnterProgMode>
        <stabDelay>100</stabDelay>
        <progModeDelay>0</progModeDelay>
        <latchCycles>5</latchCycles>
        <toggleVtg>1</toggleVtg>
        <powerOffDelay>15</powerOffDelay>
        <resetDelayMs>1</resetDelayMs>
        <resetDelayUs>0</resetDelayUs>
      </PpEnterProgMode>
      <PpLeaveProgMode>
        <stabDelay>15</stabDelay>
        <resetDelay>15</resetDelay>
      </PpLeaveProgMode>
      <PpChipErase>
        <pulseWidth>0</pulseWidth>
        <pollTimeout>10</pollTimeout>
      </PpChipErase>
      <PpProgramFlash>
        <pollTimeout>5</pollTimeout>
        <mode>0x09</mode>
        <blockSize>256</blockSize>
      </PpProgramFlash>
      <PpReadFlash>
        <blockSize>256</blockSize>
      </PpReadFlash>
      <PpProgramEeprom>
        <pollTimeout>5</pollTimeout>
        <mode>0x05</mode>
        <blockSize>256</blockSize>
      </PpProgramEeprom>
      <PpReadEeprom>
        <blockSize>256</blockSize>
      </PpReadEeprom>
      <PpProgramFuse>
        <pulseWidth>0</pulseWidth>
        <pollTimeout>5</pollTimeout>
      </PpProgramFuse>
      <PpProgramLock>
        <pulseWidth>0</pulseWidth>
        <pollTimeout>5</pollTimeout>
      </PpProgramLock>
    </STK500_2>
    <STK600>
      <IspEnterProgMode>
        <timeout>200</timeout>
        <stabDelay>100</stabDelay>
        <cmdexeDelay>25</cmdexeDelay>
        <synchLoops>32</synchLoops>
        <byteDelay>0</byteDelay>
        <pollIndex>3</pollIndex>
        <pollValue>0x53</pollValue>
      </IspEnterProgMode>
      <IspLeaveProgMode>
        <preDelay>1</preDelay>
        <postDelay>1</postDelay>
      </IspLeaveProgMode>
      <IspChipErase>
        <eraseDelay>45</eraseDelay>
        <pollMethod>1</pollMethod>
      </IspChipErase>
      <IspProgramFlash>
        <mode>0x41</mode>
        <blockSize>32</blockSize>
        <delay>6</delay>
        <cmd1>0x40</cmd1>
        <cmd2>0x4C</cmd2>
        <cmd3>0x00</cmd3>
        <pollVal1>0x00</pollVal1>
        <pollVal2>0x00</pollVal2>
      </IspProgramFlash>
      <IspProgramEeprom>
        <mode>0x41</mode>
        <blockSize>4</blockSize>
        <delay>5</delay>
        <cmd1>0xC1</cmd1>
        <cmd2>0xC2</cmd2>
        <cmd3>0x00</cmd3>
        <pollVal1>0x00</pollVal1>
        <pollVal2>0x00</pollVal2>
      </IspProgramEeprom>
      <IspReadFlash>
        <blockSize>256</blockSize>
      </IspReadFlash>
      <IspReadEeprom>
        <blockSize>256</blockSize>
      </IspReadEeprom>
      <IspReadFuse>
        <pollIndex>4</pollIndex>
      </IspReadFuse>
      <IspReadLock>
        <pollIndex>4</pollIndex>
      </IspReadLock>
      <IspReadSign>
        <pollIndex>4</pollIndex>
      </IspReadSign>
      <IspReadOsccal>
        <pollIndex>4</pollIndex>
      </IspReadOsccal>
      <PPControlStack>0x0E 0x1E 0x0E 0x1E 0x2E 0x3E 0x2E 0x3E 0x4E 0x5E 0x4E 0x5E 0x6E 0x7E 0x6E 0x7E 0x06 0x16 0x46 0x56 0x0A 0x1A 0x4A 0x5A 0x1E 0x7C 0x00 0x01 0x00 0x00 0x00 0x00</PPControlStack>
      <PpEnterProgMode>
        <stabDelay>100</stabDelay>
        <progModeDelay>0</progModeDelay>
        <latchCycles>5</latchCycles>
        <toggleVtg>1</toggleVtg>
        <powerOffDelay>20</powerOffDelay>
        <resetDelayMs>1</resetDelayMs>
        <resetDelayUs>0</resetDelayUs>
      </PpEnterProgMode>
      <PpLeaveProgMode>
        <stabDelay>15</stabDelay>
        <resetDelay>15</resetDelay>
      </PpLeaveProgMode>
      <PpChipErase>
        <pulseWidth>0</pulseWidth>
        <pollTimeout>10</pollTimeout>
      </PpChipErase>
      <PpProgramFlash>
        <pollTimeout>5</pollTimeout>
        <mode>0x09</mode>
        <blockSize>256</blockSize>
      </PpProgramFlash>
      <PpReadFlash>
        <blockSize>256</blockSize>
      </PpReadFlash>
      <PpProgramEeprom>
        <pollTimeout>5</pollTimeout>
        <mode>0x05</mode>
        <blockSize>256</blockSize>
      </PpProgramEeprom>
      <PpReadEeprom>
        <blockSize>256</blockSize>
      </PpReadEeprom>
      <PpProgramFuse>
        <pulseWidth>0</pulseWidth>
        <pollTimeout>5</pollTimeout>
      </PpProgramFuse>
      <PpProgramLock>
        <pulseWidth>0</pulseWidth>
        <pollTimeout>5</pollTimeout>
      </PpProgramLock>
    </STK600>
  </ICE_SETTINGS>
  <V2>
    <templates>
      <module class="FUSE">
        <registers name="FUSE" memspace="FUSE">
          <reg size="1" name="EXTENDED" offset="0x02">
            <bitfield name="BODPD" mask="0x18" text="BOD mode of operation when the device is in sleep mode" icon="" enum="ENUM_BODMODE"/>
            <bitfield name="BODACT" mask="0x06" text="BOD mode of operation when the device is active or idle" icon="" enum="ENUM_BODMODE"/>
            <bitfield name="SELFPRGEN" mask="0x01" text="Self Programming enable" icon=""/>
          </reg>
          <reg size="1" name="HIGH" offset="0x01">
            <bitfield name="RSTDISBL" mask="0x80" text="Reset Disabled (Enable PC2 as i/o pin)" icon=""/>
            <bitfield name="DWEN" mask="0x40" text="Debug Wire enable" icon=""/>
            <bitfield name="SPIEN" mask="0x20" text="Serial program downloading (SPI) enabled" icon=""/>
            <bitfield name="WDTON" mask="0x10" text="Watch-dog Timer always on" icon=""/>
            <bitfield name="EESAVE" mask="0x08" text="Preserve EEPROM through the Chip Erase cycle" icon=""/>
            <bitfield name="BODLEVEL" mask="0x07" text="Brown-out Detector trigger level" icon="" enum="ENUM_BODLEVEL"/>
          </reg>
          <reg size="1" name="LOW" offset="0x00">
            <bitfield name="CKDIV8" mask="0x80" text="Divide clock by 8 internally" icon=""/>
            <bitfield name="CKOUT" mask="0x40" text="Clock output on PORTC2" icon=""/>
            <bitfield name="SUT_CKSEL" mask="0x1F" text="Select Clock Source" icon="" enum="ENUM_SUT_CKSEL"/>
          </reg>
        </registers>
        <enumerator name="ENUM_SUT_CKSEL">
          <enum val="0x00" text="Ext. Clock; Start-up time PWRDWN/RESET: 6 CK/16 CK + 16 ms" constname="EXTCLK_6CK_16CK_16MS"/>
          <enum val="0x02" text="Int. RC Osc. 8 MHz; Start-up time PWRDWN/RESET: 6 CK/16 CK + 16 ms" constname="INTRCOSC_8MHZ_6CK_16CK_16MS"/>
          <enum val="0x04" text="Int. ULP Osc. 32 kHz; Start-up time PWRDWN/RESET: 6 CK/16 CK + 16 ms" constname="INTULPOSC_32KHZ_6CK_16CK_16MS"/>
          <enum val="0x08" text="Ext. Ceramic Res. 0.4-0.9 MHz; Start-up time PWRDWN/RESET: 258 CK/16 CK + 16 ms" constname="EXTCRES_0MHZ4_0MHZ9_258CK_16CK_16MS"/>
          <enum val="0x18" text="Ext. Ceramic Res. 0.4-0.9 MHz; Start-up time PWRDWN/RESET: 1K CK/16 CK + 16 ms" constname="EXTCRES_0MHZ4_0MHZ9_1KCK_16CK_16MS"/>
          <enum val="0x09" text="Ext. Crystal Osc. 0.4-0.9 MHz; Start-up time PWRDWN/RESET: 16 K CK/16 CK + 16 ms" constname="EXTXOSC_0MHZ4_0MHZ9_16KCK_16CK_16MS"/>
          <enum val="0x0a" text="Ext. Ceramic Res. 0.9-3.0 MHz; Start-up time PWRDWN/RESET: 258 CK/16 CK + 16 ms" constname="EXTCRES_0MHZ9_3MHZ_258CK_16CK_16MS"/>
          <enum val="0x1a" text="Ext. Ceramic Res. 0.9-3.0 MHz; Start-up time PWRDWN/RESET: 1K CK/16 CK + 16 ms" constname="EXTCRES_0MHZ9_3MHZ_1KCK_16CK_16MS"/>
          <enum val="0x0b" text="Ext. Crystal Osc. 0.9-3.0 MHz; Start-up time PWRDWN/RESET: 16 K CK/16 CK + 16 ms" constname="EXTXOSC_0MHZ9_3MHZ_16KCK_16CK_16MS"/>
          <enum val="0x0c" text="Ext. Ceramic Res. 3.0-8.0 MHz; Start-up time PWRDWN/RESET: 258 CK/16 CK + 16 ms" constname="EXTCRES_3MHZ_8MHZ_258CK_16CK_16MS"/>
          <enum val="0x1c" text="Ext. Ceramic Res. 3.0-8.0 MHz; Start-up time PWRDWN/RESET: 1K CK/16 CK + 16 ms" constname="EXTCRES_3MHZ_8MHZ_1KCK_16CK_16MS"/>
          <enum val="0x0d" text="Ext. Crystal Osc. 3.0-8.0 MHz; Start-up time PWRDWN/RESET: 16 K CK/16 CK + 16 ms" constname="EXTXOSC_3MHZ_8MHZ_16KCK_16CK_16MS"/>
          <enum val="0x0e" text="Ext. Ceramic Res. 8.0- MHz; Start-up time PWRDWN/RESET: 258 CK/16 CK + 16 ms" constname="EXTCRES_8MHZ_XX_258CK_16CK_16MS"/>
          <enum val="0x1e" text="Ext. Ceramic Res. 8.0- MHz; Start-up time PWRDWN/RESET: 1K CK/16 CK + 16 ms" constname="EXTCRES_8MHZ_XX_1KCK_16CK_16MS"/>
          <enum val="0x0f" text="Ext. Crystal Osc. 8.0- MHz; Start-up time PWRDWN/RESET: 16 K CK/16 CK + 16 ms" constname="EXTXOSC_8MHZ_XX_16KCK_16CK_16MS"/>
        </enumerator>
        <enumerator name="ENUM_BODLEVEL">
          <enum val="0x04" text="Brown-out detection at VCC=4.3 V" constname="4V3"/>
          <enum val="0x05" text="Brown-out detection at VCC=2.7 V" constname="2V7"/>
          <enum val="0x06" text="Brown-out detection at VCC=1.8 V" constname="1V8"/>
        </enumerator>
        <enumerator name="ENUM_BODMODE">
          <enum val="0x01" text="Sampled" constname="BOD_SAMPLED"/>
          <enum val="0x02" text="Enabled" constname="BOD_ENABLED"/>
          <enum val="0x03" text="Disabled" constname="BOD_DISABLED"/>
        </enumerator>
      </module>
      <module class="LOCKBIT">
        <registers name="LOCKBIT" memspace="LOCKBIT">
          <reg size="1" name="LOCKBIT" offset="0x00">
            <bitfield name="LB" mask="0x03" text="Memory Lock" icon="" enum="ENUM_LB"/>
          </reg>
        </registers>
        <enumerator name="ENUM_LB">
          <enum val="0x00" text="Further programming and verification disabled" constname="PROG_VER_DISABLED"/>
          <enum val="0x02" text="Further programming disabled" constname="PROG_DISABLED"/>
          <enum val="0x03" text="No memory lock features enabled" constname="NO_LOCK"/>
        </enumerator>
      </module>
      <module class="TWI" text="">
        <registers name="TWI" memspace="DATAMEM" text="" icon="io_com.bmp">
          <reg size="1" name="TWSCRA" offset="0x7F" text="TWI Slave Control Register A" icon="io_com.bmp">
            <bitfield name="TWDIE" mask="0x20" text="TWI Data Interrupt Enable" icon=""/>
            <bitfield name="TWASIE" mask="0x10" text="TWI Address/Stop Interrupt Enable" icon=""/>
            <bitfield name="TWEN" mask="0x08" text="Two-Wire Interface Enable" icon=""/>
            <bitfield name="TWSIE" mask="0x04" text="TWI Stop Interrupt Enable" icon=""/>
            <bitfield name="TWPME" mask="0x02" text="TWI Promiscuous Mode Enable" icon=""/>
            <bitfield name="TWSME" mask="0x01" text="TWI Smart Mode Enable" icon=""/>
          </reg>
          <reg size="1" name="TWSCRB" offset="0x7E" text="TWI Slave Control Register B" icon="io_com.bmp">
            <bitfield name="TWAA" mask="0x04" text="TWI Acknowledge Action" icon=""/>
            <bitfield name="TWCMD" mask="0x03" text="" icon=""/>
          </reg>
          <reg size="1" name="TWSSRA" offset="0x7D" text="TWI Slave Status Register A" icon="io_com.bmp" mask="0xFF"/>
          <reg size="1" name="TWSA" offset="0x7C" text="TWI Slave Address Register" icon="io_flag.bmp">
            <bitfield name="TWSA" mask="0xFF" text="TWI slave address bit" icon=""/>
          </reg>
          <reg size="1" name="TWSD" offset="0x7A" text="TWI Slave Data Register" icon="io_flag.bmp">
            <bitfield name="TWSD" mask="0xFF" text="TWI slave data bit" icon=""/>
          </reg>
          <reg size="1" name="TWSAM" offset="0x7B" text="TWI Slave Address Mask Register" icon="io_com.bmp" mask="0xFF"/>
        </registers>
      </module>
      <module class="PORTB" text="">
        <registers name="PORTB" memspace="DATAMEM" text="" icon="io_port.bmp">
          <reg size="1" name="PORTCR" offset="0x33" text="Port Control Register" icon="io_flag.bmp">
            <bitfield name="BBMB" mask="0x02" text="Break-Before-Make Mode Enable" icon=""/>
          </reg>
          <reg size="1" name="PUEB" offset="0x2E" text="Pull-up Enable Control Register" icon="io_flag.bmp" mask="0x0F"/>
          <reg size="1" name="DDRB" offset="0x2C" text="Data Direction Register, Port B" icon="io_flag.bmp" mask="0x0F"/>
          <reg size="1" name="PINB" offset="0x2B" text="Port B Data register" icon="io_port.bmp" mask="0x0F"/>
          <reg size="1" name="PORTB" offset="0x2D" text="Input Pins, Port B" icon="io_port.bmp" mask="0x0F"/>
        </registers>
      </module>
      <module class="PORTC" text="">
        <registers name="PORTC" memspace="DATAMEM" text="" icon="io_port.bmp">
          <reg size="1" name="PORTCR" offset="0x33" text="Port Control Register" icon="io_flag.bmp">
            <bitfield name="BBMC" mask="0x04" text="Break-Before-Make Mode Enable" icon=""/>
          </reg>
          <reg size="1" name="PUEC" offset="0x2A" text="Pull-up Enable Control Register" icon="io_flag.bmp" mask="0x3F"/>
          <reg size="1" name="PORTC" offset="0x29" text="Port C Data Register" icon="io_port.bmp" mask="0x3F"/>
          <reg size="1" name="DDRC" offset="0x28" text="Data Direction Register, Port C" icon="io_flag.bmp" mask="0x3F"/>
          <reg size="1" name="PINC" offset="0x27" text="Port C Input Pins" icon="io_port.bmp" mask="0x3F"/>
        </registers>
      </module>
      <module class="PORTA" text="">
        <registers name="PORTA" memspace="DATAMEM" text="" icon="io_port.bmp">
          <reg size="1" name="PORTCR" offset="0x33" text="Port Control Register" icon="io_flag.bmp">
            <bitfield name="BBMA" mask="0x01" text="Break-Before-Make Mode Enable" icon=""/>
          </reg>
          <reg size="1" name="PUEA" offset="0x32" text="Pull-up Enable Control Register" icon="io_flag.bmp" mask="0xFF"/>
          <reg size="1" name="PORTA" offset="0x31" text="Port A Data Register" icon="io_port.bmp" mask="0xFF"/>
          <reg size="1" name="DDRA" offset="0x30" text="Data Direction Register, Port A" icon="io_flag.bmp" mask="0xFF"/>
          <reg size="1" name="PINA" offset="0x2F" text="Port A Input Pins" icon="io_port.bmp" mask="0xFF"/>
        </registers>
      </module>
      <module class="AD_CONVERTER" text="">
        <registers name="AD_CONVERTER" memspace="DATAMEM" text="" icon="io_analo.bmp">
          <reg size="1" name="ADMUX" offset="0x24" text="The ADC multiplexer Selection Register" icon="io_analo.bmp">
            <bitfield name="REFS" mask="0xC0" text="Reference Selection Bit" icon=""/>
            <bitfield name="MUX" mask="0x0F" text="Analog Channel and Gain Selection Bits" icon=""/>
          </reg>
          <reg size="1" name="ADCSRA" offset="0x23" text="The ADC Control and Status register" icon="io_flag.bmp">
            <bitfield name="ADEN" mask="0x80" text="ADC Enable" icon=""/>
            <bitfield name="ADSC" mask="0x40" text="ADC Start Conversion" icon=""/>
            <bitfield name="ADATE" mask="0x20" text="ADC Auto Trigger Enable" icon=""/>
            <bitfield name="ADIF" mask="0x10" text="ADC Interrupt Flag" icon=""/>
            <bitfield name="ADIE" mask="0x08" text="ADC Interrupt Enable" icon=""/>
            <bitfield name="ADPS" mask="0x07" text="ADC Prescaler Select Bits" icon="" enum="ANALIG_ADC_PRESCALER"/>
          </reg>
          <reg size="2" name="ADC" offset="0x20" text="ADC Data Register  Bytes" icon="io_analo.bmp" mask="0xFFFF"/>
          <reg size="1" name="ADCSRB" offset="0x22" text="ADC Control and Status Register B" icon="io_analo.bmp">
            <bitfield name="ADLAR" mask="0x08" text="" icon=""/>
            <bitfield name="ADTS" mask="0x07" text="ADC Auto Trigger Sources" icon="" enum="ANALIG_ADC_AUTO_TRIGGER"/>
          </reg>
          <reg size="1" name="DIDR2" offset="0x62" text="Digital Input Disable Register 2" icon="io_analo.bmp">
            <bitfield name="ADC11D" mask="0x04" text="ADC11 Digital input Disable" icon=""/>
            <bitfield name="ADC10D" mask="0x02" text="ADC10 Digital input Disable" icon=""/>
            <bitfield name="ADC9D" mask="0x01" text="ADC9 Digital input Disable" icon=""/>
          </reg>
          <reg size="1" name="DIDR1" offset="0x61" text="Digital Input Disable Register 1" icon="io_analo.bmp">
            <bitfield name="ADC8D" mask="0x08" text="ADC8 Digital Input Disable" icon=""/>
            <bitfield name="ADC7D" mask="0x04" text="ADC7 Digital input Disable" icon=""/>
            <bitfield name="ADC6D" mask="0x02" text="ADC6 Digital input Disable" icon=""/>
            <bitfield name="ADC5D" mask="0x01" text="ADC5 Digital input Disable" icon=""/>
          </reg>
          <reg size="1" name="DIDR0" offset="0x60" text="Digital Input Disable Register 0" icon="io_analo.bmp">
            <bitfield name="ADC4D" mask="0x80" text="ADC4 Digital input Disable" icon=""/>
            <bitfield name="ADC3D" mask="0x40" text="ADC3 Digital input Disable" icon=""/>
            <bitfield name="ADC2D" mask="0x20" text="ADC2 Digital input Disable" icon=""/>
            <bitfield name="ADC1D" mask="0x10" text="ADC1 Digital input Disable" icon=""/>
            <bitfield name="ADC0D" mask="0x08" text="ADC0 Digital Input Disable" icon=""/>
            <bitfield name="AIN1D" mask="0x04" text="AIN1 Digital input Disable" icon=""/>
            <bitfield name="AIN0D" mask="0x02" text="AIN0 Digital input Disable" icon=""/>
            <bitfield name="AREFD" mask="0x01" text="AREF Digital input Disable" icon=""/>
          </reg>
        </registers>
        <enumerator name="ANALIG_ADC_PRESCALER">
          <enum val="0x00" text="2"/>
          <enum val="0x01" text="2"/>
          <enum val="0x02" text="4"/>
          <enum val="0x03" text="8"/>
          <enum val="0x04" text="16"/>
          <enum val="0x05" text="32"/>
          <enum val="0x06" text="64"/>
          <enum val="0x07" text="128"/>
        </enumerator>
        <enumerator name="ANALIG_ADC_AUTO_TRIGGER">
          <enum val="0x00" text="Free Running mode"/>
          <enum val="0x01" text="Analog Comparator"/>
          <enum val="0x02" text="External Interrupt Request 0"/>
          <enum val="0x03" text="Timer/Counter0 Compare Match A"/>
          <enum val="0x04" text="Timer/Counter0 Overflow"/>
          <enum val="0x05" text="Timer/Counter1 Compare Match B"/>
          <enum val="0x06" text="Timer/Counter1 Overflow"/>
          <enum val="0x07" text="Timer/Counter1 Capture Event"/>
        </enumerator>
      </module>
      <module class="ANALOG_COMPARATOR" text="">
        <registers name="ANALOG_COMPARATOR" memspace="DATAMEM" text="" icon="io_analo.bmp">
          <reg size="1" name="ACSRB" offset="0x25" text="Analog Comparator Control And Status Register B" icon="io_analo.bmp">
            <bitfield name="HSEL" mask="0x80" text="Hysteresis Select" icon=""/>
            <bitfield name="HLEV" mask="0x40" text="Hysteresis Level" icon=""/>
            <bitfield name="ACME" mask="0x04" text="Analog Comparator Multiplexer Enable" icon=""/>
          </reg>
          <reg size="1" name="ACSRA" offset="0x26" text="Analog Comparator Control And Status Register A" icon="io_analo.bmp">
            <bitfield name="ACD" mask="0x80" text="Analog Comparator Disable" icon=""/>
            <bitfield name="ACBG" mask="0x40" text="Analog Comparator Bandgap Select" icon=""/>
            <bitfield name="ACO" mask="0x20" text="Analog Compare Output" icon=""/>
            <bitfield name="ACI" mask="0x10" text="Analog Comparator Interrupt Flag" icon=""/>
            <bitfield name="ACIE" mask="0x08" text="Analog Comparator Interrupt Enable" icon=""/>
            <bitfield name="ACIC" mask="0x04" text="Analog Comparator Input Capture Enable" icon=""/>
            <bitfield name="ACIS" mask="0x03" text="Analog Comparator Interrupt Mode Select bits" icon="" enum="ANALOG_COMP_INTERRUPT"/>
          </reg>
        </registers>
        <enumerator name="ANALOG_COMP_INTERRUPT">
          <enum val="0x00" text="Interrupt on Toggle"/>
          <enum val="0x01" text="Reserved"/>
          <enum val="0x02" text="Interrupt on Falling Edge"/>
          <enum val="0x03" text="Interrupt on Rising Edge"/>
        </enumerator>
      </module>
      <module class="EEPROM" text="">
        <registers name="EEPROM" memspace="DATAMEM" text="" icon="io_cpu.bmp">
          <reg size="1" name="EEAR" offset="0x3E" text="EEPROM Read/Write Access" icon="io_cpu.bmp" mask="0xFF"/>
          <reg size="1" name="EEDR" offset="0x3D" text="EEPROM Data Register" icon="io_cpu.bmp" mask="0xFF"/>
          <reg size="1" name="EECR" offset="0x3C" text="EEPROM Control Register" icon="io_flag.bmp">
            <bitfield name="EEPM" mask="0x30" text="EEPROM Programming Mode Bits" icon="" enum="EEP_MODE"/>
            <bitfield name="EERIE" mask="0x08" text="EEProm Ready Interrupt Enable" icon=""/>
            <bitfield name="EEMPE" mask="0x04" text="EEPROM Master Write Enable" icon=""/>
            <bitfield name="EEPE" mask="0x02" text="EEPROM Write Enable" icon=""/>
            <bitfield name="EERE" mask="0x01" text="EEPROM Read Enable" icon=""/>
          </reg>
        </registers>
        <enumerator name="EEP_MODE">
          <enum val="0x00" text="Erase and Write in one operation"/>
          <enum val="0x01" text="Erase Only"/>
          <enum val="0x02" text="Write Only"/>
        </enumerator>
      </module>
      <module class="TIMER_COUNTER_1" text="">
        <registers name="TIMER_COUNTER_1" memspace="DATAMEM" text="" icon="io_timer.bmp">
          <reg size="1" name="TIMSK" offset="0x5A" text="Timer/Counter Interrupt Mask Register" icon="io_flag.bmp">
            <bitfield name="TOIE1" mask="0x80" text="Timer/Counter1 Overflow Interrupt Enable" icon=""/>
            <bitfield name="OCIE1A" mask="0x40" text="Timer/Counter1 Output CompareA Match Interrupt Enable" icon=""/>
            <bitfield name="OCIE1B" mask="0x20" text="Timer/Counter1 Output CompareB Match Interrupt Enable" icon=""/>
            <bitfield name="ICIE1" mask="0x08" text="Timer/Counter1 Input Capture Interrupt Enable" icon=""/>
          </reg>
          <reg size="1" name="TIFR" offset="0x59" text="Timer/Counter Interrupt Flag register" icon="io_flag.bmp">
            <bitfield name="TOV1" mask="0x80" text="Timer/Counter1 Overflow Flag" icon=""/>
            <bitfield name="OCF1A" mask="0x40" text="Output Compare Flag 1A" icon=""/>
            <bitfield name="OCF1B" mask="0x20" text="Output Compare Flag 1B" icon=""/>
            <bitfield name="ICF1" mask="0x08" text="Input Capture Flag 1" icon=""/>
          </reg>
          <reg size="1" name="TCCR1A" offset="0x72" text="Timer/Counter1 Control Register A" icon="io_flag.bmp">
            <bitfield name="COM1A" mask="0xC0" text="Compare Output Mode 1A, bits" icon=""/>
            <bitfield name="COM1B" mask="0x30" text="Compare Output Mode 1B, bits" icon=""/>
            <bitfield name="WGM1" mask="0x03" text="Pulse Width Modulator Select Bits" icon=""/>
          </reg>
          <reg size="1" name="TCCR1B" offset="0x71" text="Timer/Counter1 Control Register B" icon="io_flag.bmp">
            <bitfield name="ICNC1" mask="0x80" text="Input Capture 1 Noise Canceler" icon=""/>
            <bitfield name="ICES1" mask="0x40" text="Input Capture 1 Edge Select" icon=""/>
            <bitfield name="WGM1" mask="0x18" text="Waveform Generation Mode Bits" icon="" lsb="2"/>
            <bitfield name="CS1" mask="0x07" text="Clock Select1 bits" icon="" enum="CLK_SEL_3BIT_EXT"/>
          </reg>
          <reg size="1" name="TCCR1C" offset="0x70" text="Timer/Counter1 Control Register C" icon="io_flag.bmp">
            <bitfield name="FOC1A" mask="0x80" text="Force Output Compare for Channel A" icon=""/>
            <bitfield name="FOC1B" mask="0x40" text="Force Output Compare for Channel B" icon=""/>
          </reg>
          <reg size="2" name="TCNT1" offset="0x6E" text="Timer/Counter1  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="2" name="OCR1A" offset="0x6C" text="Timer/Counter1 Output Compare Register  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="2" name="OCR1B" offset="0x6A" text="Timer/Counter1 Output Compare Register  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="2" name="ICR1" offset="0x68" text="Timer/Counter1 Input Capture Register  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
        </registers>
        <enumerator name="CLK_SEL_3BIT_EXT">
          <enum val="0x00" text="No Clock Source (Stopped)"/>
          <enum val="0x01" text="Running, No Prescaling"/>
          <enum val="0x02" text="Running, CLK/8"/>
          <enum val="0x03" text="Running, CLK/64"/>
          <enum val="0x04" text="Running, CLK/256"/>
          <enum val="0x05" text="Running, CLK/1024"/>
          <enum val="0x06" text="Running, ExtClk Tx Falling Edge"/>
          <enum val="0x07" text="Running, ExtClk Tx Rising Edge"/>
        </enumerator>
      </module>
      <module class="TIMER_COUNTER_0" text="">
        <registers name="TIMER_COUNTER_0" memspace="DATAMEM" text="" icon="io_timer.bmp">
          <reg size="1" name="TIMSK" offset="0x5A" text="Timer/Counter Interrupt Mask Register" icon="io_flag.bmp">
            <bitfield name="OCIE0B" mask="0x04" text="Timer/Counter0 Output Compare Match B Interrupt Enable" icon=""/>
            <bitfield name="TOIE0" mask="0x02" text="Timer/Counter0 Overflow Interrupt Enable" icon=""/>
            <bitfield name="OCIE0A" mask="0x01" text="Timer/Counter0 Output Compare Match A Interrupt Enable" icon=""/>
          </reg>
          <reg size="1" name="TIFR" offset="0x59" text="Timer/Counter Interrupt Flag register" icon="io_flag.bmp">
            <bitfield name="OCF0B" mask="0x04" text="Timer/Counter0 Output Compare Flag 0B" icon=""/>
            <bitfield name="TOV0" mask="0x02" text="Timer/Counter0 Overflow Flag" icon=""/>
            <bitfield name="OCF0A" mask="0x01" text="Timer/Counter0 Output Compare Flag 0A" icon=""/>
          </reg>
          <reg size="1" name="OCR0B" offset="0x37" text="Timer/Counter0 Output Compare Register" icon="io_timer.bmp" mask="0xFF"/>
          <reg size="1" name="OCR0A" offset="0x38" text="Timer/Counter0 Output Compare Register" icon="io_timer.bmp" mask="0xFF"/>
          <reg size="1" name="TCCR0A" offset="0x3B" text="Timer/Counter  Control Register A" icon="io_flag.bmp">
            <bitfield name="COM0A" mask="0xC0" text="Compare Match Output A Mode" icon=""/>
            <bitfield name="COM0B" mask="0x30" text="Compare Match Output B Mode" icon=""/>
            <bitfield name="WGM0" mask="0x03" text="Waveform Generation Mode" icon=""/>
          </reg>
          <reg size="1" name="TCNT0" offset="0x39" text="Timer/Counter0" icon="io_timer.bmp" mask="0xFF"/>
          <reg size="1" name="TCCR0B" offset="0x3A" text="Timer/Counter Control Register B" icon="io_flag.bmp">
            <bitfield name="FOC0A" mask="0x80" text="Force Output Compare B" icon=""/>
            <bitfield name="FOC0B" mask="0x40" text="Force Output Compare B" icon=""/>
            <bitfield name="WGM02" mask="0x08" text="" icon=""/>
            <bitfield name="CS0" mask="0x07" text="Clock Select" icon="" enum="CLK_SEL_3BIT_EXT"/>
          </reg>
        </registers>
        <enumerator name="CLK_SEL_3BIT_EXT">
          <enum val="0x00" text="No Clock Source (Stopped)"/>
          <enum val="0x01" text="Running, No Prescaling"/>
          <enum val="0x02" text="Running, CLK/8"/>
          <enum val="0x03" text="Running, CLK/64"/>
          <enum val="0x04" text="Running, CLK/256"/>
          <enum val="0x05" text="Running, CLK/1024"/>
          <enum val="0x06" text="Running, ExtClk Tx Falling Edge"/>
          <enum val="0x07" text="Running, ExtClk Tx Rising Edge"/>
        </enumerator>
      </module>
      <module class="EXTERNAL_INTERRUPT" text="">
        <registers name="EXTERNAL_INTERRUPT" memspace="DATAMEM" text="" icon="io_ext.bmp">
          <reg size="1" name="PCMSK1" offset="0x49" text="Pin Change Mask Register 1" icon="io_flag.bmp">
            <bitfield name="PCINT" mask="0x3F" text="Pin Change Enable Masks" icon="" lsb="12"/>
          </reg>
          <reg size="1" name="PCMSK1" offset="0x48" text="Pin Change Mask Register 1" icon="io_flag.bmp">
            <bitfield name="PCINT" mask="0x0F" text="Pin Change Enable Masks" icon="" lsb="8"/>
          </reg>
          <reg size="1" name="PCMSK0" offset="0x47" text="Pin Change Mask Register 0" icon="io_flag.bmp">
            <bitfield name="PCINT" mask="0xFF" text="Pin Change Enable Masks" icon=""/>
          </reg>
          <reg size="1" name="GIFR" offset="0x5B" text="General Interrupt Flag Register" icon="io_flag.bmp">
            <bitfield name="INTF0" mask="0x40" text="External Interrupt Flag 0" icon=""/>
            <bitfield name="PCIF" mask="0x38" text="Pin Change Interrupt Flags" icon=""/>
          </reg>
          <reg size="1" name="GIMSK" offset="0x5C" text="General Interrupt Mask Register" icon="io_flag.bmp">
            <bitfield name="INT0" mask="0x40" text="External Interrupt Request 0 Enable" icon=""/>
            <bitfield name="PCIE" mask="0x38" text="Pin Change Interrupt Enables" icon=""/>
          </reg>
        </registers>
      </module>
      <module class="CPU" text="">
        <registers name="CPU" memspace="DATAMEM" text="" icon="io_cpu.bmp">
          <reg size="1" name="PRR" offset="0x54" text="Power Reduction Register" icon="io_cpu.bmp">
            <bitfield name="PRTWI" mask="0x40" text="Power Reduction TWI" icon=""/>
            <bitfield name="PRTIM1" mask="0x20" text="Power Reduction Timer/Counter1" icon=""/>
            <bitfield name="PRTIM0" mask="0x10" text="Power Reduction Timer/Counter0" icon=""/>
            <bitfield name="PRUSI" mask="0x08" text="Power Reduction USI" icon=""/>
            <bitfield name="PRUSART" mask="0x06" text="Power Reduction USARTs" icon=""/>
            <bitfield name="PRADC" mask="0x01" text="Power Reduction ADC" icon=""/>
          </reg>
          <reg size="1" name="CCP" offset="0x4F" text="Configuration Change Protection" icon="io_sph.bmp" mask="0xFF"/>
          <reg size="1" name="OSCCAL0" offset="0x63" text="Oscillator Calibration Value" icon="io_cpu.bmp" mask="0xFF"/>
          <reg size="1" name="OSCCAL1" offset="0x66" text="" icon="io_cpu.bmp" mask="0x03"/>
          <reg size="1" name="OSCTCAL0A" offset="0x64" text="" icon="io_cpu.bmp" mask="0xFF"/>
          <reg size="1" name="OSCTCAL0B" offset="0x65" text="" icon="io_cpu.bmp" mask="0xFF"/>
          <reg size="1" name="CLKPR" offset="0x53" text="Clock Prescale Register" icon="io_flag.bmp">
            <bitfield name="CLKPS" mask="0x0F" text="Clock Prescaler Select Bits" icon="" enum="CPU_CLK_PRESCALE_4_BITS_SMALL"/>
          </reg>
          <reg size="1" name="CLKSR" offset="0x52" text="Clock Setting Register" icon="io_flag.bmp">
            <bitfield name="OSCRDY" mask="0x80" text="Oscillator Ready" icon=""/>
            <bitfield name="CSTR" mask="0x40" text="Clock Switch Trigger" icon=""/>
            <bitfield name="CKOUT_IO" mask="0x20" text="Clock Output (active low)" icon=""/>
            <bitfield name="SUT" mask="0x10" text="Start-up Time" icon=""/>
            <bitfield name="CKSEL" mask="0x0F" text="Clock Select Bits" icon=""/>
          </reg>
          <reg size="1" name="SREG" offset="0x5F" text="Status Register" icon="io_sreg.bmp">
            <bitfield name="I" mask="0x80" text="Global Interrupt Enable" icon=""/>
            <bitfield name="T" mask="0x40" text="Bit Copy Storage" icon=""/>
            <bitfield name="H" mask="0x20" text="Half Carry Flag" icon=""/>
            <bitfield name="S" mask="0x10" text="Sign Bit" icon=""/>
            <bitfield name="V" mask="0x08" text="Two's Complement Overflow Flag" icon=""/>
            <bitfield name="N" mask="0x04" text="Negative Flag" icon=""/>
            <bitfield name="Z" mask="0x02" text="Zero Flag" icon=""/>
            <bitfield name="C" mask="0x01" text="Carry Flag" icon=""/>
          </reg>
          <reg size="2" name="SP" offset="0x5D" text="Stack Pointer " icon="io_sph.bmp" mask="0x07FF"/>
          <reg size="1" name="MCUCR" offset="0x56" text="MCU Control Register" icon="io_flag.bmp">
            <bitfield name="SM" mask="0x60" text="Sleep Mode Select Bits" icon="" enum="CPU_SLEEP_MODE"/>
            <bitfield name="SE" mask="0x10" text="Sleep Enable" icon=""/>
            <bitfield name="ISC0" mask="0x03" text="Interrupt Sense Control 0 bits" icon=""/>
          </reg>
          <reg size="1" name="MCUSR" offset="0x55" text="MCU Status Register" icon="io_flag.bmp">
            <bitfield name="WDRF" mask="0x08" text="Watchdog Reset Flag" icon=""/>
            <bitfield name="BORF" mask="0x04" text="Brown-out Reset Flag" icon=""/>
            <bitfield name="EXTRF" mask="0x02" text="External Reset Flag" icon=""/>
            <bitfield name="PORF" mask="0x01" text="Power-on reset flag" icon=""/>
          </reg>
          <reg size="1" name="GPIOR2" offset="0x36" text="General Purpose I/O Register 2" icon="io_flag.bmp" mask="0xFF"/>
          <reg size="1" name="GPIOR1" offset="0x35" text="General Purpose I/O Register 1" icon="io_flag.bmp" mask="0xFF"/>
          <reg size="1" name="GPIOR0" offset="0x35" text="General Purpose I/O Register 0" icon="io_flag.bmp" mask="0xFF"/>
          <reg size="1" name="SPMCSR" offset="0x57" text="Store Program Memory Control and Status Register" icon="io_sreg.bmp">
            <bitfield name="RSIG" mask="0x20" text="Read Device Signature Imprint Table" icon=""/>
            <bitfield name="CTPB" mask="0x10" text="Clear Temporary Page Buffer" icon=""/>
            <bitfield name="RFLB" mask="0x08" text="Read Fuse and Lock Bits" icon=""/>
            <bitfield name="PGWRT" mask="0x04" text="Page Write" icon=""/>
            <bitfield name="PGERS" mask="0x02" text="Page Erase" icon=""/>
            <bitfield name="SPMEN" mask="0x01" text="Store program Memory Enable" icon=""/>
          </reg>
        </registers>
        <enumerator name="CPU_CLK_PRESCALE_4_BITS_SMALL">
          <enum val="0x00" text="1"/>
          <enum val="0x01" text="2"/>
          <enum val="0x02" text="4"/>
          <enum val="0x03" text="8"/>
          <enum val="0x04" text="16"/>
          <enum val="0x05" text="32"/>
          <enum val="0x06" text="64"/>
          <enum val="0x07" text="128"/>
          <enum val="0x08" text="256"/>
        </enumerator>
        <enumerator name="CPU_SLEEP_MODE">
          <enum val="0x00" text="Idle"/>
          <enum val="0x01" text="ADC Noise Reduction (If Available)"/>
          <enum val="0x02" text="Power Down"/>
          <enum val="0x03" text="Standby"/>
        </enumerator>
      </module>
      <module class="USI" text="">
        <registers name="USI" memspace="DATAMEM" text="" icon="io_com.bmp">
          <reg size="1" name="USIBR" offset="0x4D" text="USI Buffer Register" icon="io_com.bmp" mask="0xFF"/>
          <reg size="1" name="USIDR" offset="0x4C" text="USI Data Register" icon="io_com.bmp" mask="0xFF"/>
          <reg size="1" name="USISR" offset="0x4B" text="USI Status Register" icon="io_flag.bmp">
            <bitfield name="USISIF" mask="0x80" text="Start Condition Interrupt Flag" icon=""/>
            <bitfield name="USIOIF" mask="0x40" text="Counter Overflow Interrupt Flag" icon=""/>
            <bitfield name="USIPF" mask="0x20" text="Stop Condition Flag" icon=""/>
            <bitfield name="USIDC" mask="0x10" text="Data Output Collision" icon=""/>
            <bitfield name="USICNT" mask="0x0F" text="USI Counter Value Bits" icon=""/>
          </reg>
          <reg size="1" name="USICR" offset="0x4A" text="USI Control Register" icon="io_flag.bmp">
            <bitfield name="USISIE" mask="0x80" text="Start Condition Interrupt Enable" icon=""/>
            <bitfield name="USIOIE" mask="0x40" text="Counter Overflow Interrupt Enable" icon=""/>
            <bitfield name="USIWM" mask="0x30" text="USI Wire Mode Bits" icon="" enum="COMM_USI_OP"/>
            <bitfield name="USICS" mask="0x0C" text="USI Clock Source Select Bits" icon=""/>
            <bitfield name="USICLK" mask="0x02" text="Clock Strobe" icon=""/>
            <bitfield name="USITC" mask="0x01" text="Toggle Clock Port Pin" icon=""/>
          </reg>
        </registers>
        <enumerator name="COMM_USI_OP">
          <enum val="0x00" text="Normal Operation"/>
          <enum val="0x01" text="Three-Wire Mode"/>
          <enum val="0x02" text="Two-Wire Mode"/>
          <enum val="0x03" text="Two-Wire Mode Held Low"/>
        </enumerator>
      </module>
      <module class="USART0" text="">
        <registers name="USART0" memspace="DATAMEM" text="" icon="io_com.bmp">
          <reg size="1" name="UDR0" offset="0x40" text="USART I/O Data Register" icon="io_com.bmp" mask="0xFF"/>
          <reg size="1" name="UCSR0A" offset="0x46" text="USART Control and Status Register A" icon="io_flag.bmp">
            <bitfield name="RXC0" mask="0x80" text="USART Receive Complete" icon=""/>
            <bitfield name="TXC0" mask="0x40" text="USART Transmitt Complete" icon=""/>
            <bitfield name="UDRE0" mask="0x20" text="USART Data Register Empty" icon=""/>
            <bitfield name="FE0" mask="0x10" text="Framing Error" icon=""/>
            <bitfield name="DOR0" mask="0x08" text="Data overRun" icon=""/>
            <bitfield name="UPE0" mask="0x04" text="Parity Error" icon=""/>
            <bitfield name="U2X0" mask="0x02" text="Double the USART transmission speed" icon=""/>
            <bitfield name="MPCM0" mask="0x01" text="Multi-processor Communication Mode" icon=""/>
          </reg>
          <reg size="1" name="UCSR0B" offset="0x45" text="USART Control and Status Register B" icon="io_flag.bmp">
            <bitfield name="RXCIE0" mask="0x80" text="RX Complete Interrupt Enable" icon=""/>
            <bitfield name="TXCIE0" mask="0x40" text="TX Complete Interrupt Enable" icon=""/>
            <bitfield name="UDRIE0" mask="0x20" text="USART Data register Empty Interrupt Enable" icon=""/>
            <bitfield name="RXEN0" mask="0x10" text="Receiver Enable" icon=""/>
            <bitfield name="TXEN0" mask="0x08" text="Transmitter Enable" icon=""/>
            <bitfield name="UCSZ02" mask="0x04" text="Character Size" icon=""/>
            <bitfield name="RXB80" mask="0x02" text="Receive Data Bit 8" icon=""/>
            <bitfield name="TXB80" mask="0x01" text="Transmit Data Bit 8" icon=""/>
          </reg>
          <reg size="1" name="UCSR0C" offset="0x44" text="USART Control and Status Register C" icon="io_flag.bmp">
            <bitfield name="UMSEL0" mask="0xC0" text="USART Mode Select" icon="" enum="COMM_USART_MODE"/>
            <bitfield name="UPM0" mask="0x30" text="Parity Mode Bits" icon="" enum="COMM_UPM_PARITY_MODE"/>
            <bitfield name="USBS0" mask="0x08" text="Stop Bit Select" icon="" enum="COMM_STOP_BIT_SEL"/>
            <bitfield name="UCSZ0" mask="0x06" text="Character Size" icon=""/>
            <bitfield name="UCPOL0" mask="0x01" text="Clock Polarity" icon=""/>
          </reg>
          <reg size="1" name="UCSR0D" offset="0x43" text="USART Control and Status Register D" icon="io_flag.bmp">
            <bitfield name="RXSIE0" mask="0x80" text="USART RX Start Interrupt Enable" icon=""/>
            <bitfield name="RXS0" mask="0x40" text="USART RX Start Flag" icon=""/>
            <bitfield name="SFDE0" mask="0x20" text="USART RX Start Frame Detection Enable" icon=""/>
          </reg>
          <reg size="2" name="UBRR0" offset="0x41" text="USART Baud Rate Register  Bytes" icon="io_com.bmp" mask="0x0FFF"/>
        </registers>
        <enumerator name="COMM_USART_MODE">
          <enum val="0x00" text="Asynchronous Operation"/>
          <enum val="0x01" text="Synchronous Operation"/>
        </enumerator>
        <enumerator name="COMM_UPM_PARITY_MODE">
          <enum val="0x00" text="Disabled"/>
          <enum val="0x01" text="Reserved"/>
          <enum val="0x02" text="Enabled, Even Parity"/>
          <enum val="0x03" text="Enabled, Odd Parity"/>
        </enumerator>
        <enumerator name="COMM_STOP_BIT_SEL">
          <enum val="0x00" text="1-bit"/>
          <enum val="0x01" text="2-bit"/>
        </enumerator>
      </module>
      <module class="USART1" text="">
        <registers name="USART1" memspace="DATAMEM" text="" icon="io_com.bmp">
          <reg size="1" name="UDR1" offset="0x73" text="USART I/O Data Register" icon="io_com.bmp" mask="0xFF"/>
          <reg size="1" name="UCSR1A" offset="0x79" text="USART Control and Status Register A" icon="io_flag.bmp">
            <bitfield name="RXC1" mask="0x80" text="USART Receive Complete" icon=""/>
            <bitfield name="TXC1" mask="0x40" text="USART Transmitt Complete" icon=""/>
            <bitfield name="UDRE1" mask="0x20" text="USART Data Register Empty" icon=""/>
            <bitfield name="FE1" mask="0x10" text="Framing Error" icon=""/>
            <bitfield name="DOR1" mask="0x08" text="Data overRun" icon=""/>
            <bitfield name="UPE1" mask="0x04" text="Parity Error" icon=""/>
            <bitfield name="U2X1" mask="0x02" text="Double the USART transmission speed" icon=""/>
            <bitfield name="MPCM1" mask="0x01" text="Multi-processor Communication Mode" icon=""/>
          </reg>
          <reg size="1" name="UCSR1B" offset="0x78" text="USART Control and Status Register B" icon="io_flag.bmp">
            <bitfield name="RXCIE1" mask="0x80" text="RX Complete Interrupt Enable" icon=""/>
            <bitfield name="TXCIE1" mask="0x40" text="TX Complete Interrupt Enable" icon=""/>
            <bitfield name="UDRIE1" mask="0x20" text="USART Data register Empty Interrupt Enable" icon=""/>
            <bitfield name="RXEN1" mask="0x10" text="Receiver Enable" icon=""/>
            <bitfield name="TXEN1" mask="0x08" text="Transmitter Enable" icon=""/>
            <bitfield name="UCSZ12" mask="0x04" text="Character Size" icon=""/>
            <bitfield name="RXB81" mask="0x02" text="Receive Data Bit 8" icon=""/>
            <bitfield name="TXB81" mask="0x01" text="Transmit Data Bit 8" icon=""/>
          </reg>
          <reg size="1" name="UCSR1C" offset="0x77" text="USART Control and Status Register C" icon="io_flag.bmp">
            <bitfield name="UMSEL1" mask="0xC0" text="USART Mode Select" icon="" enum="COMM_USART_MODE_2BIT"/>
            <bitfield name="UPM1" mask="0x30" text="Parity Mode Bits" icon="" enum="COMM_UPM_PARITY_MODE"/>
            <bitfield name="USBS1" mask="0x08" text="Stop Bit Select" icon="" enum="COMM_STOP_BIT_SEL"/>
            <bitfield name="UCSZ1" mask="0x06" text="Character Size" icon=""/>
            <bitfield name="UCPOL1" mask="0x01" text="Clock Polarity" icon=""/>
          </reg>
          <reg size="1" name="UCSR1D" offset="0x76" text="USART Control and Status Register D" icon="io_flag.bmp">
            <bitfield name="RXSIE1" mask="0x80" text="USART RX Start Interrupt Enable" icon=""/>
            <bitfield name="RXS1" mask="0x40" text="USART RX Start Flag" icon=""/>
            <bitfield name="SFDE1" mask="0x20" text="USART RX Start Frame Detection Enable" icon=""/>
          </reg>
          <reg size="2" name="UBRR1" offset="0x74" text="USART Baud Rate Register  Bytes" icon="io_com.bmp" mask="0x0FFF"/>
        </registers>
        <enumerator name="COMM_USART_MODE_2BIT">
          <enum val="0x00" text="Asynchronous USART"/>
          <enum val="0x01" text="Synchronous USART"/>
          <enum val="0x03" text="Master SPI"/>
        </enumerator>
        <enumerator name="COMM_UPM_PARITY_MODE">
          <enum val="0x00" text="Disabled"/>
          <enum val="0x01" text="Reserved"/>
          <enum val="0x02" text="Enabled, Even Parity"/>
          <enum val="0x03" text="Enabled, Odd Parity"/>
        </enumerator>
        <enumerator name="COMM_STOP_BIT_SEL">
          <enum val="0x00" text="1-bit"/>
          <enum val="0x01" text="2-bit"/>
        </enumerator>
      </module>
      <module class="WATCHDOG" text="">
        <registers name="WATCHDOG" memspace="DATAMEM" text="" icon="io_watch.bmp">
          <reg size="1" name="WDTCSR" offset="0x50" text="Watchdog Timer Control and Status Register" icon="io_flag.bmp">
            <bitfield name="WDIF" mask="0x80" text="Watchdog Timer Interrupt Flag" icon=""/>
            <bitfield name="WDIE" mask="0x40" text="Watchdog Timer Interrupt Enable" icon=""/>
            <bitfield name="WDP" mask="0x27" text="Watchdog Timer Prescaler Bits" icon="" enum="WDOG_TIMER_PRESCALE_4BITS_32KHZ"/>
            <bitfield name="WDE" mask="0x08" text="Watch Dog Enable" icon=""/>
          </reg>
        </registers>
        <enumerator name="WDOG_TIMER_PRESCALE_4BITS_32KHZ">
          <enum val="0x00" text="Oscillator Cycles 512 (16 ms)"/>
          <enum val="0x01" text="Oscillator Cycles 1K (32 ms)"/>
          <enum val="0x02" text="Oscillator Cycles 2K (64 ms)"/>
          <enum val="0x03" text="Oscillator Cycles 4K (0.125 s)"/>
          <enum val="0x04" text="Oscillator Cycles 8K (0.25 s)"/>
          <enum val="0x05" text="Oscillator Cycles 16K (0.5 s)"/>
          <enum val="0x06" text="Oscillator Cycles 32K (1.0 s)"/>
          <enum val="0x07" text="Oscillator Cycles 64K (2.0 s)"/>
          <enum val="0x08" text="Oscillator Cycles 128K (4.0 s)"/>
          <enum val="0x09" text="Oscillator Cycles 256K (8.0 s)"/>
        </enumerator>
      </module>
    </templates>
    <modules>
      <module implements="TWI" name="TWI">
        <registers implements="TWI" name="TWI" offset="0x00" text=""/>
      </module>
      <module implements="PORTB" name="PORTB">
        <registers implements="PORTB" name="PORTB" offset="0x00" text=""/>
      </module>
      <module implements="PORTC" name="PORTC">
        <registers implements="PORTC" name="PORTC" offset="0x00" text=""/>
      </module>
      <module implements="PORTA" name="PORTA">
        <registers implements="PORTA" name="PORTA" offset="0x00" text=""/>
      </module>
      <module implements="AD_CONVERTER" name="AD_CONVERTER">
        <registers implements="AD_CONVERTER" name="AD_CONVERTER" offset="0x00" text=""/>
      </module>
      <module implements="ANALOG_COMPARATOR" name="ANALOG_COMPARATOR">
        <registers implements="ANALOG_COMPARATOR" name="ANALOG_COMPARATOR" offset="0x00" text=""/>
      </module>
      <module implements="EEPROM" name="EEPROM">
        <registers implements="EEPROM" name="EEPROM" offset="0x00" text=""/>
      </module>
      <module implements="TIMER_COUNTER_1" name="TIMER_COUNTER_1">
        <registers implements="TIMER_COUNTER_1" name="TIMER_COUNTER_1" offset="0x00" text=""/>
      </module>
      <module implements="TIMER_COUNTER_0" name="TIMER_COUNTER_0">
        <registers implements="TIMER_COUNTER_0" name="TIMER_COUNTER_0" offset="0x00" text=""/>
      </module>
      <module implements="EXTERNAL_INTERRUPT" name="EXTERNAL_INTERRUPT">
        <registers implements="EXTERNAL_INTERRUPT" name="EXTERNAL_INTERRUPT" offset="0x00" text=""/>
      </module>
      <module implements="CPU" name="CPU">
        <registers implements="CPU" name="CPU" offset="0x00" text=""/>
      </module>
      <module implements="USI" name="USI">
        <registers implements="USI" name="USI" offset="0x00" text=""/>
      </module>
      <module implements="USART0" name="USART0">
        <registers implements="USART0" name="USART0" offset="0x00" text=""/>
      </module>
      <module implements="USART1" name="USART1">
        <registers implements="USART1" name="USART1" offset="0x00" text=""/>
      </module>
      <module implements="WATCHDOG" name="WATCHDOG">
        <registers implements="WATCHDOG" name="WATCHDOG" offset="0x00" text=""/>
      </module>
    </modules>
    <fuses>
      <fuse implements="FUSE" name="FUSE">
        <registers implements="FUSE" name="FUSE"/>
      </fuse>
    </fuses>
    <lockbits>
      <lockbit implements="LOCKBIT" name="LOCKBIT">
        <registers implements="LOCKBIT" name="LOCKBIT"/>
      </lockbit>
    </lockbits>
  </V2>
</AVRPART>

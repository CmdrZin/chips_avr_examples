<?xml version="1.0"?>
<AVRPART>
  <MODULE_LIST>[CORE:LOCKBIT:ADMIN:MEMORY:INTERRUPT_VECTOR:PACKAGE:FUSE:PROGRAMMING:IO_MODULE:ICE_SETTINGS]</MODULE_LIST>
  <CORE>
    <CORE_VERSION>V2</CORE_VERSION>
    <ID>AVRSimCoreV2.SimCoreV2</ID>
    <NEW_INSTRUCTIONS>[lpm rd,z+]</NEW_INSTRUCTIONS>
    <INSTRUCTIONS_NOT_SUPPORTED>[]</INSTRUCTIONS_NOT_SUPPORTED>
    <RAMP_REGISTERS>[]</RAMP_REGISTERS>
    <GP_REG_FILE>
      <NMB_REG>32</NMB_REG>
      <START_ADDR>$00</START_ADDR>
      <X_REG_HIGH>$1B</X_REG_HIGH>
      <X_REG_LOW>$1A</X_REG_LOW>
      <Y_REG_HIGH>$1D</Y_REG_HIGH>
      <Y_REG_LOW>$1C</Y_REG_LOW>
      <Z_REG_HIGH>$1F</Z_REG_HIGH>
      <Z_REG_LOW>$1E</Z_REG_LOW>
    </GP_REG_FILE>
  </CORE>
  <LOCKBIT>
    <ICON/>
    <ID/>
    <TEXT>[LB1 = 1 :  LB2 = 1] No memory lock features enabled. [LB1 = 0 :  LB2 = 1] Further programming of Flash and EEPROM is enabled. [LB1 = 0 :  LB2 = 0] Same as previous, but verify is also disabled</TEXT>
    <NMB_TEXT>3</NMB_TEXT>
    <NMB_LOCK_BITS>2</NMB_LOCK_BITS>
    <TEXT1>
      <MASK>0x03</MASK>
      <VALUE>0x03</VALUE>
      <TEXT>Mode 1: No memory lock features enabled</TEXT>
    </TEXT1>
    <TEXT2>
      <MASK>0x03</MASK>
      <VALUE>0x02</VALUE>
      <TEXT>Mode 2: Further programming disabled</TEXT>
    </TEXT2>
    <TEXT3>
      <MASK>0x03</MASK>
      <VALUE>0x00</VALUE>
      <TEXT>Mode 3: Further programming and verification disabled</TEXT>
    </TEXT3>
    <LOCKBIT0>
      <NAME>LB1</NAME>
      <TEXT>Lockbit</TEXT>
    </LOCKBIT0>
    <LOCKBIT1>
      <NAME>LB2</NAME>
      <TEXT>Lockbit</TEXT>
    </LOCKBIT1>
  </LOCKBIT>
  <ADMIN>
    <PART_NAME>ATtiny43U</PART_NAME>
    <SPEED>20MHZ</SPEED>
    <BUILD>1</BUILD>
    <RELEASE_STATUS>RELEASED</RELEASE_STATUS>
    <SIGNATURE>
      <ADDR000>$1E</ADDR000>
      <ADDR001>$92</ADDR001>
      <ADDR002>$0C</ADDR002>
    </SIGNATURE>
    <OCD_PARAMETERS>
      <OCD_REVISION>1</OCD_REVISION>
      <OCD_REGISTER_ADDRESS>0x27</OCD_REGISTER_ADDRESS>
      <CACHE_TYPE>0</CACHE_TYPE>
      <USE_JTAGID>0</USE_JTAGID>
      <DW_BASE_PC>0x00</DW_BASE_PC>
    </OCD_PARAMETERS>
  </ADMIN>
  <MEMORY>
    <ID>AVRSimMemory8bit.SimMemory8bit</ID>
    <PROG_FLASH>4096</PROG_FLASH>
    <EEPROM>64</EEPROM>
    <INT_SRAM>
      <SIZE>256</SIZE>
      <START_ADDR>$60</START_ADDR>
    </INT_SRAM>
    <EXT_SRAM>
      <SIZE>0</SIZE>
      <START_ADDR>NA</START_ADDR>
    </EXT_SRAM>
    <IO_MEMORY>
      <IO_START_ADDR>$00</IO_START_ADDR>
      <IO_STOP_ADDR>$3F</IO_STOP_ADDR>
      <EXT_IO_START_ADDR>NA</EXT_IO_START_ADDR>
      <EXT_IO_STOP_ADDR>NA</EXT_IO_STOP_ADDR>
      <MEM_START_ADDR>$20</MEM_START_ADDR>
      <MEM_STOP_ADDR>$5F</MEM_STOP_ADDR>
      <SREG>
        <IO_ADDR>$3F</IO_ADDR>
        <MEM_ADDR>$5F</MEM_ADDR>
        <C_MASK>0x01</C_MASK>
        <Z_MASK>0x02</Z_MASK>
        <N_MASK>0x04</N_MASK>
        <V_MASK>0x08</V_MASK>
        <S_MASK>0x10</S_MASK>
        <H_MASK>0x20</H_MASK>
        <T_MASK>0x40</T_MASK>
        <I_MASK>0x80</I_MASK>
      </SREG>
      <SPH>
        <IO_ADDR>$3E</IO_ADDR>
        <MEM_ADDR>$5E</MEM_ADDR>
        <INIT>0x01</INIT>
        <SP8_MASK>0x01</SP8_MASK>
      </SPH>
      <SPL>
        <IO_ADDR>$3D</IO_ADDR>
        <MEM_ADDR>$5D</MEM_ADDR>
        <INIT>0x5f</INIT>
        <SP0_MASK>0x01</SP0_MASK>
        <SP1_MASK>0x02</SP1_MASK>
        <SP2_MASK>0x04</SP2_MASK>
        <SP3_MASK>0x08</SP3_MASK>
        <SP4_MASK>0x10</SP4_MASK>
        <SP5_MASK>0x20</SP5_MASK>
        <SP6_MASK>0x40</SP6_MASK>
        <SP7_MASK>0x80</SP7_MASK>
      </SPL>
      <OCR0B>
        <IO_ADDR>$3C</IO_ADDR>
        <MEM_ADDR>$5C</MEM_ADDR>
        <OCR0_0_MASK>0x01</OCR0_0_MASK>
        <OCR0_1_MASK>0x02</OCR0_1_MASK>
        <OCR0_2_MASK>0x04</OCR0_2_MASK>
        <OCR0_3_MASK>0x08</OCR0_3_MASK>
        <OCR0_4_MASK>0x10</OCR0_4_MASK>
        <OCR0_5_MASK>0x20</OCR0_5_MASK>
        <OCR0_6_MASK>0x40</OCR0_6_MASK>
        <OCR0_7_MASK>0x80</OCR0_7_MASK>
      </OCR0B>
      <GIMSK>
        <IO_ADDR>$3B</IO_ADDR>
        <MEM_ADDR>$5B</MEM_ADDR>
        <PCIE0_MASK>0x10</PCIE0_MASK>
        <PCIE1_MASK>0x20</PCIE1_MASK>
        <INT0_MASK>0x40</INT0_MASK>
      </GIMSK>
      <GIFR>
        <IO_ADDR>$3A</IO_ADDR>
        <MEM_ADDR>$5A</MEM_ADDR>
        <PCIF0_MASK>0x10</PCIF0_MASK>
        <PCIF1_MASK>0x20</PCIF1_MASK>
        <INTF0_MASK>0x40</INTF0_MASK>
      </GIFR>
      <TIMSK0>
        <IO_ADDR>$39</IO_ADDR>
        <MEM_ADDR>$59</MEM_ADDR>
        <TOIE0_MASK>0x01</TOIE0_MASK>
        <OCIE0A_MASK>0x02</OCIE0A_MASK>
        <OCIE0B_MASK>0x04</OCIE0B_MASK>
      </TIMSK0>
      <TIFR0>
        <IO_ADDR>$38</IO_ADDR>
        <MEM_ADDR>$58</MEM_ADDR>
        <TOV0_MASK>0x01</TOV0_MASK>
        <OCF0A_MASK>0x02</OCF0A_MASK>
        <OCF0B_MASK>0x04</OCF0B_MASK>
      </TIFR0>
      <SPMCSR>
        <IO_ADDR>$37</IO_ADDR>
        <MEM_ADDR>$57</MEM_ADDR>
        <SPMEN_MASK>0x01</SPMEN_MASK>
        <PGERS_MASK>0x02</PGERS_MASK>
        <PGWRT_MASK>0x04</PGWRT_MASK>
        <RFLB_MASK>0x08</RFLB_MASK>
        <CTPB_MASK>0x10</CTPB_MASK>
      </SPMCSR>
      <OCR0A>
        <IO_ADDR>$36</IO_ADDR>
        <MEM_ADDR>$56</MEM_ADDR>
        <OCR0A_0_MASK>0x01</OCR0A_0_MASK>
        <OCR0A_1_MASK>0x02</OCR0A_1_MASK>
        <OCR0A_2_MASK>0x04</OCR0A_2_MASK>
        <OCR0A_3_MASK>0x08</OCR0A_3_MASK>
        <OCR0A_4_MASK>0x10</OCR0A_4_MASK>
        <OCR0A_5_MASK>0x20</OCR0A_5_MASK>
        <OCR0A_6_MASK>0x40</OCR0A_6_MASK>
        <OCR0A_7_MASK>0x80</OCR0A_7_MASK>
      </OCR0A>
      <MCUCR>
        <IO_ADDR>$35</IO_ADDR>
        <MEM_ADDR>$55</MEM_ADDR>
        <ISC00_MASK>0x01</ISC00_MASK>
        <ISC01_MASK>0x02</ISC01_MASK>
        <BODSE_MASK>0x04</BODSE_MASK>
        <SM0_MASK>0x08</SM0_MASK>
        <SM1_MASK>0x10</SM1_MASK>
        <SE_MASK>0x20</SE_MASK>
        <PUD_MASK>0x40</PUD_MASK>
        <BODS_MASK>0x80</BODS_MASK>
      </MCUCR>
      <MCUSR>
        <IO_ADDR>$34</IO_ADDR>
        <MEM_ADDR>$54</MEM_ADDR>
        <PORF_MASK>0x01</PORF_MASK>
        <EXTRF_MASK>0x02</EXTRF_MASK>
        <BORF_MASK>0x04</BORF_MASK>
        <WDRF_MASK>0x08</WDRF_MASK>
      </MCUSR>
      <TCCR0B>
        <IO_ADDR>$33</IO_ADDR>
        <MEM_ADDR>$53</MEM_ADDR>
        <CS00_MASK>0x01</CS00_MASK>
        <CS01_MASK>0x02</CS01_MASK>
        <CS02_MASK>0x04</CS02_MASK>
        <WGM02_MASK>0x08</WGM02_MASK>
        <FOC0B_MASK>0x40</FOC0B_MASK>
        <FOC0A_MASK>0x80</FOC0A_MASK>
      </TCCR0B>
      <TCNT0>
        <IO_ADDR>$32</IO_ADDR>
        <MEM_ADDR>$52</MEM_ADDR>
        <TCNT0_0_MASK>0x01</TCNT0_0_MASK>
        <TCNT0_1_MASK>0x02</TCNT0_1_MASK>
        <TCNT0_2_MASK>0x04</TCNT0_2_MASK>
        <TCNT0_3_MASK>0x08</TCNT0_3_MASK>
        <TCNT0_4_MASK>0x10</TCNT0_4_MASK>
        <TCNT0_5_MASK>0x20</TCNT0_5_MASK>
        <TCNT0_6_MASK>0x40</TCNT0_6_MASK>
        <TCNT0_7_MASK>0x80</TCNT0_7_MASK>
      </TCNT0>
      <OSCCAL>
        <IO_ADDR>$31</IO_ADDR>
        <MEM_ADDR>$51</MEM_ADDR>
        <CAL0_MASK>0x01</CAL0_MASK>
        <CAL1_MASK>0x02</CAL1_MASK>
        <CAL2_MASK>0x04</CAL2_MASK>
        <CAL3_MASK>0x08</CAL3_MASK>
        <CAL4_MASK>0x10</CAL4_MASK>
        <CAL5_MASK>0x20</CAL5_MASK>
        <CAL6_MASK>0x40</CAL6_MASK>
        <CAL7_MASK>0x80</CAL7_MASK>
      </OSCCAL>
      <TCCR0A>
        <IO_ADDR>$30</IO_ADDR>
        <MEM_ADDR>$50</MEM_ADDR>
        <WGM00_MASK>0x01</WGM00_MASK>
        <WGM01_MASK>0x02</WGM01_MASK>
        <COM0B0_MASK>0x10</COM0B0_MASK>
        <COM0B1_MASK>0x20</COM0B1_MASK>
        <COM0A0_MASK>0x40</COM0A0_MASK>
        <COM0A1_MASK>0x80</COM0A1_MASK>
      </TCCR0A>
      <TCCR1A>
        <IO_ADDR>$2F</IO_ADDR>
        <MEM_ADDR>$4F</MEM_ADDR>
        <WGM10_MASK>0x01</WGM10_MASK>
        <WGM11_MASK>0x02</WGM11_MASK>
        <COM1B0_MASK>0x10</COM1B0_MASK>
        <COM1B1_MASK>0x20</COM1B1_MASK>
        <COM1A0_MASK>0x40</COM1A0_MASK>
        <COM1A1_MASK>0x80</COM1A1_MASK>
      </TCCR1A>
      <TCCR1B>
        <IO_ADDR>$2E</IO_ADDR>
        <MEM_ADDR>$4E</MEM_ADDR>
        <CS10_MASK>0x01</CS10_MASK>
        <CS11_MASK>0x02</CS11_MASK>
        <CS12_MASK>0x04</CS12_MASK>
        <WGM12_MASK>0x08</WGM12_MASK>
        <FOC1B_MASK>0x40</FOC1B_MASK>
        <FOC1A_MASK>0x80</FOC1A_MASK>
      </TCCR1B>
      <TCNT1>
        <IO_ADDR>$2D</IO_ADDR>
        <MEM_ADDR>$4D</MEM_ADDR>
        <TCNT1_0_MASK>0x01</TCNT1_0_MASK>
        <TCNT1_1_MASK>0x02</TCNT1_1_MASK>
        <TCNT1_2_MASK>0x04</TCNT1_2_MASK>
        <TCNT1_3_MASK>0x08</TCNT1_3_MASK>
        <TCNT1_4_MASK>0x10</TCNT1_4_MASK>
        <TCNT1_5_MASK>0x20</TCNT1_5_MASK>
        <TCNT1_6_MASK>0x40</TCNT1_6_MASK>
        <TCNT1_7_MASK>0x80</TCNT1_7_MASK>
      </TCNT1>
      <OCR1A>
        <IO_ADDR>$2C</IO_ADDR>
        <MEM_ADDR>$4C</MEM_ADDR>
        <OCR1_0_MASK>0x01</OCR1_0_MASK>
        <OCR1_1_MASK>0x02</OCR1_1_MASK>
        <OCR1_2_MASK>0x04</OCR1_2_MASK>
        <OCR1_3_MASK>0x08</OCR1_3_MASK>
        <OCR1_4_MASK>0x10</OCR1_4_MASK>
        <OCR1_5_MASK>0x20</OCR1_5_MASK>
        <OCR1_6_MASK>0x40</OCR1_6_MASK>
        <OCR1_7_MASK>0x80</OCR1_7_MASK>
      </OCR1A>
      <OCR1B>
        <IO_ADDR>$2B</IO_ADDR>
        <MEM_ADDR>$4B</MEM_ADDR>
        <OCR1_0_MASK>0x01</OCR1_0_MASK>
        <OCR1_1_MASK>0x02</OCR1_1_MASK>
        <OCR1_2_MASK>0x04</OCR1_2_MASK>
        <OCR1_3_MASK>0x08</OCR1_3_MASK>
        <OCR1_4_MASK>0x10</OCR1_4_MASK>
        <OCR1_5_MASK>0x20</OCR1_5_MASK>
        <OCR1_6_MASK>0x40</OCR1_6_MASK>
        <OCR1_7_MASK>0x80</OCR1_7_MASK>
      </OCR1B>
      <CLKPR>
        <IO_ADDR>$26</IO_ADDR>
        <MEM_ADDR>$46</MEM_ADDR>
        <CLKPS0_MASK>0x01</CLKPS0_MASK>
        <CLKPS1_MASK>0x02</CLKPS1_MASK>
        <CLKPS2_MASK>0x04</CLKPS2_MASK>
        <CLKPS3_MASK>0x08</CLKPS3_MASK>
        <CLKPCE_MASK>0x80</CLKPCE_MASK>
      </CLKPR>
      <GTCCR>
        <IO_ADDR>$23</IO_ADDR>
        <MEM_ADDR>$43</MEM_ADDR>
        <PSR10_MASK>0x01</PSR10_MASK>
        <TSM_MASK>0x80</TSM_MASK>
      </GTCCR>
      <WDTCSR>
        <IO_ADDR>$21</IO_ADDR>
        <MEM_ADDR>$41</MEM_ADDR>
        <WDP0_MASK>0x01</WDP0_MASK>
        <WDP1_MASK>0x02</WDP1_MASK>
        <WDP2_MASK>0x04</WDP2_MASK>
        <WDE_MASK>0x08</WDE_MASK>
        <WDCE_MASK>0x10</WDCE_MASK>
        <WDP3_MASK>0x20</WDP3_MASK>
        <WDIE_MASK>0x40</WDIE_MASK>
        <WDIF_MASK>0x80</WDIF_MASK>
      </WDTCSR>
      <PCMSK1>
        <IO_ADDR>$20</IO_ADDR>
        <MEM_ADDR>$40</MEM_ADDR>
        <PCINT8_MASK>0x01</PCINT8_MASK>
        <PCINT9_MASK>0x02</PCINT9_MASK>
        <PCINT10_MASK>0x04</PCINT10_MASK>
        <PCINT11_MASK>0x08</PCINT11_MASK>
        <PCINT12_MASK>0x10</PCINT12_MASK>
        <PCINT13_MASK>0x20</PCINT13_MASK>
        <PCINT14_MASK>0x40</PCINT14_MASK>
        <PCINT15_MASK>0x80</PCINT15_MASK>
      </PCMSK1>
      <EEAR>
        <IO_ADDR>$1E</IO_ADDR>
        <MEM_ADDR>$3E</MEM_ADDR>
        <EEAR0_MASK>0x01</EEAR0_MASK>
        <EEAR1_MASK>0x02</EEAR1_MASK>
        <EEAR2_MASK>0x04</EEAR2_MASK>
        <EEAR3_MASK>0x08</EEAR3_MASK>
        <EEAR4_MASK>0x10</EEAR4_MASK>
        <EEAR5_MASK>0x20</EEAR5_MASK>
      </EEAR>
      <EEDR>
        <IO_ADDR>$1D</IO_ADDR>
        <MEM_ADDR>$3D</MEM_ADDR>
        <EEDR0_MASK>0x01</EEDR0_MASK>
        <EEDR1_MASK>0x02</EEDR1_MASK>
        <EEDR2_MASK>0x04</EEDR2_MASK>
        <EEDR3_MASK>0x08</EEDR3_MASK>
        <EEDR4_MASK>0x10</EEDR4_MASK>
        <EEDR5_MASK>0x20</EEDR5_MASK>
        <EEDR6_MASK>0x40</EEDR6_MASK>
        <EEDR7_MASK>0x80</EEDR7_MASK>
      </EEDR>
      <EECR>
        <IO_ADDR>$1C</IO_ADDR>
        <MEM_ADDR>$3C</MEM_ADDR>
        <EERE_MASK>0x01</EERE_MASK>
        <EEPE_MASK>0x02</EEPE_MASK>
        <EEMPE_MASK>0x04</EEMPE_MASK>
        <EERIE_MASK>0x08</EERIE_MASK>
        <EEPM0_MASK>0x10</EEPM0_MASK>
        <EEPM1_MASK>0x20</EEPM1_MASK>
      </EECR>
      <PORTA>
        <IO_ADDR>$1B</IO_ADDR>
        <MEM_ADDR>$3B</MEM_ADDR>
        <PORTA0_MASK>0x01</PORTA0_MASK>
        <PORTA1_MASK>0x02</PORTA1_MASK>
        <PORTA2_MASK>0x04</PORTA2_MASK>
        <PORTA3_MASK>0x08</PORTA3_MASK>
        <PORTA4_MASK>0x10</PORTA4_MASK>
        <PORTA5_MASK>0x20</PORTA5_MASK>
        <PORTA6_MASK>0x40</PORTA6_MASK>
        <PORTA7_MASK>0x80</PORTA7_MASK>
      </PORTA>
      <DDRA>
        <IO_ADDR>$1A</IO_ADDR>
        <MEM_ADDR>$3A</MEM_ADDR>
        <DDA0_MASK>0x01</DDA0_MASK>
        <DDA1_MASK>0x02</DDA1_MASK>
        <DDA2_MASK>0x04</DDA2_MASK>
        <DDA3_MASK>0x08</DDA3_MASK>
        <DDA4_MASK>0x10</DDA4_MASK>
        <DDA5_MASK>0x20</DDA5_MASK>
        <DDA6_MASK>0x40</DDA6_MASK>
        <DDA7_MASK>0x80</DDA7_MASK>
      </DDRA>
      <PINA>
        <IO_ADDR>$19</IO_ADDR>
        <MEM_ADDR>$39</MEM_ADDR>
        <PINA0_MASK>0x01</PINA0_MASK>
        <PINA1_MASK>0x02</PINA1_MASK>
        <PINA2_MASK>0x04</PINA2_MASK>
        <PINA3_MASK>0x08</PINA3_MASK>
        <PINA4_MASK>0x10</PINA4_MASK>
        <PINA5_MASK>0x20</PINA5_MASK>
        <PINA6_MASK>0x40</PINA6_MASK>
        <PINA7_MASK>0x80</PINA7_MASK>
      </PINA>
      <PORTB>
        <IO_ADDR>$18</IO_ADDR>
        <MEM_ADDR>$38</MEM_ADDR>
        <PORTB0_MASK>0x01</PORTB0_MASK>
        <PORTB1_MASK>0x02</PORTB1_MASK>
        <PORTB2_MASK>0x04</PORTB2_MASK>
        <PORTB3_MASK>0x08</PORTB3_MASK>
        <PORTB4_MASK>0x10</PORTB4_MASK>
        <PORTB5_MASK>0x20</PORTB5_MASK>
        <PORTB6_MASK>0x40</PORTB6_MASK>
        <PORTB7_MASK>0x80</PORTB7_MASK>
      </PORTB>
      <DDRB>
        <IO_ADDR>$17</IO_ADDR>
        <MEM_ADDR>$37</MEM_ADDR>
        <DDB0_MASK>0x01</DDB0_MASK>
        <DDB1_MASK>0x02</DDB1_MASK>
        <DDB2_MASK>0x04</DDB2_MASK>
        <DDB3_MASK>0x08</DDB3_MASK>
        <DDB4_MASK>0x10</DDB4_MASK>
        <DDB5_MASK>0x20</DDB5_MASK>
        <DDB6_MASK>0x40</DDB6_MASK>
        <DDB7_MASK>0x80</DDB7_MASK>
      </DDRB>
      <PINB>
        <IO_ADDR>$16</IO_ADDR>
        <MEM_ADDR>$36</MEM_ADDR>
        <PINB0_MASK>0x01</PINB0_MASK>
        <PINB1_MASK>0x02</PINB1_MASK>
        <PINB2_MASK>0x04</PINB2_MASK>
        <PINB3_MASK>0x08</PINB3_MASK>
        <PINB4_MASK>0x10</PINB4_MASK>
        <PINB5_MASK>0x20</PINB5_MASK>
        <PINB6_MASK>0x40</PINB6_MASK>
        <PINB7_MASK>0x80</PINB7_MASK>
      </PINB>
      <GPIOR2>
        <IO_ADDR>$15</IO_ADDR>
        <MEM_ADDR>$35</MEM_ADDR>
        <GPIOR20_MASK>0x01</GPIOR20_MASK>
        <GPIOR21_MASK>0x02</GPIOR21_MASK>
        <GPIOR22_MASK>0x04</GPIOR22_MASK>
        <GPIOR23_MASK>0x08</GPIOR23_MASK>
        <GPIOR24_MASK>0x10</GPIOR24_MASK>
        <GPIOR25_MASK>0x20</GPIOR25_MASK>
        <GPIOR26_MASK>0x40</GPIOR26_MASK>
        <GPIOR27_MASK>0x80</GPIOR27_MASK>
      </GPIOR2>
      <GPIOR1>
        <IO_ADDR>$14</IO_ADDR>
        <MEM_ADDR>$34</MEM_ADDR>
        <GPIOR10_MASK>0x01</GPIOR10_MASK>
        <GPIOR11_MASK>0x02</GPIOR11_MASK>
        <GPIOR12_MASK>0x04</GPIOR12_MASK>
        <GPIOR13_MASK>0x08</GPIOR13_MASK>
        <GPIOR14_MASK>0x10</GPIOR14_MASK>
        <GPIOR15_MASK>0x20</GPIOR15_MASK>
        <GPIOR16_MASK>0x40</GPIOR16_MASK>
        <GPIOR17_MASK>0x80</GPIOR17_MASK>
      </GPIOR1>
      <GPIOR0>
        <IO_ADDR>$13</IO_ADDR>
        <MEM_ADDR>$33</MEM_ADDR>
        <GPIOR00_MASK>0x01</GPIOR00_MASK>
        <GPIOR01_MASK>0x02</GPIOR01_MASK>
        <GPIOR02_MASK>0x04</GPIOR02_MASK>
        <GPIOR03_MASK>0x08</GPIOR03_MASK>
        <GPIOR04_MASK>0x10</GPIOR04_MASK>
        <GPIOR05_MASK>0x20</GPIOR05_MASK>
        <GPIOR06_MASK>0x40</GPIOR06_MASK>
        <GPIOR07_MASK>0x80</GPIOR07_MASK>
      </GPIOR0>
      <PCMSK0>
        <IO_ADDR>$12</IO_ADDR>
        <MEM_ADDR>$32</MEM_ADDR>
        <PCINT0_MASK>0x01</PCINT0_MASK>
        <PCINT1_MASK>0x02</PCINT1_MASK>
        <PCINT2_MASK>0x04</PCINT2_MASK>
        <PCINT3_MASK>0x08</PCINT3_MASK>
        <PCINT4_MASK>0x10</PCINT4_MASK>
        <PCINT5_MASK>0x20</PCINT5_MASK>
        <PCINT6_MASK>0x40</PCINT6_MASK>
        <PCINT7_MASK>0x80</PCINT7_MASK>
      </PCMSK0>
      <USIBR>
        <IO_ADDR>$10</IO_ADDR>
        <MEM_ADDR>$30</MEM_ADDR>
        <USIBR0_MASK>0x01</USIBR0_MASK>
        <USIBR1_MASK>0x02</USIBR1_MASK>
        <USIBR2_MASK>0x04</USIBR2_MASK>
        <USIBR3_MASK>0x08</USIBR3_MASK>
        <USIBR4_MASK>0x10</USIBR4_MASK>
        <USIBR5_MASK>0x20</USIBR5_MASK>
        <USIBR6_MASK>0x40</USIBR6_MASK>
        <USIBR7_MASK>0x80</USIBR7_MASK>
      </USIBR>
      <USIDR>
        <IO_ADDR>$0F</IO_ADDR>
        <MEM_ADDR>$2F</MEM_ADDR>
        <USIDR0_MASK>0x01</USIDR0_MASK>
        <USIDR1_MASK>0x02</USIDR1_MASK>
        <USIDR2_MASK>0x04</USIDR2_MASK>
        <USIDR3_MASK>0x08</USIDR3_MASK>
        <USIDR4_MASK>0x10</USIDR4_MASK>
        <USIDR5_MASK>0x20</USIDR5_MASK>
        <USIDR6_MASK>0x40</USIDR6_MASK>
        <USIDR7_MASK>0x80</USIDR7_MASK>
      </USIDR>
      <USISR>
        <IO_ADDR>$0E</IO_ADDR>
        <MEM_ADDR>$2E</MEM_ADDR>
        <USICNT0_MASK>0x01</USICNT0_MASK>
        <USICNT1_MASK>0x02</USICNT1_MASK>
        <USICNT2_MASK>0x04</USICNT2_MASK>
        <USICNT3_MASK>0x08</USICNT3_MASK>
        <USIDC_MASK>0x10</USIDC_MASK>
        <USIPF_MASK>0x20</USIPF_MASK>
        <USIOIF_MASK>0x40</USIOIF_MASK>
        <USISIF_MASK>0x80</USISIF_MASK>
      </USISR>
      <USICR>
        <IO_ADDR>$0D</IO_ADDR>
        <MEM_ADDR>$2D</MEM_ADDR>
        <USITC_MASK>0x01</USITC_MASK>
        <USICLK_MASK>0x02</USICLK_MASK>
        <USICS0_MASK>0x04</USICS0_MASK>
        <USICS1_MASK>0x08</USICS1_MASK>
        <USIWM0_MASK>0x10</USIWM0_MASK>
        <USIWM1_MASK>0x20</USIWM1_MASK>
        <USIOIE_MASK>0x40</USIOIE_MASK>
        <USISIE_MASK>0x80</USISIE_MASK>
      </USICR>
      <TIMSK1>
        <IO_ADDR>$0C</IO_ADDR>
        <MEM_ADDR>$2C</MEM_ADDR>
        <TOIE1_MASK>0x01</TOIE1_MASK>
        <OCIE1A_MASK>0x02</OCIE1A_MASK>
        <OCIE1B_MASK>0x04</OCIE1B_MASK>
      </TIMSK1>
      <TIFR1>
        <IO_ADDR>$0B</IO_ADDR>
        <MEM_ADDR>$2B</MEM_ADDR>
        <TOV1_MASK>0x01</TOV1_MASK>
        <OCF1A_MASK>0x02</OCF1A_MASK>
        <OCF1B_MASK>0x04</OCF1B_MASK>
      </TIFR1>
      <ACSR>
        <IO_ADDR>$08</IO_ADDR>
        <MEM_ADDR>$28</MEM_ADDR>
        <ACIS0_MASK>0x01</ACIS0_MASK>
        <ACIS1_MASK>0x02</ACIS1_MASK>
        <ACIE_MASK>0x08</ACIE_MASK>
        <ACI_MASK>0x10</ACI_MASK>
        <ACO_MASK>0x20</ACO_MASK>
        <ACBG_MASK>0x40</ACBG_MASK>
        <ACD_MASK>0x80</ACD_MASK>
      </ACSR>
      <ADMUX>
        <IO_ADDR>$07</IO_ADDR>
        <MEM_ADDR>$27</MEM_ADDR>
        <MUX0_MASK>0x01</MUX0_MASK>
        <MUX1_MASK>0x02</MUX1_MASK>
        <MUX2_MASK>0x04</MUX2_MASK>
        <REFS_MASK>0x40</REFS_MASK>
      </ADMUX>
      <ADCSRA>
        <IO_ADDR>$06</IO_ADDR>
        <MEM_ADDR>$26</MEM_ADDR>
        <ADPS0_MASK>0x01</ADPS0_MASK>
        <ADPS1_MASK>0x02</ADPS1_MASK>
        <ADPS2_MASK>0x04</ADPS2_MASK>
        <ADIE_MASK>0x08</ADIE_MASK>
        <ADIF_MASK>0x10</ADIF_MASK>
        <ADATE_MASK>0x20</ADATE_MASK>
        <ADSC_MASK>0x40</ADSC_MASK>
        <ADEN_MASK>0x80</ADEN_MASK>
      </ADCSRA>
      <ADCH>
        <IO_ADDR>$05</IO_ADDR>
        <MEM_ADDR>$25</MEM_ADDR>
        <ADCH0_MASK>0x01</ADCH0_MASK>
        <ADCH1_MASK>0x02</ADCH1_MASK>
        <ADCH2_MASK>0x04</ADCH2_MASK>
        <ADCH3_MASK>0x08</ADCH3_MASK>
        <ADCH4_MASK>0x10</ADCH4_MASK>
        <ADCH5_MASK>0x20</ADCH5_MASK>
        <ADCH6_MASK>0x40</ADCH6_MASK>
        <ADCH7_MASK>0x80</ADCH7_MASK>
      </ADCH>
      <ADCL>
        <IO_ADDR>$04</IO_ADDR>
        <MEM_ADDR>$24</MEM_ADDR>
        <ADCL0_MASK>0x01</ADCL0_MASK>
        <ADCL1_MASK>0x02</ADCL1_MASK>
        <ADCL2_MASK>0x04</ADCL2_MASK>
        <ADCL3_MASK>0x08</ADCL3_MASK>
        <ADCL4_MASK>0x10</ADCL4_MASK>
        <ADCL5_MASK>0x20</ADCL5_MASK>
        <ADCL6_MASK>0x40</ADCL6_MASK>
        <ADCL7_MASK>0x80</ADCL7_MASK>
      </ADCL>
      <ADCSRB>
        <IO_ADDR>$03</IO_ADDR>
        <MEM_ADDR>$23</MEM_ADDR>
        <ACME_MASK>0x40</ACME_MASK>
        <ADTS0_MASK>0x01</ADTS0_MASK>
        <ADTS1_MASK>0x02</ADTS1_MASK>
        <ADTS2_MASK>0x04</ADTS2_MASK>
        <ADLAR_MASK>0x10</ADLAR_MASK>
        <BVRON_MASK>0x80</BVRON_MASK>
      </ADCSRB>
      <DIDR0>
        <IO_ADDR>$01</IO_ADDR>
        <MEM_ADDR>$21</MEM_ADDR>
        <ADC0D_MASK>0x01</ADC0D_MASK>
        <ADC1D_MASK>0x02</ADC1D_MASK>
        <ADC2D_MASK>0x04</ADC2D_MASK>
        <ADC3D_MASK>0x08</ADC3D_MASK>
        <AIN0D_MASK>0x10</AIN0D_MASK>
        <AIN1D_MASK>0x20</AIN1D_MASK>
      </DIDR0>
      <PRR>
        <IO_ADDR>$00</IO_ADDR>
        <MEM_ADDR>$20</MEM_ADDR>
        <PRADC_MASK>0x01</PRADC_MASK>
        <PRUSI_MASK>0x02</PRUSI_MASK>
        <PRTIM0_MASK>0x04</PRTIM0_MASK>
        <PRTIM1_MASK>0x08</PRTIM1_MASK>
      </PRR>
    </IO_MEMORY>
    <BOOT_CONFIG>
      <NRWW_START_ADDR>$0</NRWW_START_ADDR>
      <NRWW_STOP_ADDR>$3FF</NRWW_STOP_ADDR>
      <RWW_START_ADDR>$0</RWW_START_ADDR>
      <RWW_STOP_ADDR>$0</RWW_STOP_ADDR>
      <PAGESIZE>16</PAGESIZE>
    </BOOT_CONFIG>
  </MEMORY>
  <INTERRUPT_VECTOR>
    <NMB_VECTORS>16</NMB_VECTORS>
    <VECTOR1>
      <PROGRAM_ADDRESS>$000</PROGRAM_ADDRESS>
      <SOURCE>RESET</SOURCE>
      <DEFINITION>External Pin, Power-on Reset, Brown-out Reset,Watchdog Reset</DEFINITION>
    </VECTOR1>
    <VECTOR2>
      <PROGRAM_ADDRESS>$001</PROGRAM_ADDRESS>
      <SOURCE>INT0</SOURCE>
      <DEFINITION>External Interrupt Request 0</DEFINITION>
    </VECTOR2>
    <VECTOR3>
      <PROGRAM_ADDRESS>$002</PROGRAM_ADDRESS>
      <SOURCE>PCINT0</SOURCE>
      <DEFINITION>Pin Change Interrupt Request 0</DEFINITION>
    </VECTOR3>
    <VECTOR4>
      <PROGRAM_ADDRESS>$003</PROGRAM_ADDRESS>
      <SOURCE>PCINT1</SOURCE>
      <DEFINITION>Pin Change Interrupt Request 1</DEFINITION>
    </VECTOR4>
    <VECTOR5>
      <PROGRAM_ADDRESS>$004</PROGRAM_ADDRESS>
      <SOURCE>WDT</SOURCE>
      <DEFINITION>Watchdog Time-out</DEFINITION>
    </VECTOR5>
    <VECTOR6>
      <PROGRAM_ADDRESS>$005</PROGRAM_ADDRESS>
      <SOURCE>TIM1_COMPA</SOURCE>
      <DEFINITION>Timer/Counter1 Compare Match A</DEFINITION>
    </VECTOR6>
    <VECTOR7>
      <PROGRAM_ADDRESS>$006</PROGRAM_ADDRESS>
      <SOURCE>TIM1_COMPB</SOURCE>
      <DEFINITION>Timer/Counter1 Compare Match B</DEFINITION>
    </VECTOR7>
    <VECTOR8>
      <PROGRAM_ADDRESS>$007</PROGRAM_ADDRESS>
      <SOURCE>TIM1_OVF</SOURCE>
      <DEFINITION>Timer/Counter1 Overflow</DEFINITION>
    </VECTOR8>
    <VECTOR9>
      <PROGRAM_ADDRESS>$008</PROGRAM_ADDRESS>
      <SOURCE>TIM0_COMPA</SOURCE>
      <DEFINITION>Timer/Counter0 Compare Match A</DEFINITION>
    </VECTOR9>
    <VECTOR10>
      <PROGRAM_ADDRESS>$009</PROGRAM_ADDRESS>
      <SOURCE>TIM0_COMPB</SOURCE>
      <DEFINITION>Timer/Counter0 Compare Match B</DEFINITION>
    </VECTOR10>
    <VECTOR11>
      <PROGRAM_ADDRESS>$00A</PROGRAM_ADDRESS>
      <SOURCE>TIM0_OVF</SOURCE>
      <DEFINITION>Timer/Counter0 Overflow</DEFINITION>
    </VECTOR11>
    <VECTOR12>
      <PROGRAM_ADDRESS>$00B</PROGRAM_ADDRESS>
      <SOURCE>ANA_COMP</SOURCE>
      <DEFINITION>Analog Comparator</DEFINITION>
    </VECTOR12>
    <VECTOR13>
      <PROGRAM_ADDRESS>$00C</PROGRAM_ADDRESS>
      <SOURCE>ADC</SOURCE>
      <DEFINITION>ADC Conversion Complete</DEFINITION>
    </VECTOR13>
    <VECTOR14>
      <PROGRAM_ADDRESS>$00D</PROGRAM_ADDRESS>
      <SOURCE>EE_RDY</SOURCE>
      <DEFINITION>EEPROM Ready</DEFINITION>
    </VECTOR14>
    <VECTOR15>
      <PROGRAM_ADDRESS>$00E</PROGRAM_ADDRESS>
      <SOURCE>USI_START</SOURCE>
      <DEFINITION>USI START</DEFINITION>
    </VECTOR15>
    <VECTOR16>
      <PROGRAM_ADDRESS>$00F</PROGRAM_ADDRESS>
      <SOURCE>USI_OVF</SOURCE>
      <DEFINITION>USI Overflow</DEFINITION>
    </VECTOR16>
  </INTERRUPT_VECTOR>
  <PACKAGE>
    <PACKAGES>[PDIP:SOIC]</PACKAGES>
    <PDIP>
      <NMB_PIN>20</NMB_PIN>
      <PIN1>
        <NAME>[MOSI:DI_B:SDA_B:'_OC1A:PCINT8:PB0]</NAME>
        <TEXT>DI: Data input in USI 3-wire mode. USI 3-wire mode does not override normal port functions., so pin must be configure as an input. SDA: Serial data in USI 2-wire mode. Serial data pin is bi-directional and uses open-col-lector output. The SDA pin is enabled by setting the pin as an output. The pin is pulled low when the PORTB0 or USI shiftregister is zero when DDB0 is set (one). Pull-up is disabled in USI 2-wire mode. OC1A: Inverted Timer/Counter1 PWM Output A: The PB0 pin can serve as an Inverted output for the PWM mode if not used in programming or USI. The PB0 pin has to be configured as an output (DDB0 set (one)) to serve this function. For further reading on PCINT0 please refer to the man</TEXT>
      </PIN1>
      <PIN2>
        <NAME>[MISO:DO_B:OC1A:PCINT9:PB1]</NAME>
        <TEXT>DO: Data output in USI 3-wire mode. Data output (DO) overrides PORTB1 value and it is driven to the port when the data direction bit DDB1 is set (one). However the PORTB1 bit still controls the pullup, enabling pullup if direction is input and PORTB1 is set(one). OC1A: Output compare match output: The PB1 pin can serve as an output for the Timer/Counter1 compare match A. The PB1 pin has to be configured as an output (DDB3 set (one)) to serve this function. The OC1B pin is also the output pin for the PWM mode timer function if not used in programming or USI. PCINT0: Pin Change Interrupt 0 pin. Pin change interrupt is enabled on pin when global interrupt is enabled, pin change interrupt is enabled and the alternate functions do not mask the interrupt. The masking alternate functions are the output compare match out-put OC1A and data output DO in USI 3-wire mode. Digital input is enabled on pin PB4 also in SLEEP modes, if the pin change interrupt is enabled and not masked by the alternate functi</TEXT>
      </PIN2>
      <PIN3>
        <NAME>[SCK:USCK_B:SCL_B:'OC1B:PCINT10:PB2]</NAME>
        <TEXT>SCK: Clock input or output in USI 3-wire mode. When the SPI is enabled this pin is con-figured</TEXT>
      </PIN3>
      <PIN4>
        <NAME>[OC1B:PCINT11:PB3]</NAME>
        <TEXT>OC1B: Output compare match output: The PB3 pin can serve as an output for the Timer/Counter1 compare match B. The PB3 pin has to be configured as an output (DDB3 set (one)) to serve this function. The OC1B pin is also the output pin for the PWM mode. PCINT0: Pin Change Interrupt 0 pin. Pin change interrupt is enabled on pin when global interrupt is enabled, pin change interrupt is enabled and the alternate functions do not mask the interrupt. The masking alternate function is the output compare match output OC1B. Digital input is enabled on pin PB3 also in SLEEP modes, if the pin change interrupt is enabled and not masked by the alternate functi</TEXT>
      </PIN4>
      <PIN5>
        <NAME>[VCC]</NAME>
        <TEXT/>
      </PIN5>
      <PIN6>
        <NAME>[GND]</NAME>
        <TEXT/>
      </PIN6>
      <PIN7>
        <NAME>[ADC7:XTAL1:PCINT12:'_OC1D:CLKI:PB4]</NAME>
        <TEXT>ADC7: ADC input channel 7. Configure the port pins as inputs with the internal pull-ups switched off to avoid the digital port function from interfering with the function of the ana-log to digital converter. XTAL1: Chip clock oscillator pin 1. Used for all chip clock sources except internal cali-brateble RC oscillator and PLL clock. When used as a clock pin, the pin can not be used as an I/O pin. When using internal calibratable RC oscillator or PLL clock as chip clock sources, PB4 serves as an ordinary I/O pin. PCINT1: Pin Change Interrupt 1 pin. Pin change interrupt is enabled on pin when global interrupt is enabled, pin change interrupt is enabled and the alternate functions do not mask the interrupt. The masking alternate functions are the XTAL1 inputs. Digital input is enabled on pin PB4 also in SLEEP modes, if the pin change interrupt is enabled and not masked by the alternate functi</TEXT>
      </PIN7>
      <PIN8>
        <NAME>[ADC8:XTAL2:PCINT13:OC1D:CKLO:PB5]</NAME>
        <TEXT>ADC8: ADC input channel 8. Configure the port pins as inputs with the internal pull-ups switched off to avoid the digital port function from interfering with the function of the ana-log to digital converter. XTAL2: Chip clock oscillator pin 2. Used as clock pin for all chip clock sources except internal calibrateble RC oscillator, external clock and PLL clock. When used as a clock pin, the pin can not be used as an I/O pin. When using internal calibratable RC oscillator, external clock or PLL clock as chip clock sources, PB5 serves as an ordinary I/O pin. PCINT1: Pin Change Interrupt 1 pin. Pin change interrupt is enabled on pin when global interrupt is enabled, pin change interrupt is enabled and the alternate functions do not mask the interrupt. The masking alternate functions are the XTAL2 outputs. Digital input is enabled on pin PB5 also in SLEEP modes, if the pin change interrupt is enabled and not masked by the alternate functio</TEXT>
      </PIN8>
      <PIN9>
        <NAME>[ADC9:INT0:T0:PCINT14:PB6]</NAME>
        <TEXT>ADC9: ADC input channel 9. Configure the port pins as inputs with the internal pull-ups switched off to avoid the digital port function from interfering with the function of the analog to digital converter. INT0: External Interrupt source 0: The PB6 pin can serve as an external interrupt source enabled by setting (one) the bit INT0 in the general input mask register (GIMSK). T0: Timer/Counter0 External Counter Clock Input is enabled by setting (one) the bits CS02 and CS01 in the Timer/Counter0 control register (TCCR0). PCINT1: Pin Change Interrupt 1 pin. Pin change interrupt is enabled on pin when global interrupt is enabled, pin change interrupt is enabled and the alternate functions do not mask the interrupt. The masking alternate functions are the external low level Interrupt source 0 (INT0) and the Timer/Counter0 external counter clock input (T0). Digital input is enabled on pin PB6 also in SLEEP modes, if the pin change interrupt is enabled and not masked by the alternate func</TEXT>
      </PIN9>
      <PIN10>
        <NAME>[ADC10:'RESET:PCINT15:PB7]</NAME>
        <TEXT>ADC10: ADC input channel 10. Configure the port pins as inputs with the internal pull-ups switched off to avoid the digital port function from interfering with the function of the analog to digital converter. RESET: External Reset Input is active low and enabled by unprogramming (&#x201C;1&#x201D;) the RSTDISBL fuse. Pullup is activated and output driver and digital input are deactivated when the pin is used as the RESET pin. PCINT1: Pin Change Interrupt 1 pin. Pin change interrupt is enabled on pin when global interrupt is enabled, pin change interrupt is enabled and the alternate function do not mask the interrupt. The masking alternate function is the pin usage as RESET. Digital input is enabled on pin PB7 also in SLEEP modes, if the pin change interrupt is enabled and not masked by the alternate func</TEXT>
      </PIN10>
      <PIN11>
        <NAME>[ADC6:AIN1:PCINT7:PA7]</NAME>
        <TEXT>AIN1: Analog Comparator Negative Input and ADC6: ADC input channel 6. Configure the port pin as input with the internal pull-up switched off to avoid the digital port function from interfering with the function of the analog comparator or analog to digital converter. PCINT1: Pin Change Interrupt 1 pin. Pin change interrupt is enabled on pin when global interrupt is enabled, pin change interrupt is enabled and the alternate function do not mask the interrupt. The masking alternate function is the analog comparator.Digital input is enabled on pin PA7 also in SLEEP modes, if the pin change interrupt is enabled and not masked by the alternate functi</TEXT>
      </PIN11>
      <PIN12>
        <NAME>[ADC5:AIN0:PCINT6:PA6]</NAME>
        <TEXT>AIN0: Analog Comparator Positive Input and ADC5: ADC input channel 5. Configure the port pin as input with the internal pull-up switched off to avoid the digital port function from interfering with the function of the analog comparator or analog to digital converter. PCINT1: Pin Change Interrupt 1 pin. Pin change interrupt is enabled on pin when global interrupt is enabled, pin change interrupt is enabled and the alternate function do not mask the interrupt. The masking alternate function is the analog comparator.Digital input is enabled on pin PA6 also in SLEEP modes, if the pin change interrupt is enabled and not masked by the alternate funct</TEXT>
      </PIN12>
      <PIN13>
        <NAME>[ADC4:AIN2:PCINT5:PA5]</NAME>
        <TEXT>ADC4/ADC3: ADC input channel 4 and 3. Configure the port pins as inputs with the internal pull-ups switched off to avoid the digital port function from interfering with the function of the analog to digital converter.</TEXT>
      </PIN13>
      <PIN14>
        <NAME>[ADC3:ICP0:PCINT4:PA4]</NAME>
        <TEXT>ADC4/ADC3: ADC input channel 4 and 3. Configure the port pins as inputs with the internal pull-ups switched off to avoid the digital port function from interfering with the function of the analog to digital converter.</TEXT>
      </PIN14>
      <PIN15>
        <NAME>[AVCC]</NAME>
        <TEXT/>
      </PIN15>
      <PIN16>
        <NAME>[AGND]</NAME>
        <TEXT/>
      </PIN16>
      <PIN17>
        <NAME>[AREF:PCINT3:PA3]</NAME>
        <TEXT>AREF: External reference for ADC. Pullup and output driver are disabled on PA3 when the pin is used as an external reference or Internal Voltage Reference (2.56V) with external capacitor at the AREF pin by setting (one) the bit REFS0 in the ADC Multiplexer Selection Register (ADMUX). PCINT1: Pin Change Interrupt 1 pin. Pin change interrupt is enabled on pin when global interrupt is enabled, pin change interrupt is enabled and the alternate function do not mask the interrupt. The masking alternate function is the pin usage as an analog refer-ence for the ADC. Digital input is enabled on pin PA3 also in SLEEP modes, if the pin change interrupt is enabled and not masked by the alternate function. Please refer to the manual for further detail</TEXT>
      </PIN17>
      <PIN18>
        <NAME>[ADC2:INT1:USCK_A:SCL_A:PCINT2:PA2]</NAME>
        <TEXT/>
      </PIN18>
      <PIN19>
        <NAME>[ADC1:DO_A:PCINT1:PA1]</NAME>
        <TEXT/>
      </PIN19>
      <PIN20>
        <NAME>[ADC0:DI_A:SDA_A:PCINT0:PA0]</NAME>
        <TEXT/>
      </PIN20>
    </PDIP>
  </PACKAGE>
  <FUSE>
    <LIST>[LOW:HIGH:EXTENDED]</LIST>
    <ICON/>
    <ID/>
    <TEXT/>
    <LOW>
      <NMB_TEXT>50</NMB_TEXT>
      <NMB_FUSE_BITS>8</NMB_FUSE_BITS>
      <TEXT1>
        <MASK>0x80</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Divide clock by 8 internally; [CKDIV8=0]</TEXT>
      </TEXT1>
      <TEXT2>
        <MASK>0x40</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Clock output on PORTB5; [CKOUT=0]</TEXT>
      </TEXT2>
      <TEXT3>
        <MASK>0x3F</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Ext. Clock; Start-up time PWRDWN/RESET: 6 CK/14 CK + 0 ms;   [CKSEL=0000 SUT=00]</TEXT>
      </TEXT3>
      <TEXT4>
        <MASK>0x3F</MASK>
        <VALUE>0x10</VALUE>
        <TEXT>Ext. Clock; Start-up time PWRDWN/RESET: 6 CK/14 CK + 4 ms; [CKSEL=0000 SUT=01]</TEXT>
      </TEXT4>
      <TEXT5>
        <MASK>0x3F</MASK>
        <VALUE>0x20</VALUE>
        <TEXT>Ext. Clock; Start-up time PWRDWN/RESET: 6 CK/14 CK + 64 ms;  [CKSEL=0000 SUT=10]</TEXT>
      </TEXT5>
      <TEXT6>
        <MASK>0x3F</MASK>
        <VALUE>0x01</VALUE>
        <TEXT>PLL Clock; Start-up time PWRDWN/RESET: 1K CK/14 CK + 8 ms; [CKSEL=0001 SUT=00]</TEXT>
      </TEXT6>
      <TEXT7>
        <MASK>0x3F</MASK>
        <VALUE>0x11</VALUE>
        <TEXT>PLL Clock; Start-up time PWRDWN/RESET: 16K CK/14 CK + 8 ms; [CKSEL=0001 SUT=01]</TEXT>
      </TEXT7>
      <TEXT8>
        <MASK>0x3F</MASK>
        <VALUE>0x21</VALUE>
        <TEXT>PLL Clock; Start-up time PWRDWN/RESET: 1K CK/14 CK + 68 ms; [CKSEL=0001 SUT=10]</TEXT>
      </TEXT8>
      <TEXT9>
        <MASK>0x3F</MASK>
        <VALUE>0x31</VALUE>
        <TEXT>PLL Clock; Start-up time PWRDWN/RESET: 16K CK/14 CK + 68 ms; [CKSEL=0001 SUT=11]</TEXT>
      </TEXT9>
      <TEXT10>
        <MASK>0x3F</MASK>
        <VALUE>0x02</VALUE>
        <TEXT>Int. RC Osc. 8 MHz; Start-up time PWRDWN/RESET: 6 CK/14 CK + 0 ms; [CKSEL=0010 SUT=00]</TEXT>
      </TEXT10>
      <TEXT11>
        <MASK>0x3F</MASK>
        <VALUE>0x12</VALUE>
        <TEXT>Int. RC Osc. 8 MHz; Start-up time PWRDWN/RESET: 6 CK/14 CK + 4 ms; [CKSEL=0010 SUT=01]</TEXT>
      </TEXT11>
      <TEXT12>
        <MASK>0x3F</MASK>
        <VALUE>0x22</VALUE>
        <TEXT>Int. RC Osc. 8 MHz; Start-up time PWRDWN/RESET: 6 CK/14 CK + 64 ms; [CKSEL=0010 SUT=10]; default value</TEXT>
      </TEXT12>
      <TEXT13>
        <MASK>0x3F</MASK>
        <VALUE>0x03</VALUE>
        <TEXT>WD. Osc. 128 kHz; Start-up time PWRDWN/RESET: 6 CK/14 CK + 0 ms; [CKSEL=0011 SUT=00]</TEXT>
      </TEXT13>
      <TEXT14>
        <MASK>0x3F</MASK>
        <VALUE>0x13</VALUE>
        <TEXT>WD. Osc. 128 kHz; Start-up time PWRDWN/RESET: 6 CK/14 CK + 4 ms; [CKSEL=0011 SUT=01]</TEXT>
      </TEXT14>
      <TEXT15>
        <MASK>0x3F</MASK>
        <VALUE>0x23</VALUE>
        <TEXT>WD. Osc. 128 kHz; Start-up time PWRDWN/RESET: 6 CK/14 CK + 64 ms; [CKSEL=0011 SUT=10]</TEXT>
      </TEXT15>
      <TEXT16>
        <MASK>0x3F</MASK>
        <VALUE>0x04</VALUE>
        <TEXT>Ext. Low-Freq. Crystal; Start-up time PWRDWN/RESET: 1 CK 4 ms; [CKSEL=0100 SUT=00]</TEXT>
      </TEXT16>
      <TEXT17>
        <MASK>0x3F</MASK>
        <VALUE>0x14</VALUE>
        <TEXT>Ext. Low-Freq. Crystal; Start-up time PWRDWN/RESET: 1 CK + 64 ms; [CKSEL=0100 SUT=01]</TEXT>
      </TEXT17>
      <TEXT18>
        <MASK>0x3F</MASK>
        <VALUE>0x24</VALUE>
        <TEXT>Ext. Low-Freq. Crystal; Start-up time PWRDWN/RESET: 32 CK + 64 ms; [CKSEL=0100 SUT=10]</TEXT>
      </TEXT18>
      <TEXT19>
        <MASK>0x3F</MASK>
        <VALUE>0x08</VALUE>
        <TEXT>Ext. Ceramic Res.; Frequency 0.4-0.9 MHz; Start-up time PWRDWN/RESET: 258 CK/14 CK + 4.1 ms; [CKSEL=1000 SUT=00]   </TEXT>
      </TEXT19>
      <TEXT20>
        <MASK>0x3F</MASK>
        <VALUE>0x18</VALUE>
        <TEXT>Ext. Ceramic Res.; Frequency 0.4-0.9 MHz; Start-up time PWRDWN/RESET: 258 CK/14 CK + 65 ms;  [CKSEL=1000 SUT=01]   </TEXT>
      </TEXT20>
      <TEXT21>
        <MASK>0x3F</MASK>
        <VALUE>0x28</VALUE>
        <TEXT>Ext. Ceramic Res.; Frequency 0.4-0.9 MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 0 ms;   [CKSEL=1000 SUT=10]   </TEXT>
      </TEXT21>
      <TEXT22>
        <MASK>0x3F</MASK>
        <VALUE>0x38</VALUE>
        <TEXT>Ext. Ceramic Res.; Frequency 0.4-0.9 MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 4.1 ms; [CKSEL=1000 SUT=11]   </TEXT>
      </TEXT22>
      <TEXT23>
        <MASK>0x3F</MASK>
        <VALUE>0x09</VALUE>
        <TEXT>Ext. Ceramic Res.; Frequency 0.4-0.9 MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 65 ms;  [CKSEL=1001 SUT=00]   </TEXT>
      </TEXT23>
      <TEXT24>
        <MASK>0x3F</MASK>
        <VALUE>0x19</VALUE>
        <TEXT>Ext. Crystal Osc.; Frequency 0.4-0.9 MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 0 ms;   [CKSEL=1001 SUT=01]   </TEXT>
      </TEXT24>
      <TEXT25>
        <MASK>0x3F</MASK>
        <VALUE>0x29</VALUE>
        <TEXT>Ext. Crystal Osc.; Frequency 0.4-0.9 MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 4.1 ms; [CKSEL=1001 SUT=10]   </TEXT>
      </TEXT25>
      <TEXT26>
        <MASK>0x3F</MASK>
        <VALUE>0x39</VALUE>
        <TEXT>Ext. Crystal Osc.; Frequency 0.4-0.9 MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 65 ms;  [CKSEL=1001 SUT=11]   </TEXT>
      </TEXT26>
      <TEXT27>
        <MASK>0x3F</MASK>
        <VALUE>0x0A</VALUE>
        <TEXT>Ext. Ceramic Res.; Frequency 0.9-3.0 MHz; Start-up time PWRDWN/RESET: 258 CK/14 CK + 4.1 ms; [CKSEL=1010 SUT=00]   </TEXT>
      </TEXT27>
      <TEXT28>
        <MASK>0x3F</MASK>
        <VALUE>0x1A</VALUE>
        <TEXT>Ext. Ceramic Res.; Frequency 0.9-3.0 MHz; Start-up time PWRDWN/RESET: 258 CK/14 CK + 65 ms;  [CKSEL=1010 SUT=01]   </TEXT>
      </TEXT28>
      <TEXT29>
        <MASK>0x3F</MASK>
        <VALUE>0x2A</VALUE>
        <TEXT>Ext. Ceramic Res.; Frequency 0.9-3.0 MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 0 ms;   [CKSEL=1010 SUT=10]   </TEXT>
      </TEXT29>
      <TEXT30>
        <MASK>0x3F</MASK>
        <VALUE>0x3A</VALUE>
        <TEXT>Ext. Ceramic Res.; Frequency 0.9-3.0 MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 4.1 ms; [CKSEL=1010 SUT=11]   </TEXT>
      </TEXT30>
      <TEXT31>
        <MASK>0x3F</MASK>
        <VALUE>0x0B</VALUE>
        <TEXT>Ext. Ceramic Res.; Frequency 0.9-3.0 MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 65 ms;  [CKSEL=1011 SUT=00]   </TEXT>
      </TEXT31>
      <TEXT32>
        <MASK>0x3F</MASK>
        <VALUE>0x1B</VALUE>
        <TEXT>Ext. Crystal Osc.; Frequency 0.9-3.0 MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 0 ms;   [CKSEL=1011 SUT=01]   </TEXT>
      </TEXT32>
      <TEXT33>
        <MASK>0x3F</MASK>
        <VALUE>0x2B</VALUE>
        <TEXT>Ext. Crystal Osc.; Frequency 0.9-3.0 MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 4.1 ms; [CKSEL=1011 SUT=10]   </TEXT>
      </TEXT33>
      <TEXT34>
        <MASK>0x3F</MASK>
        <VALUE>0x3B</VALUE>
        <TEXT>Ext. Crystal Osc.; Frequency 0.9-3.0 MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 65 ms;  [CKSEL=1011 SUT=11]   </TEXT>
      </TEXT34>
      <TEXT35>
        <MASK>0x3F</MASK>
        <VALUE>0x0C</VALUE>
        <TEXT>Ext. Ceramic Res.; Frequency 3.0-8.0 MHz; Start-up time PWRDWN/RESET: 258 CK/14 CK + 4.1 ms; [CKSEL=1100 SUT=00]   </TEXT>
      </TEXT35>
      <TEXT36>
        <MASK>0x3F</MASK>
        <VALUE>0x1C</VALUE>
        <TEXT>Ext. Ceramic Res.; Frequency 3.0-8.0 MHz; Start-up time PWRDWN/RESET: 258 CK/14 CK + 65 ms;  [CKSEL=1100 SUT=01]   </TEXT>
      </TEXT36>
      <TEXT37>
        <MASK>0x3F</MASK>
        <VALUE>0x2C</VALUE>
        <TEXT>Ext. Ceramic Res.; Frequency 3.0-8.0 MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 0 ms;   [CKSEL=1100 SUT=10]   </TEXT>
      </TEXT37>
      <TEXT38>
        <MASK>0x3F</MASK>
        <VALUE>0x3C</VALUE>
        <TEXT>Ext. Ceramic Res.; Frequency 3.0-8.0 MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 4.1 ms; [CKSEL=1100 SUT=11]   </TEXT>
      </TEXT38>
      <TEXT39>
        <MASK>0x3F</MASK>
        <VALUE>0x0D</VALUE>
        <TEXT>Ext. Ceramic Res.; Frequency 3.0-8.0 MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 65 ms;  [CKSEL=1101 SUT=00]   </TEXT>
      </TEXT39>
      <TEXT40>
        <MASK>0x3F</MASK>
        <VALUE>0x1D</VALUE>
        <TEXT>Ext. Crystal Osc.; Frequency 3.0-8.0 MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 0 ms;   [CKSEL=1101 SUT=01]   </TEXT>
      </TEXT40>
      <TEXT41>
        <MASK>0x3F</MASK>
        <VALUE>0x2D</VALUE>
        <TEXT>Ext. Crystal Osc.; Frequency 3.0-8.0 MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 4.1 ms; [CKSEL=1101 SUT=10]   </TEXT>
      </TEXT41>
      <TEXT42>
        <MASK>0x3F</MASK>
        <VALUE>0x3D</VALUE>
        <TEXT>Ext. Crystal Osc.; Frequency 3.0-8.0 MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 65 ms;  [CKSEL=1101 SUT=11]   </TEXT>
      </TEXT42>
      <TEXT43>
        <MASK>0x3F</MASK>
        <VALUE>0x0E</VALUE>
        <TEXT>Ext. Ceramic Res.; Frequency 8.0-    MHz; Start-up time PWRDWN/RESET: 258 CK/14 CK + 4.1 ms; [CKSEL=1110 SUT=00]   </TEXT>
      </TEXT43>
      <TEXT44>
        <MASK>0x3F</MASK>
        <VALUE>0x1E</VALUE>
        <TEXT>Ext. Ceramic Res.; Frequency 8.0-    MHz; Start-up time PWRDWN/RESET: 258 CK/14 CK + 65 ms;  [CKSEL=1110 SUT=01]   </TEXT>
      </TEXT44>
      <TEXT45>
        <MASK>0x3F</MASK>
        <VALUE>0x2E</VALUE>
        <TEXT>Ext. Ceramic Res.; Frequency 8.0-    MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 0 ms;   [CKSEL=1110 SUT=10]   </TEXT>
      </TEXT45>
      <TEXT46>
        <MASK>0x3F</MASK>
        <VALUE>0x3E</VALUE>
        <TEXT>Ext. Ceramic Res.; Frequency 8.0-    MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 4.1 ms; [CKSEL=1110 SUT=11]   </TEXT>
      </TEXT46>
      <TEXT47>
        <MASK>0x3F</MASK>
        <VALUE>0x0F</VALUE>
        <TEXT>Ext. Ceramic Res.; Frequency 8.0-    MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 65 ms;  [CKSEL=1111 SUT=00]   </TEXT>
      </TEXT47>
      <TEXT48>
        <MASK>0x3F</MASK>
        <VALUE>0x1F</VALUE>
        <TEXT>Ext. Crystal Osc.; Frequency 8.0-    MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 0 ms;   [CKSEL=1111 SUT=01]   </TEXT>
      </TEXT48>
      <TEXT49>
        <MASK>0x3F</MASK>
        <VALUE>0x2F</VALUE>
        <TEXT>Ext. Crystal Osc.; Frequency 8.0-    MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 4.1 ms; [CKSEL=1111 SUT=10]   </TEXT>
      </TEXT49>
      <TEXT50>
        <MASK>0x3F</MASK>
        <VALUE>0x3F</VALUE>
        <TEXT>Ext. Crystal Osc.; Frequency 8.0-    MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 65 ms;  [CKSEL=1111 SUT=11]   </TEXT>
      </TEXT50>
      <FUSE0>
        <NAME>CKSEL0</NAME>
        <TEXT>Select Clock source</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE0>
      <FUSE1>
        <NAME>CKSEL1</NAME>
        <TEXT>Select Clock source</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE1>
      <FUSE2>
        <NAME>CKSEL2</NAME>
        <TEXT>Select Clock source</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE2>
      <FUSE3>
        <NAME>CKSEL3</NAME>
        <TEXT>Select Clock source</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE3>
      <FUSE4>
        <NAME>SUT0</NAME>
        <TEXT>Select start-up time</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE4>
      <FUSE5>
        <NAME>SUT1</NAME>
        <TEXT>Select start-up time</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE5>
      <FUSE6>
        <NAME>CKOUT</NAME>
        <TEXT>Clock Output Enable</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE6>
      <FUSE7>
        <NAME>CKDIV8</NAME>
        <TEXT>Divide clock by 8</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE7>
    </LOW>
    <HIGH>
      <NMB_TEXT>13</NMB_TEXT>
      <NMB_FUSE_BITS>8</NMB_FUSE_BITS>
      <TEXT1>
        <MASK>0x80</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Reset Disabled (Enable PB7 as i/o pin); [RSTDISBL=0]</TEXT>
      </TEXT1>
      <TEXT2>
        <MASK>0x40</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Debug Wire enable; [DWEN=0]</TEXT>
      </TEXT2>
      <TEXT3>
        <MASK>0x20</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Serial program downloading (SPI) enabled; [SPIEN=0]</TEXT>
      </TEXT3>
      <TEXT4>
        <MASK>0x10</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Watch-dog Timer always on; [WDTON=0]</TEXT>
      </TEXT4>
      <TEXT5>
        <MASK>0x08</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Preserve EEPROM memory through the Chip Erase cycle; [EESAVE=0]</TEXT>
      </TEXT5>
      <TEXT6>
        <MASK>0x07</MASK>
        <VALUE>0x04</VALUE>
        <TEXT>Brown-out detection level at VCC=4.3 V; [BODLEVEL=100] </TEXT>
      </TEXT6>
      <TEXT7>
        <MASK>0x07</MASK>
        <VALUE>0x05</VALUE>
        <TEXT>Brown-out detection level at VCC=2.7 V; [BODLEVEL=101] </TEXT>
      </TEXT7>
      <TEXT8>
        <MASK>0x07</MASK>
        <VALUE>0x06</VALUE>
        <TEXT>Brown-out detection level at VCC=1.8 V; [BODLEVEL=110] </TEXT>
      </TEXT8>
      <TEXT9>
        <MASK>0x07</MASK>
        <VALUE>0x03</VALUE>
        <TEXT>Brown-out detection level at VCC=2.3 V; [BODLEVEL=011] </TEXT>
      </TEXT9>
      <TEXT10>
        <MASK>0x07</MASK>
        <VALUE>0x02</VALUE>
        <TEXT>Brown-out detection level at VCC=2.2 V; [BODLEVEL=010] </TEXT>
      </TEXT10>
      <TEXT11>
        <MASK>0x07</MASK>
        <VALUE>0x01</VALUE>
        <TEXT>Brown-out detection level at VCC=1.9 V; [BODLEVEL=001] </TEXT>
      </TEXT11>
      <TEXT12>
        <MASK>0x07</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Brown-out detection level at VCC=2.0 V; [BODLEVEL=000] </TEXT>
      </TEXT12>
      <TEXT13>
        <MASK>0x07</MASK>
        <VALUE>0x07</VALUE>
        <TEXT>Brown-out detection disabled; [BODLEVEL=111]                              </TEXT>
      </TEXT13>
      <FUSE0>
        <NAME>BODLEVEL0</NAME>
        <TEXT>Brown-out Detector trigger level</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE0>
      <FUSE1>
        <NAME>BODLEVEL1</NAME>
        <TEXT>Brown-out Detector trigger level</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE1>
      <FUSE2>
        <NAME>BODLEVEL2</NAME>
        <TEXT>Brown-out Detector trigger level</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE2>
      <FUSE3>
        <NAME>EESAVE</NAME>
        <TEXT>EEPROM memory is preserved through the Chip Erase</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE3>
      <FUSE4>
        <NAME>WDTON</NAME>
        <TEXT>Watchdog Timer always on</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE4>
      <FUSE5>
        <NAME>SPIEN</NAME>
        <TEXT>Enable Serial Program and Data Downloading</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE5>
      <FUSE6>
        <NAME>DWEN</NAME>
        <TEXT>DebugWIRE Enable</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE6>
      <FUSE7>
        <NAME>RSTDISBL</NAME>
        <TEXT>External Reset disable</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE7>
    </HIGH>
    <EXTENDED>
      <FUSE0>
        <NAME>SELFPRGEN</NAME>
        <TEXT>Self-Programming Enable</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE0>
      <NMB_TEXT>1</NMB_TEXT>
      <NMB_FUSE_BITS>1</NMB_FUSE_BITS>
      <TEXT1>
        <MASK>0x01</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Self Programming enable; [SELFPRGEN=0]</TEXT>
      </TEXT1>
    </EXTENDED>
  </FUSE>
  <PROGRAMMING>
    <ISPInterface>
      <FuseProgMask>0xff,0xdf</FuseProgMask>
      <FuseWarning>1,0x20,0x20,WARNING! These fuse settings will disable the ISP interface!</FuseWarning>
      <FuseWarning>1,0x40,0x00,WARNING! Enabling the debugWIRE interface will disable the ISP interface!</FuseWarning>
      <FuseWarning>1,0x80,0x00,WARNING! Disabling external reset will make the ISP interface inaccessible!</FuseWarning>
    </ISPInterface>
    <HVInterface>
      <FuseWarning>1,0x20,0x20,WARNING! These fuse settings will disable the ISP interface!</FuseWarning>
      <FuseWarning>1,0x40,0x00,WARNING! Enabling the debugWIRE interface will disable the ISP interface!</FuseWarning>
      <FuseWarning>1,0x80,0x00,WARNING! Disabling external reset will make the ISP interface inaccessible!</FuseWarning>
    </HVInterface>
    <OscCal>
      <OCEntry>0x00,8.0 MHz</OCEntry>
    </OscCal>
    <FlashPageSize>64</FlashPageSize>
    <EepromPageSize>4</EepromPageSize>
  </PROGRAMMING>
  <IO_MODULE>
    <MODULE_LIST>[PORTA:USI:WATCHDOG:TIMER_COUNTER_0:BOOT_LOAD:TIMER_COUNTER_1:CPU:EXTERNAL_INTERRUPT:PORTB:ANALOG_COMPARATOR:AD_CONVERTER:EEPROM]</MODULE_LIST>
    <PORTA>
      <LIST>[PORTA:DDRA:PINA]</LIST>
      <LINK/>
      <ICON>io_port.bmp</ICON>
      <ID>AVRSimIOPort.SimIOPort</ID>
      <TEXT/>
      <PORTA>
        <NAME>PORTA</NAME>
        <DESCRIPTION>Port A Data Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$1B</IO_ADDR>
        <MEM_ADDR>$3B</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PORTA7</NAME>
          <DESCRIPTION>Port A Data Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PORTA6</NAME>
          <DESCRIPTION>Port A Data Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PORTA5</NAME>
          <DESCRIPTION>Port A Data Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PORTA4</NAME>
          <DESCRIPTION>Port A Data Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PORTA3</NAME>
          <DESCRIPTION>Port A Data Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PORTA2</NAME>
          <DESCRIPTION>Port A Data Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PORTA1</NAME>
          <DESCRIPTION>Port A Data Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PORTA0</NAME>
          <DESCRIPTION>Port A Data Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PORTA>
      <DDRA>
        <NAME>DDRA</NAME>
        <DESCRIPTION>Port A Data Direction Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$1A</IO_ADDR>
        <MEM_ADDR>$3A</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>DDA7</NAME>
          <DESCRIPTION>Data Direction Register, Port A, bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>DDA6</NAME>
          <DESCRIPTION>Data Direction Register, Port A, bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>DDA5</NAME>
          <DESCRIPTION>Data Direction Register, Port A, bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>DDA4</NAME>
          <DESCRIPTION>Data Direction Register, Port A, bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>DDA3</NAME>
          <DESCRIPTION>Data Direction Register, Port A, bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>DDA2</NAME>
          <DESCRIPTION>Data Direction Register, Port A, bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>DDA1</NAME>
          <DESCRIPTION>Data Direction Register, Port A, bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>DDA0</NAME>
          <DESCRIPTION>Data Direction Register, Port A, bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </DDRA>
      <PINA>
        <NAME>PINA</NAME>
        <DESCRIPTION>Port A Input Pins</DESCRIPTION>
        <TEXT>The Port A Input Pins address - PINA - is not a register, and this address enables access to the physical value on each Port A pin. When reading PORTA the Port A Data Latch is read, and when reading PINA, the logical values present on the pins are read.</TEXT>
        <IO_ADDR>$19</IO_ADDR>
        <MEM_ADDR>$39</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PINA7</NAME>
          <DESCRIPTION>Input Pins, Port A bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>Hi-Z</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PINA6</NAME>
          <DESCRIPTION>Input Pins, Port A bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>Hi-Z</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PINA5</NAME>
          <DESCRIPTION>Input Pins, Port A bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>Hi-Z</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PINA4</NAME>
          <DESCRIPTION>Input Pins, Port A bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>Hi-Z</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PINA3</NAME>
          <DESCRIPTION>Input Pins, Port A bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>Hi-Z</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PINA2</NAME>
          <DESCRIPTION>Input Pins, Port A bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>Hi-Z</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PINA1</NAME>
          <DESCRIPTION>Input Pins, Port A bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>Hi-Z</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PINA0</NAME>
          <DESCRIPTION>Input Pins, Port A bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>Hi-Z</INIT_VAL>
        </BIT0>
      </PINA>
    </PORTA>
    <USI>
      <LIST>[USIBR:USIDR:USISR:USICR]</LIST>
      <LINK/>
      <ICON>io_com.bmp</ICON>
      <ID/>
      <TEXT>Universal Serial Interface</TEXT>
      <USIBR>
        <NAME>USIBR</NAME>
        <DESCRIPTION>USI Buffer Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$10</IO_ADDR>
        <MEM_ADDR>$30</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>USIBR7</NAME>
          <DESCRIPTION>USI Buffer Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>USIBR6</NAME>
          <DESCRIPTION>USI Buffer Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>USIBR5</NAME>
          <DESCRIPTION>USI Buffer Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>USIBR4</NAME>
          <DESCRIPTION>USI Buffer Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>USIBR3</NAME>
          <DESCRIPTION>USI Buffer Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>USIBR2</NAME>
          <DESCRIPTION>USI Buffer Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>USIBR1</NAME>
          <DESCRIPTION>USI Buffer Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>USIBR0</NAME>
          <DESCRIPTION>USI Buffer Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </USIBR>
      <USIDR>
        <NAME>USIDR</NAME>
        <DESCRIPTION>USI Data Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$0F</IO_ADDR>
        <MEM_ADDR>$2F</MEM_ADDR>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>USIDR7</NAME>
          <DESCRIPTION>USI Data Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>USIDR6</NAME>
          <DESCRIPTION>USI Data Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>USIDR5</NAME>
          <DESCRIPTION>USI Data Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>USIDR4</NAME>
          <DESCRIPTION>USI Data Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>USIDR3</NAME>
          <DESCRIPTION>USI Data Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>USIDR2</NAME>
          <DESCRIPTION>USI Data Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>USIDR1</NAME>
          <DESCRIPTION>USI Data Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>USIDR0</NAME>
          <DESCRIPTION>USI Data Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </USIDR>
      <USISR>
        <NAME>USISR</NAME>
        <DESCRIPTION>USI Status Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$0E</IO_ADDR>
        <MEM_ADDR>$2E</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>USISIF</NAME>
          <DESCRIPTION>Start Condition Interrupt Flag</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>USIOIF</NAME>
          <DESCRIPTION>Counter Overflow Interrupt Flag</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>USIPF</NAME>
          <DESCRIPTION>Stop Condition Flag</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>USIDC</NAME>
          <DESCRIPTION>Data Output Collision</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>USICNT3</NAME>
          <DESCRIPTION>USI Counter Value Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>USICNT2</NAME>
          <DESCRIPTION>USI Counter Value Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>USICNT1</NAME>
          <DESCRIPTION>USI Counter Value Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>USICNT0</NAME>
          <DESCRIPTION>USI Counter Value Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </USISR>
      <USICR>
        <NAME>USICR</NAME>
        <DESCRIPTION>USI Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$0D</IO_ADDR>
        <MEM_ADDR>$2D</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>USISIE</NAME>
          <DESCRIPTION>Start Condition Interrupt Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>USIOIE</NAME>
          <DESCRIPTION>Counter Overflow Interrupt Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>USIWM1</NAME>
          <DESCRIPTION>USI Wire Mode Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>USIWM0</NAME>
          <DESCRIPTION>USI Wire Mode Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <ENUM>COMM_USI_OP</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>USICS1</NAME>
          <DESCRIPTION>USI Clock Source Select Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>USICS0</NAME>
          <DESCRIPTION>USI Clock Source Select Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>USICLK</NAME>
          <DESCRIPTION>Clock Strobe</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>USITC</NAME>
          <DESCRIPTION>Toggle Clock Port Pin</DESCRIPTION>
          <TEXT/>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </USICR>
    </USI>
    <WATCHDOG>
      <LIST>[WDTCSR]</LIST>
      <LINK/>
      <ICON>io_watch.bmp</ICON>
      <ID/>
      <TEXT/>
      <WDTCSR>
        <NAME>WDTCSR</NAME>
        <DESCRIPTION>Watchdog Timer Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$21</IO_ADDR>
        <MEM_ADDR>$41</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>WDIF</NAME>
          <DESCRIPTION>Watchdog Timeout Interrupt Flag</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>WDIE</NAME>
          <DESCRIPTION>Watchdog Timeout Interrupt Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>WDP3</NAME>
          <DESCRIPTION>Watchdog Timer Prescaler Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>WDCE</NAME>
          <DESCRIPTION>Watchdog Change Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>WDE</NAME>
          <DESCRIPTION>Watch Dog Enable</DESCRIPTION>
          <TEXT>When the WDE is set (one) the Watchdog Timer is enabled, and if the WDE is cleared (zero) the Watchdog Timer function is disabled. WDE can only be cleared if the WDTOE bit is set(one). To disable an enabled watchdog timer, the following procedure must be followed: 1. In the same operation, write a logical one to WDTOE and WDE. A logical one must be written to WDE even though it is set to one before the disable operation starts. 2. Within the next four clock cycles, write a logical 0 to WDE. This disables the watchdog</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>WDP2</NAME>
          <DESCRIPTION>Watch Dog Timer Prescaler bit 2</DESCRIPTION>
          <TEXT/>
          <ENUM>WDOG_TIMER_PRESCALE_4BITS</ENUM>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>WDP1</NAME>
          <DESCRIPTION>Watch Dog Timer Prescaler bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>WDP0</NAME>
          <DESCRIPTION>Watch Dog Timer Prescaler bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </WDTCSR>
    </WATCHDOG>
    <TIMER_COUNTER_0>
      <LIST>[TIMSK0:TIFR0:TCCR0A:TCCR0B:TCNT0:OCR0A:OCR0B:GTCCR]</LIST>
      <LINK/>
      <ICON>io_timer.bmp</ICON>
      <ID/>
      <TEXT/>
      <TIMSK0>
        <NAME>TIMSK0</NAME>
        <DESCRIPTION>Timer/Counter Interrupt Mask Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$39</IO_ADDR>
        <MEM_ADDR>$59</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT2>
          <NAME>OCIE0B</NAME>
          <DESCRIPTION>Timer/Counter0 Output Compare Match B Interrupt Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCIE0A</NAME>
          <DESCRIPTION>Timer/Counter0 Output Compare Match A Interrupt Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TOIE0</NAME>
          <DESCRIPTION>Timer/Counter0 Overflow Interrupt Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TIMSK0>
      <TIFR0>
        <NAME>TIFR0</NAME>
        <DESCRIPTION>Timer/Counter0 Interrupt Flag Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$38</IO_ADDR>
        <MEM_ADDR>$58</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT2>
          <NAME>OCF0B</NAME>
          <DESCRIPTION>Timer/Counter0 Output Compare Flag B</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCF0A</NAME>
          <DESCRIPTION>Timer/Counter0 Output Compare Flag A</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TOV0</NAME>
          <DESCRIPTION>Timer/Counter0 Overflow Flag</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TIFR0>
      <TCCR0A>
        <NAME>TCCR0A</NAME>
        <DESCRIPTION>Timer/Counter  Control Register A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$30</IO_ADDR>
        <MEM_ADDR>$50</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>COM0A1</NAME>
          <DESCRIPTION>Compare Match Output A Mode bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>COM0A0</NAME>
          <DESCRIPTION>Compare Match Output A Mode bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>COM0B1</NAME>
          <DESCRIPTION>Compare Match Output B Mode bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>COM0B0</NAME>
          <DESCRIPTION>Compare Match Output B Mode bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT1>
          <NAME>WGM01</NAME>
          <DESCRIPTION>Waveform Generation Mode bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>WGM00</NAME>
          <DESCRIPTION>Waveform Generation Mode bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCCR0A>
      <TCCR0B>
        <NAME>TCCR0B</NAME>
        <DESCRIPTION>Timer/Counter Control Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$33</IO_ADDR>
        <MEM_ADDR>$53</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>FOC0A</NAME>
          <DESCRIPTION>Force Output Compare A</DESCRIPTION>
          <TEXT/>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>FOC0B</NAME>
          <DESCRIPTION>Force Output Compare B</DESCRIPTION>
          <TEXT/>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT3>
          <NAME>WGM02</NAME>
          <DESCRIPTION>Waveform Generation Mode bit 2</DESCRIPTION>
          <TEXT/>
          <ACESS>RW</ACESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CS02</NAME>
          <DESCRIPTION>Clock Select bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CS01</NAME>
          <DESCRIPTION>Clock Select bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CS00</NAME>
          <DESCRIPTION>Clock Select bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <ENUM>CLK_SEL_3BIT_EXT</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCCR0B>
      <TCNT0>
        <NAME>TCNT0</NAME>
        <DESCRIPTION>Timer/Counter0</DESCRIPTION>
        <TEXT>The Timer/Counter Register gives direct access, both for read and write operations, to the Timer/Counter unit 8-bit counter. Writing to the TCNT0 register blocks (removes) the compare match on the following timer clock. Modifying the counter (TCNT0) while the counter is running, introduces a risk of missing a compare match between TCNT0 the OCR0 register.</TEXT>
        <IO_ADDR>$32</IO_ADDR>
        <MEM_ADDR>$52</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TCNT0_7</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TCNT0_6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TCNT0_5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TCNT0_4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TCNT0_3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TCNT0_2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TCNT0_1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TCNT0_0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCNT0>
      <OCR0A>
        <NAME>OCR0A</NAME>
        <DESCRIPTION>Timer/Counter0 Output Compare Register A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$36</IO_ADDR>
        <MEM_ADDR>$56</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR0A_7</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR0A_6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR0A_5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR0A_4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR0A_3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR0A_2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR0A_1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR0A_0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCR0A>
      <OCR0B>
        <NAME>OCR0B</NAME>
        <DESCRIPTION>Timer/Counter0 Output Compare Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$3C</IO_ADDR>
        <MEM_ADDR>$5C</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR0_7</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR0_6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR0_5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR0_4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR0_3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR0_2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR0_1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR0_0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCR0B>
      <GTCCR>
        <NAME>GTCCR</NAME>
        <DESCRIPTION>General Timer/Counter Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$23</IO_ADDR>
        <MEM_ADDR>$43</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>TSM</NAME>
          <DESCRIPTION>Timer/Counter Synchronization Mode</DESCRIPTION>
          <TEXT>Writing the TSM bit to one activates the Timer/Counter Synchronization mode. In this mode, the value that is written to the PSR2 and PSR10 bits is kept, hence keeping the corresponding prescaler reset signals asserted. This ensures that the corresponding Timer/Counters are halted and can be configured to the same value without the risk of one of them advancing during configuration. When the TSM bit is written to zero, the PSR2 and PSR10 bits are cleared by hardware, and the Timer/Counters start counting simultaneousl</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT0>
          <NAME>PSR10</NAME>
          <DESCRIPTION>Prescaler Reset Timer/CounterN</DESCRIPTION>
          <TEXT>When this bit is one, Timer/Counter1 and Timer/Counter0 prescaler will be Reset. This bit is normally cleared immediately by hardware, except if the TSM bit is set. Note that Timer/Counter1 and Timer/Counter0 share the same prescaler and a reset of this prescaler will affect both timers.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </GTCCR>
    </TIMER_COUNTER_0>
    <BOOT_LOAD>
      <LIST>[SPMCSR]</LIST>
      <LINK/>
      <RULES/>
      <ICON>io_cpu.bmp</ICON>
      <ID/>
      <TEXT>The Boot Loader Support provides a real Read While Write self-programming mechanism for downloading and uploading program code by the MCU itself. This feature allows flexible application software updates controlled by the MCU using a Flash-resident Boot Loader program. The Boot Loader program can use any available data interface and associated proto-col to read code and write (program) that code into the Flash memory, or read the code from the program memory. The program code within the Boot Loader section has the capability to write into the entire Flash, including the Boot Loader Memory. The Boot Loader can thus even modify itself, and it can also erase itself from the code if the feature is not needed anymore. The size of the Boot Loader Memory is configurable with fuses and the Boot Loader has two separate sets of Boot Lock Bits which can be set independently. This gives the user a unique flexibility to select different levels of protection. Boot Loader Features: Read While Write self-programming. Flexibl Boot Memory size. High security (separate Boot Lock bits for a flexible protection).  Separate fuse to select reset vector Optimized page (1) size. Code efficient algorithm Efficient read-modify-write suppo</TEXT>
      <SPMCSR>
        <NAME>SPMCSR</NAME>
        <DESCRIPTION>Store Program Memory Control Register</DESCRIPTION>
        <TEXT>The Store Program Memory Control Register contains the control bits needed to control the Boot Loader operations.</TEXT>
        <IO_ADDR>$37</IO_ADDR>
        <MEM_ADDR>$57</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT4>
          <NAME>CTPB</NAME>
          <DESCRIPTION>Clear temporary page buffer</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>RFLB</NAME>
          <DESCRIPTION>Read fuse and lock bits</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PGWRT</NAME>
          <DESCRIPTION>Page Write</DESCRIPTION>
          <TEXT>If this bit is written to one at the same time as SPMEN, the next SPM instruction within four clock cycles executes page write, with the data stored in the temporary buffer. The page address is taken from the high part of the Z pointer. The data in R1 and R0 are ignored. The PGWRT bit will auto-clear upon completion of a page write, or if no SPM instruction is exe-cuted within four clock cycles. The CPU is halted during the entire page write operation if the NRWW section is addressed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PGERS</NAME>
          <DESCRIPTION>Page Erase</DESCRIPTION>
          <TEXT>If this bit is written to one at the same time as SPMEN, the next SPM instruction within four clock cycles executes page erase. The page address is taken from the high part of the Z pointer. The data in R1 and R0 are ignored. The PGERS bit will auto-clear upon completion of a page erase, or if no SPM instruction is executed within four clock cycles. The CPU is halted during the entire page write operation if the NRWW section is addressed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SPMEN</NAME>
          <DESCRIPTION>Store Program Memory Enable</DESCRIPTION>
          <TEXT>This bit enables the SPM instruction for the next four clock cycles. If written to one together with either RWWSRE, BLB-SET, PGWRT or PGERS, the following SPM instruction will have a special meaning, see description above. If only SPMEN is written, the following SPM instruction will store the value in R1:R0 in the temporary page buffer addressed by the Z pointer. The LSB of the Z pointer is ignored. The SPMEN bit will auto-clear upon completion of an SPM instruction, or if no SPM instruction is executed within four clock cycles. During page erase and page write, the SPMEN bit remain high until the operation is completed. Writing any other combination than &#x201C;10001&#x201D;, "01001", "00101", "00011" or "00001" in the lower five bits will have no eff</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SPMCSR>
    </BOOT_LOAD>
    <TIMER_COUNTER_1>
      <LIST>[TIMSK1:TIFR1:TCCR1A:TCCR1B:TCNT1:OCR1A:OCR1B:GTCCR]</LIST>
      <LINK/>
      <ICON>io_timer.bmp</ICON>
      <ID/>
      <TEXT/>
      <TIMSK1>
        <NAME>TIMSK1</NAME>
        <DESCRIPTION>Timer/Counter Interrupt Mask Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$0C</IO_ADDR>
        <MEM_ADDR>$2C</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT2>
          <NAME>OCIE1B</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Match B Interrupt Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCIE1A</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Match A Interrupt Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TOIE1</NAME>
          <DESCRIPTION>Timer/Counter1 Overflow Interrupt Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TIMSK1>
      <TIFR1>
        <NAME>TIFR1</NAME>
        <DESCRIPTION>Timer/Counter1 Interrupt Flag Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$0B</IO_ADDR>
        <MEM_ADDR>$2B</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT2>
          <NAME>OCF1B</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Flag B</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCF1A</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Flag A</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TOV1</NAME>
          <DESCRIPTION>Timer/Counter1 Overflow Flag</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TIFR1>
      <TCCR1A>
        <NAME>TCCR1A</NAME>
        <DESCRIPTION>Timer/Counter1 Control Register A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$2F</IO_ADDR>
        <MEM_ADDR>$4F</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>COM1A1</NAME>
          <DESCRIPTION>Compare Match Output A Mode bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>COM1A0</NAME>
          <DESCRIPTION>Compare Match Output A Mode bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>COM1B1</NAME>
          <DESCRIPTION>Compare Match Output B Mode bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>COM1B0</NAME>
          <DESCRIPTION>Compare Match Output B Mode bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT1>
          <NAME>WGM11</NAME>
          <DESCRIPTION>Waveform Generation Mode bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>WGM10</NAME>
          <DESCRIPTION>Waveform Generation Mode bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCCR1A>
      <TCCR1B>
        <NAME>TCCR1B</NAME>
        <DESCRIPTION>Timer/Counter Control Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$2E</IO_ADDR>
        <MEM_ADDR>$4E</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>FOC1A</NAME>
          <DESCRIPTION>Force Output Compare A</DESCRIPTION>
          <TEXT/>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>FOC1B</NAME>
          <DESCRIPTION>Force Output Compare B</DESCRIPTION>
          <TEXT/>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT3>
          <NAME>WGM12</NAME>
          <DESCRIPTION>Waveform Generation Mode bit 2</DESCRIPTION>
          <TEXT/>
          <ACESS>RW</ACESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CS12</NAME>
          <DESCRIPTION>Clock Select bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CS11</NAME>
          <DESCRIPTION>Clock Select bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CS10</NAME>
          <DESCRIPTION>Clock Select bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <ENUM>CLK_SEL_3BIT_EXT</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCCR1B>
      <TCNT1>
        <NAME>TCNT1</NAME>
        <DESCRIPTION>Timer/Counter1</DESCRIPTION>
        <TEXT>The Timer/Counter Register gives direct access, both for read and write operations, to the Timer/Counter unit 8-bit counter. Writing to the TCNT1 register blocks (removes) the compare match on the following timer clock. Modifying the counter (TCNT1) while the counter is running, introduces a risk of missing a compare match between TCNT1 the OCR0 register.</TEXT>
        <IO_ADDR>$2D</IO_ADDR>
        <MEM_ADDR>$4D</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TCNT1_7</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TCNT1_6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TCNT1_5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TCNT1_4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TCNT1_3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TCNT1_2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TCNT1_1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TCNT1_0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCNT1>
      <OCR1A>
        <NAME>OCR1A</NAME>
        <DESCRIPTION>Timer/Counter1 Output Compare Register A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$2C</IO_ADDR>
        <MEM_ADDR>$4C</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR1_7</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR1_6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR1_5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR1_4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR1_3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR1_2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR1_1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR1_0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCR1A>
      <OCR1B>
        <NAME>OCR1B</NAME>
        <DESCRIPTION>Timer/Counter1 Output Compare Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$2B</IO_ADDR>
        <MEM_ADDR>$4B</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR1_7</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR1_6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR1_5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR1_4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR1_3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR1_2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR1_1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR1_0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCR1B>
      <GTCCR>
        <NAME>GTCCR</NAME>
        <DESCRIPTION>General Timer/Counter Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$23</IO_ADDR>
        <MEM_ADDR>$43</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>TSM</NAME>
          <DESCRIPTION>Timer/Counter Synchronization Mode</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT0>
          <NAME>PSR10</NAME>
          <DESCRIPTION>Prescaler Reset Timer/CounterN</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </GTCCR>
    </TIMER_COUNTER_1>
    <CPU>
      <LIST>[SREG:SPH:SPL:MCUCR:MCUSR:OSCCAL:GPIOR2:GPIOR1:GPIOR0:PRR:CLKPR]</LIST>
      <LINK>[SPH:SPL]</LINK>
      <ICON>io_cpu.bmp</ICON>
      <ID/>
      <TEXT/>
      <PRR>
        <NAME>PRR</NAME>
        <DESCRIPTION>Power Reduction Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$00</IO_ADDR>
        <MEM_ADDR>$20</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT3>
          <NAME>PRTIM1</NAME>
          <DESCRIPTION>Power Reduction Timer/Counter1</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PRTIM0</NAME>
          <DESCRIPTION>Power Reduction Timer/Counter0</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PRUSI</NAME>
          <DESCRIPTION>Power Reduction USI</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PRADC</NAME>
          <DESCRIPTION>Power Reduction ADC</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PRR>
      <OSCCAL>
        <NAME>OSCCAL</NAME>
        <DESCRIPTION>Oscillator Calibration Value</DESCRIPTION>
        <TEXT>Writing the calibration byte to this address will trim the internal oscillator to remove process variations from the oscillator frequency. This is done automatically during chip reset. When OSCCAL is zero, the lowest available frequency is chosen. Writing non-zero values to this register will increase the frequency of the internal oscillator. Writing $FF to the register gives the highest available frequency. The calibrated oscillator is used to time EEPROM and Flash access. If EEPROM or Flash is written, do not calibrate to more than 10% above the nominal frequency. Otherwise, the EEPROM or Flash write may fail. Note that the Oscillator is intended for calibration to 1.0 MHz, 2.0 MHz, 4.0 MHz, or 8.0MHz. Tuning to other values is not guaranteed, as indicated in Table 14</TEXT>
        <IO_ADDR>$31</IO_ADDR>
        <MEM_ADDR>$51</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>CAL7</NAME>
          <DESCRIPTION>Oscillator Calibration Value Bit7</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>CAL6</NAME>
          <DESCRIPTION>Oscillator Calibration Value Bit6</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>CAL5</NAME>
          <DESCRIPTION>Oscillator Calibration Value Bit5</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>CAL4</NAME>
          <DESCRIPTION>Oscillator Calibration Value Bit4</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>CAL3</NAME>
          <DESCRIPTION>Oscillator Calibration Value Bit3</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CAL2</NAME>
          <DESCRIPTION>Oscillator Calibration Value Bit2</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CAL1</NAME>
          <DESCRIPTION>Oscillator Calibration Value Bit1</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CAL0</NAME>
          <DESCRIPTION>Oscillator Calibration Value Bit0</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OSCCAL>
      <CLKPR>
        <NAME>CLKPR</NAME>
        <DESCRIPTION>Clock Prescale Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$26</IO_ADDR>
        <MEM_ADDR>$46</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>CLKPCE</NAME>
          <DESCRIPTION>Clock Prescaler Change Enable</DESCRIPTION>
          <TEXT>The CLKPCE bit must be written to logic one to enable change of the CLKPS bits. The CLKPCE bit is only updated when the other bits in CLKPR are simultaneously written to zero. CLKPCE is cleared by hardware four cycles after it is written or when CLKPS bits are written. Rewriting the CLKPCE bit within this time-out period does neither extend the time-out period, nor clear the CLKPCE bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT3>
          <NAME>CLKPS3</NAME>
          <DESCRIPTION>Clock Prescaler Select Bit 3</DESCRIPTION>
          <TEXT>These bits define the division factor between the selected clock source and the internal system clock. These bits can be written run-time to vary the clock frequency to suit the application requirements. As the divider divides the master clock input to the MCU, the speed of all synchronous peripherals is reduced when a division factor is used.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CLKPS2</NAME>
          <DESCRIPTION>Clock Prescaler Select Bit 2</DESCRIPTION>
          <TEXT>These bits define the division factor between the selected clock source and the internal system clock. These bits can be written run-time to vary the clock frequency to suit the application requirements. As the divider divides the master clock input to the MCU, the speed of all synchronous peripherals is reduced when a division factor is used.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CLKPS1</NAME>
          <DESCRIPTION>Clock Prescaler Select Bit 1</DESCRIPTION>
          <TEXT>These bits define the division factor between the selected clock source and the internal system clock. These bits can be written run-time to vary the clock frequency to suit the application requirements. As the divider divides the master clock input to the MCU, the speed of all synchronous peripherals is reduced when a division factor is used.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CLKPS0</NAME>
          <DESCRIPTION>Clock Prescaler Select Bit 0</DESCRIPTION>
          <TEXT>These bits define the division factor between the selected clock source and the internal system clock. These bits can be written run-time to vary the clock frequency to suit the application requirements. As the divider divides the master clock input to the MCU, the speed of all synchronous peripherals is reduced when a division factor is used.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>CPU_CLK_PRESCALE_4_BITS_SMALL</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </CLKPR>
      <SREG>
        <NAME>SREG</NAME>
        <DESCRIPTION>Status Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$3F</IO_ADDR>
        <MEM_ADDR>$5F</MEM_ADDR>
        <ICON>io_sreg.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>I</NAME>
          <DESCRIPTION>Global Interrupt Enable</DESCRIPTION>
          <TEXT>The global interrupt enable bit must be set (one) for the interrupts to be enabled. The individual interrupt enable control is then performed in separate control registers. If the global interrupt enable bit is cleared (zero), none of the interrupts are enabled independent of the individual interrupt enable settings. The I-bit is cleared by hardware after an interrupt has occurred, and is set by the RETI instruction to enable subsequent interrupts.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>T</NAME>
          <DESCRIPTION>Bit Copy Storage</DESCRIPTION>
          <TEXT>The bit copy instructions BLD (Bit LoaD) and BST (Bit STore) use the T bit as source and destination for the operated bit. A bit from a register in the register file can be copied into T by the BST instruction, and a bit in T can be copied into a bit in a register in the register file by the BLD instruction.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>H</NAME>
          <DESCRIPTION>Half Carry Flag</DESCRIPTION>
          <TEXT>The half carry flag H indicates a half carry in some arithmetic operations. See the Instruction Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>S</NAME>
          <DESCRIPTION>Sign Bit</DESCRIPTION>
          <TEXT>The S-bit is always an exclusive or between the negative flag N and the two&#x2019;s complement overflow flag V. See the Instruc-tion Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>V</NAME>
          <DESCRIPTION>Two's Complement Overflow Flag</DESCRIPTION>
          <TEXT>The two&#x2019;s complement overflow flag V supports two&#x2019;s complement arithmetics. See the Instruction Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>N</NAME>
          <DESCRIPTION>Negative Flag</DESCRIPTION>
          <TEXT>The negative flag N indicates a negative result after the different arithmetic and logic operations. See the Instruction Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>Z</NAME>
          <DESCRIPTION>Zero Flag</DESCRIPTION>
          <TEXT>The zero flag Z indicates a zero result after the different arithmetic and logic operations. See the Instruction Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>C</NAME>
          <DESCRIPTION>Carry Flag</DESCRIPTION>
          <TEXT>The carry flag C indicates a carry in an arithmetic or logic operation. See the Instruction Set Description for detailed information. Note that the status register is not automatically stored when entering an interrupt routine and restored when returning from an interrupt routine. This must be handled by software.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SREG>
      <SPH>
        <NAME>SPH</NAME>
        <DESCRIPTION>Stack Pointer High</DESCRIPTION>
        <TEXT>The general AVR 16-bit Stack Pointer is effectively built up of two 8-bit registers in the I/O space locations $3E ($5E) and $3D ($5D). As the AT90S4414/8515 supports up to 64 kB external SRAM, all 16-bits are used. The Stack Pointer points to the data SRAM stack area where the Subroutine and Interrupt Stacks are located. This Stack space in the data SRAM must be defined by the program before any subroutine calls are executed or interrupts are enabled. The stack pointer must be set to point above $60. The Stack Pointer is decremented by one when data is pushed onto the Stack with the PUSH instruction, and it is decremented by two when an address is pushed onto the Stack with subroutine calls and interrupts. The Stack Pointer is incremented by one when data is popped from the Stack with the POP instruction, and it is incremented by two when an address is popped from the Stack with return from subroutine RET or return from interrupt R</TEXT>
        <IO_ADDR>$3E</IO_ADDR>
        <MEM_ADDR>$5E</MEM_ADDR>
        <ICON>io_sph.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT0>
          <NAME>SP8</NAME>
          <DESCRIPTION>Stack pointer bit 8</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SPH>
      <SPL>
        <NAME>SPL</NAME>
        <DESCRIPTION>Stack Pointer Low</DESCRIPTION>
        <TEXT>The general AVR 16-bit Stack Pointer is effectively built up of two 8-bit registers in the I/O space locations $3E ($5E) and $3D ($5D). As the AT90S4414/8515 supports up to 64 kB external SRAM, all 16-bits are used. The Stack Pointer points to the data SRAM stack area where the Subroutine and Interrupt Stacks are located. This Stack space in the data SRAM must be defined by the program before any subroutine calls are executed or interrupts are enabled. The stack pointer must be set to point above $60. The Stack Pointer is decremented by one when data is pushed onto the Stack with the PUSH instruction, and it is decremented by two when an address is pushed onto the Stack with subroutine calls and interrupts. The Stack Pointer is incremented by one when data is popped from the Stack with the POP instruction, and it is incremented by two when an address is popped from the Stack with return from subroutine RET or return from interrupt </TEXT>
        <IO_ADDR>$3D</IO_ADDR>
        <MEM_ADDR>$5D</MEM_ADDR>
        <ICON>io_sph.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>SP7</NAME>
          <DESCRIPTION>Stack pointer bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SP6</NAME>
          <DESCRIPTION>Stack pointer bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SP5</NAME>
          <DESCRIPTION>Stack pointer bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SP4</NAME>
          <DESCRIPTION>Stack pointer bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SP3</NAME>
          <DESCRIPTION>Stack pointer bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SP2</NAME>
          <DESCRIPTION>Stack pointer bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SP1</NAME>
          <DESCRIPTION>Stack pointer bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SP0</NAME>
          <DESCRIPTION>Stack pointer bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SPL>
      <MCUCR>
        <NAME>MCUCR</NAME>
        <DESCRIPTION>MCU Control Register</DESCRIPTION>
        <TEXT>The MCU Control Register contains control bits for general MCU functions.</TEXT>
        <IO_ADDR>$35</IO_ADDR>
        <MEM_ADDR>$55</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>BODS</NAME>
          <DESCRIPTION>BOD Sleep</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PUD</NAME>
          <DESCRIPTION>Pull-Up Disable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SE</NAME>
          <DESCRIPTION>Sleep Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SM1</NAME>
          <DESCRIPTION>Sleep Mode Select Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SM0</NAME>
          <DESCRIPTION>Sleep Mode Select Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <ENUM>CPU_SLEEP_MODE</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>BODSE</NAME>
          <DESCRIPTION>BOD Sleep Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ISC01</NAME>
          <DESCRIPTION>Interrupt Sense Control 0 Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ISC00</NAME>
          <DESCRIPTION>Interrupt Sense Control 0 Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <ENUM>INTERRUPT_SENSE_CONTROL2</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </MCUCR>
      <MCUSR>
        <NAME>MCUSR</NAME>
        <DESCRIPTION>MCU Status Register</DESCRIPTION>
        <TEXT>The MCU Status Register provides information on which reset source caused an MCU reset.</TEXT>
        <IO_ADDR>$34</IO_ADDR>
        <MEM_ADDR>$54</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT3>
          <NAME>WDRF</NAME>
          <DESCRIPTION>Watchdog Reset Flag</DESCRIPTION>
          <TEXT>This bit is set if a watchdog reset occurs. The bit is reset by a power-on reset, or by writing a logic zero to the flag.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>BORF</NAME>
          <DESCRIPTION>Brown-out Reset Flag</DESCRIPTION>
          <TEXT>This bit is set if a brown-out reset occurs. The bit is reset by a power-on reset, or by writing a logic zero to the flag.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>EXTRF</NAME>
          <DESCRIPTION>External Reset Flag</DESCRIPTION>
          <TEXT>This bit is set if an external reset occurs. The bit is reset by a power-on reset, or by writing a logic zero to the flag.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PORF</NAME>
          <DESCRIPTION>Power-on reset flag</DESCRIPTION>
          <TEXT>This bit is set if a power-on reset occurs. The bit is reset only by writing a logic zero to the flag. To make use of the reset flags to identify a reset condition, the user should read and then reset the MCUCSR as early as possible in the program. If the register is cleared before another reset occurs, the source of the reset can be found by examining the reset flags.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </MCUSR>
      <GPIOR2>
        <NAME>GPIOR2</NAME>
        <DESCRIPTION>General Purpose I/O Register 2</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$15</IO_ADDR>
        <MEM_ADDR>$35</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>GPIOR27</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>GPIOR26</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>GPIOR25</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>GPIOR24</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>GPIOR23</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS/>
          <INIT_VAL/>
        </BIT3>
        <BIT2>
          <NAME>GPIOR22</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>GPIOR21</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>GPIOR20</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </GPIOR2>
      <GPIOR1>
        <NAME>GPIOR1</NAME>
        <DESCRIPTION>General Purpose I/O Register 1</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$14</IO_ADDR>
        <MEM_ADDR>$34</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>GPIOR17</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>GPIOR16</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>GPIOR15</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>GPIOR14</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>GPIOR13</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS/>
          <INIT_VAL/>
        </BIT3>
        <BIT2>
          <NAME>GPIOR12</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>GPIOR11</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>GPIOR10</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </GPIOR1>
      <GPIOR0>
        <NAME>GPIOR0</NAME>
        <DESCRIPTION>General Purpose I/O Register 0</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$13</IO_ADDR>
        <MEM_ADDR>$33</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>GPIOR07</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>GPIOR06</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>GPIOR05</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>GPIOR04</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>GPIOR03</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS/>
          <INIT_VAL/>
        </BIT3>
        <BIT2>
          <NAME>GPIOR02</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>GPIOR01</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>GPIOR00</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </GPIOR0>
    </CPU>
    <EXTERNAL_INTERRUPT>
      <LIST>[MCUCR:GIMSK:GIFR:PCMSK1:PCMSK0]</LIST>
      <LINK/>
      <ICON>io_ext.bmp</ICON>
      <ID/>
      <TEXT/>
      <MCUCR>
        <NAME>MCUCR</NAME>
        <DESCRIPTION>MCU Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$35</IO_ADDR>
        <MEM_ADDR>$55</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT1>
          <NAME>ISC01</NAME>
          <DESCRIPTION>Interrupt Sense Control 0 Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ISC00</NAME>
          <DESCRIPTION>Interrupt Sense Control 0 Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <ENUM>INTERRUPT_SENSE_CONTROL</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </MCUCR>
      <GIMSK>
        <NAME>GIMSK</NAME>
        <ALIAS>GICR</ALIAS>
        <DESCRIPTION>General Interrupt Mask Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$3B</IO_ADDR>
        <MEM_ADDR>$5B</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT6>
          <NAME>INT0</NAME>
          <DESCRIPTION>External Interrupt Request 0 Enable</DESCRIPTION>
          <TEXT>When the INT0 bit is set (one) and the I-bit in the Status Register (SREG) is set (one), the external pin interrupt is enabled. The Interrupt Sense Control0 bits 1/0 (ISC01 and ISC00) in the MCU general Control Register (MCUCR) defines whether the external interrupt is activated on rising or falling edge of the INT0 pin or level sensed. Activity on the pin will cause an interrupt request even if INT0 is configured as an output. The corresponding interrupt of External Interrupt Request 0 is executed from program memory address $001. See also &#x201C;External Interrupts.&#x201D; &#x2022; Bits 5..0 - Res: Reserved bits</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PCIE1</NAME>
          <DESCRIPTION>Pin Change Interrupt Enable 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PCIE0</NAME>
          <DESCRIPTION>Pin Change Interrupt Enable 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
      </GIMSK>
      <GIFR>
        <NAME>GIFR</NAME>
        <DESCRIPTION>General Interrupt Flag register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$3A</IO_ADDR>
        <MEM_ADDR>$5A</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT6>
          <NAME>INTF0</NAME>
          <DESCRIPTION>External Interrupt Flag 0</DESCRIPTION>
          <TEXT>When an event on the INT0 pin triggers an interrupt request, INTF0 becomes set (one). If the I-bit in SREG and the INT0 bit in GIMSK are set (one), the MCU will jump to the interrupt vector at address $001. The flag is cleared when the interrupt routine is executed. Alternatively, the flag can be cleared by writing a logical one to it. </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PCIF1</NAME>
          <DESCRIPTION>Pin Change Interrupt Flag 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PCIF0</NAME>
          <DESCRIPTION>Pin Change Interrupt Flag 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
      </GIFR>
      <PCMSK1>
        <NAME>PCMSK1</NAME>
        <DESCRIPTION>Pin Change Enable Mask Byte 1</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$20</IO_ADDR>
        <MEM_ADDR>$40</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PCINT15</NAME>
          <DESCRIPTION>Pin Change Enable Mask Bit 15</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PCINT14</NAME>
          <DESCRIPTION>Pin Change Enable Mask Bit 14</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PCINT13</NAME>
          <DESCRIPTION>Pin Change Enable Mask Bit 13</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PCINT12</NAME>
          <DESCRIPTION>Pin Change Enable Mask Bit 12</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PCINT11</NAME>
          <DESCRIPTION>Pin Change Enable Mask Bit 11</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PCINT10</NAME>
          <DESCRIPTION>Pin Change Enable Mask Bit 10</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PCINT9</NAME>
          <DESCRIPTION>Pin Change Enable Mask Bit 9</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PCINT8</NAME>
          <DESCRIPTION>Pin Change Enable Mask Bit 8</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT0>
      </PCMSK1>
      <PCMSK0>
        <NAME>PCMSK0</NAME>
        <DESCRIPTION>Pin Change Enable Mask Byte 0</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$12</IO_ADDR>
        <MEM_ADDR>$32</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PCINT7</NAME>
          <DESCRIPTION>Pin Change Enable Mask Bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PCINT6</NAME>
          <DESCRIPTION>Pin Change Enable Mask Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PCINT5</NAME>
          <DESCRIPTION>Pin Change Enable Mask Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PCINT4</NAME>
          <DESCRIPTION>Pin Change Enable Mask Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PCINT3</NAME>
          <DESCRIPTION>Pin Change Enable Mask Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PCINT2</NAME>
          <DESCRIPTION>Pin Change Enable Mask Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PCINT1</NAME>
          <DESCRIPTION>Pin Change Enable Mask Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PCINT0</NAME>
          <DESCRIPTION>Pin Change Enable Mask Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT0>
      </PCMSK0>
    </EXTERNAL_INTERRUPT>
    <PORTB>
      <LIST>[PORTB:DDRB:PINB]</LIST>
      <LINK/>
      <ICON>io_port.bmp</ICON>
      <ID>AVRSimIOPort.SimIOPort</ID>
      <TEXT/>
      <PORTB>
        <NAME>PORTB</NAME>
        <DESCRIPTION>Port B Data Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$18</IO_ADDR>
        <MEM_ADDR>$38</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PORTB7</NAME>
          <DESCRIPTION>Port B Data Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PORTB6</NAME>
          <DESCRIPTION>Port B Data Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PORTB5</NAME>
          <DESCRIPTION>Port B Data Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PORTB4</NAME>
          <DESCRIPTION>Port B Data Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PORTB3</NAME>
          <DESCRIPTION>Port B Data Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PORTB2</NAME>
          <DESCRIPTION>Port B Data Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PORTB1</NAME>
          <DESCRIPTION>Port B Data Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PORTB0</NAME>
          <DESCRIPTION>Port B Data Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PORTB>
      <DDRB>
        <NAME>DDRB</NAME>
        <DESCRIPTION>Port B Data Direction Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$17</IO_ADDR>
        <MEM_ADDR>$37</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>DDB7</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>DDB6</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>DDB5</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>DDB4</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>DDB3</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>DDB2</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>DDB1</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>DDB0</NAME>
          <DESCRIPTION>Port B Data Direction Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </DDRB>
      <PINB>
        <NAME>PINB</NAME>
        <DESCRIPTION>Port B Input Pins</DESCRIPTION>
        <TEXT>The Port B Input Pins address - PINB - is not a register, and this address enables access to the physical value on each Port B pin. When reading PORTB, the Port B Data Latch is read, and when reading PINB, the logical values present on the pins are read.</TEXT>
        <IO_ADDR>$16</IO_ADDR>
        <MEM_ADDR>$36</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PINB7</NAME>
          <DESCRIPTION>Port B Input Pins bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PINB6</NAME>
          <DESCRIPTION>Port B Input Pins bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PINB5</NAME>
          <DESCRIPTION>Port B Input Pins bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PINB4</NAME>
          <DESCRIPTION>Port B Input Pins bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PINB3</NAME>
          <DESCRIPTION>Port B Input Pins bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PINB2</NAME>
          <DESCRIPTION>Port B Input Pins bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PINB1</NAME>
          <DESCRIPTION>Port B Input Pins bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PINB0</NAME>
          <DESCRIPTION>Port B Input Pins bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PINB>
    </PORTB>
    <ANALOG_COMPARATOR>
      <LIST>[ADCSRB:ACSR:DIDR0]</LIST>
      <LINK/>
      <ICON>io_analo.bmp</ICON>
      <ID>AlgComp_01</ID>
      <TEXT/>
      <ADCSRB>
        <NAME>ADCSRB</NAME>
        <DESCRIPTION>ADC Control and Status Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$03</IO_ADDR>
        <MEM_ADDR>$23</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT6>
          <NAME>ACME</NAME>
          <DESCRIPTION>Analog Comparator Multiplexer Enable</DESCRIPTION>
          <TEXT>When this bit is written logic one and the ADC is switched off (ADEN in ADCSR is zero), the ADC multiplexer selects the negative input to the Analog Comparator. When this bit is written logic zero, AIN1 is applied to the negative input of the Analog Comparator. For a detailed description of this bit, see &#x201C;Analog Comparator Multiplexed Input&#x201D; on page 186.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
      </ADCSRB>
      <ACSR>
        <NAME>ACSR</NAME>
        <DESCRIPTION>Analog Comparator Control And Status Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$08</IO_ADDR>
        <MEM_ADDR>$28</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>ACD</NAME>
          <DESCRIPTION>Analog Comparator Disable</DESCRIPTION>
          <TEXT>When this bit is written logic one, the power to the analog comparator is switched off. This bit can be set at any time to turn off the analog comparator. This will reduce power consumption in active and idle mode. When changing the ACD bit, the Analog Comparator Interrupt must be disabled by clearing the ACIE bit in ACSR. Otherwise an interrupt can occur when the bit is changed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ACBG</NAME>
          <ALIAS>AINBG</ALIAS>
          <DESCRIPTION>Analog Comparator Bandgap Select</DESCRIPTION>
          <TEXT>When this bit is set, a fixed bandgap reference voltage replaces the positive input to the Analog Comparator. When this bit is cleared, AIN0 is applied to the positive input of the Analog Comparator. See &#x201C;Internal Voltage Reference&#x201D; on page 42.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ACO</NAME>
          <DESCRIPTION>Analog Compare Output</DESCRIPTION>
          <TEXT>The output of the analog comparator is synchronized and then directly connected to ACO. The synchronization introduces a delay of 1-2 clock cycles.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>NA</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ACI</NAME>
          <DESCRIPTION>Analog Comparator Interrupt Flag</DESCRIPTION>
          <TEXT>This bit is set by hardware when a comparator output event triggers the interrupt mode defined by ACIS1 and ACIS0. The Analog Comparator Interrupt routine is executed if the ACIE bit is set and the I-bit in SREG is set. ACI is cleared by hard-ware when executing the corresponding interrupt handling vector. Alternatively, ACI is cleared by writing a logic one to the flag.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ACIE</NAME>
          <DESCRIPTION>Analog Comparator Interrupt Enable</DESCRIPTION>
          <TEXT>When the ACIE bit is written logic one and the I-bit in the Status Register is set, the analog comparator interrupt is acti-vated. When written logic zero, the interrupt is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT1>
          <NAME>ACIS1</NAME>
          <DESCRIPTION>Analog Comparator Interrupt Mode Select bit 1</DESCRIPTION>
          <TEXT>These bits determine which comparator events that trigger the Analog Comparator interrupt.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ACIS0</NAME>
          <DESCRIPTION>Analog Comparator Interrupt Mode Select bit 0</DESCRIPTION>
          <TEXT>These bits determine which comparator events that trigger the Analog Comparator interrupt.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>ANALOG_COMP_INTERRUPT</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ACSR>
      <DIDR0>
        <NAME>DIDR0</NAME>
        <DESCRIPTION/>
        <TEXT/>
        <IO_ADDR>$01</IO_ADDR>
        <MEM_ADDR>$21</MEM_ADDR>
        <ICON/>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT1>
          <NAME>ADC1D</NAME>
          <DESCRIPTION>ADC 1 Digital input buffer disable</DESCRIPTION>
          <TEXT>When this bit is written logic one,the digital input buffer on the AIN1 pin is disabled.The corresponding PIN register bit will always read as zero when this bit is set.When an analog signal is applied to the AIN1/0 pin and the digital input from this pin is not needed,this bit should be written logic one to reduce power consumption in the digital input buffer.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ADC0D</NAME>
          <DESCRIPTION>ADC 0 Digital input buffer disable</DESCRIPTION>
          <TEXT>When this bit is written logic one,the digital input buffer on the AIN0 pin is disabled.The corresponding PIN register bit will always read as zero when this bit is set.When an analog signal is applied to the AIN1/0 pin and the digital input from this pin is not needed,this bit should be written logic one to reduce power consumption in the digital input buffer.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </DIDR0>
    </ANALOG_COMPARATOR>
    <AD_CONVERTER>
      <LIST>[ADMUX:ADCSRA:ADCH:ADCL:ADCSRB:DIDR0]</LIST>
      <LINK/>
      <ICON>io_analo.bmp</ICON>
      <TEXT/>
      <ADMUX>
        <NAME>ADMUX</NAME>
        <DESCRIPTION>ADC Multiplexer Selection Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$07</IO_ADDR>
        <MEM_ADDR>$27</MEM_ADDR>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT6>
          <NAME>REFS</NAME>
          <DESCRIPTION>Reference Selection Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <ENUM>ANALOG_ADC_V_REF5</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT2>
          <NAME>MUX2</NAME>
          <DESCRIPTION>Analog Channel Selection Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>MUX1</NAME>
          <DESCRIPTION>Analog Channel Selection Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>MUX0</NAME>
          <DESCRIPTION>Analog Channel Selection Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ADMUX>
      <ADCSRA>
        <NAME>ADCSRA</NAME>
        <DESCRIPTION>ADC Control and Status Register A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$06</IO_ADDR>
        <MEM_ADDR>$26</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>ADEN</NAME>
          <DESCRIPTION>ADC Enable</DESCRIPTION>
          <TEXT>Writing a logical &#x2018;1&#x2019; to this bit enables the ADC. By clearing this bit to zero, the ADC is turned off. Turning the ADC off while a conversion is in progress, will terminate this conversion.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ADSC</NAME>
          <DESCRIPTION>ADC Start Conversion</DESCRIPTION>
          <TEXT>In Single Conversion Mode, a logical &#x2018;1&#x2019; must be written to this bit to start each conversion. In Free Running Mode, a logical &#x2018;1&#x2019; must be written to this bit to start the first conversion. The first time ADSC has been written after the ADC has been enabled, or if ADSC is written at the same time as the ADC is enabled, an extended conversion will result. This extended conversion performs initialization of the ADC. ADSC will read as one as long as a conversion is in progress. When the conversion is complete, it returns to zero. When a dummy conversion precedes a real conversion, ADSC will stay high until the real conversion completes. Writing a 0 to this bit has no effec</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ADATE</NAME>
          <DESCRIPTION>ADC Auto Trigger Enable</DESCRIPTION>
          <TEXT>When this bit is written to one,Auto Triggering of the ADC is enabled.The ADC will start a conversion on a positive edge of the selected trigger signal.The trigger source is selected by setting the ADC Trigger Select bits,ADTS in ADCSRB.     </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ADIF</NAME>
          <DESCRIPTION>ADC Interrupt Flag</DESCRIPTION>
          <TEXT>This bit is set (one) when an ADC conversion completes and the data registers are updated. The ADC Conversion Complete Interrupt is executed if the ADIE bit and the I-bit in SREG are set (one). ADIF is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, ADIF is cleared by writing a logical one to the flag. Beware that if doing a read-modify-write on ADCSR, a pending interrupt can be disabled. This also applies if the SBI and CBI instructions are used.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ADIE</NAME>
          <DESCRIPTION>ADC Interrupt Enable</DESCRIPTION>
          <TEXT>When this bit is set (one) and the I-bit in SREG is set (one), the ADC Conversion Complete Interrupt is activated.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ADPS2</NAME>
          <DESCRIPTION>ADC  Prescaler Select Bit 2</DESCRIPTION>
          <TEXT>These bits determine the division factor between the XTAL frequency and the input clock to the ADC.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ADPS1</NAME>
          <DESCRIPTION>ADC  Prescaler Select Bit 1</DESCRIPTION>
          <TEXT>These bits determine the division factor between the XTAL frequency and the input clock to the ADC.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ADPS0</NAME>
          <DESCRIPTION>ADC  Prescaler Select Bit 0</DESCRIPTION>
          <TEXT>These bits determine the division factor between the XTAL frequency and the input clock to the ADC.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>ANALIG_ADC_PRESCALER</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ADCSRA>
      <ADCH>
        <NAME>ADCH</NAME>
        <DESCRIPTION>ADC Data Register High Byte</DESCRIPTION>
        <TEXT>When an ADC conversion is complete, the result is found in these two registers. If differential channels are used, the result is presented in two&#x2019;s complement form. The selected channel is differential if MUX4..0 are between &#x2018;01000&#x2019; and &#x2018;11101&#x2019;, otherwise the selected channel is single ended. When ADCL is read, the ADC Data Register is not updated until ADCH is read. Consequently, if the result is left adjusted and no more than 8 bit precision (7 bit + sign bit for differential input channels) is required, it is sufficient to read ADCH. Otherwise, ADCL must be read first, then ADCH. The ADLAR bit in ADMUX, and the MUX4..0 bits in ADMUX affect the way the result is read from the registers. If ADLAR is set, the result is left adjusted. If ADLAR is cleared (default), the result is right </TEXT>
        <IO_ADDR>$05</IO_ADDR>
        <MEM_ADDR>$25</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>ADCH7</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ADCH6</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ADCH5</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ADCH4</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ADCH3</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ADCH2</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ADCH1</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ADCH0</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ADCH>
      <ADCL>
        <NAME>ADCL</NAME>
        <DESCRIPTION>ADC Data Register Low Byte</DESCRIPTION>
        <TEXT>When an ADC conversion is complete, the result is found in these two registers. If differential channels are used, the result is presented in two&#x2019;s complement form. The selected channel is differential if MUX4..0 are between &#x2018;01000&#x2019; and &#x2018;11101&#x2019;, otherwise the selected channel is single ended. When ADCL is read, the ADC Data Register is not updated until ADCH is read. Consequently, if the result is left adjusted and no more than 8 bit precision (7 bit + sign bit for differential input channels) is required, it is sufficient to read ADCH. Otherwise, ADCL must be read first, then ADCH. The ADLAR bit in ADMUX, and the MUX4..0 bits in ADMUX affect the way the result is read from the registers. If ADLAR is set, the result is left adjusted. If ADLAR is cleared (default), the result is right</TEXT>
        <IO_ADDR>$04</IO_ADDR>
        <MEM_ADDR>$24</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>ADCL7</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ADCL6</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ADCL5</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ADCL4</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ADCL3</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ADCL2</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ADCL1</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ADCL0</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ADCL>
      <ADCSRB>
        <NAME>ADCSRB</NAME>
        <DESCRIPTION>ADC Control and Status Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$03</IO_ADDR>
        <MEM_ADDR>$23</MEM_ADDR>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>BVRON</NAME>
          <DESCRIPTION>Boost Regulator Status Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ACME</NAME>
          <DESCRIPTION>Analog Comparator Multiplexer Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT4>
          <NAME>ADLAR</NAME>
          <DESCRIPTION>ADC Left Adjust Result</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT2>
          <NAME>ADTS2</NAME>
          <DESCRIPTION>ADC Auto Trigger Source bit 2</DESCRIPTION>
          <TEXT>If ADATE in ADCSRA is written to one,the value of these bits selects which source will trigger an ADC conversion.If ADATE is cleared,the ADTS2:0 settings will have no effect.A conversion will be triggered by the rising edge of the selected interrupt flag.Note that switching from a trigger source that is cleared to a trigger source that is set,will generate a positive edge on the trigger signal.If ADEN in ADCSRA is set,this will start a conversion.Switching to Free Running Mode (ADTS [2:0 ]=0)will not cause a trigger event,even if the ADC Interrupt Flag is set .  </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ADTS1</NAME>
          <DESCRIPTION>ADC Auto Trigger Source bit 1</DESCRIPTION>
          <TEXT>If ADATE in ADCSRA is written to one,the value of these bits selects which source will trigger an ADC conversion.If ADATE is cleared,the ADTS2:0 settings will have no effect.A conversion will be triggered by the rising edge of the selected interrupt flag.Note that switching from a trigger source that is cleared to a trigger source that is set,will generate a positive edge on the trigger signal.If ADEN in ADCSRA is set,this will start a conversion.Switching to Free Running Mode (ADTS [2:0 ]=0)will not cause a trigger event,even if the ADC Interrupt Flag is set .   </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ADTS0</NAME>
          <DESCRIPTION>ADC Auto Trigger Source bit 0</DESCRIPTION>
          <TEXT>If ADATE in ADCSRA is written to one,the value of these bits selects which source will trigger an ADC conversion.If ADATE is cleared,the ADTS2:0 settings will have no effect.A conversion will be triggered by the rising edge of the selected interrupt flag.Note that switching from a trigger source that is cleared to a trigger source that is set,will generate a positive edge on the trigger signal.If ADEN in ADCSRA is set,this will start a conversion.Switching to Free Running Mode (ADTS [2:0 ]=0)will not cause a trigger event,even if the ADC Interrupt Flag is set . </TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>ANALOG_ADC_AUTO_TRIGGER_T43U</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ADCSRB>
      <DIDR0>
        <NAME>DIDR0</NAME>
        <DESCRIPTION>Digital Input Disable Register 0</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$01</IO_ADDR>
        <MEM_ADDR>$21</MEM_ADDR>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT5>
          <NAME>AIN1D</NAME>
          <DESCRIPTION>Analog Comparator IO</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>AIN0D</NAME>
          <DESCRIPTION>Analog Comparator IO</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ADC3D</NAME>
          <DESCRIPTION>ADC3 Digital Input Disable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ADC2D</NAME>
          <DESCRIPTION>ADC2 Digital Input Disable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ADC1D</NAME>
          <DESCRIPTION>ADC1 Digital Input Disable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ADC0D</NAME>
          <DESCRIPTION>ADC0 Digital Input Disable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </DIDR0>
    </AD_CONVERTER>
    <EEPROM>
      <LIST>[EEAR:EEDR:EECR]</LIST>
      <LINK/>
      <ICON>io_cpu.bmp</ICON>
      <ID/>
      <TEXT>EEPROM Read/Write Access. The EEPROM access registers are accessible in the I/O space. The write access time for the EEPROM is given in Table 1. A self-timing function, however, lets the user software detect when the next byte can be written. If the user code contains instructions that write the EEPROM, some precautions must be taken. In heavily filtered power supplies, V CC is likely to rise or fall slowly on power-up/down. This causes the device for some period of time to run at a voltage lower than specified as minimum for the clock frequency used. See &#x201C;Preventing EEPROM Corruption&#x201D; on page 19. for details on how to avoid problems in these situations.In order to prevent unintentional EEPROM writes, a specific write procedure must be followed. Refer to the description of the EEPROM Control Register for details on this. When the EEPROM is read, the CPU is halted for four clock cycles before the next instruction is executed. When theEEPROM is written, the CPU is halted for two clock cycles before the next instruction is execut</TEXT>
      <EEAR>
        <NAME>EEAR</NAME>
        <ALIAS>EEAR</ALIAS>
        <DESCRIPTION>EEPROM Address Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$1E</IO_ADDR>
        <MEM_ADDR>$3E</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT5>
          <NAME>EEAR5</NAME>
          <DESCRIPTION>EEPROM Read/Write Access Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>EEAR4</NAME>
          <DESCRIPTION>EEPROM Read/Write Access Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>EEAR3</NAME>
          <DESCRIPTION>EEPROM Read/Write Access Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>EEAR2</NAME>
          <DESCRIPTION>EEPROM Read/Write Access Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>EEAR1</NAME>
          <DESCRIPTION>EEPROM Read/Write Access Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>EEAR0</NAME>
          <DESCRIPTION>EEPROM Read/Write Access Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </EEAR>
      <EEDR>
        <NAME>EEDR</NAME>
        <DESCRIPTION>EEPROM Data Register</DESCRIPTION>
        <TEXT>For the EEPROM write operation, the EEDR register contains the data to be written to the EEPROM in the address given by the EEAR register. For the EEPROM read operation, the EEDR contains the data read out from the EEPROM at the address given by EEAR.</TEXT>
        <IO_ADDR>$1D</IO_ADDR>
        <MEM_ADDR>$3D</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>EEDR7</NAME>
          <DESCRIPTION>EEPROM Data Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>EEDR6</NAME>
          <DESCRIPTION>EEPROM Data Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>EEDR5</NAME>
          <DESCRIPTION>EEPROM Data Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>EEDR4</NAME>
          <DESCRIPTION>EEPROM Data Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>EEDR3</NAME>
          <DESCRIPTION>EEPROM Data Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>EEDR2</NAME>
          <DESCRIPTION>EEPROM Data Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>EEDR1</NAME>
          <DESCRIPTION>EEPROM Data Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>EEDR0</NAME>
          <DESCRIPTION>EEPROM Data Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </EEDR>
      <EECR>
        <NAME>EECR</NAME>
        <DESCRIPTION>EEPROM Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$1C</IO_ADDR>
        <MEM_ADDR>$3C</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT5>
          <NAME>EEPM1</NAME>
          <DESCRIPTION>EEPROM Programming Mode Bit 1</DESCRIPTION>
          <TEXT>The EEPROM Programming mode bit setting defines which programming action that will be triggered when writing EEPE. It is possible to program data in one atomic operation (erase the old value and program the new value) or to split the Erase and Write operations in two different operations. The Programming times for the different modes are shown in Table 2. While EEPE is set, any write to EEPMn will be ignored. During reset, the EEPMn bits will be reset to 0b00 unless the EEPROM is busy programming.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>EEPM0</NAME>
          <DESCRIPTION>EEPROM Programming Mode Bit 0</DESCRIPTION>
          <TEXT>The EEPROM Programming mode bit setting defines which programming action that will be triggered when writing EEPE. It is possible to program data in one atomic operation (erase the old value and program the new value) or to split the Erase and Write operations in two different operations. The Programming times for the different modes are shown in Table 2. While EEPE is set, any write to EEPMn will be ignored. During reset, the EEPMn bits will be reset to 0b00 unless the EEPROM is busy programming.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>EEP_MODE</ENUM>
          <INIT_VAL>X</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>EERIE</NAME>
          <DESCRIPTION>EEPROM Ready Interrupt Enable</DESCRIPTION>
          <TEXT>EEPROM Ready Interrupt Enable Writing EERIE to one enables the EEPROM Ready Interrupt if the I bit in SREG is set. Writing EERIE to zero disables the interrupt. The EEPROM Ready interrupt generates a constant interrupt when EEWE is cleared.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>EEMPE</NAME>
          <DESCRIPTION>EEPROM Master Write Enable</DESCRIPTION>
          <TEXT>The EEMWE bit determines whether setting EEWE to one causes the EEPROM to be written. When EEMWE is written to one, writing EEWE to one within 4 clock cycles will write data to the EEPROM at the selected address. If EEMWE is zero, writing EEWE to one will have no effect. When EEMWE has been written to one by software, hardware clears the bit to zero after four clock cycles. See the description of the EEWE bit for an EEPROM write procedure.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>EEPE</NAME>
          <DESCRIPTION>EEPROM Write Enable</DESCRIPTION>
          <TEXT>The EEPROM Write Enable Signal EEWE is the write strobe to the EEPROM. When address and data are correctly set up, the EEWE bit must be set to write the value into the EEPROM. The EEMWE bit must be set when the logical one is written to EEWE, otherwise no EEPROM write takes place. The following procedure should be followed when writing the EEPROM (the order of steps 3 and 4 is not essential): 1. Wait until EEWE becomes zero. 2. Wait until SPMEN in SPMCR becomes zero. 3. Write new EEPROM address to EEAR (optional). 4. Write new EEPROM data to EEDR (optional). 5. Write a logical one to the EEMWE bit while writing a zero to EEWE in EECR. 6. Within four clock cycles after setting EEMWE, write a logical one to EEWE. The EEPROM can not be programmed during a CPU write to the Flash memory. The software must check that the Flash programming is completed before initiating a new EEPROM write. Step 2 is only relevant if the software contains a boot loader allowing the CPU to program the Flash. If the Flash is never being updated by the CPU, step 2 can be omitted. See &#x201C;Boot Loader Support - Read While Write self-programming&#x201D; on page 228 for details about boot programming. Caution: An interrupt between step 5 and step 6 will make the write cycle fail, since the EEPROM Master Write Enable will time-out. If an interrupt routine accessing the EEPROM is interrupting another EEPROM access, the EEAR or EEDR regis-ter will be modified, causing the interrupted EEPROM access to fail. It is recommended to have the global interrupt flag cleared during the 4 last steps to avoid these problems. When the write access time has elapsed, the EEWE bit is cleared by hardware. The user software can poll this bit and wait for a zero before writing the next byte. When EEWE has been set, the CPU is halted for two cycles before the next instruc-tion is executed</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>EERE</NAME>
          <DESCRIPTION>EEPROM Read Enable</DESCRIPTION>
          <TEXT>The EEPROM Read Enable Signal EERE is the read strobe to the EEPROM. When the correct address is set up in the EEAR register, the EERE bit must be written to a logic one to trigger the EEPROM read. The EEPROM read access takes one instruction, and the requested data is available immediately. When the EEPROM is read, the CPU is halted for four cycles before the next instruction is executed. The user should poll the EEWE bit before starting the read operation. If a write operation is in progress, it is neither possible to read the EEPROM, nor to change the EEAR register. The calibrated oscillator is used to time the EEPROM accesses. Table 1 lists the typical programming time for EEPROM access from the CPU</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </EECR>
    </EEPROM>
  </IO_MODULE>
  <ICE_SETTINGS>
    <MODULE_LIST>[AVRISPmkII:AVRDragon:SIMULATOR:JTAGICEmkII:STK600:STK500_2:SIMULATOR2:AVRONE]</MODULE_LIST>
    <AVRISPmkII/>
    <AVRDragon/>
    <SIMULATOR>
      <CoreID>AVRSimCoreV2.SimCoreV2</CoreID>
      <MemoryID>AVRSimMemory8bit.SimMemory8bit</MemoryID>
      <InterruptID>AVRSimInterrupt.SimInterrupt</InterruptID>
      <EEINTERRUPT>0x0e</EEINTERRUPT>
      <EEAR_EXTRA_BIT>0</EEAR_EXTRA_BIT>
      <NmbIOModules>12</NmbIOModules>
      <PORTA>
        <ID>AVRSimIOPort.SimIOPort</ID>
        <TOGGLE_PIN>Y</TOGGLE_PIN>
      </PORTA>
      <PORTB>
        <ID>AVRSimIOPort.SimIOPort</ID>
        <TOGGLE_PIN>Y</TOGGLE_PIN>
      </PORTB>
      <EXTINT0>
        <ID>AVRSimIOExtInterrupt.SimIOExtInterrupt</ID>
        <IntVector>0x01</IntVector>
        <EnableIOAdr>0x3b</EnableIOAdr>
        <EnableMask>0x40</EnableMask>
        <FlagIOAdr>0x3a</FlagIOAdr>
        <FlagMask>0x40</FlagMask>
        <ExtPinIOAdr>0x16</ExtPinIOAdr>
        <ExtPinMask>0x80</ExtPinMask>
        <SenseIOAdr>0x35</SenseIOAdr>
        <SenseMask>0x03</SenseMask>
      </EXTINT0>
      <PININT0>
        <ID>AVRSimIOPinChangeInterrupt.SimIOPinChangeInterrupt</ID>
        <IntVector>0x02</IntVector>
        <EnableIOAdr>0x3B</EnableIOAdr>
        <EnableMask>0x10</EnableMask>
        <FlagIOAdr>0x3A</FlagIOAdr>
        <FlagMask>0x10</FlagMask>
        <PCMaskIOAdr>0x12</PCMaskIOAdr>
        <ExtPinIOAdr>0x19</ExtPinIOAdr>
        <ExtPinMask>0xFF</ExtPinMask>
      </PININT0>
      <PININT1>
        <ID>AVRSimIOPinChangeInterrupt.SimIOPinChangeInterrupt</ID>
        <IntVector>0x03</IntVector>
        <EnableIOAdr>0x3B</EnableIOAdr>
        <EnableMask>0x20</EnableMask>
        <FlagIOAdr>0x3A</FlagIOAdr>
        <FlagMask>0x20</FlagMask>
        <PCMaskIOAdr>0x20</PCMaskIOAdr>
        <ExtPinIOAdr>0x16</ExtPinIOAdr>
        <ExtPinMask>0xff</ExtPinMask>
      </PININT1>
      <ANALOGCOMPARATOR>
        <ID>AVRSimAC.SimIOAC</ID>
        <IntVector>0x0B</IntVector>
      </ANALOGCOMPARATOR>
      <ADC>
        <ID>AVRSimADC.SimADC</ID>
        <IntVector>0x0C</IntVector>
      </ADC>
      <TIMER0>
        <ID>AvrSimIOTim8pwmsync2.tim8pwmsync2</ID>
        <OvfVector>0x0a</OvfVector>
        <CompAVector>0x08</CompAVector>
        <CompBVector>0x09</CompBVector>
        <OCnAport>PORTB</OCnAport>
        <OCnAbit>1</OCnAbit>
        <OCnBport>PORTB</OCnBport>
        <OCnBbit>2</OCnBbit>
        <TxPort>PORTB</TxPort>
        <TxBit>0</TxBit>
      </TIMER0>
      <TIMER1>
        <ID>AvrSimIOTim8pwmsync2.tim8pwmsync2</ID>
        <OvfVector>0x07</OvfVector>
        <CompAVector>0x05</CompAVector>
        <CompBVector>0x06</CompBVector>
        <OCnAport>PORTB</OCnAport>
        <OCnAbit>4</OCnAbit>
        <OCnBport>PORTB</OCnBport>
        <OCnBbit>5</OCnBbit>
        <TxPort>PORTB</TxPort>
        <TxBit>3</TxBit>
      </TIMER1>
      <USI>
        <ID>AvrSimUSI.SimUSI</ID>
        <OvfVector>0x0F</OvfVector>
        <StartVector>0x0E</StartVector>
      </USI>
      <WATCHDOG>
        <ID>AvrMasterTimer.MasterTimer</ID>
        <Frequency>128</Frequency>
        <Version>1</Version>
        <IntVector>0x004</IntVector>
        <PrescaleArray>2048:4096:8192:16384:32768:65536:131072:262144:524288:1048576</PrescaleArray>
      </WATCHDOG>
      <DEFAULT_SETTINGS>
        <HighFuse>0xdf</HighFuse>
        <ExtendedFuse>0xff</ExtendedFuse>
        <LowFuse>0x62</LowFuse>
        <Lockbit>0xff</Lockbit>
      </DEFAULT_SETTINGS>
    </SIMULATOR>
    <JTAGICEmkII>
      <ID>0x920C</ID>
      <Interface>DebugWire</Interface>
<!--Bit 0 in byte 0 is I/O location, bit 7 in byte 7 is I/O location 63-->
      <ucRead>0xFB,0xF9,0xFD,0x7F,0x4B,0xF8,0xFF,0xFF</ucRead>
      <ucWrite>0x8B,0xB0,0xBD,0x7D,0x09,0xF8,0x7D,0xFA</ucWrite>
      <ucReadShadow>0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00</ucReadShadow>
      <ucWriteShadow>0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00</ucWriteShadow>
<!--Bit 0 in byte 0 is extended I/O location, bit 7 in byte 7 is I/O location 63-->
      <ucExtRead>0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00</ucExtRead>
      <ucExtWrite>0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00</ucExtWrite>
      <ucExtReadShadow>0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00</ucExtReadShadow>
      <ucExtWriteShadow>0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00</ucExtWriteShadow>
<!--Register locations etc.-->
      <ucIDRAddress>0x00</ucIDRAddress>
      <ucSPMCAddress>0x57</ucSPMCAddress>
<!--no longer needed build 356 ucRAMPZAddress>0x00</ucRAMPZAddress -->
      <ulFlashPageSize>0x0040</ulFlashPageSize>
      <ulEepromPageSize>0x0004</ulEepromPageSize>
      <ulBootAddress>0</ulBootAddress>
<!-- No longer needed build 356
       <BootAddress11>0</BootAddress11>
       <BootAddress10>0</BootAddress10>
       <BootAddress01>0</BootAddress01>
       <BootAddress00>0</BootAddress00>
       -->
      <ucUpperExtIOLoc>0x0000</ucUpperExtIOLoc>
<!--no longer needed build 356 ulFlashSize>0x1000</ulFlashSize -->
      <ulRegStart>0x0000,32</ulRegStart>
      <ulIoStart>0x0020,64</ulIoStart>
<!--Other stuff-->
      <DWENmaskExt>0x00</DWENmaskExt>
      <DWENmaskHigh>0x40</DWENmaskHigh>
      <DWENmaskLow>0x00</DWENmaskLow>
<!--no longer needed build 356
       <SPIENmaskExt>0x00</SPIENmaskExt>
       <SPIENmaskHigh>0x20</SPIENmaskHigh>
       <SPIENmaskLow>0x00</SPIENmaskLow>
       -->
      <ucEepromInst>0xBB,0xFF,0xBB,0xEE,0xBB,0xCC,0xB2,0x0D,0xBC,0x07,0xB4,0x07,0xBA,0x0D,0xBB,0xBC,0x99,0xE1,0xBB,0xAC</ucEepromInst>
      <ucFlashInst>0xB4,0x07,0x17</ucFlashInst>
<!--no longer needed build 356
       <ucSPHaddr>0x3E</ucSPHaddr>
       <ucSPLaddr>0x3D</ucSPLaddr>
       -->
      <DWdatareg>0x27</DWdatareg>
      <DWbasePC>0x00</DWbasePC>
      <PCMaskExtended>0</PCMaskExtended>
      <PCMaskHigh>0</PCMaskHigh>
      <Osccalshared>0x00</Osccalshared>
      <ucAllowFullPageBitstream>0x00</ucAllowFullPageBitstream>
      <uiStartSmallestBootLoaderSection>0x00</uiStartSmallestBootLoaderSection>
      <ucUseJTAGID>0x00</ucUseJTAGID>
      <EECRAddress>0x3C</EECRAddress>
      <EnablePageProgramming>1</EnablePageProgramming>
      <CacheType>0</CacheType>
      <ResetType>0</ResetType>
      <bUseProgIfc>1</bUseProgIfc>
    </JTAGICEmkII>
    <STK600>
      <IspEnterProgMode>
        <timeout>200</timeout>
        <stabDelay>100</stabDelay>
        <cmdexeDelay>25</cmdexeDelay>
        <synchLoops>32</synchLoops>
        <byteDelay>0</byteDelay>
        <pollIndex>3</pollIndex>
        <pollValue>0x53</pollValue>
      </IspEnterProgMode>
      <IspLeaveProgMode>
        <preDelay>1</preDelay>
        <postDelay>1</postDelay>
      </IspLeaveProgMode>
      <IspChipErase>
        <eraseDelay>10</eraseDelay>
        <pollMethod>0</pollMethod>
      </IspChipErase>
      <IspProgramFlash>
        <mode>0x41</mode>
        <blockSize>64</blockSize>
        <delay>10</delay>
        <cmd1>0x40</cmd1>
        <cmd2>0x4C</cmd2>
        <cmd3>0x00</cmd3>
        <pollVal1>0x00</pollVal1>
        <pollVal2>0x00</pollVal2>
      </IspProgramFlash>
      <IspProgramEeprom>
        <mode>0x41</mode>
        <blockSize>4</blockSize>
        <delay>10</delay>
        <cmd1>0xC1</cmd1>
        <cmd2>0xC2</cmd2>
        <cmd3>0x00</cmd3>
        <pollVal1>0x00</pollVal1>
        <pollVal2>0x00</pollVal2>
      </IspProgramEeprom>
      <IspReadFlash>
        <blockSize>256</blockSize>
      </IspReadFlash>
      <IspReadEeprom>
        <blockSize>256</blockSize>
      </IspReadEeprom>
      <IspReadFuse>
        <pollIndex>4</pollIndex>
      </IspReadFuse>
      <IspReadLock>
        <pollIndex>4</pollIndex>
      </IspReadLock>
      <IspReadSign>
        <pollIndex>4</pollIndex>
      </IspReadSign>
      <IspReadOsccal>
        <pollIndex>4</pollIndex>
      </IspReadOsccal>
      <PPControlStack>0x0E 0x1E 0x0E 0x1E 0x2E 0x3E 0x2E 0x3E 0x4E 0x5E 0x4E 0x5E 0x6E 0x7E 0x6E 0x7E 0x06 0x16 0x46 0x56 0x0A 0x1A 0x4A 0x5A 0x1E 0x7C 0x00 0x01 0x00 0x00 0x00 0x00</PPControlStack>
      <PpEnterProgMode>
        <stabDelay>100</stabDelay>
        <progModeDelay>0</progModeDelay>
        <latchCycles>5</latchCycles>
        <toggleVtg>1</toggleVtg>
        <powerOffDelay>20</powerOffDelay>
        <resetDelayMs>1</resetDelayMs>
        <resetDelayUs>0</resetDelayUs>
      </PpEnterProgMode>
      <PpLeaveProgMode>
        <stabDelay>15</stabDelay>
        <resetDelay>15</resetDelay>
      </PpLeaveProgMode>
      <PpChipErase>
        <pulseWidth>0</pulseWidth>
        <pollTimeout>10</pollTimeout>
      </PpChipErase>
      <PpProgramFlash>
        <pollTimeout>5</pollTimeout>
        <mode>0x0B</mode>
        <blockSize>256</blockSize>
      </PpProgramFlash>
      <PpReadFlash>
        <blockSize>256</blockSize>
      </PpReadFlash>
      <PpProgramEeprom>
        <pollTimeout>5</pollTimeout>
        <mode>0x05</mode>
        <blockSize>256</blockSize>
      </PpProgramEeprom>
      <PpReadEeprom>
        <blockSize>256</blockSize>
      </PpReadEeprom>
      <PpProgramFuse>
        <pulseWidth>0</pulseWidth>
        <pollTimeout>5</pollTimeout>
      </PpProgramFuse>
      <PpProgramLock>
        <pulseWidth>0</pulseWidth>
        <pollTimeout>5</pollTimeout>
      </PpProgramLock>
    </STK600>
    <STK500_2>
      <IspEnterProgMode>
        <timeout>200</timeout>
        <stabDelay>100</stabDelay>
        <cmdexeDelay>25</cmdexeDelay>
        <synchLoops>32</synchLoops>
        <byteDelay>0</byteDelay>
        <pollIndex>3</pollIndex>
        <pollValue>0x53</pollValue>
      </IspEnterProgMode>
      <IspLeaveProgMode>
        <preDelay>1</preDelay>
        <postDelay>1</postDelay>
      </IspLeaveProgMode>
      <IspChipErase>
        <eraseDelay>10</eraseDelay>
        <pollMethod>0</pollMethod>
      </IspChipErase>
      <IspProgramFlash>
        <mode>0x41</mode>
        <blockSize>64</blockSize>
        <delay>10</delay>
        <cmd1>0x40</cmd1>
        <cmd2>0x4C</cmd2>
        <cmd3>0x00</cmd3>
        <pollVal1>0x00</pollVal1>
        <pollVal2>0x00</pollVal2>
      </IspProgramFlash>
      <IspProgramEeprom>
        <mode>0x41</mode>
        <blockSize>4</blockSize>
        <delay>10</delay>
        <cmd1>0xC1</cmd1>
        <cmd2>0xC2</cmd2>
        <cmd3>0x00</cmd3>
        <pollVal1>0x00</pollVal1>
        <pollVal2>0x00</pollVal2>
      </IspProgramEeprom>
      <IspReadFlash>
        <blockSize>256</blockSize>
      </IspReadFlash>
      <IspReadEeprom>
        <blockSize>256</blockSize>
      </IspReadEeprom>
      <IspReadFuse>
        <pollIndex>4</pollIndex>
      </IspReadFuse>
      <IspReadLock>
        <pollIndex>4</pollIndex>
      </IspReadLock>
      <IspReadSign>
        <pollIndex>4</pollIndex>
      </IspReadSign>
      <IspReadOsccal>
        <pollIndex>4</pollIndex>
      </IspReadOsccal>
      <PPControlStack>0x0E 0x1E 0x0E 0x1E 0x2E 0x3E 0x2E 0x3E 0x4E 0x5E 0x4E 0x5E 0x6E 0x7E 0x6E 0x7E 0x06 0x16 0x46 0x56 0x0A 0x1A 0x4A 0x5A 0x1E 0x7C 0x00 0x01 0x00 0x00 0x00 0x00</PPControlStack>
      <PpEnterProgMode>
        <stabDelay>100</stabDelay>
        <progModeDelay>0</progModeDelay>
        <latchCycles>5</latchCycles>
        <toggleVtg>1</toggleVtg>
        <powerOffDelay>20</powerOffDelay>
        <resetDelayMs>1</resetDelayMs>
        <resetDelayUs>0</resetDelayUs>
      </PpEnterProgMode>
      <PpLeaveProgMode>
        <stabDelay>15</stabDelay>
        <resetDelay>15</resetDelay>
      </PpLeaveProgMode>
      <PpChipErase>
        <pulseWidth>0</pulseWidth>
        <pollTimeout>10</pollTimeout>
      </PpChipErase>
      <PpProgramFlash>
        <pollTimeout>5</pollTimeout>
        <mode>0x0B</mode>
        <blockSize>256</blockSize>
      </PpProgramFlash>
      <PpReadFlash>
        <blockSize>256</blockSize>
      </PpReadFlash>
      <PpProgramEeprom>
        <pollTimeout>5</pollTimeout>
        <mode>0x05</mode>
        <blockSize>256</blockSize>
      </PpProgramEeprom>
      <PpReadEeprom>
        <blockSize>256</blockSize>
      </PpReadEeprom>
      <PpProgramFuse>
        <pulseWidth>0</pulseWidth>
        <pollTimeout>5</pollTimeout>
      </PpProgramFuse>
      <PpProgramLock>
        <pulseWidth>0</pulseWidth>
        <pollTimeout>5</pollTimeout>
      </PpProgramLock>
    </STK500_2>
    <SIMULATOR2/>
    <AVRONE>
      <ID>0x920C</ID>
      <Interface>DebugWire</Interface>
    </AVRONE>
  </ICE_SETTINGS>
  <V2>
    <templates>
      <module class="FUSE">
        <registers name="FUSE" memspace="FUSE">
          <reg size="1" name="EXTENDED" offset="0x02">
            <bitfield name="SELFPRGEN" mask="0x01" text="Self Programming enable" icon=""/>
          </reg>
          <reg size="1" name="HIGH" offset="0x01">
            <bitfield name="RSTDISBL" mask="0x80" text="Reset Disabled (Enable PB7 as i/o pin)" icon=""/>
            <bitfield name="DWEN" mask="0x40" text="Debug Wire enable" icon=""/>
            <bitfield name="SPIEN" mask="0x20" text="Serial program downloading (SPI) enabled" icon=""/>
            <bitfield name="WDTON" mask="0x10" text="Watch-dog Timer always on" icon=""/>
            <bitfield name="EESAVE" mask="0x08" text="Preserve EEPROM through the Chip Erase cycle" icon=""/>
            <bitfield name="BODLEVEL" mask="0x07" text="Brown-out Detector trigger level" icon="" enum="ENUM_BODLEVEL"/>
          </reg>
          <reg size="1" name="LOW" offset="0x00">
            <bitfield name="CKDIV8" mask="0x80" text="Divide clock by 8 internally" icon=""/>
            <bitfield name="CKOUT" mask="0x40" text="Clock output on PORTB5" icon=""/>
            <bitfield name="SUT_CKSEL" mask="0x3F" text="Select Clock source" icon="" enum="ENUM_SUT_CKSEL"/>
          </reg>
        </registers>
        <enumerator name="ENUM_SUT_CKSEL">
          <enum val="0x00" text="Ext. Clock; Start-up time PWRDWN/RESET: 6 CK/14 CK + 0 ms" constname="EXTCLK_6CK_14CK_0MS"/>
          <enum val="0x10" text="Ext. Clock; Start-up time PWRDWN/RESET: 6 CK/14 CK + 4 ms" constname="EXTCLK_6CK_14CK_4MS"/>
          <enum val="0x20" text="Ext. Clock; Start-up time PWRDWN/RESET: 6 CK/14 CK + 64 ms" constname="EXTCLK_6CK_14CK_64MS"/>
          <enum val="0x01" text="PLL Clock; Start-up time PWRDWN/RESET: 1K CK/14 CK + 8 ms" constname="PLLCLK_1KCK_14CK_8MS"/>
          <enum val="0x11" text="PLL Clock; Start-up time PWRDWN/RESET: 16K CK/14 CK + 8 ms" constname="PLLCLK_16KCK_14CK_8MS"/>
          <enum val="0x21" text="PLL Clock; Start-up time PWRDWN/RESET: 1K CK/14 CK + 68 ms" constname="PLLCLK_1KCK_14CK_68MS"/>
          <enum val="0x31" text="PLL Clock; Start-up time PWRDWN/RESET: 16K CK/14 CK + 68 ms" constname="PLLCLK_16KCK_14CK_68MS"/>
          <enum val="0x02" text="Int. RC Osc. 8 MHz; Start-up time PWRDWN/RESET: 6 CK/14 CK + 0 ms" constname="INTRCOSC_8MHZ_6CK_14CK_0MS"/>
          <enum val="0x12" text="Int. RC Osc. 8 MHz; Start-up time PWRDWN/RESET: 6 CK/14 CK + 4 ms" constname="INTRCOSC_8MHZ_6CK_14CK_4MS"/>
          <enum val="0x22" text="Int. RC Osc. 8 MHz; Start-up time PWRDWN/RESET: 6 CK/14 CK + 64 ms" constname="INTRCOSC_8MHZ_6CK_14CK_64MS"/>
          <enum val="0x03" text="WD. Osc. 128 kHz; Start-up time PWRDWN/RESET: 6 CK/14 CK + 0 ms" constname="WDOSC_128KHZ_6CK_14CK_0MS"/>
          <enum val="0x13" text="WD. Osc. 128 kHz; Start-up time PWRDWN/RESET: 6 CK/14 CK + 4 ms" constname="WDOSC_128KHZ_6CK_14CK_4MS"/>
          <enum val="0x23" text="WD. Osc. 128 kHz; Start-up time PWRDWN/RESET: 6 CK/14 CK + 64 ms" constname="WDOSC_128KHZ_6CK_14CK_64MS"/>
          <enum val="0x04" text="Ext. Low-Freq. Crystal; Start-up time PWRDWN/RESET: 1 CK 4 ms" constname="EXTLOFXTAL_1CK_4MS"/>
          <enum val="0x14" text="Ext. Low-Freq. Crystal; Start-up time PWRDWN/RESET: 1 CK + 64 ms" constname="EXTLOFXTAL_1CK_64MS"/>
          <enum val="0x24" text="Ext. Low-Freq. Crystal; Start-up time PWRDWN/RESET: 32 CK + 64 ms" constname="EXTLOFXTAL_32CK_64MS"/>
          <enum val="0x08" text="Ext. Ceramic Res. 0.4-0.9 MHz; Start-up time PWRDWN/RESET: 258 CK/14 CK + 4.1 ms" constname="EXTCRES_0MHZ4_0MHZ9_258CK_14CK_4MS1"/>
          <enum val="0x18" text="Ext. Ceramic Res. 0.4-0.9 MHz; Start-up time PWRDWN/RESET: 258 CK/14 CK + 65 ms" constname="EXTCRES_0MHZ4_0MHZ9_258CK_14CK_65MS"/>
          <enum val="0x28" text="Ext. Ceramic Res. 0.4-0.9 MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 0 ms" constname="EXTCRES_0MHZ4_0MHZ9_1KCK_14CK_0MS"/>
          <enum val="0x38" text="Ext. Ceramic Res. 0.4-0.9 MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 4.1 ms" constname="EXTCRES_0MHZ4_0MHZ9_1KCK_14CK_4MS1"/>
          <enum val="0x09" text="Ext. Ceramic Res. 0.4-0.9 MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 65 ms" constname="EXTCRES_0MHZ4_0MHZ9_1KCK_14CK_65MS"/>
          <enum val="0x19" text="Ext. Crystal Osc. 0.4-0.9 MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 0 ms" constname="EXTXOSC_0MHZ4_0MHZ9_16KCK_14CK_0MS"/>
          <enum val="0x29" text="Ext. Crystal Osc. 0.4-0.9 MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 4.1 ms" constname="EXTXOSC_0MHZ4_0MHZ9_16KCK_14CK_4MS1"/>
          <enum val="0x39" text="Ext. Crystal Osc. 0.4-0.9 MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 65 ms" constname="EXTXOSC_0MHZ4_0MHZ9_16KCK_14CK_65MS"/>
          <enum val="0x0A" text="Ext. Ceramic Res. 0.9-3.0 MHz; Start-up time PWRDWN/RESET: 258 CK/14 CK + 4.1 ms" constname="EXTCRES_0MHZ9_3MHZ_258CK_14CK_4MS1"/>
          <enum val="0x1A" text="Ext. Ceramic Res. 0.9-3.0 MHz; Start-up time PWRDWN/RESET: 258 CK/14 CK + 65 ms" constname="EXTCRES_0MHZ9_3MHZ_258CK_14CK_65MS"/>
          <enum val="0x2A" text="Ext. Ceramic Res. 0.9-3.0 MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 0 ms" constname="EXTCRES_0MHZ9_3MHZ_1KCK_14CK_0MS"/>
          <enum val="0x3A" text="Ext. Ceramic Res. 0.9-3.0 MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 4.1 ms" constname="EXTCRES_0MHZ9_3MHZ_1KCK_14CK_4MS1"/>
          <enum val="0x0B" text="Ext. Ceramic Res. 0.9-3.0 MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 65 ms" constname="EXTCRES_0MHZ9_3MHZ_1KCK_14CK_65MS"/>
          <enum val="0x1B" text="Ext. Crystal Osc. 0.9-3.0 MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 0 ms" constname="EXTXOSC_0MHZ9_3MHZ_16KCK_14CK_0MS"/>
          <enum val="0x2B" text="Ext. Crystal Osc. 0.9-3.0 MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 4.1 ms" constname="EXTXOSC_0MHZ9_3MHZ_16KCK_14CK_4MS1"/>
          <enum val="0x3B" text="Ext. Crystal Osc. 0.9-3.0 MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 65 ms" constname="EXTXOSC_0MHZ9_3MHZ_16KCK_14CK_65MS"/>
          <enum val="0x0C" text="Ext. Ceramic Res. 3.0-8.0 MHz; Start-up time PWRDWN/RESET: 258 CK/14 CK + 4.1 ms" constname="EXTCRES_3MHZ_8MHZ_258CK_14CK_4MS1"/>
          <enum val="0x1C" text="Ext. Ceramic Res. 3.0-8.0 MHz; Start-up time PWRDWN/RESET: 258 CK/14 CK + 65 ms" constname="EXTCRES_3MHZ_8MHZ_258CK_14CK_65MS"/>
          <enum val="0x2C" text="Ext. Ceramic Res. 3.0-8.0 MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 0 ms" constname="EXTCRES_3MHZ_8MHZ_1KCK_14CK_0MS"/>
          <enum val="0x3C" text="Ext. Ceramic Res. 3.0-8.0 MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 4.1 ms" constname="EXTCRES_3MHZ_8MHZ_1KCK_14CK_4MS1"/>
          <enum val="0x0D" text="Ext. Ceramic Res. 3.0-8.0 MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 65 ms" constname="EXTCRES_3MHZ_8MHZ_1KCK_14CK_65MS"/>
          <enum val="0x1D" text="Ext. Crystal Osc. 3.0-8.0 MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 0 ms" constname="EXTXOSC_3MHZ_8MHZ_16KCK_14CK_0MS"/>
          <enum val="0x2D" text="Ext. Crystal Osc. 3.0-8.0 MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 4.1 ms" constname="EXTXOSC_3MHZ_8MHZ_16KCK_14CK_4MS1"/>
          <enum val="0x3D" text="Ext. Crystal Osc. 3.0-8.0 MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 65 ms" constname="EXTXOSC_3MHZ_8MHZ_16KCK_14CK_65MS"/>
          <enum val="0x0E" text="Ext. Ceramic Res. 8.0-    MHz; Start-up time PWRDWN/RESET: 258 CK/14 CK + 4.1 ms" constname="EXTCRES_8MHZ_XX_258CK_14CK_4MS1"/>
          <enum val="0x1E" text="Ext. Ceramic Res. 8.0-    MHz; Start-up time PWRDWN/RESET: 258 CK/14 CK + 65 ms" constname="EXTCRES_8MHZ_XX_258CK_14CK_65MS"/>
          <enum val="0x2E" text="Ext. Ceramic Res. 8.0-    MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 0 ms" constname="EXTCRES_8MHZ_XX_1KCK_14CK_0MS"/>
          <enum val="0x3E" text="Ext. Ceramic Res. 8.0-    MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 4.1 ms" constname="EXTCRES_8MHZ_XX_1KCK_14CK_4MS1"/>
          <enum val="0x0F" text="Ext. Ceramic Res. 8.0-    MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 65 ms" constname="EXTCRES_8MHZ_XX_1KCK_14CK_65MS"/>
          <enum val="0x1F" text="Ext. Crystal Osc. 8.0-    MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 0 ms" constname="EXTXOSC_8MHZ_XX_16KCK_14CK_0MS"/>
          <enum val="0x2F" text="Ext. Crystal Osc. 8.0-    MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 4.1 ms" constname="EXTXOSC_8MHZ_XX_16KCK_14CK_4MS1"/>
          <enum val="0x3F" text="Ext. Crystal Osc. 8.0-    MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 65 ms" constname="EXTXOSC_8MHZ_XX_16KCK_14CK_65MS"/>
        </enumerator>
        <enumerator name="ENUM_BODLEVEL">
          <enum val="0x04" text="Brown-out detection at VCC=4.3 V" constname="4V3"/>
          <enum val="0x05" text="Brown-out detection at VCC=2.7 V" constname="2V7"/>
          <enum val="0x06" text="Brown-out detection at VCC=1.8 V" constname="1V8"/>
          <enum val="0x03" text="Brown-out detection at VCC=2.3 V" constname="2V3"/>
          <enum val="0x02" text="Brown-out detection at VCC=2.2 V" constname="2V2"/>
          <enum val="0x01" text="Brown-out detection at VCC=1.9 V" constname="1V9"/>
          <enum val="0x00" text="Brown-out detection at VCC=2.0 V" constname="2V0"/>
          <enum val="0x07" text="Brown-out detection disabled" constname="DISABLED"/>
        </enumerator>
      </module>
      <module class="LOCKBIT">
        <registers name="LOCKBIT" memspace="LOCKBIT">
          <reg size="1" name="LOCKBIT" offset="0x00">
            <bitfield name="LB" mask="0x03" text="Memory Lock" icon="" enum="ENUM_LB"/>
          </reg>
        </registers>
        <enumerator name="ENUM_LB">
          <enum val="0x00" text="Further programming and verification disabled" constname="PROG_VER_DISABLED"/>
          <enum val="0x02" text="Further programming disabled" constname="PROG_DISABLED"/>
          <enum val="0x03" text="No memory lock features enabled" constname="NO_LOCK"/>
        </enumerator>
      </module>
      <module class="PORTA" text="">
        <registers name="PORTA" memspace="DATAMEM" text="" icon="io_port.bmp">
          <reg size="1" name="PORTA" offset="0x3B" text="Port A Data Register" icon="io_port.bmp" mask="0xFF"/>
          <reg size="1" name="DDRA" offset="0x3A" text="Port A Data Direction Register" icon="io_flag.bmp" mask="0xFF"/>
          <reg size="1" name="PINA" offset="0x39" text="Port A Input Pins" icon="io_port.bmp" mask="0xFF"/>
        </registers>
      </module>
      <module class="USI" text="">
        <registers name="USI" memspace="DATAMEM" text="" icon="io_com.bmp">
          <reg size="1" name="USIBR" offset="0x30" text="USI Buffer Register" icon="io_com.bmp" mask="0xFF"/>
          <reg size="1" name="USIDR" offset="0x2F" text="USI Data Register" icon="io_com.bmp" mask="0xFF"/>
          <reg size="1" name="USISR" offset="0x2E" text="USI Status Register" icon="io_flag.bmp">
            <bitfield name="USISIF" mask="0x80" text="Start Condition Interrupt Flag" icon=""/>
            <bitfield name="USIOIF" mask="0x40" text="Counter Overflow Interrupt Flag" icon=""/>
            <bitfield name="USIPF" mask="0x20" text="Stop Condition Flag" icon=""/>
            <bitfield name="USIDC" mask="0x10" text="Data Output Collision" icon=""/>
            <bitfield name="USICNT" mask="0x0F" text="USI Counter Value Bits" icon=""/>
          </reg>
          <reg size="1" name="USICR" offset="0x2D" text="USI Control Register" icon="io_flag.bmp">
            <bitfield name="USISIE" mask="0x80" text="Start Condition Interrupt Enable" icon=""/>
            <bitfield name="USIOIE" mask="0x40" text="Counter Overflow Interrupt Enable" icon=""/>
            <bitfield name="USIWM" mask="0x30" text="USI Wire Mode Bits" icon="" enum="COMM_USI_OP"/>
            <bitfield name="USICS" mask="0x0C" text="USI Clock Source Select Bits" icon=""/>
            <bitfield name="USICLK" mask="0x02" text="Clock Strobe" icon=""/>
            <bitfield name="USITC" mask="0x01" text="Toggle Clock Port Pin" icon=""/>
          </reg>
        </registers>
        <enumerator name="COMM_USI_OP">
          <enum val="0x00" text="Normal Operation"/>
          <enum val="0x01" text="Three-Wire Mode"/>
          <enum val="0x02" text="Two-Wire Mode"/>
          <enum val="0x03" text="Two-Wire Mode Held Low"/>
        </enumerator>
      </module>
      <module class="WATCHDOG" text="">
        <registers name="WATCHDOG" memspace="DATAMEM" text="" icon="io_watch.bmp">
          <reg size="1" name="WDTCSR" offset="0x41" text="Watchdog Timer Control Register" icon="io_flag.bmp">
            <bitfield name="WDIF" mask="0x80" text="Watchdog Timeout Interrupt Flag" icon=""/>
            <bitfield name="WDIE" mask="0x40" text="Watchdog Timeout Interrupt Enable" icon=""/>
            <bitfield name="WDP" mask="0x27" text="Watchdog Timer Prescaler Bits" icon="" enum="WDOG_TIMER_PRESCALE_4BITS"/>
            <bitfield name="WDCE" mask="0x10" text="Watchdog Change Enable" icon=""/>
            <bitfield name="WDE" mask="0x08" text="Watch Dog Enable" icon=""/>
          </reg>
        </registers>
        <enumerator name="WDOG_TIMER_PRESCALE_4BITS">
          <enum val="0x00" text="Oscillator Cycles 2K"/>
          <enum val="0x01" text="Oscillator Cycles 4K"/>
          <enum val="0x02" text="Oscillator Cycles 8K"/>
          <enum val="0x03" text="Oscillator Cycles 16K"/>
          <enum val="0x04" text="Oscillator Cycles 32K"/>
          <enum val="0x05" text="Oscillator Cycles 64K"/>
          <enum val="0x06" text="Oscillator Cycles 128K"/>
          <enum val="0x07" text="Oscillator Cycles 256K"/>
          <enum val="0x08" text="Oscillator Cycles 512K"/>
          <enum val="0x09" text="Oscillator Cycles 1024K"/>
        </enumerator>
      </module>
      <module class="TIMER_COUNTER_0" text="">
        <registers name="TIMER_COUNTER_0" memspace="DATAMEM" text="" icon="io_timer.bmp">
          <reg size="1" name="TIMSK0" offset="0x59" text="Timer/Counter Interrupt Mask Register" icon="io_flag.bmp">
            <bitfield name="OCIE0B" mask="0x04" text="Timer/Counter0 Output Compare Match B Interrupt Enable" icon=""/>
            <bitfield name="OCIE0A" mask="0x02" text="Timer/Counter0 Output Compare Match A Interrupt Enable" icon=""/>
            <bitfield name="TOIE0" mask="0x01" text="Timer/Counter0 Overflow Interrupt Enable" icon=""/>
          </reg>
          <reg size="1" name="TIFR0" offset="0x58" text="Timer/Counter0 Interrupt Flag Register" icon="io_flag.bmp">
            <bitfield name="OCF0B" mask="0x04" text="Timer/Counter0 Output Compare Flag B" icon=""/>
            <bitfield name="OCF0A" mask="0x02" text="Timer/Counter0 Output Compare Flag A" icon=""/>
            <bitfield name="TOV0" mask="0x01" text="Timer/Counter0 Overflow Flag" icon=""/>
          </reg>
          <reg size="1" name="TCCR0A" offset="0x50" text="Timer/Counter  Control Register A" icon="io_flag.bmp">
            <bitfield name="COM0A" mask="0xC0" text="Compare Match Output A Mode bits" icon=""/>
            <bitfield name="COM0B" mask="0x30" text="Compare Match Output B Mode bits" icon=""/>
            <bitfield name="WGM0" mask="0x03" text="Waveform Generation Mode bits" icon=""/>
          </reg>
          <reg size="1" name="TCCR0B" offset="0x53" text="Timer/Counter Control Register B" icon="io_flag.bmp">
            <bitfield name="FOC0A" mask="0x80" text="Force Output Compare A" icon=""/>
            <bitfield name="FOC0B" mask="0x40" text="Force Output Compare B" icon=""/>
            <bitfield name="WGM02" mask="0x08" text="Waveform Generation Mode bit 2" icon=""/>
            <bitfield name="CS0" mask="0x07" text="Clock Select bits" icon="" enum="CLK_SEL_3BIT_EXT"/>
          </reg>
          <reg size="1" name="TCNT0" offset="0x52" text="Timer/Counter0" icon="io_timer.bmp" mask="0xFF"/>
          <reg size="1" name="OCR0A" offset="0x56" text="Timer/Counter0 Output Compare Register A" icon="io_timer.bmp" mask="0xFF"/>
          <reg size="1" name="OCR0B" offset="0x5C" text="Timer/Counter0 Output Compare Register B" icon="io_timer.bmp" mask="0xFF"/>
          <reg size="1" name="GTCCR" offset="0x43" text="General Timer/Counter Control Register" icon="io_flag.bmp">
            <bitfield name="TSM" mask="0x80" text="Timer/Counter Synchronization Mode" icon=""/>
            <bitfield name="PSR10" mask="0x01" text="Prescaler Reset Timer/CounterN" icon=""/>
          </reg>
        </registers>
        <enumerator name="CLK_SEL_3BIT_EXT">
          <enum val="0x00" text="No Clock Source (Stopped)"/>
          <enum val="0x01" text="Running, No Prescaling"/>
          <enum val="0x02" text="Running, CLK/8"/>
          <enum val="0x03" text="Running, CLK/64"/>
          <enum val="0x04" text="Running, CLK/256"/>
          <enum val="0x05" text="Running, CLK/1024"/>
          <enum val="0x06" text="Running, ExtClk Tx Falling Edge"/>
          <enum val="0x07" text="Running, ExtClk Tx Rising Edge"/>
        </enumerator>
      </module>
      <module class="BOOT_LOAD" text="">
        <registers name="BOOT_LOAD" memspace="DATAMEM" text="" icon="io_cpu.bmp">
          <reg size="1" name="SPMCSR" offset="0x57" text="Store Program Memory Control Register" icon="io_flag.bmp">
            <bitfield name="CTPB" mask="0x10" text="Clear temporary page buffer" icon=""/>
            <bitfield name="RFLB" mask="0x08" text="Read fuse and lock bits" icon=""/>
            <bitfield name="PGWRT" mask="0x04" text="Page Write" icon=""/>
            <bitfield name="PGERS" mask="0x02" text="Page Erase" icon=""/>
            <bitfield name="SPMEN" mask="0x01" text="Store Program Memory Enable" icon=""/>
          </reg>
        </registers>
      </module>
      <module class="TIMER_COUNTER_1" text="">
        <registers name="TIMER_COUNTER_1" memspace="DATAMEM" text="" icon="io_timer.bmp">
          <reg size="1" name="TIMSK1" offset="0x2C" text="Timer/Counter Interrupt Mask Register" icon="io_flag.bmp">
            <bitfield name="OCIE1B" mask="0x04" text="Timer/Counter1 Output Compare Match B Interrupt Enable" icon=""/>
            <bitfield name="OCIE1A" mask="0x02" text="Timer/Counter1 Output Compare Match A Interrupt Enable" icon=""/>
            <bitfield name="TOIE1" mask="0x01" text="Timer/Counter1 Overflow Interrupt Enable" icon=""/>
          </reg>
          <reg size="1" name="TIFR1" offset="0x2B" text="Timer/Counter1 Interrupt Flag Register" icon="io_flag.bmp">
            <bitfield name="OCF1B" mask="0x04" text="Timer/Counter1 Output Compare Flag B" icon=""/>
            <bitfield name="OCF1A" mask="0x02" text="Timer/Counter1 Output Compare Flag A" icon=""/>
            <bitfield name="TOV1" mask="0x01" text="Timer/Counter1 Overflow Flag" icon=""/>
          </reg>
          <reg size="1" name="TCCR1A" offset="0x4F" text="Timer/Counter1 Control Register A" icon="io_flag.bmp">
            <bitfield name="COM1A" mask="0xC0" text="Compare Match Output A Mode bits" icon=""/>
            <bitfield name="COM1B" mask="0x30" text="Compare Match Output B Mode bits" icon=""/>
            <bitfield name="WGM1" mask="0x03" text="Waveform Generation Mode bits" icon=""/>
          </reg>
          <reg size="1" name="TCCR1B" offset="0x4E" text="Timer/Counter Control Register B" icon="io_flag.bmp">
            <bitfield name="FOC1A" mask="0x80" text="Force Output Compare A" icon=""/>
            <bitfield name="FOC1B" mask="0x40" text="Force Output Compare B" icon=""/>
            <bitfield name="WGM12" mask="0x08" text="Waveform Generation Mode bit 2" icon=""/>
            <bitfield name="CS1" mask="0x07" text="Clock Select bits" icon="" enum="CLK_SEL_3BIT_EXT"/>
          </reg>
          <reg size="1" name="TCNT1" offset="0x4D" text="Timer/Counter1" icon="io_timer.bmp" mask="0xFF"/>
          <reg size="1" name="OCR1A" offset="0x4C" text="Timer/Counter1 Output Compare Register A" icon="io_timer.bmp" mask="0xFF"/>
          <reg size="1" name="OCR1B" offset="0x4B" text="Timer/Counter1 Output Compare Register B" icon="io_timer.bmp" mask="0xFF"/>
          <reg size="1" name="GTCCR" offset="0x43" text="General Timer/Counter Control Register" icon="io_flag.bmp">
            <bitfield name="TSM" mask="0x80" text="Timer/Counter Synchronization Mode" icon=""/>
            <bitfield name="PSR10" mask="0x01" text="Prescaler Reset Timer/CounterN" icon=""/>
          </reg>
        </registers>
        <enumerator name="CLK_SEL_3BIT_EXT">
          <enum val="0x00" text="No Clock Source (Stopped)"/>
          <enum val="0x01" text="Running, No Prescaling"/>
          <enum val="0x02" text="Running, CLK/8"/>
          <enum val="0x03" text="Running, CLK/64"/>
          <enum val="0x04" text="Running, CLK/256"/>
          <enum val="0x05" text="Running, CLK/1024"/>
          <enum val="0x06" text="Running, ExtClk Tx Falling Edge"/>
          <enum val="0x07" text="Running, ExtClk Tx Rising Edge"/>
        </enumerator>
      </module>
      <module class="CPU" text="">
        <registers name="CPU" memspace="DATAMEM" text="" icon="io_cpu.bmp">
          <reg size="1" name="PRR" offset="0x20" text="Power Reduction Register" icon="io_cpu.bmp">
            <bitfield name="PRTIM1" mask="0x08" text="Power Reduction Timer/Counter1" icon=""/>
            <bitfield name="PRTIM0" mask="0x04" text="Power Reduction Timer/Counter0" icon=""/>
            <bitfield name="PRUSI" mask="0x02" text="Power Reduction USI" icon=""/>
            <bitfield name="PRADC" mask="0x01" text="Power Reduction ADC" icon=""/>
          </reg>
          <reg size="1" name="OSCCAL" offset="0x51" text="Oscillator Calibration Value" icon="io_cpu.bmp" mask="0xFF"/>
          <reg size="1" name="CLKPR" offset="0x46" text="Clock Prescale Register" icon="io_flag.bmp">
            <bitfield name="CLKPCE" mask="0x80" text="Clock Prescaler Change Enable" icon=""/>
            <bitfield name="CLKPS" mask="0x0F" text="Clock Prescaler Select Bits" icon="" enum="CPU_CLK_PRESCALE_4_BITS_SMALL"/>
          </reg>
          <reg size="1" name="SREG" offset="0x5F" text="Status Register" icon="io_sreg.bmp">
            <bitfield name="I" mask="0x80" text="Global Interrupt Enable" icon=""/>
            <bitfield name="T" mask="0x40" text="Bit Copy Storage" icon=""/>
            <bitfield name="H" mask="0x20" text="Half Carry Flag" icon=""/>
            <bitfield name="S" mask="0x10" text="Sign Bit" icon=""/>
            <bitfield name="V" mask="0x08" text="Two's Complement Overflow Flag" icon=""/>
            <bitfield name="N" mask="0x04" text="Negative Flag" icon=""/>
            <bitfield name="Z" mask="0x02" text="Zero Flag" icon=""/>
            <bitfield name="C" mask="0x01" text="Carry Flag" icon=""/>
          </reg>
          <reg size="2" name="SP" offset="0x5D" text="Stack Pointer " icon="io_sph.bmp" mask="0x01FF"/>
          <reg size="1" name="MCUCR" offset="0x55" text="MCU Control Register" icon="io_flag.bmp">
            <bitfield name="BODS" mask="0x80" text="BOD Sleep" icon=""/>
            <bitfield name="PUD" mask="0x40" text="Pull-Up Disable" icon=""/>
            <bitfield name="SE" mask="0x20" text="Sleep Enable" icon=""/>
            <bitfield name="SM" mask="0x18" text="Sleep Mode Select Bits" icon="" enum="CPU_SLEEP_MODE"/>
            <bitfield name="BODSE" mask="0x04" text="BOD Sleep Enable" icon=""/>
            <bitfield name="ISC0" mask="0x03" text="Interrupt Sense Control 0 Bits" icon="" enum="INTERRUPT_SENSE_CONTROL2"/>
          </reg>
          <reg size="1" name="MCUSR" offset="0x54" text="MCU Status Register" icon="io_flag.bmp">
            <bitfield name="WDRF" mask="0x08" text="Watchdog Reset Flag" icon=""/>
            <bitfield name="BORF" mask="0x04" text="Brown-out Reset Flag" icon=""/>
            <bitfield name="EXTRF" mask="0x02" text="External Reset Flag" icon=""/>
            <bitfield name="PORF" mask="0x01" text="Power-on reset flag" icon=""/>
          </reg>
          <reg size="1" name="GPIOR2" offset="0x35" text="General Purpose I/O Register 2" icon="io_flag.bmp" mask="0xFF"/>
          <reg size="1" name="GPIOR1" offset="0x34" text="General Purpose I/O Register 1" icon="io_flag.bmp" mask="0xFF"/>
          <reg size="1" name="GPIOR0" offset="0x33" text="General Purpose I/O Register 0" icon="io_flag.bmp" mask="0xFF"/>
        </registers>
        <enumerator name="CPU_CLK_PRESCALE_4_BITS_SMALL">
          <enum val="0x00" text="1"/>
          <enum val="0x01" text="2"/>
          <enum val="0x02" text="4"/>
          <enum val="0x03" text="8"/>
          <enum val="0x04" text="16"/>
          <enum val="0x05" text="32"/>
          <enum val="0x06" text="64"/>
          <enum val="0x07" text="128"/>
          <enum val="0x08" text="256"/>
        </enumerator>
        <enumerator name="CPU_SLEEP_MODE">
          <enum val="0x00" text="Idle"/>
          <enum val="0x01" text="ADC Noise Reduction (If Available)"/>
          <enum val="0x02" text="Power Down"/>
          <enum val="0x03" text="Standby"/>
        </enumerator>
        <enumerator name="INTERRUPT_SENSE_CONTROL2">
          <enum val="0x00" text="Low Level of INTX"/>
          <enum val="0x01" text="Any Logical Change in INTX"/>
          <enum val="0x02" text="Falling Edge of INTX"/>
          <enum val="0x03" text="Rising Edge of INTX"/>
        </enumerator>
      </module>
      <module class="EXTERNAL_INTERRUPT" text="">
        <registers name="EXTERNAL_INTERRUPT" memspace="DATAMEM" text="" icon="io_ext.bmp">
          <reg size="1" name="MCUCR" offset="0x55" text="MCU Control Register" icon="io_cpu.bmp">
            <bitfield name="ISC01" mask="0x02" text="Interrupt Sense Control 0 Bit 1" icon=""/>
            <bitfield name="ISC00" mask="0x01" text="Interrupt Sense Control 0 Bit 0" icon="" enum="INTERRUPT_SENSE_CONTROL"/>
          </reg>
          <reg size="1" name="GIMSK" offset="0x5B" text="General Interrupt Mask Register" icon="io_flag.bmp">
            <bitfield name="INT0" mask="0x40" text="External Interrupt Request 0 Enable" icon=""/>
            <bitfield name="PCIE" mask="0x30" text="Pin Change Interrupt Enables" icon=""/>
          </reg>
          <reg size="1" name="GIFR" offset="0x5A" text="General Interrupt Flag register" icon="io_flag.bmp">
            <bitfield name="INTF0" mask="0x40" text="External Interrupt Flag 0" icon=""/>
            <bitfield name="PCIF" mask="0x30" text="Pin Change Interrupt Flags" icon=""/>
          </reg>
          <reg size="1" name="PCMSK1" offset="0x40" text="Pin Change Enable Mask Byte 1" icon="io_flag.bmp" mask="0xFF"/>
          <reg size="1" name="PCMSK0" offset="0x32" text="Pin Change Enable Mask Byte 0" icon="io_flag.bmp" mask="0xFF"/>
        </registers>
        <enumerator name="INTERRUPT_SENSE_CONTROL">
          <enum val="0x00" text="Low Level of INTX"/>
          <enum val="0x01" text="Reserved"/>
          <enum val="0x02" text="Falling Edge of INTX"/>
          <enum val="0x03" text="Rising Edge of INTX"/>
        </enumerator>
      </module>
      <module class="PORTB" text="">
        <registers name="PORTB" memspace="DATAMEM" text="" icon="io_port.bmp">
          <reg size="1" name="PORTB" offset="0x38" text="Port B Data Register" icon="io_port.bmp" mask="0xFF"/>
          <reg size="1" name="DDRB" offset="0x37" text="Port B Data Direction Register" icon="io_flag.bmp" mask="0xFF"/>
          <reg size="1" name="PINB" offset="0x36" text="Port B Input Pins" icon="io_port.bmp" mask="0xFF"/>
        </registers>
      </module>
      <module class="ANALOG_COMPARATOR" text="">
        <registers name="ANALOG_COMPARATOR" memspace="DATAMEM" text="" icon="io_analo.bmp">
          <reg size="1" name="ADCSRB" offset="0x23" text="ADC Control and Status Register B" icon="io_flag.bmp">
            <bitfield name="ACME" mask="0x40" text="Analog Comparator Multiplexer Enable" icon=""/>
          </reg>
          <reg size="1" name="ACSR" offset="0x28" text="Analog Comparator Control And Status Register" icon="io_analo.bmp">
            <bitfield name="ACD" mask="0x80" text="Analog Comparator Disable" icon=""/>
            <bitfield name="ACBG" mask="0x40" text="Analog Comparator Bandgap Select" icon=""/>
            <bitfield name="ACO" mask="0x20" text="Analog Compare Output" icon=""/>
            <bitfield name="ACI" mask="0x10" text="Analog Comparator Interrupt Flag" icon=""/>
            <bitfield name="ACIE" mask="0x08" text="Analog Comparator Interrupt Enable" icon=""/>
            <bitfield name="ACIS" mask="0x03" text="Analog Comparator Interrupt Mode Select bits" icon="" enum="ANALOG_COMP_INTERRUPT"/>
          </reg>
          <reg size="1" name="DIDR0" offset="0x21" text="" icon="">
            <bitfield name="ADC1D" mask="0x02" text="ADC 1 Digital input buffer disable" icon=""/>
            <bitfield name="ADC0D" mask="0x01" text="ADC 0 Digital input buffer disable" icon=""/>
          </reg>
        </registers>
        <enumerator name="ANALOG_COMP_INTERRUPT">
          <enum val="0x00" text="Interrupt on Toggle"/>
          <enum val="0x01" text="Reserved"/>
          <enum val="0x02" text="Interrupt on Falling Edge"/>
          <enum val="0x03" text="Interrupt on Rising Edge"/>
        </enumerator>
      </module>
      <module class="AD_CONVERTER" text="">
        <registers name="AD_CONVERTER" memspace="DATAMEM" text="" icon="io_analo.bmp">
          <reg size="1" name="ADMUX" offset="0x27" text="ADC Multiplexer Selection Register" icon="io_analo.bmp">
            <bitfield name="REFS" mask="0x40" text="Reference Selection Bit" icon="" enum="ANALOG_ADC_V_REF5"/>
            <bitfield name="MUX" mask="0x07" text="Analog Channel Selection Bits" icon=""/>
          </reg>
          <reg size="1" name="ADCSRA" offset="0x26" text="ADC Control and Status Register A" icon="io_flag.bmp">
            <bitfield name="ADEN" mask="0x80" text="ADC Enable" icon=""/>
            <bitfield name="ADSC" mask="0x40" text="ADC Start Conversion" icon=""/>
            <bitfield name="ADATE" mask="0x20" text="ADC Auto Trigger Enable" icon=""/>
            <bitfield name="ADIF" mask="0x10" text="ADC Interrupt Flag" icon=""/>
            <bitfield name="ADIE" mask="0x08" text="ADC Interrupt Enable" icon=""/>
            <bitfield name="ADPS" mask="0x07" text="ADC  Prescaler Select Bits" icon="" enum="ANALIG_ADC_PRESCALER"/>
          </reg>
          <reg size="2" name="ADC" offset="0x24" text="ADC Data Register  Bytes" icon="io_analo.bmp" mask="0xFFFF"/>
          <reg size="1" name="ADCSRB" offset="0x23" text="ADC Control and Status Register B" icon="io_analo.bmp">
            <bitfield name="BVRON" mask="0x80" text="Boost Regulator Status Bit" icon=""/>
            <bitfield name="ACME" mask="0x40" text="Analog Comparator Multiplexer Enable" icon=""/>
            <bitfield name="ADLAR" mask="0x10" text="ADC Left Adjust Result" icon=""/>
            <bitfield name="ADTS" mask="0x07" text="ADC Auto Trigger Source bits" icon="" enum="ANALOG_ADC_AUTO_TRIGGER_T43U"/>
          </reg>
          <reg size="1" name="DIDR0" offset="0x21" text="Digital Input Disable Register 0" icon="io_analo.bmp">
            <bitfield name="AIN1D" mask="0x20" text="Analog Comparator IO" icon=""/>
            <bitfield name="AIN0D" mask="0x10" text="Analog Comparator IO" icon=""/>
            <bitfield name="ADC3D" mask="0x08" text="ADC3 Digital Input Disable" icon=""/>
            <bitfield name="ADC2D" mask="0x04" text="ADC2 Digital Input Disable" icon=""/>
            <bitfield name="ADC1D" mask="0x02" text="ADC1 Digital Input Disable" icon=""/>
            <bitfield name="ADC0D" mask="0x01" text="ADC0 Digital Input Disable" icon=""/>
          </reg>
        </registers>
        <enumerator name="ANALOG_ADC_V_REF5">
          <enum val="0x00" text="Vcc"/>
          <enum val="0x01" text="Internal 1.1V Voltage Reference"/>
        </enumerator>
        <enumerator name="ANALIG_ADC_PRESCALER">
          <enum val="0x00" text="2"/>
          <enum val="0x01" text="2"/>
          <enum val="0x02" text="4"/>
          <enum val="0x03" text="8"/>
          <enum val="0x04" text="16"/>
          <enum val="0x05" text="32"/>
          <enum val="0x06" text="64"/>
          <enum val="0x07" text="128"/>
        </enumerator>
        <enumerator name="ANALOG_ADC_AUTO_TRIGGER_T43U">
          <enum val="0x00" text="Free Running mode"/>
          <enum val="0x01" text="Analog Comparator"/>
          <enum val="0x02" text="External Interrupt Request 0"/>
          <enum val="0x03" text="Timer/Counter0 Compare Match A"/>
          <enum val="0x04" text="Timer/Counter0 Overflow"/>
          <enum val="0x05" text="Timer/Counter1 Compare Match A"/>
          <enum val="0x06" text="Timer/Counter1 Overflow"/>
          <enum val="0x07" text="Timer/Counter1 Capture Match B"/>
        </enumerator>
      </module>
      <module class="EEPROM" text="">
        <registers name="EEPROM" memspace="DATAMEM" text="" icon="io_cpu.bmp">
          <reg size="1" name="EEAR" offset="0x3E" text="EEPROM Address Register" icon="io_cpu.bmp" mask="0x3F"/>
          <reg size="1" name="EEDR" offset="0x3D" text="EEPROM Data Register" icon="io_cpu.bmp" mask="0xFF"/>
          <reg size="1" name="EECR" offset="0x3C" text="EEPROM Control Register" icon="io_flag.bmp">
            <bitfield name="EEPM" mask="0x30" text="EEPROM Programming Mode Bits" icon="" enum="EEP_MODE"/>
            <bitfield name="EERIE" mask="0x08" text="EEPROM Ready Interrupt Enable" icon=""/>
            <bitfield name="EEMPE" mask="0x04" text="EEPROM Master Write Enable" icon=""/>
            <bitfield name="EEPE" mask="0x02" text="EEPROM Write Enable" icon=""/>
            <bitfield name="EERE" mask="0x01" text="EEPROM Read Enable" icon=""/>
          </reg>
        </registers>
        <enumerator name="EEP_MODE">
          <enum val="0x00" text="Erase and Write in one operation"/>
          <enum val="0x01" text="Erase Only"/>
          <enum val="0x02" text="Write Only"/>
        </enumerator>
      </module>
    </templates>
    <modules>
      <module implements="PORTA" name="PORTA">
        <registers implements="PORTA" name="PORTA" offset="0x00" text=""/>
      </module>
      <module implements="USI" name="USI">
        <registers implements="USI" name="USI" offset="0x00" text=""/>
      </module>
      <module implements="WATCHDOG" name="WATCHDOG">
        <registers implements="WATCHDOG" name="WATCHDOG" offset="0x00" text=""/>
      </module>
      <module implements="TIMER_COUNTER_0" name="TIMER_COUNTER_0">
        <registers implements="TIMER_COUNTER_0" name="TIMER_COUNTER_0" offset="0x00" text=""/>
      </module>
      <module implements="BOOT_LOAD" name="BOOT_LOAD">
        <registers implements="BOOT_LOAD" name="BOOT_LOAD" offset="0x00" text=""/>
      </module>
      <module implements="TIMER_COUNTER_1" name="TIMER_COUNTER_1">
        <registers implements="TIMER_COUNTER_1" name="TIMER_COUNTER_1" offset="0x00" text=""/>
      </module>
      <module implements="CPU" name="CPU">
        <registers implements="CPU" name="CPU" offset="0x00" text=""/>
      </module>
      <module implements="EXTERNAL_INTERRUPT" name="EXTERNAL_INTERRUPT">
        <registers implements="EXTERNAL_INTERRUPT" name="EXTERNAL_INTERRUPT" offset="0x00" text=""/>
      </module>
      <module implements="PORTB" name="PORTB">
        <registers implements="PORTB" name="PORTB" offset="0x00" text=""/>
      </module>
      <module implements="ANALOG_COMPARATOR" name="ANALOG_COMPARATOR">
        <registers implements="ANALOG_COMPARATOR" name="ANALOG_COMPARATOR" offset="0x00" text=""/>
      </module>
      <module implements="AD_CONVERTER" name="AD_CONVERTER">
        <registers implements="AD_CONVERTER" name="AD_CONVERTER" offset="0x00" text=""/>
      </module>
      <module implements="EEPROM" name="EEPROM">
        <registers implements="EEPROM" name="EEPROM" offset="0x00" text=""/>
      </module>
    </modules>
    <fuses>
      <fuse implements="FUSE" name="FUSE">
        <registers implements="FUSE" name="FUSE"/>
      </fuse>
    </fuses>
    <lockbits>
      <lockbit implements="LOCKBIT" name="LOCKBIT">
        <registers implements="LOCKBIT" name="LOCKBIT"/>
      </lockbit>
    </lockbits>
  </V2>
</AVRPART>

<?xml version="1.0"?>
<AVRPART>
  <MODULE_LIST>[CORE:INTERRUPT_VECTOR:LOCKBIT:PACKAGE:POWER:PROGVOLT:MEMORY:ADMIN:FUSE:PROGRAMMING:IO_MODULE:ICE_SETTINGS]</MODULE_LIST>
  <CORE>
    <CORE_VERSION>V3</CORE_VERSION>
    <ID>AVRSimCore32.SimCoreV3</ID>
    <NEW_INSTRUCTIONS>[]</NEW_INSTRUCTIONS>
    <INSTRUCTIONS_NOT_SUPPORTED>[]</INSTRUCTIONS_NOT_SUPPORTED>
    <RAMP_REGISTERS>[]</RAMP_REGISTERS>
    <GP_REG_FILE>
      <NMB_REG>32</NMB_REG>
      <START_ADDR>$00</START_ADDR>
      <X_REG_HIGH>$1B</X_REG_HIGH>
      <X_REG_LOW>$1A</X_REG_LOW>
      <Y_REG_HIGH>$1D</Y_REG_HIGH>
      <Y_REG_LOW>$1C</Y_REG_LOW>
      <Z_REG_HIGH>$1F</Z_REG_HIGH>
      <Z_REG_LOW>$1E</Z_REG_LOW>
    </GP_REG_FILE>
  </CORE>
  <INTERRUPT_VECTOR>
    <NMB_VECTORS>72</NMB_VECTORS>
    <VECTOR1>
      <PROGRAM_ADDRESS>$000</PROGRAM_ADDRESS>
      <SOURCE>RESET</SOURCE>
      <DEFINITION>External Pin,Power-on Reset,Brown-out Reset,Watchdog Reset,and JTAG AVR Reset. See Datasheet.     </DEFINITION>
    </VECTOR1>
    <VECTOR2>
      <PROGRAM_ADDRESS>$002</PROGRAM_ADDRESS>
      <SOURCE>INT0</SOURCE>
      <DEFINITION>External Interrupt Request 0</DEFINITION>
    </VECTOR2>
    <VECTOR3>
      <PROGRAM_ADDRESS>$004</PROGRAM_ADDRESS>
      <SOURCE>INT1</SOURCE>
      <DEFINITION>External Interrupt Request 1</DEFINITION>
    </VECTOR3>
    <VECTOR4>
      <PROGRAM_ADDRESS>$006</PROGRAM_ADDRESS>
      <SOURCE>INT2</SOURCE>
      <DEFINITION>External Interrupt Request 2</DEFINITION>
    </VECTOR4>
    <VECTOR5>
      <PROGRAM_ADDRESS>$008</PROGRAM_ADDRESS>
      <SOURCE>INT3</SOURCE>
      <DEFINITION>External Interrupt Request 3</DEFINITION>
    </VECTOR5>
    <VECTOR6>
      <PROGRAM_ADDRESS>$00A</PROGRAM_ADDRESS>
      <SOURCE>INT4</SOURCE>
      <DEFINITION>External Interrupt Request 4</DEFINITION>
    </VECTOR6>
    <VECTOR7>
      <PROGRAM_ADDRESS>$00C</PROGRAM_ADDRESS>
      <SOURCE>INT5</SOURCE>
      <DEFINITION>External Interrupt Request 5</DEFINITION>
    </VECTOR7>
    <VECTOR8>
      <PROGRAM_ADDRESS>$00E</PROGRAM_ADDRESS>
      <SOURCE>INT6</SOURCE>
      <DEFINITION>External Interrupt Request 6</DEFINITION>
    </VECTOR8>
    <VECTOR9>
      <PROGRAM_ADDRESS>$010</PROGRAM_ADDRESS>
      <SOURCE>INT7</SOURCE>
      <DEFINITION>External Interrupt Request 7</DEFINITION>
    </VECTOR9>
    <VECTOR10>
      <PROGRAM_ADDRESS>$012</PROGRAM_ADDRESS>
      <SOURCE>PCINT0</SOURCE>
      <DEFINITION>Pin Change Interrupt Request 0</DEFINITION>
    </VECTOR10>
    <VECTOR11>
      <PROGRAM_ADDRESS>$014</PROGRAM_ADDRESS>
      <SOURCE>PCINT1</SOURCE>
      <DEFINITION>Pin Change Interrupt Request 1</DEFINITION>
    </VECTOR11>
    <VECTOR12>
      <PROGRAM_ADDRESS>$016</PROGRAM_ADDRESS>
      <SOURCE>PCINT2</SOURCE>
      <DEFINITION>Pin Change Interrupt Request 2</DEFINITION>
    </VECTOR12>
    <VECTOR13>
      <PROGRAM_ADDRESS>$018</PROGRAM_ADDRESS>
      <SOURCE>WDT</SOURCE>
      <DEFINITION>Watchdog Time-out Interrupt</DEFINITION>
    </VECTOR13>
    <VECTOR14>
      <PROGRAM_ADDRESS>$01A</PROGRAM_ADDRESS>
      <SOURCE>TIMER2_COMPA</SOURCE>
      <DEFINITION>Timer/Counter2 Compare Match A</DEFINITION>
    </VECTOR14>
    <VECTOR15>
      <PROGRAM_ADDRESS>$01C</PROGRAM_ADDRESS>
      <SOURCE>TIMER2_COMPB</SOURCE>
      <DEFINITION>Timer/Counter2 Compare Match B</DEFINITION>
    </VECTOR15>
    <VECTOR16>
      <PROGRAM_ADDRESS>$01E</PROGRAM_ADDRESS>
      <SOURCE>TIMER2_OVF</SOURCE>
      <DEFINITION>Timer/Counter2 Overflow</DEFINITION>
    </VECTOR16>
    <VECTOR17>
      <PROGRAM_ADDRESS>$020</PROGRAM_ADDRESS>
      <SOURCE>TIMER1_CAPT</SOURCE>
      <DEFINITION>Timer/Counter1 Capture Event</DEFINITION>
    </VECTOR17>
    <VECTOR18>
      <PROGRAM_ADDRESS>$022</PROGRAM_ADDRESS>
      <SOURCE>TIMER1_COMPA</SOURCE>
      <DEFINITION>Timer/Counter1 Compare Match A</DEFINITION>
    </VECTOR18>
    <VECTOR19>
      <PROGRAM_ADDRESS>$024</PROGRAM_ADDRESS>
      <SOURCE>TIMER1_COMPB</SOURCE>
      <DEFINITION>Timer/Counter1 Compare Match B</DEFINITION>
    </VECTOR19>
    <VECTOR20>
      <PROGRAM_ADDRESS>$026</PROGRAM_ADDRESS>
      <SOURCE>TIMER1_COMPC</SOURCE>
      <DEFINITION>Timer/Counter1 Compare Match C</DEFINITION>
    </VECTOR20>
    <VECTOR21>
      <PROGRAM_ADDRESS>$028</PROGRAM_ADDRESS>
      <SOURCE>TIMER1_OVF</SOURCE>
      <DEFINITION>Timer/Counter1 Overflow</DEFINITION>
    </VECTOR21>
    <VECTOR22>
      <PROGRAM_ADDRESS>$02A</PROGRAM_ADDRESS>
      <SOURCE>TIMER0_COMPA</SOURCE>
      <DEFINITION>Timer/Counter0 Compare Match A</DEFINITION>
    </VECTOR22>
    <VECTOR23>
      <PROGRAM_ADDRESS>$02C</PROGRAM_ADDRESS>
      <SOURCE>TIMER0_COMPB</SOURCE>
      <DEFINITION>Timer/Counter0 Compare Match B</DEFINITION>
    </VECTOR23>
    <VECTOR24>
      <PROGRAM_ADDRESS>$02E</PROGRAM_ADDRESS>
      <SOURCE>TIMER0_OVF</SOURCE>
      <DEFINITION>Timer/Counter0 Overflow</DEFINITION>
    </VECTOR24>
    <VECTOR25>
      <PROGRAM_ADDRESS>$030</PROGRAM_ADDRESS>
      <SOURCE>SPI_STC</SOURCE>
      <DEFINITION>SPI Serial Transfer Complete</DEFINITION>
    </VECTOR25>
    <VECTOR26>
      <PROGRAM_ADDRESS>$032</PROGRAM_ADDRESS>
      <SOURCE>USART0_RX</SOURCE>
      <DEFINITION>USART0, Rx Complete</DEFINITION>
    </VECTOR26>
    <VECTOR27>
      <PROGRAM_ADDRESS>$034</PROGRAM_ADDRESS>
      <SOURCE>USART0_UDRE</SOURCE>
      <DEFINITION>USART0 Data register Empty</DEFINITION>
    </VECTOR27>
    <VECTOR28>
      <PROGRAM_ADDRESS>$036</PROGRAM_ADDRESS>
      <SOURCE>USART0_TX</SOURCE>
      <DEFINITION>USART0, Tx Complete</DEFINITION>
    </VECTOR28>
    <VECTOR29>
      <PROGRAM_ADDRESS>$038</PROGRAM_ADDRESS>
      <SOURCE>ANALOG_COMP</SOURCE>
      <DEFINITION>Analog Comparator</DEFINITION>
    </VECTOR29>
    <VECTOR30>
      <PROGRAM_ADDRESS>$03A</PROGRAM_ADDRESS>
      <SOURCE>ADC</SOURCE>
      <DEFINITION>ADC Conversion Complete</DEFINITION>
    </VECTOR30>
    <VECTOR31>
      <PROGRAM_ADDRESS>$03C</PROGRAM_ADDRESS>
      <SOURCE>EE_READY</SOURCE>
      <DEFINITION>EEPROM Ready</DEFINITION>
    </VECTOR31>
    <VECTOR32>
      <PROGRAM_ADDRESS>$03E</PROGRAM_ADDRESS>
      <SOURCE>TIMER3_CAPT</SOURCE>
      <DEFINITION>Timer/Counter3 Capture Event</DEFINITION>
    </VECTOR32>
    <VECTOR33>
      <PROGRAM_ADDRESS>$040</PROGRAM_ADDRESS>
      <SOURCE>TIMER3_COMPA</SOURCE>
      <DEFINITION>Timer/Counter3 Compare Match A</DEFINITION>
    </VECTOR33>
    <VECTOR34>
      <PROGRAM_ADDRESS>$042</PROGRAM_ADDRESS>
      <SOURCE>TIMER3_COMPB</SOURCE>
      <DEFINITION>Timer/Counter3 Compare Match B</DEFINITION>
    </VECTOR34>
    <VECTOR35>
      <PROGRAM_ADDRESS>$044</PROGRAM_ADDRESS>
      <SOURCE>TIMER3_COMPC</SOURCE>
      <DEFINITION>Timer/Counter3 Compare Match C</DEFINITION>
    </VECTOR35>
    <VECTOR36>
      <PROGRAM_ADDRESS>$046</PROGRAM_ADDRESS>
      <SOURCE>TIMER3_OVF</SOURCE>
      <DEFINITION>Timer/Counter3 Overflow</DEFINITION>
    </VECTOR36>
    <VECTOR37>
      <PROGRAM_ADDRESS>$048</PROGRAM_ADDRESS>
      <SOURCE>USART1_RX</SOURCE>
      <DEFINITION>USART1, Rx Complete</DEFINITION>
    </VECTOR37>
    <VECTOR38>
      <PROGRAM_ADDRESS>$04A</PROGRAM_ADDRESS>
      <SOURCE>USART1_UDRE</SOURCE>
      <DEFINITION>USART1 Data register Empty</DEFINITION>
    </VECTOR38>
    <VECTOR39>
      <PROGRAM_ADDRESS>$04C</PROGRAM_ADDRESS>
      <SOURCE>USART1_TX</SOURCE>
      <DEFINITION>USART1, Tx Complete</DEFINITION>
    </VECTOR39>
    <VECTOR40>
      <PROGRAM_ADDRESS>$04E</PROGRAM_ADDRESS>
      <SOURCE>TWI</SOURCE>
      <DEFINITION>2-wire Serial Interface</DEFINITION>
    </VECTOR40>
    <VECTOR41>
      <PROGRAM_ADDRESS>$050</PROGRAM_ADDRESS>
      <SOURCE>SPM_READY</SOURCE>
      <DEFINITION>Store Program Memory Read</DEFINITION>
    </VECTOR41>
    <VECTOR42>
      <PROGRAM_ADDRESS>$052</PROGRAM_ADDRESS>
      <SOURCE>TIMER4_CAPT</SOURCE>
      <DEFINITION>Timer/Counter4 Capture Event</DEFINITION>
    </VECTOR42>
    <VECTOR43>
      <PROGRAM_ADDRESS>$054</PROGRAM_ADDRESS>
      <SOURCE>TIMER4_COMPA</SOURCE>
      <DEFINITION>Timer/Counter4 Compare Match A</DEFINITION>
    </VECTOR43>
    <VECTOR44>
      <PROGRAM_ADDRESS>$056</PROGRAM_ADDRESS>
      <SOURCE>TIMER4_COMPB</SOURCE>
      <DEFINITION>Timer/Counter4 Compare Match B</DEFINITION>
    </VECTOR44>
    <VECTOR45>
      <PROGRAM_ADDRESS>$058</PROGRAM_ADDRESS>
      <SOURCE>TIMER4_COMPC</SOURCE>
      <DEFINITION>Timer/Counter4 Compare Match C</DEFINITION>
    </VECTOR45>
    <VECTOR46>
      <PROGRAM_ADDRESS>$05A</PROGRAM_ADDRESS>
      <SOURCE>TIMER4_OVF</SOURCE>
      <DEFINITION>Timer/Counter4 Overflow</DEFINITION>
    </VECTOR46>
    <VECTOR47>
      <PROGRAM_ADDRESS>$05C</PROGRAM_ADDRESS>
      <SOURCE>TIMER5_CAPT</SOURCE>
      <DEFINITION>Timer/Counter5 Capture Event</DEFINITION>
    </VECTOR47>
    <VECTOR48>
      <PROGRAM_ADDRESS>$05E</PROGRAM_ADDRESS>
      <SOURCE>TIMER5_COMPA</SOURCE>
      <DEFINITION>Timer/Counter5 Compare Match A</DEFINITION>
    </VECTOR48>
    <VECTOR49>
      <PROGRAM_ADDRESS>$060</PROGRAM_ADDRESS>
      <SOURCE>TIMER5_COMPB</SOURCE>
      <DEFINITION>Timer/Counter5 Compare Match B</DEFINITION>
    </VECTOR49>
    <VECTOR50>
      <PROGRAM_ADDRESS>$062</PROGRAM_ADDRESS>
      <SOURCE>TIMER5_COMPC</SOURCE>
      <DEFINITION>Timer/Counter5 Compare Match C</DEFINITION>
    </VECTOR50>
    <VECTOR51>
      <PROGRAM_ADDRESS>$064</PROGRAM_ADDRESS>
      <SOURCE>TIMER5_OVF</SOURCE>
      <DEFINITION>Timer/Counter5 Overflow</DEFINITION>
    </VECTOR51>
    <VECTOR52>
      <PROGRAM_ADDRESS>$066</PROGRAM_ADDRESS>
      <SOURCE>USART2_RX</SOURCE>
      <DEFINITION>USART2, Rx Complete</DEFINITION>
    </VECTOR52>
    <VECTOR53>
      <PROGRAM_ADDRESS>$068</PROGRAM_ADDRESS>
      <SOURCE>USART2_UDRE</SOURCE>
      <DEFINITION>USART2 Data register Empty</DEFINITION>
    </VECTOR53>
    <VECTOR54>
      <PROGRAM_ADDRESS>$06A</PROGRAM_ADDRESS>
      <SOURCE>USART2_TX</SOURCE>
      <DEFINITION>USART2, Tx Complete</DEFINITION>
    </VECTOR54>
    <VECTOR55>
      <PROGRAM_ADDRESS>$06C</PROGRAM_ADDRESS>
      <SOURCE>USART3_RX</SOURCE>
      <DEFINITION>USART3, Rx Complete</DEFINITION>
    </VECTOR55>
    <VECTOR56>
      <PROGRAM_ADDRESS>$06E</PROGRAM_ADDRESS>
      <SOURCE>USART3_UDRE</SOURCE>
      <DEFINITION>USART3 Data register Empty</DEFINITION>
    </VECTOR56>
    <VECTOR57>
      <PROGRAM_ADDRESS>$070</PROGRAM_ADDRESS>
      <SOURCE>USART3_TX</SOURCE>
      <DEFINITION>USART3, Tx Complete</DEFINITION>
    </VECTOR57>
    <VECTOR58>
      <PROGRAM_ADDRESS>$072</PROGRAM_ADDRESS>
      <SOURCE>TRX24_PLL_LOCK</SOURCE>
      <DEFINITION>TRX24 - PLL lock interrupt</DEFINITION>
    </VECTOR58>
    <VECTOR59>
      <PROGRAM_ADDRESS>$074</PROGRAM_ADDRESS>
      <SOURCE>TRX24_PLL_UNLOCK</SOURCE>
      <DEFINITION>TRX24 - PLL unlock interrupt</DEFINITION>
    </VECTOR59>
    <VECTOR60>
      <PROGRAM_ADDRESS>$076</PROGRAM_ADDRESS>
      <SOURCE>TRX24_RX_START</SOURCE>
      <DEFINITION>TRX24 - Receive start interrupt</DEFINITION>
    </VECTOR60>
    <VECTOR61>
      <PROGRAM_ADDRESS>$078</PROGRAM_ADDRESS>
      <SOURCE>TRX24_RX_END</SOURCE>
      <DEFINITION>TRX24 - RX_END interrupt</DEFINITION>
    </VECTOR61>
    <VECTOR62>
      <PROGRAM_ADDRESS>$07A</PROGRAM_ADDRESS>
      <SOURCE>TRX24_CCA_ED_DONE</SOURCE>
      <DEFINITION>TRX24 - CCA/ED done interrupt</DEFINITION>
    </VECTOR62>
    <VECTOR63>
      <PROGRAM_ADDRESS>$07C</PROGRAM_ADDRESS>
      <SOURCE>TRX24_XAH_AMI</SOURCE>
      <DEFINITION>TRX24 - XAH - AMI</DEFINITION>
    </VECTOR63>
    <VECTOR64>
      <PROGRAM_ADDRESS>$07E</PROGRAM_ADDRESS>
      <SOURCE>TRX24_TX_END</SOURCE>
      <DEFINITION>TRX24 - TX_END interrupt</DEFINITION>
    </VECTOR64>
    <VECTOR65>
      <PROGRAM_ADDRESS>$080</PROGRAM_ADDRESS>
      <SOURCE>TRX24_AWAKE</SOURCE>
      <DEFINITION>TRX24 AWAKE - tranceiver is reaching state TRX_OFF</DEFINITION>
    </VECTOR65>
    <VECTOR66>
      <PROGRAM_ADDRESS>$082</PROGRAM_ADDRESS>
      <SOURCE>SCNT_CMP1</SOURCE>
      <DEFINITION>Symbol counter - compare match 1 interrupt</DEFINITION>
    </VECTOR66>
    <VECTOR67>
      <PROGRAM_ADDRESS>$084</PROGRAM_ADDRESS>
      <SOURCE>SCNT_CMP2</SOURCE>
      <DEFINITION>Symbol counter - compare match 2 interrupt</DEFINITION>
    </VECTOR67>
    <VECTOR68>
      <PROGRAM_ADDRESS>$086</PROGRAM_ADDRESS>
      <SOURCE>SCNT_CMP3</SOURCE>
      <DEFINITION>Symbol counter - compare match 3 interrupt</DEFINITION>
    </VECTOR68>
    <VECTOR69>
      <PROGRAM_ADDRESS>$088</PROGRAM_ADDRESS>
      <SOURCE>SCNT_OVFL</SOURCE>
      <DEFINITION>Symbol counter - overflow interrupt</DEFINITION>
    </VECTOR69>
    <VECTOR70>
      <PROGRAM_ADDRESS>$08A</PROGRAM_ADDRESS>
      <SOURCE>SCNT_BACKOFF</SOURCE>
      <DEFINITION>Symbol counter - backoff interrupt</DEFINITION>
    </VECTOR70>
    <VECTOR71>
      <PROGRAM_ADDRESS>$08C</PROGRAM_ADDRESS>
      <SOURCE>AES_READY</SOURCE>
      <DEFINITION>AES engine ready interrupt</DEFINITION>
    </VECTOR71>
    <VECTOR72>
      <PROGRAM_ADDRESS>$08E</PROGRAM_ADDRESS>
      <SOURCE>BAT_LOW</SOURCE>
      <DEFINITION>Battery monitor indicates supply voltage below threshold</DEFINITION>
    </VECTOR72>
  </INTERRUPT_VECTOR>
  <LOCKBIT>
    <ICON/>
    <ID/>
    <TEXT>[LB1 = 1 :  LB2 = 1] No memory lock features enabled. [LB1 = 0 :  LB2 = 1] Further programming of Flash and EEPROM is enabled. [LB1 = 0 :  LB2 = 0] Same as previous, but verify is also disabled</TEXT>
    <NMB_LOCK_BITS>6</NMB_LOCK_BITS>
    <NMB_TEXT>11</NMB_TEXT>
    <TEXT1>
      <MASK>0x03</MASK>
      <VALUE>0x03</VALUE>
      <TEXT>Mode 1: No memory lock features enabled</TEXT>
    </TEXT1>
    <TEXT2>
      <MASK>0x03</MASK>
      <VALUE>0x02</VALUE>
      <TEXT>Mode 2: Further programming disabled</TEXT>
    </TEXT2>
    <TEXT3>
      <MASK>0x03</MASK>
      <VALUE>0x00</VALUE>
      <TEXT>Mode 3: Further programming and verification disabled</TEXT>
    </TEXT3>
    <TEXT4>
      <MASK>0x0C</MASK>
      <VALUE>0x0C</VALUE>
      <TEXT>Application Protection Mode 1: No lock on SPM and LPM in Application Section</TEXT>
    </TEXT4>
    <TEXT5>
      <MASK>0x0C</MASK>
      <VALUE>0x08</VALUE>
      <TEXT>Application Protection Mode 2: SPM prohibited in Application Section</TEXT>
    </TEXT5>
    <TEXT6>
      <MASK>0x0C</MASK>
      <VALUE>0x00</VALUE>
      <TEXT>Application Protection Mode 3: LPM and SPM prohibited in Application Section</TEXT>
    </TEXT6>
    <TEXT7>
      <MASK>0x0C</MASK>
      <VALUE>0x04</VALUE>
      <TEXT>Application Protection Mode 4: LPM prohibited in Application Section</TEXT>
    </TEXT7>
    <TEXT8>
      <MASK>0x30</MASK>
      <VALUE>0x30</VALUE>
      <TEXT>Boot Loader Protection Mode 1: No lock on SPM and LPM in Boot Loader Section</TEXT>
    </TEXT8>
    <TEXT9>
      <MASK>0x30</MASK>
      <VALUE>0x20</VALUE>
      <TEXT>Boot Loader Protection Mode 2: SPM prohibited in Boot Loader Section</TEXT>
    </TEXT9>
    <TEXT10>
      <MASK>0x30</MASK>
      <VALUE>0x00</VALUE>
      <TEXT>Boot Loader Protection Mode 3: LPM and SPM prohibited in Boot Loader Section</TEXT>
    </TEXT10>
    <TEXT11>
      <MASK>0x30</MASK>
      <VALUE>0x10</VALUE>
      <TEXT>Boot Loader Protection Mode 4: LPM prohibited in Boot Loader Section</TEXT>
    </TEXT11>
    <LOCKBIT0>
      <NAME>LB1</NAME>
      <TEXT>Lock bit</TEXT>
    </LOCKBIT0>
    <LOCKBIT1>
      <NAME>LB2</NAME>
      <TEXT>Lock bit</TEXT>
    </LOCKBIT1>
    <LOCKBIT2>
      <NAME>BLB01</NAME>
      <TEXT>Boot Lock bit</TEXT>
    </LOCKBIT2>
    <LOCKBIT3>
      <NAME>BLB02</NAME>
      <TEXT>Boot Lock bit</TEXT>
    </LOCKBIT3>
    <LOCKBIT4>
      <NAME>BLB11</NAME>
      <TEXT>Boot lock bit</TEXT>
    </LOCKBIT4>
    <LOCKBIT5>
      <NAME>BLB12</NAME>
      <TEXT>Boot lock bit</TEXT>
    </LOCKBIT5>
  </LOCKBIT>
  <PACKAGE>
    <PACKAGES>[QFN]</PACKAGES>
    <QFN>
      <NMB_PIN>64</NMB_PIN>
      <PIN1>
        <NAME>[PF2:ADC2:DIG2]</NAME>
        <TEXT>ADC2, Analog to Digital Converter, Channel 2 : DIG2, Antenna diversity RF switch control (DIG1 inverted)</TEXT>
      </PIN1>
      <PIN2>
        <NAME>[PF3:ADC3:DIG4]</NAME>
        <TEXT>ADC3, Analog to Digital Converter, Channel 3 : DIG4, RX/TX Indicator (DIG3 inverted)</TEXT>
      </PIN2>
      <PIN3>
        <NAME>[PF4:ADC4:TCK]</NAME>
        <TEXT>ADC4, Analog to Digital Converter, channel 4. TCK, JTAG Test Clock: JTAG operation is synchronous to TCK. When the JTAG interface is enabled, this pin can not be used as an I/O pin.</TEXT>
      </PIN3>
      <PIN4>
        <NAME>[PF5:ADC5:TMS]</NAME>
        <TEXT>ADC5, Analog to Digital Converter, channel 5. TMS, JTAG Test Mode Select: This pin is used for navigating through the TAP-controller state machine. When the JTAG interface is enabled, this pin can not be used as an I/O pin.</TEXT>
      </PIN4>
      <PIN5>
        <NAME>[PF6:ADC6:TDO]</NAME>
        <TEXT>ADC6, Analog to Digital Converter, channel 6. TDO, JTAG Test Data Out: Serial output data from Instruction register or Data Register. When the JTAG interface is enabled, this pin can not be used as an I/O pin.</TEXT>
      </PIN5>
      <PIN6>
        <NAME>[PF7:ADC7:TDI]</NAME>
        <TEXT>ADC7, Analog to Digital Converter, channel 7. TDI, JTAG Test Data In: Serial input data to be shifted in to the Instruction Register or Data Register (scan chains). When the JTAG interface is enabled, this pin can not be used as an I/O pin.</TEXT>
      </PIN6>
      <PIN7>
        <NAME>[AVSS_RFP]</NAME>
        <TEXT>Ground supply for RF pin RFP.</TEXT>
      </PIN7>
      <PIN8>
        <NAME>[RFP]</NAME>
        <TEXT>RF pin, positive terminal when differential excitation.</TEXT>
      </PIN8>
      <PIN9>
        <NAME>[RFN]</NAME>
        <TEXT>RF pin, negative terminal when differential excitation.</TEXT>
      </PIN9>
      <PIN10>
        <NAME>[AVSS_RFN]</NAME>
        <TEXT>Ground supply for RF pin RFN.</TEXT>
      </PIN10>
      <PIN11>
        <NAME>[TST]</NAME>
        <TEXT>Programming and test mode enable</TEXT>
      </PIN11>
      <PIN12>
        <NAME>[RSTN]</NAME>
        <TEXT>Active low asynchronous reset of the IC</TEXT>
      </PIN12>
      <PIN13>
        <NAME>[RSTON]</NAME>
        <TEXT>Low active reset output pin</TEXT>
      </PIN13>
      <PIN14>
        <NAME>[PG0:DIG3]</NAME>
        <TEXT>DIG3, RX/TX Indicator</TEXT>
      </PIN14>
      <PIN15>
        <NAME>[PG1:DIG1]</NAME>
        <TEXT>DIG1, Antenna diversity RF switch control</TEXT>
      </PIN15>
      <PIN16>
        <NAME>[PG2:AMR]</NAME>
        <TEXT>
				</TEXT>
      </PIN16>
      <PIN17>
        <NAME>[PG3:TOSC2]</NAME>
        <TEXT>TOSC2, Timer Oscillator pin 2: When the AS0 bit in ASSR is set (one) to enable asynchronous clocking of Timer/Counter0, pin PG3 is disconnected from the port, and becomes the input of the inverting oscillator amplifier. In this mode, a crystal oscillator is connected to this pin, and the pin can not be used as an I/O pin.</TEXT>
      </PIN17>
      <PIN18>
        <NAME>[PG4:TOSC1]</NAME>
        <TEXT>TOSC1, Timer Oscillator pin 1: When the AS0 bit in ASSR is set (one) to enable asynchronous clocking of Timer/Counter0, pin PG4 is disconnected from the port, and becomes the inverting output of the oscillator amplifier. In this mode, a crystal oscillator is connected to this pin, and the pin can not be used as an I/O pin.</TEXT>
      </PIN18>
      <PIN19>
        <NAME>[PG5:OC0B]</NAME>
        <TEXT>OC0B, Output Compare and PWM Output B for Timer/Counter 0.</TEXT>
      </PIN19>
      <PIN20>
        <NAME>[DVSS:DSVSS]</NAME>
        <TEXT>Ground &amp; Substrate supply for the digital part of the IC.</TEXT>
      </PIN20>
      <PIN21>
        <NAME>[DVDD]</NAME>
        <TEXT>Digital regulated 1.8V supply voltage</TEXT>
      </PIN21>
      <PIN22>
        <NAME>[DVDD]</NAME>
        <TEXT>Digital regulated 1.8V supply voltage</TEXT>
      </PIN22>
      <PIN23>
        <NAME>[DEVDD]</NAME>
        <TEXT>Digital external supply voltage (IO, voltage regulator)</TEXT>
      </PIN23>
      <PIN24>
        <NAME>[DVSS]</NAME>
        <TEXT>Digital ground supply (core, IO)</TEXT>
      </PIN24>
      <PIN25>
        <NAME>[PD0:SCL:INT0]</NAME>
        <TEXT>INT0, External Interrupt source 0. The PD0 pin can serve as external active low interrupt source to the MCU. The internal pull up MOS resistors can be activated as described above. See the interrupt description for further details, and how to enable the source. SCL, 2-wire Serial Interface Clock: When the TWEN bit in TWCR is set (one) to enable the 2-wire Serial Interface, pin PD0 is disconnected from the port and becomes the Serial Clock I/O pin for the 2-wire Serial Interface. In this mode, there is a spike filter on the pin to suppress spikes shorter than 50 ns on the input signal, and the pin is driven by an open drain driver with slew-rate limitation</TEXT>
      </PIN25>
      <PIN26>
        <NAME>[PD1:SDA:INT1]</NAME>
        <TEXT>INT1, External Interrupt source 1. The PD1 pin can serve as external active low interrupt source to the MCU. The internal pull up MOS resistors can be activated as described above. See the interrupt description for further details, and how to enable the source. SDA, 2-wire Serial Interface Data: When the TWEN bit in TWCR is set (one) to enable the 2-wire Serial Interface, pin PD1 is disconnected from the port and becomes the Serial Data I/O pin for the 2-wire Serial Interface. In this mode, there is a spike filter on the pin to suppress spikes shorter than 50 ns on the input signal, and the pin is driven by an open drain driver with slew-rate limitation</TEXT>
      </PIN26>
      <PIN27>
        <NAME>[PD2:RXD1:INT2]</NAME>
        <TEXT>INT2, External Interrupt source 2. The PD2 pin can serve as external active low interrupt source to the MCU. The internal pull up MOS resistors can be activated as described above. See the interrupt description for further details, and how to enable the source. RXD1, Receive Data (Data input pin for the USART1). When the USART1 receiver is enabled this pin is configured as an input regardless of the value of DDD2. When the USART forces this pin to be an input, the pull-up can still be controlled by the PORTD2 bi</TEXT>
      </PIN27>
      <PIN28>
        <NAME>[PD3:TXD1:INT3]</NAME>
        <TEXT>INT3, External Interrupt source 3. The PD3 pin can serve as external active low interrupt source to the MCU. The internal pull up MOS resistors can be activated as described above. See the interrupt description for further details, and how to enable the source. TXD1, Transmit Data (Data output pin for the USART1). When the USART1 transmitter is enabled, this pin is configured as an output regardless of the value of DDD3.</TEXT>
      </PIN28>
      <PIN29>
        <NAME>[PD4:ICP1]</NAME>
        <TEXT>ICP1 - Input Capture Pin1: The PD4 pin can act as an input capture pin for Timer/Counter1.</TEXT>
      </PIN29>
      <PIN30>
        <NAME>[PD5:XCK1]</NAME>
        <TEXT>XCK1, USART1 external clock. The Data Direction Register (DDD4) controls whether the clock is output (DDD4 set) or input (DDD4 cleared). The XCK1 pin is active only when the USART1 operates in synchronous mode.</TEXT>
      </PIN30>
      <PIN31>
        <NAME>[PD6:T1]</NAME>
        <TEXT>T1, Timer/Counter1 counter source.</TEXT>
      </PIN31>
      <PIN32>
        <NAME>[PD7:T0]</NAME>
        <TEXT>T0, Timer/Counter0 counter source.</TEXT>
      </PIN32>
      <PIN33>
        <NAME>[CLKI]</NAME>
        <TEXT>Input to the internal clock operating circuit of the microcontroller.</TEXT>
      </PIN33>
      <PIN34>
        <NAME>[DEVDD]</NAME>
        <TEXT>Digital external supply voltage (IO)</TEXT>
      </PIN34>
      <PIN35>
        <NAME>[DVSS]</NAME>
        <TEXT>Digital ground supply (IO)</TEXT>
      </PIN35>
      <PIN36>
        <NAME>[PB0:SSN:PCINT0]</NAME>
        <TEXT>SSN: Slave port select input. When the SPI is enabled as a slave, this pin is configured as an input regardless of the setting of DDB0. As a slave, the SPI is activated when this pin is driven low. When the SPI is enabled as a master, the data direction of this pin is controlled by DDB0. When the pin is forced to be an input, the pull-up can still be controlled by the PORTB0 bit.</TEXT>
      </PIN36>
      <PIN37>
        <NAME>[PB1:SCK:PCINT1]</NAME>
        <TEXT>SCK: Master clock output, slave clock input pin for SPI channel. When the SPI is enabled as a slave, this pin is configured as an input regardless of the setting of DDB1. When the SPI is enabled as a master, the data direction of this pin is con-trolled by DDB1. When the pin is forced to be an input, the pull-up can still be controlled by the PORTB1 bit.</TEXT>
      </PIN37>
      <PIN38>
        <NAME>[PB2:MOSI:PDI:PCINT2]</NAME>
        <TEXT>MOSI: SPI Master data output, slave data input for SPI channel. When the SPI is enabled as a slave, this pin is configured as an input regardless of the setting of DDB2. When the SPI is enabled as a master, the data direction of this pin is con-trolled by DDB2. When the pin is forced to be an input, the pull-up can still be controlled by the PORTB2 bit. PDI, Serial Programming Data Input. During Serial Program Downloading, this pin is used as data input line.</TEXT>
      </PIN38>
      <PIN39>
        <NAME>[PB3:MISO:PDO:PCINT3]</NAME>
        <TEXT>MISO: Master data input, slave data output pin for SPI channel. When the SPI is enabled as a master, this pin is configured as an input regardless of the setting of DDB3. When the SPI is enabled as a slave, the data direction of this pin is controlled by DDB3. When the pin is forced to be an input, the pull-up can still be controlled by the PORTB3 bit. PDO, Serial Programming Data Output. During Serial Program Downloading, this pin is used as data output line.</TEXT>
      </PIN39>
      <PIN40>
        <NAME>[PB4:OC2A:PCINT4]</NAME>
        <TEXT>OC2A, Output Compare match output: The PB4 pin can serve as an external output for the Timer/Counter2 output compare. The pin has to be configured as an output (DDB4 set (one)) to serve this function. The OC0 pin is also the output pin for the PWM mode timer function.</TEXT>
      </PIN40>
      <PIN41>
        <NAME>[PB5:OC1A:PCINT5]</NAME>
        <TEXT>OC1A, Output Compare matchA output: The PB5 pin can serve as an external output for the Timer/Counter1 output compareA. The pin has to be configured as an output (DDB5 set (one)) to serve this function. The OC1A pin is also the output pin for the PWM mode timer function.</TEXT>
      </PIN41>
      <PIN42>
        <NAME>[PB6:OC1B:PCINT6]</NAME>
        <TEXT>OC1B, Output Compare matchB output: The PB6 pin can serve as an external output for the Timer/Counter1 output compare B. The pin has to be configured as an output (DDB6 set (one)) to serve this function. The OC1B pin is also the output pin for the PWM mode timer function.</TEXT>
      </PIN42>
      <PIN43>
        <NAME>[PB7:OC0A:OC1C:PCINT7]</NAME>
        <TEXT>OC0A, Output Compare matchA output: The PB7 pin can serve as an external output for the Timer/Counter0 output compare. The pin has to be configured as an output (DDB7 set (one)) to serve this function. The OC0A pin is also the output pin for the PWM mode timer function.</TEXT>
      </PIN43>
      <PIN44>
        <NAME>[DEVDD]</NAME>
        <TEXT>Digital external supply voltage (IO)</TEXT>
      </PIN44>
      <PIN45>
        <NAME>[DVSS]</NAME>
        <TEXT>Digital ground supply (IO)</TEXT>
      </PIN45>
      <PIN46>
        <NAME>[PE0:RXD0:PCINT8]</NAME>
        <TEXT>RXD0, USART0 Receive Pin. Receive Data (Data input pin for the USART0). When the USART0 receiver is enabled this pin is configured as an input regardless of the value of DDRE0. When the USART0 forces this pin to be an input, a logical one in PORTE0 will turn on the internal pull-up.</TEXT>
      </PIN46>
      <PIN47>
        <NAME>[PE1:TXD0]</NAME>
        <TEXT>TXD0, UART0 Transmit Pin.</TEXT>
      </PIN47>
      <PIN48>
        <NAME>[PE2:XCK0:AIN0]</NAME>
        <TEXT>AIN0 - Analog Comparator Positive Input. This pin is directly connected to the positive input of the analog comparator. XCK0, USART0 external clock. The Data Direction Register (DDE2) controls whether the clock is output (DDE2 set) or input (DDE2 cleared). The XCK0 pin is active only when the USART0 operates in synchronous mode.</TEXT>
      </PIN48>
      <PIN49>
        <NAME>[PE3:OC3A:AIN1]</NAME>
        <TEXT>AIN1 - Analog Comparator Negative Input. This pin is directly connected to the negative input of the analog comparator. OC3A, Output Compare matchA output: The PE3 pin can serve as an external output for the Timer/Counter3 output compareA. The pin has to be configured as an output (DDE3 set (one)) to serve this function. The OC3A pin is also the output pin for the PWM mode timer function.</TEXT>
      </PIN49>
      <PIN50>
        <NAME>[PE4:OC3B:INT4]</NAME>
        <TEXT>INT4, External Interrupt source 4: The PE4 pin can serve as an external interrupt source. OC3B, Output Compare matchB output: The PE4 pin can serve as an external output for the Timer/Counter3 output compareB. The pin has to be configured as an output (DDE4 set (one)) to serve this function. The OC3B pin is also the output pin for the PWM mode timer function.</TEXT>
      </PIN50>
      <PIN51>
        <NAME>[PE5:OC3C:INT5]</NAME>
        <TEXT>INT5, External Interrupt source 5: The PE5 pin can serve as an external interrupt source. OC3C, Output Compare matchC output: The PE5 pin can serve as an external output for the Timer/Counter3 output compareC. The pin has to be configured as an output (DDE5 set (one)) to serve this function. The OC3C pin is also the output pin for the PWM mode timer function.</TEXT>
      </PIN51>
      <PIN52>
        <NAME>[PE6:T3:INT6]</NAME>
        <TEXT>INT6, External Interrupt source 6: The PE6 pin can serve as an external interrupt source. T3, Timer/Counter3 counter source.</TEXT>
      </PIN52>
      <PIN53>
        <NAME>[PE7:ICP3:INT7:CLKO]</NAME>
        <TEXT>INT7, External Interrupt source 7: The PE7 pin can serve as an external interrupt source. ICP3, Input Capture Pin3: The PE7 pin can act as an input capture pin for Timer/Counter3. CLKO, Clock output: The PE7 pin will be the output of the divided system clock if the CKOUT Fuse is programmed, regardless of the PORTE7 and DDE7 settings. In this case it will be output during reset.</TEXT>
      </PIN53>
      <PIN54>
        <NAME>[DEVDD]</NAME>
        <TEXT>Digital external supply voltage (IO)</TEXT>
      </PIN54>
      <PIN55>
        <NAME>[DVSS]</NAME>
        <TEXT>Digital ground supply (IO)</TEXT>
      </PIN55>
      <PIN56>
        <NAME>[XTAL2]</NAME>
        <TEXT>Output of the inverting 16MHz amplifier. The XTAL2 pin can serve as an external 16MHz reference clock for the transceiver.</TEXT>
      </PIN56>
      <PIN57>
        <NAME>[XTAL1]</NAME>
        <TEXT>Input to the inverting 16MHz oscillator amplifier.</TEXT>
      </PIN57>
      <PIN58>
        <NAME>[AVSS]</NAME>
        <TEXT>Analog ground and substrate supply</TEXT>
      </PIN58>
      <PIN59>
        <NAME>[EVDD]</NAME>
        <TEXT>External supply voltage for the analog part of the IC.</TEXT>
      </PIN59>
      <PIN60>
        <NAME>[AVDD]</NAME>
        <TEXT>Analog regulated 1.8V supply voltage</TEXT>
      </PIN60>
      <PIN61>
        <NAME>[AVSS:ASVSS]</NAME>
        <TEXT>Analog ground and substrate supply</TEXT>
      </PIN61>
      <PIN62>
        <NAME>[AREF]</NAME>
        <TEXT>Analog voltage reference</TEXT>
      </PIN62>
      <PIN63>
        <NAME>[PF0:ADC0]</NAME>
        <TEXT>Analog to Digital Converter, Channel 0</TEXT>
      </PIN63>
      <PIN64>
        <NAME>[PF1:ADC1]</NAME>
        <TEXT>Analog to Digital Converter, Channel 1</TEXT>
      </PIN64>
      <PADDLE>
        <NAME>[AVSS]</NAME>
        <TEXT>Exposed paddle of the QFN package.</TEXT>
      </PADDLE>
    </QFN>
  </PACKAGE>
  <POWER>
    <CLOCK>4MHz</CLOCK>
    <TEMP>25C</TEMP>
    <ACTIVE>5.0mA</ACTIVE>
    <IDLE>2.2mA</IDLE>
    <POWER_DOWN>&lt;3uA</POWER_DOWN>
  </POWER>
  <PROGVOLT>
    <SER_PROG_MIN_V>1.8</SER_PROG_MIN_V>
    <SER_PROG_MAX_V>3.6</SER_PROG_MAX_V>
    <PAR_PROG_MIN_V>1.8</PAR_PROG_MIN_V>
    <PAR_PROG_MAX_V>3.6</PAR_PROG_MAX_V>
  </PROGVOLT>
  <MEMORY>
    <ID>AVRSimMemory8bit.SimMemory8bit</ID>
    <PROG_FLASH>131072</PROG_FLASH>
    <EEPROM>4096</EEPROM>
    <INT_SRAM>
      <SIZE>16384</SIZE>
      <START_ADDR>$200</START_ADDR>
    </INT_SRAM>
    <EXT_SRAM>
      <SIZE>0</SIZE>
      <START_ADDR>NA</START_ADDR>
    </EXT_SRAM>
    <IO_MEMORY>
      <IO_START_ADDR>$00</IO_START_ADDR>
      <IO_STOP_ADDR>$3F</IO_STOP_ADDR>
      <EXT_IO_START_ADDR>$60</EXT_IO_START_ADDR>
      <EXT_IO_STOP_ADDR>$1FF</EXT_IO_STOP_ADDR>
      <MEM_START_ADDR>$20</MEM_START_ADDR>
      <MEM_STOP_ADDR>$1FF</MEM_STOP_ADDR>
      <TRXFBEND>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$1FF</MEM_ADDR>
        <TRXFBEND0_MASK>0x01</TRXFBEND0_MASK>
        <TRXFBEND1_MASK>0x02</TRXFBEND1_MASK>
        <TRXFBEND2_MASK>0x04</TRXFBEND2_MASK>
        <TRXFBEND3_MASK>0x08</TRXFBEND3_MASK>
        <TRXFBEND4_MASK>0x10</TRXFBEND4_MASK>
        <TRXFBEND5_MASK>0x20</TRXFBEND5_MASK>
        <TRXFBEND6_MASK>0x40</TRXFBEND6_MASK>
        <TRXFBEND7_MASK>0x80</TRXFBEND7_MASK>
      </TRXFBEND>
      <TRXFBST>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$180</MEM_ADDR>
        <TRXFBST0_MASK>0x01</TRXFBST0_MASK>
        <TRXFBST1_MASK>0x02</TRXFBST1_MASK>
        <TRXFBST2_MASK>0x04</TRXFBST2_MASK>
        <TRXFBST3_MASK>0x08</TRXFBST3_MASK>
        <TRXFBST4_MASK>0x10</TRXFBST4_MASK>
        <TRXFBST5_MASK>0x20</TRXFBST5_MASK>
        <TRXFBST6_MASK>0x40</TRXFBST6_MASK>
        <TRXFBST7_MASK>0x80</TRXFBST7_MASK>
      </TRXFBST>
      <TST_RX_LENGTH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$17B</MEM_ADDR>
        <RX_LENGTH0_MASK>0x01</RX_LENGTH0_MASK>
        <RX_LENGTH1_MASK>0x02</RX_LENGTH1_MASK>
        <RX_LENGTH2_MASK>0x04</RX_LENGTH2_MASK>
        <RX_LENGTH3_MASK>0x08</RX_LENGTH3_MASK>
        <RX_LENGTH4_MASK>0x10</RX_LENGTH4_MASK>
        <RX_LENGTH5_MASK>0x20</RX_LENGTH5_MASK>
        <RX_LENGTH6_MASK>0x40</RX_LENGTH6_MASK>
        <RX_LENGTH7_MASK>0x80</RX_LENGTH7_MASK>
      </TST_RX_LENGTH>
      <TST_CTRL_DIGI>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$176</MEM_ADDR>
        <TST_CTRL_DIG0_MASK>0x01</TST_CTRL_DIG0_MASK>
        <TST_CTRL_DIG1_MASK>0x02</TST_CTRL_DIG1_MASK>
        <TST_CTRL_DIG2_MASK>0x04</TST_CTRL_DIG2_MASK>
        <TST_CTRL_DIG3_MASK>0x08</TST_CTRL_DIG3_MASK>
      </TST_CTRL_DIGI>
      <CSMA_BE>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$16F</MEM_ADDR>
        <MIN_BE0_MASK>0x01</MIN_BE0_MASK>
        <MIN_BE1_MASK>0x02</MIN_BE1_MASK>
        <MIN_BE2_MASK>0x04</MIN_BE2_MASK>
        <MIN_BE3_MASK>0x08</MIN_BE3_MASK>
        <MAX_BE0_MASK>0x10</MAX_BE0_MASK>
        <MAX_BE1_MASK>0x20</MAX_BE1_MASK>
        <MAX_BE2_MASK>0x40</MAX_BE2_MASK>
        <MAX_BE3_MASK>0x80</MAX_BE3_MASK>
      </CSMA_BE>
      <CSMA_SEED_1>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$16E</MEM_ADDR>
        <CSMA_SEED_10_MASK>0x01</CSMA_SEED_10_MASK>
        <CSMA_SEED_11_MASK>0x02</CSMA_SEED_11_MASK>
        <CSMA_SEED_12_MASK>0x04</CSMA_SEED_12_MASK>
        <AACK_I_AM_COORD_MASK>0x08</AACK_I_AM_COORD_MASK>
        <AACK_DIS_ACK_MASK>0x10</AACK_DIS_ACK_MASK>
        <AACK_SET_PD_MASK>0x20</AACK_SET_PD_MASK>
        <AACK_FVN_MODE0_MASK>0x40</AACK_FVN_MODE0_MASK>
        <AACK_FVN_MODE1_MASK>0x80</AACK_FVN_MODE1_MASK>
      </CSMA_SEED_1>
      <CSMA_SEED_0>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$16D</MEM_ADDR>
        <CSMA_SEED_00_MASK>0x01</CSMA_SEED_00_MASK>
        <CSMA_SEED_01_MASK>0x02</CSMA_SEED_01_MASK>
        <CSMA_SEED_02_MASK>0x04</CSMA_SEED_02_MASK>
        <CSMA_SEED_03_MASK>0x08</CSMA_SEED_03_MASK>
        <CSMA_SEED_04_MASK>0x10</CSMA_SEED_04_MASK>
        <CSMA_SEED_05_MASK>0x20</CSMA_SEED_05_MASK>
        <CSMA_SEED_06_MASK>0x40</CSMA_SEED_06_MASK>
        <CSMA_SEED_07_MASK>0x80</CSMA_SEED_07_MASK>
      </CSMA_SEED_0>
      <XAH_CTRL_0>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$16C</MEM_ADDR>
        <SLOTTED_OPERATION_MASK>0x01</SLOTTED_OPERATION_MASK>
        <MAX_CSMA_RETRIES0_MASK>0x02</MAX_CSMA_RETRIES0_MASK>
        <MAX_CSMA_RETRIES1_MASK>0x04</MAX_CSMA_RETRIES1_MASK>
        <MAX_CSMA_RETRIES2_MASK>0x08</MAX_CSMA_RETRIES2_MASK>
        <MAX_FRAME_RETRIES0_MASK>0x10</MAX_FRAME_RETRIES0_MASK>
        <MAX_FRAME_RETRIES1_MASK>0x20</MAX_FRAME_RETRIES1_MASK>
        <MAX_FRAME_RETRIES2_MASK>0x40</MAX_FRAME_RETRIES2_MASK>
        <MAX_FRAME_RETRIES3_MASK>0x80</MAX_FRAME_RETRIES3_MASK>
      </XAH_CTRL_0>
      <IEEE_ADDR_7>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$16B</MEM_ADDR>
        <IEEE_ADDR_70_MASK>0x01</IEEE_ADDR_70_MASK>
        <IEEE_ADDR_71_MASK>0x02</IEEE_ADDR_71_MASK>
        <IEEE_ADDR_72_MASK>0x04</IEEE_ADDR_72_MASK>
        <IEEE_ADDR_73_MASK>0x08</IEEE_ADDR_73_MASK>
        <IEEE_ADDR_74_MASK>0x10</IEEE_ADDR_74_MASK>
        <IEEE_ADDR_75_MASK>0x20</IEEE_ADDR_75_MASK>
        <IEEE_ADDR_76_MASK>0x40</IEEE_ADDR_76_MASK>
        <IEEE_ADDR_77_MASK>0x80</IEEE_ADDR_77_MASK>
      </IEEE_ADDR_7>
      <IEEE_ADDR_6>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$16A</MEM_ADDR>
        <IEEE_ADDR_60_MASK>0x01</IEEE_ADDR_60_MASK>
        <IEEE_ADDR_61_MASK>0x02</IEEE_ADDR_61_MASK>
        <IEEE_ADDR_62_MASK>0x04</IEEE_ADDR_62_MASK>
        <IEEE_ADDR_63_MASK>0x08</IEEE_ADDR_63_MASK>
        <IEEE_ADDR_64_MASK>0x10</IEEE_ADDR_64_MASK>
        <IEEE_ADDR_65_MASK>0x20</IEEE_ADDR_65_MASK>
        <IEEE_ADDR_66_MASK>0x40</IEEE_ADDR_66_MASK>
        <IEEE_ADDR_67_MASK>0x80</IEEE_ADDR_67_MASK>
      </IEEE_ADDR_6>
      <IEEE_ADDR_5>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$169</MEM_ADDR>
        <IEEE_ADDR_50_MASK>0x01</IEEE_ADDR_50_MASK>
        <IEEE_ADDR_51_MASK>0x02</IEEE_ADDR_51_MASK>
        <IEEE_ADDR_52_MASK>0x04</IEEE_ADDR_52_MASK>
        <IEEE_ADDR_53_MASK>0x08</IEEE_ADDR_53_MASK>
        <IEEE_ADDR_54_MASK>0x10</IEEE_ADDR_54_MASK>
        <IEEE_ADDR_55_MASK>0x20</IEEE_ADDR_55_MASK>
        <IEEE_ADDR_56_MASK>0x40</IEEE_ADDR_56_MASK>
        <IEEE_ADDR_57_MASK>0x80</IEEE_ADDR_57_MASK>
      </IEEE_ADDR_5>
      <IEEE_ADDR_4>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$168</MEM_ADDR>
        <IEEE_ADDR_40_MASK>0x01</IEEE_ADDR_40_MASK>
        <IEEE_ADDR_41_MASK>0x02</IEEE_ADDR_41_MASK>
        <IEEE_ADDR_42_MASK>0x04</IEEE_ADDR_42_MASK>
        <IEEE_ADDR_43_MASK>0x08</IEEE_ADDR_43_MASK>
        <IEEE_ADDR_44_MASK>0x10</IEEE_ADDR_44_MASK>
        <IEEE_ADDR_45_MASK>0x20</IEEE_ADDR_45_MASK>
        <IEEE_ADDR_46_MASK>0x40</IEEE_ADDR_46_MASK>
        <IEEE_ADDR_47_MASK>0x80</IEEE_ADDR_47_MASK>
      </IEEE_ADDR_4>
      <IEEE_ADDR_3>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$167</MEM_ADDR>
        <IEEE_ADDR_30_MASK>0x01</IEEE_ADDR_30_MASK>
        <IEEE_ADDR_31_MASK>0x02</IEEE_ADDR_31_MASK>
        <IEEE_ADDR_32_MASK>0x04</IEEE_ADDR_32_MASK>
        <IEEE_ADDR_33_MASK>0x08</IEEE_ADDR_33_MASK>
        <IEEE_ADDR_34_MASK>0x10</IEEE_ADDR_34_MASK>
        <IEEE_ADDR_35_MASK>0x20</IEEE_ADDR_35_MASK>
        <IEEE_ADDR_36_MASK>0x40</IEEE_ADDR_36_MASK>
        <IEEE_ADDR_37_MASK>0x80</IEEE_ADDR_37_MASK>
      </IEEE_ADDR_3>
      <IEEE_ADDR_2>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$166</MEM_ADDR>
        <IEEE_ADDR_20_MASK>0x01</IEEE_ADDR_20_MASK>
        <IEEE_ADDR_21_MASK>0x02</IEEE_ADDR_21_MASK>
        <IEEE_ADDR_22_MASK>0x04</IEEE_ADDR_22_MASK>
        <IEEE_ADDR_23_MASK>0x08</IEEE_ADDR_23_MASK>
        <IEEE_ADDR_24_MASK>0x10</IEEE_ADDR_24_MASK>
        <IEEE_ADDR_25_MASK>0x20</IEEE_ADDR_25_MASK>
        <IEEE_ADDR_26_MASK>0x40</IEEE_ADDR_26_MASK>
        <IEEE_ADDR_27_MASK>0x80</IEEE_ADDR_27_MASK>
      </IEEE_ADDR_2>
      <IEEE_ADDR_1>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$165</MEM_ADDR>
        <IEEE_ADDR_10_MASK>0x01</IEEE_ADDR_10_MASK>
        <IEEE_ADDR_11_MASK>0x02</IEEE_ADDR_11_MASK>
        <IEEE_ADDR_12_MASK>0x04</IEEE_ADDR_12_MASK>
        <IEEE_ADDR_13_MASK>0x08</IEEE_ADDR_13_MASK>
        <IEEE_ADDR_14_MASK>0x10</IEEE_ADDR_14_MASK>
        <IEEE_ADDR_15_MASK>0x20</IEEE_ADDR_15_MASK>
        <IEEE_ADDR_16_MASK>0x40</IEEE_ADDR_16_MASK>
        <IEEE_ADDR_17_MASK>0x80</IEEE_ADDR_17_MASK>
      </IEEE_ADDR_1>
      <IEEE_ADDR_0>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$164</MEM_ADDR>
        <IEEE_ADDR_00_MASK>0x01</IEEE_ADDR_00_MASK>
        <IEEE_ADDR_01_MASK>0x02</IEEE_ADDR_01_MASK>
        <IEEE_ADDR_02_MASK>0x04</IEEE_ADDR_02_MASK>
        <IEEE_ADDR_03_MASK>0x08</IEEE_ADDR_03_MASK>
        <IEEE_ADDR_04_MASK>0x10</IEEE_ADDR_04_MASK>
        <IEEE_ADDR_05_MASK>0x20</IEEE_ADDR_05_MASK>
        <IEEE_ADDR_06_MASK>0x40</IEEE_ADDR_06_MASK>
        <IEEE_ADDR_07_MASK>0x80</IEEE_ADDR_07_MASK>
      </IEEE_ADDR_0>
      <PAN_ID_1>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$163</MEM_ADDR>
        <PAN_ID_10_MASK>0x01</PAN_ID_10_MASK>
        <PAN_ID_11_MASK>0x02</PAN_ID_11_MASK>
        <PAN_ID_12_MASK>0x04</PAN_ID_12_MASK>
        <PAN_ID_13_MASK>0x08</PAN_ID_13_MASK>
        <PAN_ID_14_MASK>0x10</PAN_ID_14_MASK>
        <PAN_ID_15_MASK>0x20</PAN_ID_15_MASK>
        <PAN_ID_16_MASK>0x40</PAN_ID_16_MASK>
        <PAN_ID_17_MASK>0x80</PAN_ID_17_MASK>
      </PAN_ID_1>
      <PAN_ID_0>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$162</MEM_ADDR>
        <PAN_ID_00_MASK>0x01</PAN_ID_00_MASK>
        <PAN_ID_01_MASK>0x02</PAN_ID_01_MASK>
        <PAN_ID_02_MASK>0x04</PAN_ID_02_MASK>
        <PAN_ID_03_MASK>0x08</PAN_ID_03_MASK>
        <PAN_ID_04_MASK>0x10</PAN_ID_04_MASK>
        <PAN_ID_05_MASK>0x20</PAN_ID_05_MASK>
        <PAN_ID_06_MASK>0x40</PAN_ID_06_MASK>
        <PAN_ID_07_MASK>0x80</PAN_ID_07_MASK>
      </PAN_ID_0>
      <SHORT_ADDR_1>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$161</MEM_ADDR>
        <SHORT_ADDR_10_MASK>0x01</SHORT_ADDR_10_MASK>
        <SHORT_ADDR_11_MASK>0x02</SHORT_ADDR_11_MASK>
        <SHORT_ADDR_12_MASK>0x04</SHORT_ADDR_12_MASK>
        <SHORT_ADDR_13_MASK>0x08</SHORT_ADDR_13_MASK>
        <SHORT_ADDR_14_MASK>0x10</SHORT_ADDR_14_MASK>
        <SHORT_ADDR_15_MASK>0x20</SHORT_ADDR_15_MASK>
        <SHORT_ADDR_16_MASK>0x40</SHORT_ADDR_16_MASK>
        <SHORT_ADDR_17_MASK>0x80</SHORT_ADDR_17_MASK>
      </SHORT_ADDR_1>
      <SHORT_ADDR_0>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$160</MEM_ADDR>
        <SHORT_ADDR_00_MASK>0x01</SHORT_ADDR_00_MASK>
        <SHORT_ADDR_01_MASK>0x02</SHORT_ADDR_01_MASK>
        <SHORT_ADDR_02_MASK>0x04</SHORT_ADDR_02_MASK>
        <SHORT_ADDR_03_MASK>0x08</SHORT_ADDR_03_MASK>
        <SHORT_ADDR_04_MASK>0x10</SHORT_ADDR_04_MASK>
        <SHORT_ADDR_05_MASK>0x20</SHORT_ADDR_05_MASK>
        <SHORT_ADDR_06_MASK>0x40</SHORT_ADDR_06_MASK>
        <SHORT_ADDR_07_MASK>0x80</SHORT_ADDR_07_MASK>
      </SHORT_ADDR_0>
      <MAN_ID_1>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$15F</MEM_ADDR>
        <MAN_ID_10_MASK>0x01</MAN_ID_10_MASK>
        <MAN_ID_11_MASK>0x02</MAN_ID_11_MASK>
        <MAN_ID_12_MASK>0x04</MAN_ID_12_MASK>
        <MAN_ID_13_MASK>0x08</MAN_ID_13_MASK>
        <MAN_ID_14_MASK>0x10</MAN_ID_14_MASK>
        <MAN_ID_15_MASK>0x20</MAN_ID_15_MASK>
        <MAN_ID_16_MASK>0x40</MAN_ID_16_MASK>
        <MAN_ID_17_MASK>0x80</MAN_ID_17_MASK>
      </MAN_ID_1>
      <MAN_ID_0>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$15E</MEM_ADDR>
        <MAN_ID_00_MASK>0x01</MAN_ID_00_MASK>
        <MAN_ID_01_MASK>0x02</MAN_ID_01_MASK>
        <MAN_ID_02_MASK>0x04</MAN_ID_02_MASK>
        <MAN_ID_03_MASK>0x08</MAN_ID_03_MASK>
        <MAN_ID_04_MASK>0x10</MAN_ID_04_MASK>
        <MAN_ID_05_MASK>0x20</MAN_ID_05_MASK>
        <MAN_ID_06_MASK>0x40</MAN_ID_06_MASK>
        <MAN_ID_07_MASK>0x80</MAN_ID_07_MASK>
      </MAN_ID_0>
      <VERSION_NUM>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$15D</MEM_ADDR>
        <VERSION_NUM0_MASK>0x01</VERSION_NUM0_MASK>
        <VERSION_NUM1_MASK>0x02</VERSION_NUM1_MASK>
        <VERSION_NUM2_MASK>0x04</VERSION_NUM2_MASK>
        <VERSION_NUM3_MASK>0x08</VERSION_NUM3_MASK>
        <VERSION_NUM4_MASK>0x10</VERSION_NUM4_MASK>
        <VERSION_NUM5_MASK>0x20</VERSION_NUM5_MASK>
        <VERSION_NUM6_MASK>0x40</VERSION_NUM6_MASK>
        <VERSION_NUM7_MASK>0x80</VERSION_NUM7_MASK>
      </VERSION_NUM>
      <PART_NUM>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$15C</MEM_ADDR>
        <PART_NUM0_MASK>0x01</PART_NUM0_MASK>
        <PART_NUM1_MASK>0x02</PART_NUM1_MASK>
        <PART_NUM2_MASK>0x04</PART_NUM2_MASK>
        <PART_NUM3_MASK>0x08</PART_NUM3_MASK>
        <PART_NUM4_MASK>0x10</PART_NUM4_MASK>
        <PART_NUM5_MASK>0x20</PART_NUM5_MASK>
        <PART_NUM6_MASK>0x40</PART_NUM6_MASK>
        <PART_NUM7_MASK>0x80</PART_NUM7_MASK>
      </PART_NUM>
      <PLL_DCU>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$15B</MEM_ADDR>
        <PLL_DCU_START_MASK>0x80</PLL_DCU_START_MASK>
      </PLL_DCU>
      <PLL_CF>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$15A</MEM_ADDR>
        <PLL_CF_START_MASK>0x80</PLL_CF_START_MASK>
      </PLL_CF>
      <FTN_CTRL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$158</MEM_ADDR>
        <FTN_START_MASK>0x80</FTN_START_MASK>
      </FTN_CTRL>
      <XAH_CTRL_1>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$157</MEM_ADDR>
        <Res_MASK>0x01</Res_MASK>
        <AACK_PROM_MODE_MASK>0x02</AACK_PROM_MODE_MASK>
        <AACK_ACK_TIME_MASK>0x04</AACK_ACK_TIME_MASK>
        <AACK_UPLD_RES_FT_MASK>0x10</AACK_UPLD_RES_FT_MASK>
        <AACK_FLTR_RES_FT_MASK>0x20</AACK_FLTR_RES_FT_MASK>
        <Res0_MASK>0x40</Res0_MASK>
        <Res1_MASK>0x80</Res1_MASK>
      </XAH_CTRL_1>
      <RX_SYN>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$155</MEM_ADDR>
        <RX_PDT_LEVEL0_MASK>0x01</RX_PDT_LEVEL0_MASK>
        <RX_PDT_LEVEL1_MASK>0x02</RX_PDT_LEVEL1_MASK>
        <RX_PDT_LEVEL2_MASK>0x04</RX_PDT_LEVEL2_MASK>
        <RX_PDT_LEVEL3_MASK>0x08</RX_PDT_LEVEL3_MASK>
        <Res0_MASK>0x10</Res0_MASK>
        <Res1_MASK>0x20</Res1_MASK>
        <Res2_MASK>0x40</Res2_MASK>
        <RX_PDT_DIS_MASK>0x80</RX_PDT_DIS_MASK>
      </RX_SYN>
      <XOSC_CTRL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$152</MEM_ADDR>
        <XTAL_TRIM0_MASK>0x01</XTAL_TRIM0_MASK>
        <XTAL_TRIM1_MASK>0x02</XTAL_TRIM1_MASK>
        <XTAL_TRIM2_MASK>0x04</XTAL_TRIM2_MASK>
        <XTAL_TRIM3_MASK>0x08</XTAL_TRIM3_MASK>
        <XTAL_MODE0_MASK>0x10</XTAL_MODE0_MASK>
        <XTAL_MODE1_MASK>0x20</XTAL_MODE1_MASK>
        <XTAL_MODE2_MASK>0x40</XTAL_MODE2_MASK>
        <XTAL_MODE3_MASK>0x80</XTAL_MODE3_MASK>
      </XOSC_CTRL>
      <BATMON>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$151</MEM_ADDR>
        <BATMON_VTH0_MASK>0x01</BATMON_VTH0_MASK>
        <BATMON_VTH1_MASK>0x02</BATMON_VTH1_MASK>
        <BATMON_VTH2_MASK>0x04</BATMON_VTH2_MASK>
        <BATMON_VTH3_MASK>0x08</BATMON_VTH3_MASK>
        <BATMON_HR_MASK>0x10</BATMON_HR_MASK>
        <BATMON_OK_MASK>0x20</BATMON_OK_MASK>
        <BAT_LOW_EN_MASK>0x40</BAT_LOW_EN_MASK>
        <BAT_LOW_MASK>0x80</BAT_LOW_MASK>
      </BATMON>
      <VREG_CTRL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$150</MEM_ADDR>
        <DVDD_OK_MASK>0x04</DVDD_OK_MASK>
        <DVREG_EXT_MASK>0x08</DVREG_EXT_MASK>
        <AVDD_OK_MASK>0x40</AVDD_OK_MASK>
        <AVREG_EXT_MASK>0x80</AVREG_EXT_MASK>
      </VREG_CTRL>
      <IRQ_STATUS>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$14F</MEM_ADDR>
        <PLL_LOCK_MASK>0x01</PLL_LOCK_MASK>
        <PLL_UNLOCK_MASK>0x02</PLL_UNLOCK_MASK>
        <RX_START_MASK>0x04</RX_START_MASK>
        <RX_END_MASK>0x08</RX_END_MASK>
        <CCA_ED_DONE_MASK>0x10</CCA_ED_DONE_MASK>
        <AMI_MASK>0x20</AMI_MASK>
        <TX_END_MASK>0x40</TX_END_MASK>
        <AWAKE_MASK>0x80</AWAKE_MASK>
      </IRQ_STATUS>
      <IRQ_MASK>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$14E</MEM_ADDR>
        <PLL_LOCK_EN_MASK>0x01</PLL_LOCK_EN_MASK>
        <PLL_UNLOCK_EN_MASK>0x02</PLL_UNLOCK_EN_MASK>
        <RX_START_EN_MASK>0x04</RX_START_EN_MASK>
        <RX_END_EN_MASK>0x08</RX_END_EN_MASK>
        <CCA_ED_DONE_EN_MASK>0x10</CCA_ED_DONE_EN_MASK>
        <AMI_EN_MASK>0x20</AMI_EN_MASK>
        <TX_END_EN_MASK>0x40</TX_END_EN_MASK>
        <AWAKE_EN_MASK>0x80</AWAKE_EN_MASK>
      </IRQ_MASK>
      <ANT_DIV>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$14D</MEM_ADDR>
        <ANT_CTRL0_MASK>0x01</ANT_CTRL0_MASK>
        <ANT_CTRL1_MASK>0x02</ANT_CTRL1_MASK>
        <ANT_EXT_SW_EN_MASK>0x04</ANT_EXT_SW_EN_MASK>
        <ANT_DIV_EN_MASK>0x08</ANT_DIV_EN_MASK>
        <Res0_MASK>0x10</Res0_MASK>
        <Res1_MASK>0x20</Res1_MASK>
        <Res2_MASK>0x40</Res2_MASK>
        <ANT_SEL_MASK>0x80</ANT_SEL_MASK>
      </ANT_DIV>
      <TRX_CTRL_2>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$14C</MEM_ADDR>
        <OQPSK_DATA_RATE0_MASK>0x01</OQPSK_DATA_RATE0_MASK>
        <OQPSK_DATA_RATE1_MASK>0x02</OQPSK_DATA_RATE1_MASK>
        <Res0_MASK>0x04</Res0_MASK>
        <Res1_MASK>0x08</Res1_MASK>
        <Res2_MASK>0x10</Res2_MASK>
        <Res3_MASK>0x20</Res3_MASK>
        <Res4_MASK>0x40</Res4_MASK>
        <RX_SAFE_MODE_MASK>0x80</RX_SAFE_MODE_MASK>
      </TRX_CTRL_2>
      <SFD_VALUE>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$14B</MEM_ADDR>
        <SFD_VALUE0_MASK>0x01</SFD_VALUE0_MASK>
        <SFD_VALUE1_MASK>0x02</SFD_VALUE1_MASK>
        <SFD_VALUE2_MASK>0x04</SFD_VALUE2_MASK>
        <SFD_VALUE3_MASK>0x08</SFD_VALUE3_MASK>
        <SFD_VALUE4_MASK>0x10</SFD_VALUE4_MASK>
        <SFD_VALUE5_MASK>0x20</SFD_VALUE5_MASK>
        <SFD_VALUE6_MASK>0x40</SFD_VALUE6_MASK>
        <SFD_VALUE7_MASK>0x80</SFD_VALUE7_MASK>
      </SFD_VALUE>
      <RX_CTRL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$14A</MEM_ADDR>
        <PDT_THRES0_MASK>0x01</PDT_THRES0_MASK>
        <PDT_THRES1_MASK>0x02</PDT_THRES1_MASK>
        <PDT_THRES2_MASK>0x04</PDT_THRES2_MASK>
        <PDT_THRES3_MASK>0x08</PDT_THRES3_MASK>
      </RX_CTRL>
      <CCA_THRES>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$149</MEM_ADDR>
        <CCA_ED_THRES0_MASK>0x01</CCA_ED_THRES0_MASK>
        <CCA_ED_THRES1_MASK>0x02</CCA_ED_THRES1_MASK>
        <CCA_ED_THRES2_MASK>0x04</CCA_ED_THRES2_MASK>
        <CCA_ED_THRES3_MASK>0x08</CCA_ED_THRES3_MASK>
        <CCA_CS_THRES0_MASK>0x10</CCA_CS_THRES0_MASK>
        <CCA_CS_THRES1_MASK>0x20</CCA_CS_THRES1_MASK>
        <CCA_CS_THRES2_MASK>0x40</CCA_CS_THRES2_MASK>
        <CCA_CS_THRES3_MASK>0x80</CCA_CS_THRES3_MASK>
      </CCA_THRES>
      <PHY_CC_CCA>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$148</MEM_ADDR>
        <CHANNEL0_MASK>0x01</CHANNEL0_MASK>
        <CHANNEL1_MASK>0x02</CHANNEL1_MASK>
        <CHANNEL2_MASK>0x04</CHANNEL2_MASK>
        <CHANNEL3_MASK>0x08</CHANNEL3_MASK>
        <CHANNEL4_MASK>0x10</CHANNEL4_MASK>
        <CCA_MODE0_MASK>0x20</CCA_MODE0_MASK>
        <CCA_MODE1_MASK>0x40</CCA_MODE1_MASK>
        <CCA_REQUEST_MASK>0x80</CCA_REQUEST_MASK>
      </PHY_CC_CCA>
      <PHY_ED_LEVEL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$147</MEM_ADDR>
        <ED_LEVEL0_MASK>0x01</ED_LEVEL0_MASK>
        <ED_LEVEL1_MASK>0x02</ED_LEVEL1_MASK>
        <ED_LEVEL2_MASK>0x04</ED_LEVEL2_MASK>
        <ED_LEVEL3_MASK>0x08</ED_LEVEL3_MASK>
        <ED_LEVEL4_MASK>0x10</ED_LEVEL4_MASK>
        <ED_LEVEL5_MASK>0x20</ED_LEVEL5_MASK>
        <ED_LEVEL6_MASK>0x40</ED_LEVEL6_MASK>
        <ED_LEVEL7_MASK>0x80</ED_LEVEL7_MASK>
      </PHY_ED_LEVEL>
      <PHY_RSSI>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$146</MEM_ADDR>
        <RSSI0_MASK>0x01</RSSI0_MASK>
        <RSSI1_MASK>0x02</RSSI1_MASK>
        <RSSI2_MASK>0x04</RSSI2_MASK>
        <RSSI3_MASK>0x08</RSSI3_MASK>
        <RSSI4_MASK>0x10</RSSI4_MASK>
        <RND_VALUE0_MASK>0x20</RND_VALUE0_MASK>
        <RND_VALUE1_MASK>0x40</RND_VALUE1_MASK>
        <RX_CRC_VALID_MASK>0x80</RX_CRC_VALID_MASK>
      </PHY_RSSI>
      <PHY_TX_PWR>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$145</MEM_ADDR>
        <TX_PWR0_MASK>0x01</TX_PWR0_MASK>
        <TX_PWR1_MASK>0x02</TX_PWR1_MASK>
        <TX_PWR2_MASK>0x04</TX_PWR2_MASK>
        <TX_PWR3_MASK>0x08</TX_PWR3_MASK>
        <PA_LT0_MASK>0x10</PA_LT0_MASK>
        <PA_LT1_MASK>0x20</PA_LT1_MASK>
        <PA_BUF_LT0_MASK>0x40</PA_BUF_LT0_MASK>
        <PA_BUF_LT1_MASK>0x80</PA_BUF_LT1_MASK>
      </PHY_TX_PWR>
      <TRX_CTRL_1>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$144</MEM_ADDR>
        <Res0_MASK>0x01</Res0_MASK>
        <Res1_MASK>0x02</Res1_MASK>
        <Res2_MASK>0x04</Res2_MASK>
        <Res3_MASK>0x08</Res3_MASK>
        <Res4_MASK>0x10</Res4_MASK>
        <TX_AUTO_CRC_ON_MASK>0x20</TX_AUTO_CRC_ON_MASK>
        <IRQ_2_EXT_EN_MASK>0x40</IRQ_2_EXT_EN_MASK>
        <PA_EXT_EN_MASK>0x80</PA_EXT_EN_MASK>
      </TRX_CTRL_1>
      <TRX_CTRL_0>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$143</MEM_ADDR>
        <Res0_MASK>0x01</Res0_MASK>
        <Res1_MASK>0x02</Res1_MASK>
        <Res2_MASK>0x04</Res2_MASK>
        <Res3_MASK>0x08</Res3_MASK>
        <Res4_MASK>0x10</Res4_MASK>
        <Res5_MASK>0x20</Res5_MASK>
        <Res6_MASK>0x40</Res6_MASK>
        <Res7_MASK>0x80</Res7_MASK>
      </TRX_CTRL_0>
      <TRX_STATE>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$142</MEM_ADDR>
        <TRX_CMD0_MASK>0x01</TRX_CMD0_MASK>
        <TRX_CMD1_MASK>0x02</TRX_CMD1_MASK>
        <TRX_CMD2_MASK>0x04</TRX_CMD2_MASK>
        <TRX_CMD3_MASK>0x08</TRX_CMD3_MASK>
        <TRX_CMD4_MASK>0x10</TRX_CMD4_MASK>
        <TRAC_STATUS0_MASK>0x20</TRAC_STATUS0_MASK>
        <TRAC_STATUS1_MASK>0x40</TRAC_STATUS1_MASK>
        <TRAC_STATUS2_MASK>0x80</TRAC_STATUS2_MASK>
      </TRX_STATE>
      <TRX_STATUS>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$141</MEM_ADDR>
        <TRX_STATUS0_MASK>0x01</TRX_STATUS0_MASK>
        <TRX_STATUS1_MASK>0x02</TRX_STATUS1_MASK>
        <TRX_STATUS2_MASK>0x04</TRX_STATUS2_MASK>
        <TRX_STATUS3_MASK>0x08</TRX_STATUS3_MASK>
        <TRX_STATUS4_MASK>0x10</TRX_STATUS4_MASK>
        <TST_STATUS_MASK>0x20</TST_STATUS_MASK>
        <CCA_STATUS_MASK>0x40</CCA_STATUS_MASK>
        <CCA_DONE_MASK>0x80</CCA_DONE_MASK>
      </TRX_STATUS>
      <AES_KEY>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$13F</MEM_ADDR>
        <AES_KEY0_MASK>0x01</AES_KEY0_MASK>
        <AES_KEY1_MASK>0x02</AES_KEY1_MASK>
        <AES_KEY2_MASK>0x04</AES_KEY2_MASK>
        <AES_KEY3_MASK>0x08</AES_KEY3_MASK>
        <AES_KEY4_MASK>0x10</AES_KEY4_MASK>
        <AES_KEY5_MASK>0x20</AES_KEY5_MASK>
        <AES_KEY6_MASK>0x40</AES_KEY6_MASK>
        <AES_KEY7_MASK>0x80</AES_KEY7_MASK>
      </AES_KEY>
      <AES_STATE>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$13E</MEM_ADDR>
        <AES_STATE0_MASK>0x01</AES_STATE0_MASK>
        <AES_STATE1_MASK>0x02</AES_STATE1_MASK>
        <AES_STATE2_MASK>0x04</AES_STATE2_MASK>
        <AES_STATE3_MASK>0x08</AES_STATE3_MASK>
        <AES_STATE4_MASK>0x10</AES_STATE4_MASK>
        <AES_STATE5_MASK>0x20</AES_STATE5_MASK>
        <AES_STATE6_MASK>0x40</AES_STATE6_MASK>
        <AES_STATE7_MASK>0x80</AES_STATE7_MASK>
      </AES_STATE>
      <AES_STATUS>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$13D</MEM_ADDR>
        <AES_DONE_MASK>0x01</AES_DONE_MASK>
        <Res0_MASK>0x02</Res0_MASK>
        <Res1_MASK>0x04</Res1_MASK>
        <Res2_MASK>0x08</Res2_MASK>
        <Res3_MASK>0x10</Res3_MASK>
        <Res4_MASK>0x20</Res4_MASK>
        <Res5_MASK>0x40</Res5_MASK>
        <AES_ER_MASK>0x80</AES_ER_MASK>
      </AES_STATUS>
      <AES_CTRL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$13C</MEM_ADDR>
        <Res0_MASK>0x01</Res0_MASK>
        <Res1_MASK>0x02</Res1_MASK>
        <AES_IM_MASK>0x04</AES_IM_MASK>
        <AES_DIR_MASK>0x08</AES_DIR_MASK>
        <Res_MASK>0x10</Res_MASK>
        <AES_MODE_MASK>0x20</AES_MODE_MASK>
        <AES_REQUEST_MASK>0x80</AES_REQUEST_MASK>
      </AES_CTRL>
      <TRXPR>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$139</MEM_ADDR>
        <TRXRST_MASK>0x01</TRXRST_MASK>
        <SLPTR_MASK>0x02</SLPTR_MASK>
        <Res0_MASK>0x10</Res0_MASK>
        <Res1_MASK>0x20</Res1_MASK>
        <Res2_MASK>0x40</Res2_MASK>
        <Res3_MASK>0x80</Res3_MASK>
      </TRXPR>
      <DPDS1>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$137</MEM_ADDR>
        <PGDRV0_MASK>0x01</PGDRV0_MASK>
        <PGDRV1_MASK>0x02</PGDRV1_MASK>
        <Res0_MASK>0x04</Res0_MASK>
        <Res1_MASK>0x08</Res1_MASK>
        <Res2_MASK>0x10</Res2_MASK>
        <Res3_MASK>0x20</Res3_MASK>
        <Res4_MASK>0x40</Res4_MASK>
        <Res5_MASK>0x80</Res5_MASK>
      </DPDS1>
      <DPDS0>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$136</MEM_ADDR>
        <PBDRV0_MASK>0x01</PBDRV0_MASK>
        <PBDRV1_MASK>0x02</PBDRV1_MASK>
        <PDDRV0_MASK>0x04</PDDRV0_MASK>
        <PDDRV1_MASK>0x08</PDDRV1_MASK>
        <PEDRV0_MASK>0x10</PEDRV0_MASK>
        <PEDRV1_MASK>0x20</PEDRV1_MASK>
        <PFDRV0_MASK>0x40</PFDRV0_MASK>
        <PFDRV1_MASK>0x80</PFDRV1_MASK>
      </DPDS0>
      <DRTRAM0>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$135</MEM_ADDR>
        <ENDRT_MASK>0x10</ENDRT_MASK>
        <DRTSWOK_MASK>0x20</DRTSWOK_MASK>
        <Res0_MASK>0x40</Res0_MASK>
        <Res1_MASK>0x80</Res1_MASK>
      </DRTRAM0>
      <DRTRAM1>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$134</MEM_ADDR>
        <ENDRT_MASK>0x10</ENDRT_MASK>
        <DRTSWOK_MASK>0x20</DRTSWOK_MASK>
        <Res0_MASK>0x40</Res0_MASK>
        <Res1_MASK>0x80</Res1_MASK>
      </DRTRAM1>
      <DRTRAM2>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$133</MEM_ADDR>
        <ENDRT_MASK>0x10</ENDRT_MASK>
        <DRTSWOK_MASK>0x20</DRTSWOK_MASK>
        <Res_MASK>0x40</Res_MASK>
      </DRTRAM2>
      <DRTRAM3>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$132</MEM_ADDR>
        <ENDRT_MASK>0x10</ENDRT_MASK>
        <DRTSWOK_MASK>0x20</DRTSWOK_MASK>
        <Res0_MASK>0x40</Res0_MASK>
        <Res1_MASK>0x80</Res1_MASK>
      </DRTRAM3>
      <LLDRH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$131</MEM_ADDR>
        <LLDRH0_MASK>0x01</LLDRH0_MASK>
        <LLDRH1_MASK>0x02</LLDRH1_MASK>
        <LLDRH2_MASK>0x04</LLDRH2_MASK>
        <LLDRH3_MASK>0x08</LLDRH3_MASK>
        <LLDRH4_MASK>0x10</LLDRH4_MASK>
        <Res0_MASK>0x20</Res0_MASK>
        <Res1_MASK>0x40</Res1_MASK>
        <Res2_MASK>0x80</Res2_MASK>
      </LLDRH>
      <LLDRL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$130</MEM_ADDR>
        <LLDRL0_MASK>0x01</LLDRL0_MASK>
        <LLDRL1_MASK>0x02</LLDRL1_MASK>
        <LLDRL2_MASK>0x04</LLDRL2_MASK>
        <LLDRL3_MASK>0x08</LLDRL3_MASK>
        <Res0_MASK>0x10</Res0_MASK>
        <Res1_MASK>0x20</Res1_MASK>
        <Res2_MASK>0x40</Res2_MASK>
        <Res3_MASK>0x80</Res3_MASK>
      </LLDRL>
      <LLCR>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$12F</MEM_ADDR>
        <LLENCAL_MASK>0x01</LLENCAL_MASK>
        <LLSHORT_MASK>0x02</LLSHORT_MASK>
        <LLTCO_MASK>0x04</LLTCO_MASK>
        <LLCAL_MASK>0x08</LLCAL_MASK>
        <LLCOMP_MASK>0x10</LLCOMP_MASK>
        <LLDONE_MASK>0x20</LLDONE_MASK>
        <Res0_MASK>0x40</Res0_MASK>
        <Res1_MASK>0x80</Res1_MASK>
      </LLCR>
      <OCR5CH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$12D</MEM_ADDR>
        <OCR5CH0_MASK>0x01</OCR5CH0_MASK>
        <OCR5CH1_MASK>0x02</OCR5CH1_MASK>
        <OCR5CH2_MASK>0x04</OCR5CH2_MASK>
        <OCR5CH3_MASK>0x08</OCR5CH3_MASK>
        <OCR5CH4_MASK>0x10</OCR5CH4_MASK>
        <OCR5CH5_MASK>0x20</OCR5CH5_MASK>
        <OCR5CH6_MASK>0x40</OCR5CH6_MASK>
        <OCR5CH7_MASK>0x80</OCR5CH7_MASK>
      </OCR5CH>
      <OCR5CL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$12C</MEM_ADDR>
        <OCR5CL0_MASK>0x01</OCR5CL0_MASK>
        <OCR5CL1_MASK>0x02</OCR5CL1_MASK>
        <OCR5CL2_MASK>0x04</OCR5CL2_MASK>
        <OCR5CL3_MASK>0x08</OCR5CL3_MASK>
        <OCR5CL4_MASK>0x10</OCR5CL4_MASK>
        <OCR5CL5_MASK>0x20</OCR5CL5_MASK>
        <OCR5CL6_MASK>0x40</OCR5CL6_MASK>
        <OCR5CL7_MASK>0x80</OCR5CL7_MASK>
      </OCR5CL>
      <OCR5BH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$12B</MEM_ADDR>
        <OCR5BH0_MASK>0x01</OCR5BH0_MASK>
        <OCR5BH1_MASK>0x02</OCR5BH1_MASK>
        <OCR5BH2_MASK>0x04</OCR5BH2_MASK>
        <OCR5BH3_MASK>0x08</OCR5BH3_MASK>
        <OCR5BH4_MASK>0x10</OCR5BH4_MASK>
        <OCR5BH5_MASK>0x20</OCR5BH5_MASK>
        <OCR5BH6_MASK>0x40</OCR5BH6_MASK>
        <OCR5BH7_MASK>0x80</OCR5BH7_MASK>
      </OCR5BH>
      <OCR5BL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$12A</MEM_ADDR>
        <OCR5BL0_MASK>0x01</OCR5BL0_MASK>
        <OCR5BL1_MASK>0x02</OCR5BL1_MASK>
        <OCR5BL2_MASK>0x04</OCR5BL2_MASK>
        <OCR5BL3_MASK>0x08</OCR5BL3_MASK>
        <OCR5BL4_MASK>0x10</OCR5BL4_MASK>
        <OCR5BL5_MASK>0x20</OCR5BL5_MASK>
        <OCR5BL6_MASK>0x40</OCR5BL6_MASK>
        <OCR5BL7_MASK>0x80</OCR5BL7_MASK>
      </OCR5BL>
      <OCR5AH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$129</MEM_ADDR>
        <OCR5AH0_MASK>0x01</OCR5AH0_MASK>
        <OCR5AH1_MASK>0x02</OCR5AH1_MASK>
        <OCR5AH2_MASK>0x04</OCR5AH2_MASK>
        <OCR5AH3_MASK>0x08</OCR5AH3_MASK>
        <OCR5AH4_MASK>0x10</OCR5AH4_MASK>
        <OCR5AH5_MASK>0x20</OCR5AH5_MASK>
        <OCR5AH6_MASK>0x40</OCR5AH6_MASK>
        <OCR5AH7_MASK>0x80</OCR5AH7_MASK>
      </OCR5AH>
      <OCR5AL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$128</MEM_ADDR>
        <OCR5AL0_MASK>0x01</OCR5AL0_MASK>
        <OCR5AL1_MASK>0x02</OCR5AL1_MASK>
        <OCR5AL2_MASK>0x04</OCR5AL2_MASK>
        <OCR5AL3_MASK>0x08</OCR5AL3_MASK>
        <OCR5AL4_MASK>0x10</OCR5AL4_MASK>
        <OCR5AL5_MASK>0x20</OCR5AL5_MASK>
        <OCR5AL6_MASK>0x40</OCR5AL6_MASK>
        <OCR5AL7_MASK>0x80</OCR5AL7_MASK>
      </OCR5AL>
      <ICR5H>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$127</MEM_ADDR>
        <ICR5H0_MASK>0x01</ICR5H0_MASK>
        <ICR5H1_MASK>0x02</ICR5H1_MASK>
        <ICR5H2_MASK>0x04</ICR5H2_MASK>
        <ICR5H3_MASK>0x08</ICR5H3_MASK>
        <ICR5H4_MASK>0x10</ICR5H4_MASK>
        <ICR5H5_MASK>0x20</ICR5H5_MASK>
        <ICR5H6_MASK>0x40</ICR5H6_MASK>
        <ICR5H7_MASK>0x80</ICR5H7_MASK>
      </ICR5H>
      <ICR5L>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$126</MEM_ADDR>
        <ICR5L0_MASK>0x01</ICR5L0_MASK>
        <ICR5L1_MASK>0x02</ICR5L1_MASK>
        <ICR5L2_MASK>0x04</ICR5L2_MASK>
        <ICR5L3_MASK>0x08</ICR5L3_MASK>
        <ICR5L4_MASK>0x10</ICR5L4_MASK>
        <ICR5L5_MASK>0x20</ICR5L5_MASK>
        <ICR5L6_MASK>0x40</ICR5L6_MASK>
        <ICR5L7_MASK>0x80</ICR5L7_MASK>
      </ICR5L>
      <TCNT5H>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$125</MEM_ADDR>
        <TCNT5H0_MASK>0x01</TCNT5H0_MASK>
        <TCNT5H1_MASK>0x02</TCNT5H1_MASK>
        <TCNT5H2_MASK>0x04</TCNT5H2_MASK>
        <TCNT5H3_MASK>0x08</TCNT5H3_MASK>
        <TCNT5H4_MASK>0x10</TCNT5H4_MASK>
        <TCNT5H5_MASK>0x20</TCNT5H5_MASK>
        <TCNT5H6_MASK>0x40</TCNT5H6_MASK>
        <TCNT5H7_MASK>0x80</TCNT5H7_MASK>
      </TCNT5H>
      <TCNT5L>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$124</MEM_ADDR>
        <TCNT5L0_MASK>0x01</TCNT5L0_MASK>
        <TCNT5L1_MASK>0x02</TCNT5L1_MASK>
        <TCNT5L2_MASK>0x04</TCNT5L2_MASK>
        <TCNT5L3_MASK>0x08</TCNT5L3_MASK>
        <TCNT5L4_MASK>0x10</TCNT5L4_MASK>
        <TCNT5L5_MASK>0x20</TCNT5L5_MASK>
        <TCNT5L6_MASK>0x40</TCNT5L6_MASK>
        <TCNT5L7_MASK>0x80</TCNT5L7_MASK>
      </TCNT5L>
      <TCCR5C>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$122</MEM_ADDR>
        <Res0_MASK>0x01</Res0_MASK>
        <Res1_MASK>0x02</Res1_MASK>
        <Res2_MASK>0x04</Res2_MASK>
        <Res3_MASK>0x08</Res3_MASK>
        <Res4_MASK>0x10</Res4_MASK>
        <FOC5C_MASK>0x20</FOC5C_MASK>
        <FOC5B_MASK>0x40</FOC5B_MASK>
        <FOC5A_MASK>0x80</FOC5A_MASK>
      </TCCR5C>
      <TCCR5B>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$121</MEM_ADDR>
        <CS50_MASK>0x01</CS50_MASK>
        <CS51_MASK>0x02</CS51_MASK>
        <CS52_MASK>0x04</CS52_MASK>
        <WGM52_MASK>0x08</WGM52_MASK>
        <WGM53_MASK>0x10</WGM53_MASK>
        <Res_MASK>0x20</Res_MASK>
        <ICES5_MASK>0x40</ICES5_MASK>
        <ICNC5_MASK>0x80</ICNC5_MASK>
      </TCCR5B>
      <TCCR5A>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$120</MEM_ADDR>
        <WGM50_MASK>0x01</WGM50_MASK>
        <WGM51_MASK>0x02</WGM51_MASK>
        <COM5C0_MASK>0x04</COM5C0_MASK>
        <COM5C1_MASK>0x08</COM5C1_MASK>
        <COM5B0_MASK>0x10</COM5B0_MASK>
        <COM5B1_MASK>0x20</COM5B1_MASK>
        <COM5A0_MASK>0x40</COM5A0_MASK>
        <COM5A1_MASK>0x80</COM5A1_MASK>
      </TCCR5A>
      <PORTL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$10B</MEM_ADDR>
      </PORTL>
      <DDRL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$10A</MEM_ADDR>
      </DDRL>
      <PINL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$109</MEM_ADDR>
      </PINL>
      <PORTK>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$108</MEM_ADDR>
      </PORTK>
      <DDRK>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$107</MEM_ADDR>
      </DDRK>
      <PINK>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$106</MEM_ADDR>
      </PINK>
      <PORTJ>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$105</MEM_ADDR>
      </PORTJ>
      <DDRJ>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$104</MEM_ADDR>
      </DDRJ>
      <PINJ>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$103</MEM_ADDR>
      </PINJ>
      <PORTH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$102</MEM_ADDR>
      </PORTH>
      <DDRH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$101</MEM_ADDR>
      </DDRH>
      <PINH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$100</MEM_ADDR>
      </PINH>
      <SCOCR1HH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$F8</MEM_ADDR>
        <SCOCR1HH0_MASK>0x01</SCOCR1HH0_MASK>
        <SCOCR1HH1_MASK>0x02</SCOCR1HH1_MASK>
        <SCOCR1HH2_MASK>0x04</SCOCR1HH2_MASK>
        <SCOCR1HH3_MASK>0x08</SCOCR1HH3_MASK>
        <SCOCR1HH4_MASK>0x10</SCOCR1HH4_MASK>
        <SCOCR1HH5_MASK>0x20</SCOCR1HH5_MASK>
        <SCOCR1HH6_MASK>0x40</SCOCR1HH6_MASK>
        <SCOCR1HH7_MASK>0x80</SCOCR1HH7_MASK>
      </SCOCR1HH>
      <SCOCR1HL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$F7</MEM_ADDR>
        <SCOCR1HL0_MASK>0x01</SCOCR1HL0_MASK>
        <SCOCR1HL1_MASK>0x02</SCOCR1HL1_MASK>
        <SCOCR1HL2_MASK>0x04</SCOCR1HL2_MASK>
        <SCOCR1HL3_MASK>0x08</SCOCR1HL3_MASK>
        <SCOCR1HL4_MASK>0x10</SCOCR1HL4_MASK>
        <SCOCR1HL5_MASK>0x20</SCOCR1HL5_MASK>
        <SCOCR1HL6_MASK>0x40</SCOCR1HL6_MASK>
        <SCOCR1HL7_MASK>0x80</SCOCR1HL7_MASK>
      </SCOCR1HL>
      <SCOCR1LH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$F6</MEM_ADDR>
        <SCOCR1LH0_MASK>0x01</SCOCR1LH0_MASK>
        <SCOCR1LH1_MASK>0x02</SCOCR1LH1_MASK>
        <SCOCR1LH2_MASK>0x04</SCOCR1LH2_MASK>
        <SCOCR1LH3_MASK>0x08</SCOCR1LH3_MASK>
        <SCOCR1LH4_MASK>0x10</SCOCR1LH4_MASK>
        <SCOCR1LH5_MASK>0x20</SCOCR1LH5_MASK>
        <SCOCR1LH6_MASK>0x40</SCOCR1LH6_MASK>
        <SCOCR1LH7_MASK>0x80</SCOCR1LH7_MASK>
      </SCOCR1LH>
      <SCOCR1LL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$F5</MEM_ADDR>
        <SCOCR1LL0_MASK>0x01</SCOCR1LL0_MASK>
        <SCOCR1LL1_MASK>0x02</SCOCR1LL1_MASK>
        <SCOCR1LL2_MASK>0x04</SCOCR1LL2_MASK>
        <SCOCR1LL3_MASK>0x08</SCOCR1LL3_MASK>
        <SCOCR1LL4_MASK>0x10</SCOCR1LL4_MASK>
        <SCOCR1LL5_MASK>0x20</SCOCR1LL5_MASK>
        <SCOCR1LL6_MASK>0x40</SCOCR1LL6_MASK>
        <SCOCR1LL7_MASK>0x80</SCOCR1LL7_MASK>
      </SCOCR1LL>
      <SCOCR2HH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$F4</MEM_ADDR>
        <SCOCR2HH0_MASK>0x01</SCOCR2HH0_MASK>
        <SCOCR2HH1_MASK>0x02</SCOCR2HH1_MASK>
        <SCOCR2HH2_MASK>0x04</SCOCR2HH2_MASK>
        <SCOCR2HH3_MASK>0x08</SCOCR2HH3_MASK>
        <SCOCR2HH4_MASK>0x10</SCOCR2HH4_MASK>
        <SCOCR2HH5_MASK>0x20</SCOCR2HH5_MASK>
        <SCOCR2HH6_MASK>0x40</SCOCR2HH6_MASK>
        <SCOCR2HH7_MASK>0x80</SCOCR2HH7_MASK>
      </SCOCR2HH>
      <SCOCR2HL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$F3</MEM_ADDR>
        <SCOCR2HL0_MASK>0x01</SCOCR2HL0_MASK>
        <SCOCR2HL1_MASK>0x02</SCOCR2HL1_MASK>
        <SCOCR2HL2_MASK>0x04</SCOCR2HL2_MASK>
        <SCOCR2HL3_MASK>0x08</SCOCR2HL3_MASK>
        <SCOCR2HL4_MASK>0x10</SCOCR2HL4_MASK>
        <SCOCR2HL5_MASK>0x20</SCOCR2HL5_MASK>
        <SCOCR2HL6_MASK>0x40</SCOCR2HL6_MASK>
        <SCOCR2HL7_MASK>0x80</SCOCR2HL7_MASK>
      </SCOCR2HL>
      <SCOCR2LH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$F2</MEM_ADDR>
        <SCOCR2LH0_MASK>0x01</SCOCR2LH0_MASK>
        <SCOCR2LH1_MASK>0x02</SCOCR2LH1_MASK>
        <SCOCR2LH2_MASK>0x04</SCOCR2LH2_MASK>
        <SCOCR2LH3_MASK>0x08</SCOCR2LH3_MASK>
        <SCOCR2LH4_MASK>0x10</SCOCR2LH4_MASK>
        <SCOCR2LH5_MASK>0x20</SCOCR2LH5_MASK>
        <SCOCR2LH6_MASK>0x40</SCOCR2LH6_MASK>
        <SCOCR2LH7_MASK>0x80</SCOCR2LH7_MASK>
      </SCOCR2LH>
      <SCOCR2LL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$F1</MEM_ADDR>
        <SCOCR2LL0_MASK>0x01</SCOCR2LL0_MASK>
        <SCOCR2LL1_MASK>0x02</SCOCR2LL1_MASK>
        <SCOCR2LL2_MASK>0x04</SCOCR2LL2_MASK>
        <SCOCR2LL3_MASK>0x08</SCOCR2LL3_MASK>
        <SCOCR2LL4_MASK>0x10</SCOCR2LL4_MASK>
        <SCOCR2LL5_MASK>0x20</SCOCR2LL5_MASK>
        <SCOCR2LL6_MASK>0x40</SCOCR2LL6_MASK>
        <SCOCR2LL7_MASK>0x80</SCOCR2LL7_MASK>
      </SCOCR2LL>
      <SCOCR3HH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$F0</MEM_ADDR>
        <SCOCR3HH0_MASK>0x01</SCOCR3HH0_MASK>
        <SCOCR3HH1_MASK>0x02</SCOCR3HH1_MASK>
        <SCOCR3HH2_MASK>0x04</SCOCR3HH2_MASK>
        <SCOCR3HH3_MASK>0x08</SCOCR3HH3_MASK>
        <SCOCR3HH4_MASK>0x10</SCOCR3HH4_MASK>
        <SCOCR3HH5_MASK>0x20</SCOCR3HH5_MASK>
        <SCOCR3HH6_MASK>0x40</SCOCR3HH6_MASK>
        <SCOCR3HH7_MASK>0x80</SCOCR3HH7_MASK>
      </SCOCR3HH>
      <SCOCR3HL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$EF</MEM_ADDR>
        <SCOCR3HL0_MASK>0x01</SCOCR3HL0_MASK>
        <SCOCR3HL1_MASK>0x02</SCOCR3HL1_MASK>
        <SCOCR3HL2_MASK>0x04</SCOCR3HL2_MASK>
        <SCOCR3HL3_MASK>0x08</SCOCR3HL3_MASK>
        <SCOCR3HL4_MASK>0x10</SCOCR3HL4_MASK>
        <SCOCR3HL5_MASK>0x20</SCOCR3HL5_MASK>
        <SCOCR3HL6_MASK>0x40</SCOCR3HL6_MASK>
        <SCOCR3HL7_MASK>0x80</SCOCR3HL7_MASK>
      </SCOCR3HL>
      <SCOCR3LH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$EE</MEM_ADDR>
        <SCOCR3LH0_MASK>0x01</SCOCR3LH0_MASK>
        <SCOCR3LH1_MASK>0x02</SCOCR3LH1_MASK>
        <SCOCR3LH2_MASK>0x04</SCOCR3LH2_MASK>
        <SCOCR3LH3_MASK>0x08</SCOCR3LH3_MASK>
        <SCOCR3LH4_MASK>0x10</SCOCR3LH4_MASK>
        <SCOCR3LH5_MASK>0x20</SCOCR3LH5_MASK>
        <SCOCR3LH6_MASK>0x40</SCOCR3LH6_MASK>
        <SCOCR3LH7_MASK>0x80</SCOCR3LH7_MASK>
      </SCOCR3LH>
      <SCOCR3LL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$ED</MEM_ADDR>
        <SCOCR3LL0_MASK>0x01</SCOCR3LL0_MASK>
        <SCOCR3LL1_MASK>0x02</SCOCR3LL1_MASK>
        <SCOCR3LL2_MASK>0x04</SCOCR3LL2_MASK>
        <SCOCR3LL3_MASK>0x08</SCOCR3LL3_MASK>
        <SCOCR3LL4_MASK>0x10</SCOCR3LL4_MASK>
        <SCOCR3LL5_MASK>0x20</SCOCR3LL5_MASK>
        <SCOCR3LL6_MASK>0x40</SCOCR3LL6_MASK>
        <SCOCR3LL7_MASK>0x80</SCOCR3LL7_MASK>
      </SCOCR3LL>
      <SCTSRHH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$EC</MEM_ADDR>
        <SCTSRHH0_MASK>0x01</SCTSRHH0_MASK>
        <SCTSRHH1_MASK>0x02</SCTSRHH1_MASK>
        <SCTSRHH2_MASK>0x04</SCTSRHH2_MASK>
        <SCTSRHH3_MASK>0x08</SCTSRHH3_MASK>
        <SCTSRHH4_MASK>0x10</SCTSRHH4_MASK>
        <SCTSRHH5_MASK>0x20</SCTSRHH5_MASK>
        <SCTSRHH6_MASK>0x40</SCTSRHH6_MASK>
        <SCTSRHH7_MASK>0x80</SCTSRHH7_MASK>
      </SCTSRHH>
      <SCTSRHL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$EB</MEM_ADDR>
        <SCTSRHL0_MASK>0x01</SCTSRHL0_MASK>
        <SCTSRHL1_MASK>0x02</SCTSRHL1_MASK>
        <SCTSRHL2_MASK>0x04</SCTSRHL2_MASK>
        <SCTSRHL3_MASK>0x08</SCTSRHL3_MASK>
        <SCTSRHL4_MASK>0x10</SCTSRHL4_MASK>
        <SCTSRHL5_MASK>0x20</SCTSRHL5_MASK>
        <SCTSRHL6_MASK>0x40</SCTSRHL6_MASK>
        <SCTSRHL7_MASK>0x80</SCTSRHL7_MASK>
      </SCTSRHL>
      <SCTSRLH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$EA</MEM_ADDR>
        <SCTSRLH0_MASK>0x01</SCTSRLH0_MASK>
        <SCTSRLH1_MASK>0x02</SCTSRLH1_MASK>
        <SCTSRLH2_MASK>0x04</SCTSRLH2_MASK>
        <SCTSRLH3_MASK>0x08</SCTSRLH3_MASK>
        <SCTSRLH4_MASK>0x10</SCTSRLH4_MASK>
        <SCTSRLH5_MASK>0x20</SCTSRLH5_MASK>
        <SCTSRLH6_MASK>0x40</SCTSRLH6_MASK>
        <SCTSRLH7_MASK>0x80</SCTSRLH7_MASK>
      </SCTSRLH>
      <SCTSRLL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$E9</MEM_ADDR>
        <SCTSRLL0_MASK>0x01</SCTSRLL0_MASK>
        <SCTSRLL1_MASK>0x02</SCTSRLL1_MASK>
        <SCTSRLL2_MASK>0x04</SCTSRLL2_MASK>
        <SCTSRLL3_MASK>0x08</SCTSRLL3_MASK>
        <SCTSRLL4_MASK>0x10</SCTSRLL4_MASK>
        <SCTSRLL5_MASK>0x20</SCTSRLL5_MASK>
        <SCTSRLL6_MASK>0x40</SCTSRLL6_MASK>
        <SCTSRLL7_MASK>0x80</SCTSRLL7_MASK>
      </SCTSRLL>
      <SCBTSRHH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$E8</MEM_ADDR>
        <SCBTSRHH0_MASK>0x01</SCBTSRHH0_MASK>
        <SCBTSRHH1_MASK>0x02</SCBTSRHH1_MASK>
        <SCBTSRHH2_MASK>0x04</SCBTSRHH2_MASK>
        <SCBTSRHH3_MASK>0x08</SCBTSRHH3_MASK>
        <SCBTSRHH4_MASK>0x10</SCBTSRHH4_MASK>
        <SCBTSRHH5_MASK>0x20</SCBTSRHH5_MASK>
        <SCBTSRHH6_MASK>0x40</SCBTSRHH6_MASK>
        <SCBTSRHH7_MASK>0x80</SCBTSRHH7_MASK>
      </SCBTSRHH>
      <SCBTSRHL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$E7</MEM_ADDR>
        <SCBTSRHL0_MASK>0x01</SCBTSRHL0_MASK>
        <SCBTSRHL1_MASK>0x02</SCBTSRHL1_MASK>
        <SCBTSRHL2_MASK>0x04</SCBTSRHL2_MASK>
        <SCBTSRHL3_MASK>0x08</SCBTSRHL3_MASK>
        <SCBTSRHL4_MASK>0x10</SCBTSRHL4_MASK>
        <SCBTSRHL5_MASK>0x20</SCBTSRHL5_MASK>
        <SCBTSRHL6_MASK>0x40</SCBTSRHL6_MASK>
        <SCBTSRHL7_MASK>0x80</SCBTSRHL7_MASK>
      </SCBTSRHL>
      <SCBTSRLH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$E6</MEM_ADDR>
        <SCBTSRLH0_MASK>0x01</SCBTSRLH0_MASK>
        <SCBTSRLH1_MASK>0x02</SCBTSRLH1_MASK>
        <SCBTSRLH2_MASK>0x04</SCBTSRLH2_MASK>
        <SCBTSRLH3_MASK>0x08</SCBTSRLH3_MASK>
        <SCBTSRLH4_MASK>0x10</SCBTSRLH4_MASK>
        <SCBTSRLH5_MASK>0x20</SCBTSRLH5_MASK>
        <SCBTSRLH6_MASK>0x40</SCBTSRLH6_MASK>
        <SCBTSRLH7_MASK>0x80</SCBTSRLH7_MASK>
      </SCBTSRLH>
      <SCBTSRLL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$E5</MEM_ADDR>
        <SCBTSRLL0_MASK>0x01</SCBTSRLL0_MASK>
        <SCBTSRLL1_MASK>0x02</SCBTSRLL1_MASK>
        <SCBTSRLL2_MASK>0x04</SCBTSRLL2_MASK>
        <SCBTSRLL3_MASK>0x08</SCBTSRLL3_MASK>
        <SCBTSRLL4_MASK>0x10</SCBTSRLL4_MASK>
        <SCBTSRLL5_MASK>0x20</SCBTSRLL5_MASK>
        <SCBTSRLL6_MASK>0x40</SCBTSRLL6_MASK>
        <SCBTSRLL7_MASK>0x80</SCBTSRLL7_MASK>
      </SCBTSRLL>
      <SCCNTHH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$E4</MEM_ADDR>
        <SCCNTHH0_MASK>0x01</SCCNTHH0_MASK>
        <SCCNTHH1_MASK>0x02</SCCNTHH1_MASK>
        <SCCNTHH2_MASK>0x04</SCCNTHH2_MASK>
        <SCCNTHH3_MASK>0x08</SCCNTHH3_MASK>
        <SCCNTHH4_MASK>0x10</SCCNTHH4_MASK>
        <SCCNTHH5_MASK>0x20</SCCNTHH5_MASK>
        <SCCNTHH6_MASK>0x40</SCCNTHH6_MASK>
        <SCCNTHH7_MASK>0x80</SCCNTHH7_MASK>
      </SCCNTHH>
      <SCCNTHL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$E3</MEM_ADDR>
        <SCCNTHL0_MASK>0x01</SCCNTHL0_MASK>
        <SCCNTHL1_MASK>0x02</SCCNTHL1_MASK>
        <SCCNTHL2_MASK>0x04</SCCNTHL2_MASK>
        <SCCNTHL3_MASK>0x08</SCCNTHL3_MASK>
        <SCCNTHL4_MASK>0x10</SCCNTHL4_MASK>
        <SCCNTHL5_MASK>0x20</SCCNTHL5_MASK>
        <SCCNTHL6_MASK>0x40</SCCNTHL6_MASK>
        <SCCNTHL7_MASK>0x80</SCCNTHL7_MASK>
      </SCCNTHL>
      <SCCNTLH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$E2</MEM_ADDR>
        <SCCNTLH0_MASK>0x01</SCCNTLH0_MASK>
        <SCCNTLH1_MASK>0x02</SCCNTLH1_MASK>
        <SCCNTLH2_MASK>0x04</SCCNTLH2_MASK>
        <SCCNTLH3_MASK>0x08</SCCNTLH3_MASK>
        <SCCNTLH4_MASK>0x10</SCCNTLH4_MASK>
        <SCCNTLH5_MASK>0x20</SCCNTLH5_MASK>
        <SCCNTLH6_MASK>0x40</SCCNTLH6_MASK>
        <SCCNTLH7_MASK>0x80</SCCNTLH7_MASK>
      </SCCNTLH>
      <SCCNTLL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$E1</MEM_ADDR>
        <SCCNTLL0_MASK>0x01</SCCNTLL0_MASK>
        <SCCNTLL1_MASK>0x02</SCCNTLL1_MASK>
        <SCCNTLL2_MASK>0x04</SCCNTLL2_MASK>
        <SCCNTLL3_MASK>0x08</SCCNTLL3_MASK>
        <SCCNTLL4_MASK>0x10</SCCNTLL4_MASK>
        <SCCNTLL5_MASK>0x20</SCCNTLL5_MASK>
        <SCCNTLL6_MASK>0x40</SCCNTLL6_MASK>
        <SCCNTLL7_MASK>0x80</SCCNTLL7_MASK>
      </SCCNTLL>
      <SCIRQS>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$E0</MEM_ADDR>
        <IRQSCP1_MASK>0x01</IRQSCP1_MASK>
        <IRQSCP2_MASK>0x02</IRQSCP2_MASK>
        <IRQSCP3_MASK>0x04</IRQSCP3_MASK>
        <IRQSOF_MASK>0x08</IRQSOF_MASK>
        <IRQSBO_MASK>0x10</IRQSBO_MASK>
        <Res0_MASK>0x20</Res0_MASK>
        <Res1_MASK>0x40</Res1_MASK>
        <Res2_MASK>0x80</Res2_MASK>
      </SCIRQS>
      <SCIRQM>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$DF</MEM_ADDR>
        <IRQMCP1_MASK>0x01</IRQMCP1_MASK>
        <IRQMCP2_MASK>0x02</IRQMCP2_MASK>
        <IRQMCP3_MASK>0x04</IRQMCP3_MASK>
        <IRQMOF_MASK>0x08</IRQMOF_MASK>
        <IRQMBO_MASK>0x10</IRQMBO_MASK>
        <Res0_MASK>0x20</Res0_MASK>
        <Res1_MASK>0x40</Res1_MASK>
        <Res2_MASK>0x80</Res2_MASK>
      </SCIRQM>
      <SCSR>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$DE</MEM_ADDR>
        <SCBSY_MASK>0x01</SCBSY_MASK>
        <Res0_MASK>0x02</Res0_MASK>
        <Res1_MASK>0x04</Res1_MASK>
        <Res2_MASK>0x08</Res2_MASK>
        <Res3_MASK>0x10</Res3_MASK>
        <Res4_MASK>0x20</Res4_MASK>
        <Res5_MASK>0x40</Res5_MASK>
        <Res6_MASK>0x80</Res6_MASK>
      </SCSR>
      <SCCR1>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$DD</MEM_ADDR>
        <SCENBO_MASK>0x01</SCENBO_MASK>
        <Res0_MASK>0x02</Res0_MASK>
        <Res1_MASK>0x04</Res1_MASK>
        <Res2_MASK>0x08</Res2_MASK>
        <Res3_MASK>0x10</Res3_MASK>
        <Res4_MASK>0x20</Res4_MASK>
        <Res5_MASK>0x40</Res5_MASK>
        <Res6_MASK>0x80</Res6_MASK>
      </SCCR1>
      <SCCR0>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$DC</MEM_ADDR>
        <SCCMP1_MASK>0x01</SCCMP1_MASK>
        <SCCMP2_MASK>0x02</SCCMP2_MASK>
        <SCCMP3_MASK>0x04</SCCMP3_MASK>
        <SCTSE_MASK>0x08</SCTSE_MASK>
        <SCCKSEL_MASK>0x10</SCCKSEL_MASK>
        <SCEN_MASK>0x20</SCEN_MASK>
        <SCMBTS_MASK>0x40</SCMBTS_MASK>
        <SCRES_MASK>0x80</SCRES_MASK>
      </SCCR0>
      <ATBR33>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$D1</MEM_ADDR>
      </ATBR33>
      <ATBR18>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$D0</MEM_ADDR>
      </ATBR18>
      <UDR1>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$CE</MEM_ADDR>
        <UDR10_MASK>0x01</UDR10_MASK>
        <UDR11_MASK>0x02</UDR11_MASK>
        <UDR12_MASK>0x04</UDR12_MASK>
        <UDR13_MASK>0x08</UDR13_MASK>
        <UDR14_MASK>0x10</UDR14_MASK>
        <UDR15_MASK>0x20</UDR15_MASK>
        <UDR16_MASK>0x40</UDR16_MASK>
        <UDR17_MASK>0x80</UDR17_MASK>
      </UDR1>
      <UBRR1H>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$CD</MEM_ADDR>
        <UBRR8_MASK>0x01</UBRR8_MASK>
        <UBRR9_MASK>0x02</UBRR9_MASK>
        <UBRR10_MASK>0x04</UBRR10_MASK>
        <UBRR11_MASK>0x08</UBRR11_MASK>
        <Res0_MASK>0x10</Res0_MASK>
        <Res1_MASK>0x20</Res1_MASK>
        <Res2_MASK>0x40</Res2_MASK>
        <Res3_MASK>0x80</Res3_MASK>
      </UBRR1H>
      <UBRR1L>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$CC</MEM_ADDR>
        <UBRR0_MASK>0x01</UBRR0_MASK>
        <UBRR1_MASK>0x02</UBRR1_MASK>
        <UBRR2_MASK>0x04</UBRR2_MASK>
        <UBRR3_MASK>0x08</UBRR3_MASK>
        <UBRR4_MASK>0x10</UBRR4_MASK>
        <UBRR5_MASK>0x20</UBRR5_MASK>
        <UBRR6_MASK>0x40</UBRR6_MASK>
        <UBRR7_MASK>0x80</UBRR7_MASK>
      </UBRR1L>
      <UCSR1C>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$CA</MEM_ADDR>
        <UCPOL1_MASK>0x01</UCPOL1_MASK>
        <UCSZ10_MASK>0x02</UCSZ10_MASK>
        <UCSZ11_MASK>0x04</UCSZ11_MASK>
        <USBS1_MASK>0x08</USBS1_MASK>
        <UPM10_MASK>0x10</UPM10_MASK>
        <UPM11_MASK>0x20</UPM11_MASK>
        <UMSEL10_MASK>0x40</UMSEL10_MASK>
        <UMSEL11_MASK>0x80</UMSEL11_MASK>
        <UCPHA1_MASK>0x02</UCPHA1_MASK>
        <UDORD1_MASK>0x04</UDORD1_MASK>
      </UCSR1C>
      <UCSR1B>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$C9</MEM_ADDR>
        <TXB81_MASK>0x01</TXB81_MASK>
        <RXB81_MASK>0x02</RXB81_MASK>
        <UCSZ12_MASK>0x04</UCSZ12_MASK>
        <TXEN1_MASK>0x08</TXEN1_MASK>
        <RXEN1_MASK>0x10</RXEN1_MASK>
        <UDRIE1_MASK>0x20</UDRIE1_MASK>
        <TXCIE1_MASK>0x40</TXCIE1_MASK>
        <RXCIE1_MASK>0x80</RXCIE1_MASK>
      </UCSR1B>
      <UCSR1A>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$C8</MEM_ADDR>
        <MPCM1_MASK>0x01</MPCM1_MASK>
        <U2X1_MASK>0x02</U2X1_MASK>
        <UPE1_MASK>0x04</UPE1_MASK>
        <DOR1_MASK>0x08</DOR1_MASK>
        <FE1_MASK>0x10</FE1_MASK>
        <UDRE1_MASK>0x20</UDRE1_MASK>
        <TXC1_MASK>0x40</TXC1_MASK>
        <RXC1_MASK>0x80</RXC1_MASK>
      </UCSR1A>
      <UDR0>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$C6</MEM_ADDR>
        <UDR00_MASK>0x01</UDR00_MASK>
        <UDR01_MASK>0x02</UDR01_MASK>
        <UDR02_MASK>0x04</UDR02_MASK>
        <UDR03_MASK>0x08</UDR03_MASK>
        <UDR04_MASK>0x10</UDR04_MASK>
        <UDR05_MASK>0x20</UDR05_MASK>
        <UDR06_MASK>0x40</UDR06_MASK>
        <UDR07_MASK>0x80</UDR07_MASK>
      </UDR0>
      <UBRR0H>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$C5</MEM_ADDR>
        <UBRR8_MASK>0x01</UBRR8_MASK>
        <UBRR9_MASK>0x02</UBRR9_MASK>
        <UBRR10_MASK>0x04</UBRR10_MASK>
        <UBRR11_MASK>0x08</UBRR11_MASK>
        <Res0_MASK>0x10</Res0_MASK>
        <Res1_MASK>0x20</Res1_MASK>
        <Res2_MASK>0x40</Res2_MASK>
        <Res3_MASK>0x80</Res3_MASK>
      </UBRR0H>
      <UBRR0L>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$C4</MEM_ADDR>
        <UBRR0_MASK>0x01</UBRR0_MASK>
        <UBRR1_MASK>0x02</UBRR1_MASK>
        <UBRR2_MASK>0x04</UBRR2_MASK>
        <UBRR3_MASK>0x08</UBRR3_MASK>
        <UBRR4_MASK>0x10</UBRR4_MASK>
        <UBRR5_MASK>0x20</UBRR5_MASK>
        <UBRR6_MASK>0x40</UBRR6_MASK>
        <UBRR7_MASK>0x80</UBRR7_MASK>
      </UBRR0L>
      <UCSR0C>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$C2</MEM_ADDR>
        <UCPOL0_MASK>0x01</UCPOL0_MASK>
        <UCSZ00_MASK>0x02</UCSZ00_MASK>
        <UCSZ01_MASK>0x04</UCSZ01_MASK>
        <USBS0_MASK>0x08</USBS0_MASK>
        <UPM00_MASK>0x10</UPM00_MASK>
        <UPM01_MASK>0x20</UPM01_MASK>
        <UMSEL00_MASK>0x40</UMSEL00_MASK>
        <UMSEL01_MASK>0x80</UMSEL01_MASK>
        <UCPHA0_MASK>0x02</UCPHA0_MASK>
        <UDORD0_MASK>0x04</UDORD0_MASK>
      </UCSR0C>
      <UCSR0B>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$C1</MEM_ADDR>
        <TXB80_MASK>0x01</TXB80_MASK>
        <RXB80_MASK>0x02</RXB80_MASK>
        <UCSZ02_MASK>0x04</UCSZ02_MASK>
        <TXEN0_MASK>0x08</TXEN0_MASK>
        <RXEN0_MASK>0x10</RXEN0_MASK>
        <UDRIE0_MASK>0x20</UDRIE0_MASK>
        <TXCIE0_MASK>0x40</TXCIE0_MASK>
        <RXCIE0_MASK>0x80</RXCIE0_MASK>
      </UCSR0B>
      <UCSR0A>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$C0</MEM_ADDR>
        <MPCM0_MASK>0x01</MPCM0_MASK>
        <U2X0_MASK>0x02</U2X0_MASK>
        <UPE0_MASK>0x04</UPE0_MASK>
        <DOR0_MASK>0x08</DOR0_MASK>
        <FE0_MASK>0x10</FE0_MASK>
        <UDRE0_MASK>0x20</UDRE0_MASK>
        <TXC0_MASK>0x40</TXC0_MASK>
        <RXC0_MASK>0x80</RXC0_MASK>
      </UCSR0A>
      <TWAMR>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$BD</MEM_ADDR>
        <Res_MASK>0x01</Res_MASK>
        <TWAM0_MASK>0x02</TWAM0_MASK>
        <TWAM1_MASK>0x04</TWAM1_MASK>
        <TWAM2_MASK>0x08</TWAM2_MASK>
        <TWAM3_MASK>0x10</TWAM3_MASK>
        <TWAM4_MASK>0x20</TWAM4_MASK>
        <TWAM5_MASK>0x40</TWAM5_MASK>
        <TWAM6_MASK>0x80</TWAM6_MASK>
      </TWAMR>
      <TWCR>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$BC</MEM_ADDR>
        <TWIE_MASK>0x01</TWIE_MASK>
        <Res_MASK>0x02</Res_MASK>
        <TWEN_MASK>0x04</TWEN_MASK>
        <TWWC_MASK>0x08</TWWC_MASK>
        <TWSTO_MASK>0x10</TWSTO_MASK>
        <TWSTA_MASK>0x20</TWSTA_MASK>
        <TWEA_MASK>0x40</TWEA_MASK>
        <TWINT_MASK>0x80</TWINT_MASK>
      </TWCR>
      <TWDR>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$BB</MEM_ADDR>
        <TWD0_MASK>0x01</TWD0_MASK>
        <TWD1_MASK>0x02</TWD1_MASK>
        <TWD2_MASK>0x04</TWD2_MASK>
        <TWD3_MASK>0x08</TWD3_MASK>
        <TWD4_MASK>0x10</TWD4_MASK>
        <TWD5_MASK>0x20</TWD5_MASK>
        <TWD6_MASK>0x40</TWD6_MASK>
        <TWD7_MASK>0x80</TWD7_MASK>
      </TWDR>
      <TWAR>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$BA</MEM_ADDR>
        <TWGCE_MASK>0x01</TWGCE_MASK>
        <TWA0_MASK>0x02</TWA0_MASK>
        <TWA1_MASK>0x04</TWA1_MASK>
        <TWA2_MASK>0x08</TWA2_MASK>
        <TWA3_MASK>0x10</TWA3_MASK>
        <TWA4_MASK>0x20</TWA4_MASK>
        <TWA5_MASK>0x40</TWA5_MASK>
        <TWA6_MASK>0x80</TWA6_MASK>
      </TWAR>
      <TWSR>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$B9</MEM_ADDR>
        <TWPS0_MASK>0x01</TWPS0_MASK>
        <TWPS1_MASK>0x02</TWPS1_MASK>
        <Res_MASK>0x04</Res_MASK>
        <TWS3_MASK>0x08</TWS3_MASK>
        <TWS4_MASK>0x10</TWS4_MASK>
        <TWS5_MASK>0x20</TWS5_MASK>
        <TWS6_MASK>0x40</TWS6_MASK>
        <TWS7_MASK>0x80</TWS7_MASK>
      </TWSR>
      <TWBR>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$B8</MEM_ADDR>
        <TWBR0_MASK>0x01</TWBR0_MASK>
        <TWBR1_MASK>0x02</TWBR1_MASK>
        <TWBR2_MASK>0x04</TWBR2_MASK>
        <TWBR3_MASK>0x08</TWBR3_MASK>
        <TWBR4_MASK>0x10</TWBR4_MASK>
        <TWBR5_MASK>0x20</TWBR5_MASK>
        <TWBR6_MASK>0x40</TWBR6_MASK>
        <TWBR7_MASK>0x80</TWBR7_MASK>
      </TWBR>
      <ASSR>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$B6</MEM_ADDR>
        <TCR2BUB_MASK>0x01</TCR2BUB_MASK>
        <TCR2AUB_MASK>0x02</TCR2AUB_MASK>
        <OCR2BUB_MASK>0x04</OCR2BUB_MASK>
        <OCR2AUB_MASK>0x08</OCR2AUB_MASK>
        <TCN2UB_MASK>0x10</TCN2UB_MASK>
        <AS2_MASK>0x20</AS2_MASK>
        <EXCLK_MASK>0x40</EXCLK_MASK>
        <EXCLKAMR_MASK>0x80</EXCLKAMR_MASK>
      </ASSR>
      <OCR2B>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$B4</MEM_ADDR>
        <OCR2B0_MASK>0x01</OCR2B0_MASK>
        <OCR2B1_MASK>0x02</OCR2B1_MASK>
        <OCR2B2_MASK>0x04</OCR2B2_MASK>
        <OCR2B3_MASK>0x08</OCR2B3_MASK>
        <OCR2B4_MASK>0x10</OCR2B4_MASK>
        <OCR2B5_MASK>0x20</OCR2B5_MASK>
        <OCR2B6_MASK>0x40</OCR2B6_MASK>
        <OCR2B7_MASK>0x80</OCR2B7_MASK>
      </OCR2B>
      <OCR2A>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$B3</MEM_ADDR>
        <OCR2A0_MASK>0x01</OCR2A0_MASK>
        <OCR2A1_MASK>0x02</OCR2A1_MASK>
        <OCR2A2_MASK>0x04</OCR2A2_MASK>
        <OCR2A3_MASK>0x08</OCR2A3_MASK>
        <OCR2A4_MASK>0x10</OCR2A4_MASK>
        <OCR2A5_MASK>0x20</OCR2A5_MASK>
        <OCR2A6_MASK>0x40</OCR2A6_MASK>
        <OCR2A7_MASK>0x80</OCR2A7_MASK>
      </OCR2A>
      <TCNT2>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$B2</MEM_ADDR>
        <TCNT20_MASK>0x01</TCNT20_MASK>
        <TCNT21_MASK>0x02</TCNT21_MASK>
        <TCNT22_MASK>0x04</TCNT22_MASK>
        <TCNT23_MASK>0x08</TCNT23_MASK>
        <TCNT24_MASK>0x10</TCNT24_MASK>
        <TCNT25_MASK>0x20</TCNT25_MASK>
        <TCNT26_MASK>0x40</TCNT26_MASK>
        <TCNT27_MASK>0x80</TCNT27_MASK>
      </TCNT2>
      <TCCR2B>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$B1</MEM_ADDR>
        <CS20_MASK>0x01</CS20_MASK>
        <CS21_MASK>0x02</CS21_MASK>
        <CS22_MASK>0x04</CS22_MASK>
        <WGM22_MASK>0x08</WGM22_MASK>
        <Res0_MASK>0x10</Res0_MASK>
        <Res1_MASK>0x20</Res1_MASK>
        <FOC2B_MASK>0x40</FOC2B_MASK>
        <FOC2A_MASK>0x80</FOC2A_MASK>
      </TCCR2B>
      <TCCR2A>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$B0</MEM_ADDR>
        <WGM20_MASK>0x01</WGM20_MASK>
        <WGM21_MASK>0x02</WGM21_MASK>
        <Res0_MASK>0x04</Res0_MASK>
        <Res1_MASK>0x08</Res1_MASK>
        <COM2B0_MASK>0x10</COM2B0_MASK>
        <COM2B1_MASK>0x20</COM2B1_MASK>
        <COM2A0_MASK>0x40</COM2A0_MASK>
        <COM2A1_MASK>0x80</COM2A1_MASK>
      </TCCR2A>
      <OCR4CH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$AD</MEM_ADDR>
        <OCR4CH0_MASK>0x01</OCR4CH0_MASK>
        <OCR4CH1_MASK>0x02</OCR4CH1_MASK>
        <OCR4CH2_MASK>0x04</OCR4CH2_MASK>
        <OCR4CH3_MASK>0x08</OCR4CH3_MASK>
        <OCR4CH4_MASK>0x10</OCR4CH4_MASK>
        <OCR4CH5_MASK>0x20</OCR4CH5_MASK>
        <OCR4CH6_MASK>0x40</OCR4CH6_MASK>
        <OCR4CH7_MASK>0x80</OCR4CH7_MASK>
      </OCR4CH>
      <OCR4CL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$AC</MEM_ADDR>
        <OCR4CL0_MASK>0x01</OCR4CL0_MASK>
        <OCR4CL1_MASK>0x02</OCR4CL1_MASK>
        <OCR4CL2_MASK>0x04</OCR4CL2_MASK>
        <OCR4CL3_MASK>0x08</OCR4CL3_MASK>
        <OCR4CL4_MASK>0x10</OCR4CL4_MASK>
        <OCR4CL5_MASK>0x20</OCR4CL5_MASK>
        <OCR4CL6_MASK>0x40</OCR4CL6_MASK>
        <OCR4CL7_MASK>0x80</OCR4CL7_MASK>
      </OCR4CL>
      <OCR4BH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$AB</MEM_ADDR>
        <OCR4BH0_MASK>0x01</OCR4BH0_MASK>
        <OCR4BH1_MASK>0x02</OCR4BH1_MASK>
        <OCR4BH2_MASK>0x04</OCR4BH2_MASK>
        <OCR4BH3_MASK>0x08</OCR4BH3_MASK>
        <OCR4BH4_MASK>0x10</OCR4BH4_MASK>
        <OCR4BH5_MASK>0x20</OCR4BH5_MASK>
        <OCR4BH6_MASK>0x40</OCR4BH6_MASK>
        <OCR4BH7_MASK>0x80</OCR4BH7_MASK>
      </OCR4BH>
      <OCR4BL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$AA</MEM_ADDR>
        <OCR4BL0_MASK>0x01</OCR4BL0_MASK>
        <OCR4BL1_MASK>0x02</OCR4BL1_MASK>
        <OCR4BL2_MASK>0x04</OCR4BL2_MASK>
        <OCR4BL3_MASK>0x08</OCR4BL3_MASK>
        <OCR4BL4_MASK>0x10</OCR4BL4_MASK>
        <OCR4BL5_MASK>0x20</OCR4BL5_MASK>
        <OCR4BL6_MASK>0x40</OCR4BL6_MASK>
        <OCR4BL7_MASK>0x80</OCR4BL7_MASK>
      </OCR4BL>
      <OCR4AH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$A9</MEM_ADDR>
        <OCR4AH0_MASK>0x01</OCR4AH0_MASK>
        <OCR4AH1_MASK>0x02</OCR4AH1_MASK>
        <OCR4AH2_MASK>0x04</OCR4AH2_MASK>
        <OCR4AH3_MASK>0x08</OCR4AH3_MASK>
        <OCR4AH4_MASK>0x10</OCR4AH4_MASK>
        <OCR4AH5_MASK>0x20</OCR4AH5_MASK>
        <OCR4AH6_MASK>0x40</OCR4AH6_MASK>
        <OCR4AH7_MASK>0x80</OCR4AH7_MASK>
      </OCR4AH>
      <OCR4AL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$A8</MEM_ADDR>
        <OCR4AL0_MASK>0x01</OCR4AL0_MASK>
        <OCR4AL1_MASK>0x02</OCR4AL1_MASK>
        <OCR4AL2_MASK>0x04</OCR4AL2_MASK>
        <OCR4AL3_MASK>0x08</OCR4AL3_MASK>
        <OCR4AL4_MASK>0x10</OCR4AL4_MASK>
        <OCR4AL5_MASK>0x20</OCR4AL5_MASK>
        <OCR4AL6_MASK>0x40</OCR4AL6_MASK>
        <OCR4AL7_MASK>0x80</OCR4AL7_MASK>
      </OCR4AL>
      <ICR4H>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$A7</MEM_ADDR>
        <ICR4H0_MASK>0x01</ICR4H0_MASK>
        <ICR4H1_MASK>0x02</ICR4H1_MASK>
        <ICR4H2_MASK>0x04</ICR4H2_MASK>
        <ICR4H3_MASK>0x08</ICR4H3_MASK>
        <ICR4H4_MASK>0x10</ICR4H4_MASK>
        <ICR4H5_MASK>0x20</ICR4H5_MASK>
        <ICR4H6_MASK>0x40</ICR4H6_MASK>
        <ICR4H7_MASK>0x80</ICR4H7_MASK>
      </ICR4H>
      <ICR4L>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$A6</MEM_ADDR>
        <ICR4L0_MASK>0x01</ICR4L0_MASK>
        <ICR4L1_MASK>0x02</ICR4L1_MASK>
        <ICR4L2_MASK>0x04</ICR4L2_MASK>
        <ICR4L3_MASK>0x08</ICR4L3_MASK>
        <ICR4L4_MASK>0x10</ICR4L4_MASK>
        <ICR4L5_MASK>0x20</ICR4L5_MASK>
        <ICR4L6_MASK>0x40</ICR4L6_MASK>
        <ICR4L7_MASK>0x80</ICR4L7_MASK>
      </ICR4L>
      <TCNT4H>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$A5</MEM_ADDR>
        <TCNT4H0_MASK>0x01</TCNT4H0_MASK>
        <TCNT4H1_MASK>0x02</TCNT4H1_MASK>
        <TCNT4H2_MASK>0x04</TCNT4H2_MASK>
        <TCNT4H3_MASK>0x08</TCNT4H3_MASK>
        <TCNT4H4_MASK>0x10</TCNT4H4_MASK>
        <TCNT4H5_MASK>0x20</TCNT4H5_MASK>
        <TCNT4H6_MASK>0x40</TCNT4H6_MASK>
        <TCNT4H7_MASK>0x80</TCNT4H7_MASK>
      </TCNT4H>
      <TCNT4L>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$A4</MEM_ADDR>
        <TCNT4L0_MASK>0x01</TCNT4L0_MASK>
        <TCNT4L1_MASK>0x02</TCNT4L1_MASK>
        <TCNT4L2_MASK>0x04</TCNT4L2_MASK>
        <TCNT4L3_MASK>0x08</TCNT4L3_MASK>
        <TCNT4L4_MASK>0x10</TCNT4L4_MASK>
        <TCNT4L5_MASK>0x20</TCNT4L5_MASK>
        <TCNT4L6_MASK>0x40</TCNT4L6_MASK>
        <TCNT4L7_MASK>0x80</TCNT4L7_MASK>
      </TCNT4L>
      <TCCR4C>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$A2</MEM_ADDR>
        <Res0_MASK>0x01</Res0_MASK>
        <Res1_MASK>0x02</Res1_MASK>
        <Res2_MASK>0x04</Res2_MASK>
        <Res3_MASK>0x08</Res3_MASK>
        <Res4_MASK>0x10</Res4_MASK>
        <FOC4C_MASK>0x20</FOC4C_MASK>
        <FOC4B_MASK>0x40</FOC4B_MASK>
        <FOC4A_MASK>0x80</FOC4A_MASK>
      </TCCR4C>
      <TCCR4B>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$A1</MEM_ADDR>
        <CS40_MASK>0x01</CS40_MASK>
        <CS41_MASK>0x02</CS41_MASK>
        <CS42_MASK>0x04</CS42_MASK>
        <WGM42_MASK>0x08</WGM42_MASK>
        <WGM43_MASK>0x10</WGM43_MASK>
        <Res_MASK>0x20</Res_MASK>
        <ICES4_MASK>0x40</ICES4_MASK>
        <ICNC4_MASK>0x80</ICNC4_MASK>
      </TCCR4B>
      <TCCR4A>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$A0</MEM_ADDR>
        <WGM40_MASK>0x01</WGM40_MASK>
        <WGM41_MASK>0x02</WGM41_MASK>
        <COM4C0_MASK>0x04</COM4C0_MASK>
        <COM4C1_MASK>0x08</COM4C1_MASK>
        <COM4B0_MASK>0x10</COM4B0_MASK>
        <COM4B1_MASK>0x20</COM4B1_MASK>
        <COM4A0_MASK>0x40</COM4A0_MASK>
        <COM4A1_MASK>0x80</COM4A1_MASK>
      </TCCR4A>
      <OCR3CH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$9D</MEM_ADDR>
        <OCR3CH0_MASK>0x01</OCR3CH0_MASK>
        <OCR3CH1_MASK>0x02</OCR3CH1_MASK>
        <OCR3CH2_MASK>0x04</OCR3CH2_MASK>
        <OCR3CH3_MASK>0x08</OCR3CH3_MASK>
        <OCR3CH4_MASK>0x10</OCR3CH4_MASK>
        <OCR3CH5_MASK>0x20</OCR3CH5_MASK>
        <OCR3CH6_MASK>0x40</OCR3CH6_MASK>
        <OCR3CH7_MASK>0x80</OCR3CH7_MASK>
      </OCR3CH>
      <OCR3CL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$9C</MEM_ADDR>
        <OCR3CL0_MASK>0x01</OCR3CL0_MASK>
        <OCR3CL1_MASK>0x02</OCR3CL1_MASK>
        <OCR3CL2_MASK>0x04</OCR3CL2_MASK>
        <OCR3CL3_MASK>0x08</OCR3CL3_MASK>
        <OCR3CL4_MASK>0x10</OCR3CL4_MASK>
        <OCR3CL5_MASK>0x20</OCR3CL5_MASK>
        <OCR3CL6_MASK>0x40</OCR3CL6_MASK>
        <OCR3CL7_MASK>0x80</OCR3CL7_MASK>
      </OCR3CL>
      <OCR3BH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$9B</MEM_ADDR>
        <OCR3BH0_MASK>0x01</OCR3BH0_MASK>
        <OCR3BH1_MASK>0x02</OCR3BH1_MASK>
        <OCR3BH2_MASK>0x04</OCR3BH2_MASK>
        <OCR3BH3_MASK>0x08</OCR3BH3_MASK>
        <OCR3BH4_MASK>0x10</OCR3BH4_MASK>
        <OCR3BH5_MASK>0x20</OCR3BH5_MASK>
        <OCR3BH6_MASK>0x40</OCR3BH6_MASK>
        <OCR3BH7_MASK>0x80</OCR3BH7_MASK>
      </OCR3BH>
      <OCR3BL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$9A</MEM_ADDR>
        <OCR3BL0_MASK>0x01</OCR3BL0_MASK>
        <OCR3BL1_MASK>0x02</OCR3BL1_MASK>
        <OCR3BL2_MASK>0x04</OCR3BL2_MASK>
        <OCR3BL3_MASK>0x08</OCR3BL3_MASK>
        <OCR3BL4_MASK>0x10</OCR3BL4_MASK>
        <OCR3BL5_MASK>0x20</OCR3BL5_MASK>
        <OCR3BL6_MASK>0x40</OCR3BL6_MASK>
        <OCR3BL7_MASK>0x80</OCR3BL7_MASK>
      </OCR3BL>
      <OCR3AH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$99</MEM_ADDR>
        <OCR3AH0_MASK>0x01</OCR3AH0_MASK>
        <OCR3AH1_MASK>0x02</OCR3AH1_MASK>
        <OCR3AH2_MASK>0x04</OCR3AH2_MASK>
        <OCR3AH3_MASK>0x08</OCR3AH3_MASK>
        <OCR3AH4_MASK>0x10</OCR3AH4_MASK>
        <OCR3AH5_MASK>0x20</OCR3AH5_MASK>
        <OCR3AH6_MASK>0x40</OCR3AH6_MASK>
        <OCR3AH7_MASK>0x80</OCR3AH7_MASK>
      </OCR3AH>
      <OCR3AL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$98</MEM_ADDR>
        <OCR3AL0_MASK>0x01</OCR3AL0_MASK>
        <OCR3AL1_MASK>0x02</OCR3AL1_MASK>
        <OCR3AL2_MASK>0x04</OCR3AL2_MASK>
        <OCR3AL3_MASK>0x08</OCR3AL3_MASK>
        <OCR3AL4_MASK>0x10</OCR3AL4_MASK>
        <OCR3AL5_MASK>0x20</OCR3AL5_MASK>
        <OCR3AL6_MASK>0x40</OCR3AL6_MASK>
        <OCR3AL7_MASK>0x80</OCR3AL7_MASK>
      </OCR3AL>
      <ICR3H>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$97</MEM_ADDR>
        <ICR3H0_MASK>0x01</ICR3H0_MASK>
        <ICR3H1_MASK>0x02</ICR3H1_MASK>
        <ICR3H2_MASK>0x04</ICR3H2_MASK>
        <ICR3H3_MASK>0x08</ICR3H3_MASK>
        <ICR3H4_MASK>0x10</ICR3H4_MASK>
        <ICR3H5_MASK>0x20</ICR3H5_MASK>
        <ICR3H6_MASK>0x40</ICR3H6_MASK>
        <ICR3H7_MASK>0x80</ICR3H7_MASK>
      </ICR3H>
      <ICR3L>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$96</MEM_ADDR>
        <ICR3L0_MASK>0x01</ICR3L0_MASK>
        <ICR3L1_MASK>0x02</ICR3L1_MASK>
        <ICR3L2_MASK>0x04</ICR3L2_MASK>
        <ICR3L3_MASK>0x08</ICR3L3_MASK>
        <ICR3L4_MASK>0x10</ICR3L4_MASK>
        <ICR3L5_MASK>0x20</ICR3L5_MASK>
        <ICR3L6_MASK>0x40</ICR3L6_MASK>
        <ICR3L7_MASK>0x80</ICR3L7_MASK>
      </ICR3L>
      <TCNT3H>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$95</MEM_ADDR>
        <TCNT3H0_MASK>0x01</TCNT3H0_MASK>
        <TCNT3H1_MASK>0x02</TCNT3H1_MASK>
        <TCNT3H2_MASK>0x04</TCNT3H2_MASK>
        <TCNT3H3_MASK>0x08</TCNT3H3_MASK>
        <TCNT3H4_MASK>0x10</TCNT3H4_MASK>
        <TCNT3H5_MASK>0x20</TCNT3H5_MASK>
        <TCNT3H6_MASK>0x40</TCNT3H6_MASK>
        <TCNT3H7_MASK>0x80</TCNT3H7_MASK>
      </TCNT3H>
      <TCNT3L>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$94</MEM_ADDR>
        <TCNT3L0_MASK>0x01</TCNT3L0_MASK>
        <TCNT3L1_MASK>0x02</TCNT3L1_MASK>
        <TCNT3L2_MASK>0x04</TCNT3L2_MASK>
        <TCNT3L3_MASK>0x08</TCNT3L3_MASK>
        <TCNT3L4_MASK>0x10</TCNT3L4_MASK>
        <TCNT3L5_MASK>0x20</TCNT3L5_MASK>
        <TCNT3L6_MASK>0x40</TCNT3L6_MASK>
        <TCNT3L7_MASK>0x80</TCNT3L7_MASK>
      </TCNT3L>
      <TCCR3C>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$92</MEM_ADDR>
        <Res0_MASK>0x01</Res0_MASK>
        <Res1_MASK>0x02</Res1_MASK>
        <Res2_MASK>0x04</Res2_MASK>
        <Res3_MASK>0x08</Res3_MASK>
        <Res4_MASK>0x10</Res4_MASK>
        <FOC3C_MASK>0x20</FOC3C_MASK>
        <FOC3B_MASK>0x40</FOC3B_MASK>
        <FOC3A_MASK>0x80</FOC3A_MASK>
      </TCCR3C>
      <TCCR3B>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$91</MEM_ADDR>
        <CS30_MASK>0x01</CS30_MASK>
        <CS31_MASK>0x02</CS31_MASK>
        <CS32_MASK>0x04</CS32_MASK>
        <WGM32_MASK>0x08</WGM32_MASK>
        <WGM33_MASK>0x10</WGM33_MASK>
        <Res_MASK>0x20</Res_MASK>
        <ICES3_MASK>0x40</ICES3_MASK>
        <ICNC3_MASK>0x80</ICNC3_MASK>
      </TCCR3B>
      <TCCR3A>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$90</MEM_ADDR>
        <WGM30_MASK>0x01</WGM30_MASK>
        <WGM31_MASK>0x02</WGM31_MASK>
        <COM3C0_MASK>0x04</COM3C0_MASK>
        <COM3C1_MASK>0x08</COM3C1_MASK>
        <COM3B0_MASK>0x10</COM3B0_MASK>
        <COM3B1_MASK>0x20</COM3B1_MASK>
        <COM3A0_MASK>0x40</COM3A0_MASK>
        <COM3A1_MASK>0x80</COM3A1_MASK>
      </TCCR3A>
      <OCR1CH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$8D</MEM_ADDR>
        <OCR1CH0_MASK>0x01</OCR1CH0_MASK>
        <OCR1CH1_MASK>0x02</OCR1CH1_MASK>
        <OCR1CH2_MASK>0x04</OCR1CH2_MASK>
        <OCR1CH3_MASK>0x08</OCR1CH3_MASK>
        <OCR1CH4_MASK>0x10</OCR1CH4_MASK>
        <OCR1CH5_MASK>0x20</OCR1CH5_MASK>
        <OCR1CH6_MASK>0x40</OCR1CH6_MASK>
        <OCR1CH7_MASK>0x80</OCR1CH7_MASK>
      </OCR1CH>
      <OCR1CL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$8C</MEM_ADDR>
        <OCR1CL0_MASK>0x01</OCR1CL0_MASK>
        <OCR1CL1_MASK>0x02</OCR1CL1_MASK>
        <OCR1CL2_MASK>0x04</OCR1CL2_MASK>
        <OCR1CL3_MASK>0x08</OCR1CL3_MASK>
        <OCR1CL4_MASK>0x10</OCR1CL4_MASK>
        <OCR1CL5_MASK>0x20</OCR1CL5_MASK>
        <OCR1CL6_MASK>0x40</OCR1CL6_MASK>
        <OCR1CL7_MASK>0x80</OCR1CL7_MASK>
      </OCR1CL>
      <OCR1BH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$8B</MEM_ADDR>
        <OCR1BH0_MASK>0x01</OCR1BH0_MASK>
        <OCR1BH1_MASK>0x02</OCR1BH1_MASK>
        <OCR1BH2_MASK>0x04</OCR1BH2_MASK>
        <OCR1BH3_MASK>0x08</OCR1BH3_MASK>
        <OCR1BH4_MASK>0x10</OCR1BH4_MASK>
        <OCR1BH5_MASK>0x20</OCR1BH5_MASK>
        <OCR1BH6_MASK>0x40</OCR1BH6_MASK>
        <OCR1BH7_MASK>0x80</OCR1BH7_MASK>
      </OCR1BH>
      <OCR1BL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$8A</MEM_ADDR>
        <OCR1BL0_MASK>0x01</OCR1BL0_MASK>
        <OCR1BL1_MASK>0x02</OCR1BL1_MASK>
        <OCR1BL2_MASK>0x04</OCR1BL2_MASK>
        <OCR1BL3_MASK>0x08</OCR1BL3_MASK>
        <OCR1BL4_MASK>0x10</OCR1BL4_MASK>
        <OCR1BL5_MASK>0x20</OCR1BL5_MASK>
        <OCR1BL6_MASK>0x40</OCR1BL6_MASK>
        <OCR1BL7_MASK>0x80</OCR1BL7_MASK>
      </OCR1BL>
      <OCR1AH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$89</MEM_ADDR>
        <OCR1AH0_MASK>0x01</OCR1AH0_MASK>
        <OCR1AH1_MASK>0x02</OCR1AH1_MASK>
        <OCR1AH2_MASK>0x04</OCR1AH2_MASK>
        <OCR1AH3_MASK>0x08</OCR1AH3_MASK>
        <OCR1AH4_MASK>0x10</OCR1AH4_MASK>
        <OCR1AH5_MASK>0x20</OCR1AH5_MASK>
        <OCR1AH6_MASK>0x40</OCR1AH6_MASK>
        <OCR1AH7_MASK>0x80</OCR1AH7_MASK>
      </OCR1AH>
      <OCR1AL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$88</MEM_ADDR>
        <OCR1AL0_MASK>0x01</OCR1AL0_MASK>
        <OCR1AL1_MASK>0x02</OCR1AL1_MASK>
        <OCR1AL2_MASK>0x04</OCR1AL2_MASK>
        <OCR1AL3_MASK>0x08</OCR1AL3_MASK>
        <OCR1AL4_MASK>0x10</OCR1AL4_MASK>
        <OCR1AL5_MASK>0x20</OCR1AL5_MASK>
        <OCR1AL6_MASK>0x40</OCR1AL6_MASK>
        <OCR1AL7_MASK>0x80</OCR1AL7_MASK>
      </OCR1AL>
      <ICR1H>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$87</MEM_ADDR>
        <ICR1H0_MASK>0x01</ICR1H0_MASK>
        <ICR1H1_MASK>0x02</ICR1H1_MASK>
        <ICR1H2_MASK>0x04</ICR1H2_MASK>
        <ICR1H3_MASK>0x08</ICR1H3_MASK>
        <ICR1H4_MASK>0x10</ICR1H4_MASK>
        <ICR1H5_MASK>0x20</ICR1H5_MASK>
        <ICR1H6_MASK>0x40</ICR1H6_MASK>
        <ICR1H7_MASK>0x80</ICR1H7_MASK>
      </ICR1H>
      <ICR1L>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$86</MEM_ADDR>
        <ICR1L0_MASK>0x01</ICR1L0_MASK>
        <ICR1L1_MASK>0x02</ICR1L1_MASK>
        <ICR1L2_MASK>0x04</ICR1L2_MASK>
        <ICR1L3_MASK>0x08</ICR1L3_MASK>
        <ICR1L4_MASK>0x10</ICR1L4_MASK>
        <ICR1L5_MASK>0x20</ICR1L5_MASK>
        <ICR1L6_MASK>0x40</ICR1L6_MASK>
        <ICR1L7_MASK>0x80</ICR1L7_MASK>
      </ICR1L>
      <TCNT1H>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$85</MEM_ADDR>
        <TCNT1H0_MASK>0x01</TCNT1H0_MASK>
        <TCNT1H1_MASK>0x02</TCNT1H1_MASK>
        <TCNT1H2_MASK>0x04</TCNT1H2_MASK>
        <TCNT1H3_MASK>0x08</TCNT1H3_MASK>
        <TCNT1H4_MASK>0x10</TCNT1H4_MASK>
        <TCNT1H5_MASK>0x20</TCNT1H5_MASK>
        <TCNT1H6_MASK>0x40</TCNT1H6_MASK>
        <TCNT1H7_MASK>0x80</TCNT1H7_MASK>
      </TCNT1H>
      <TCNT1L>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$84</MEM_ADDR>
        <TCNT1L0_MASK>0x01</TCNT1L0_MASK>
        <TCNT1L1_MASK>0x02</TCNT1L1_MASK>
        <TCNT1L2_MASK>0x04</TCNT1L2_MASK>
        <TCNT1L3_MASK>0x08</TCNT1L3_MASK>
        <TCNT1L4_MASK>0x10</TCNT1L4_MASK>
        <TCNT1L5_MASK>0x20</TCNT1L5_MASK>
        <TCNT1L6_MASK>0x40</TCNT1L6_MASK>
        <TCNT1L7_MASK>0x80</TCNT1L7_MASK>
      </TCNT1L>
      <TCCR1C>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$82</MEM_ADDR>
        <Res0_MASK>0x01</Res0_MASK>
        <Res1_MASK>0x02</Res1_MASK>
        <Res2_MASK>0x04</Res2_MASK>
        <Res3_MASK>0x08</Res3_MASK>
        <Res4_MASK>0x10</Res4_MASK>
        <FOC1C_MASK>0x20</FOC1C_MASK>
        <FOC1B_MASK>0x40</FOC1B_MASK>
        <FOC1A_MASK>0x80</FOC1A_MASK>
      </TCCR1C>
      <TCCR1B>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$81</MEM_ADDR>
        <CS10_MASK>0x01</CS10_MASK>
        <CS11_MASK>0x02</CS11_MASK>
        <CS12_MASK>0x04</CS12_MASK>
        <WGM12_MASK>0x08</WGM12_MASK>
        <WGM13_MASK>0x10</WGM13_MASK>
        <Res_MASK>0x20</Res_MASK>
        <ICES1_MASK>0x40</ICES1_MASK>
        <ICNC1_MASK>0x80</ICNC1_MASK>
      </TCCR1B>
      <TCCR1A>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$80</MEM_ADDR>
        <WGM10_MASK>0x01</WGM10_MASK>
        <WGM11_MASK>0x02</WGM11_MASK>
        <COM1C0_MASK>0x04</COM1C0_MASK>
        <COM1C1_MASK>0x08</COM1C1_MASK>
        <COM1B0_MASK>0x10</COM1B0_MASK>
        <COM1B1_MASK>0x20</COM1B1_MASK>
        <COM1A0_MASK>0x40</COM1A0_MASK>
        <COM1A1_MASK>0x80</COM1A1_MASK>
      </TCCR1A>
      <DIDR1>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$7F</MEM_ADDR>
        <AIN0D_MASK>0x01</AIN0D_MASK>
        <AIN1D_MASK>0x02</AIN1D_MASK>
      </DIDR1>
      <DIDR0>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$7E</MEM_ADDR>
        <ADC0D_MASK>0x01</ADC0D_MASK>
        <ADC1D_MASK>0x02</ADC1D_MASK>
        <ADC2D_MASK>0x04</ADC2D_MASK>
        <ADC3D_MASK>0x08</ADC3D_MASK>
        <ADC4D_MASK>0x10</ADC4D_MASK>
        <ADC5D_MASK>0x20</ADC5D_MASK>
        <ADC6D_MASK>0x40</ADC6D_MASK>
        <ADC7D_MASK>0x80</ADC7D_MASK>
      </DIDR0>
      <DIDR2>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$7D</MEM_ADDR>
        <ADC8D_MASK>0x01</ADC8D_MASK>
        <ADC9D_MASK>0x02</ADC9D_MASK>
        <ADC10D_MASK>0x04</ADC10D_MASK>
        <ADC11D_MASK>0x08</ADC11D_MASK>
        <ADC12D_MASK>0x10</ADC12D_MASK>
        <ADC13D_MASK>0x20</ADC13D_MASK>
        <ADC14D_MASK>0x40</ADC14D_MASK>
        <ADC15D_MASK>0x80</ADC15D_MASK>
      </DIDR2>
      <ADMUX>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$7C</MEM_ADDR>
        <MUX0_MASK>0x01</MUX0_MASK>
        <MUX1_MASK>0x02</MUX1_MASK>
        <MUX2_MASK>0x04</MUX2_MASK>
        <MUX3_MASK>0x08</MUX3_MASK>
        <MUX4_MASK>0x10</MUX4_MASK>
        <ADLAR_MASK>0x20</ADLAR_MASK>
        <REFS0_MASK>0x40</REFS0_MASK>
        <REFS1_MASK>0x80</REFS1_MASK>
      </ADMUX>
      <ADCSRB>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$7B</MEM_ADDR>
        <ACME_MASK>0x40</ACME_MASK>
        <ADTS0_MASK>0x01</ADTS0_MASK>
        <ADTS1_MASK>0x02</ADTS1_MASK>
        <ADTS2_MASK>0x04</ADTS2_MASK>
        <MUX5_MASK>0x08</MUX5_MASK>
        <ACCH_MASK>0x10</ACCH_MASK>
        <REFOK_MASK>0x20</REFOK_MASK>
        <AVDDOK_MASK>0x80</AVDDOK_MASK>
      </ADCSRB>
      <ADCSRA>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$7A</MEM_ADDR>
        <ADPS0_MASK>0x01</ADPS0_MASK>
        <ADPS1_MASK>0x02</ADPS1_MASK>
        <ADPS2_MASK>0x04</ADPS2_MASK>
        <ADIE_MASK>0x08</ADIE_MASK>
        <ADIF_MASK>0x10</ADIF_MASK>
        <ADATE_MASK>0x20</ADATE_MASK>
        <ADSC_MASK>0x40</ADSC_MASK>
        <ADEN_MASK>0x80</ADEN_MASK>
      </ADCSRA>
      <ADCH>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$79</MEM_ADDR>
        <ADCH0_MASK>0x01</ADCH0_MASK>
        <ADCH1_MASK>0x02</ADCH1_MASK>
        <ADCH2_MASK>0x04</ADCH2_MASK>
        <ADCH3_MASK>0x08</ADCH3_MASK>
        <ADCH4_MASK>0x10</ADCH4_MASK>
        <ADCH5_MASK>0x20</ADCH5_MASK>
        <ADCH6_MASK>0x40</ADCH6_MASK>
        <ADCH7_MASK>0x80</ADCH7_MASK>
      </ADCH>
      <ADCL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$78</MEM_ADDR>
        <ADCL0_MASK>0x01</ADCL0_MASK>
        <ADCL1_MASK>0x02</ADCL1_MASK>
        <ADCL2_MASK>0x04</ADCL2_MASK>
        <ADCL3_MASK>0x08</ADCL3_MASK>
        <ADCL4_MASK>0x10</ADCL4_MASK>
        <ADCL5_MASK>0x20</ADCL5_MASK>
        <ADCL6_MASK>0x40</ADCL6_MASK>
        <ADCL7_MASK>0x80</ADCL7_MASK>
      </ADCL>
      <ADCSRC>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$77</MEM_ADDR>
        <ADSUT0_MASK>0x01</ADSUT0_MASK>
        <ADSUT1_MASK>0x02</ADSUT1_MASK>
        <ADSUT2_MASK>0x04</ADSUT2_MASK>
        <ADSUT3_MASK>0x08</ADSUT3_MASK>
        <ADSUT4_MASK>0x10</ADSUT4_MASK>
        <Res0_MASK>0x20</Res0_MASK>
        <ADTHT0_MASK>0x40</ADTHT0_MASK>
        <ADTHT1_MASK>0x80</ADTHT1_MASK>
      </ADCSRC>
      <NEMCR>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$75</MEM_ADDR>
        <AEAM0_MASK>0x10</AEAM0_MASK>
        <AEAM1_MASK>0x20</AEAM1_MASK>
        <ENEAM_MASK>0x40</ENEAM_MASK>
      </NEMCR>
      <TIMSK5>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$73</MEM_ADDR>
        <TOIE5_MASK>0x01</TOIE5_MASK>
        <OCIE5A_MASK>0x02</OCIE5A_MASK>
        <OCIE5B_MASK>0x04</OCIE5B_MASK>
        <OCIE5C_MASK>0x08</OCIE5C_MASK>
        <Res_MASK>0x10</Res_MASK>
        <ICIE5_MASK>0x20</ICIE5_MASK>
        <Res0_MASK>0x40</Res0_MASK>
        <Res1_MASK>0x80</Res1_MASK>
      </TIMSK5>
      <TIMSK4>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$72</MEM_ADDR>
        <TOIE4_MASK>0x01</TOIE4_MASK>
        <OCIE4A_MASK>0x02</OCIE4A_MASK>
        <OCIE4B_MASK>0x04</OCIE4B_MASK>
        <OCIE4C_MASK>0x08</OCIE4C_MASK>
        <Res_MASK>0x10</Res_MASK>
        <ICIE4_MASK>0x20</ICIE4_MASK>
        <Res0_MASK>0x40</Res0_MASK>
        <Res1_MASK>0x80</Res1_MASK>
      </TIMSK4>
      <TIMSK3>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$71</MEM_ADDR>
        <TOIE3_MASK>0x01</TOIE3_MASK>
        <OCIE3A_MASK>0x02</OCIE3A_MASK>
        <OCIE3B_MASK>0x04</OCIE3B_MASK>
        <OCIE3C_MASK>0x08</OCIE3C_MASK>
        <Res_MASK>0x10</Res_MASK>
        <ICIE3_MASK>0x20</ICIE3_MASK>
        <Res0_MASK>0x40</Res0_MASK>
        <Res1_MASK>0x80</Res1_MASK>
      </TIMSK3>
      <TIMSK2>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$70</MEM_ADDR>
        <TOIE2_MASK>0x01</TOIE2_MASK>
        <OCIE2A_MASK>0x02</OCIE2A_MASK>
        <OCIE2B_MASK>0x04</OCIE2B_MASK>
        <Res0_MASK>0x08</Res0_MASK>
        <Res1_MASK>0x10</Res1_MASK>
        <Res2_MASK>0x20</Res2_MASK>
        <Res3_MASK>0x40</Res3_MASK>
        <Res4_MASK>0x80</Res4_MASK>
      </TIMSK2>
      <TIMSK1>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$6F</MEM_ADDR>
        <TOIE1_MASK>0x01</TOIE1_MASK>
        <OCIE1A_MASK>0x02</OCIE1A_MASK>
        <OCIE1B_MASK>0x04</OCIE1B_MASK>
        <OCIE1C_MASK>0x08</OCIE1C_MASK>
        <Res_MASK>0x10</Res_MASK>
        <ICIE1_MASK>0x20</ICIE1_MASK>
        <Res0_MASK>0x40</Res0_MASK>
        <Res1_MASK>0x80</Res1_MASK>
      </TIMSK1>
      <TIMSK0>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$6E</MEM_ADDR>
        <TOIE0_MASK>0x01</TOIE0_MASK>
        <OCIE0A_MASK>0x02</OCIE0A_MASK>
        <OCIE0B_MASK>0x04</OCIE0B_MASK>
        <Res0_MASK>0x08</Res0_MASK>
        <Res1_MASK>0x10</Res1_MASK>
        <Res2_MASK>0x20</Res2_MASK>
        <Res3_MASK>0x40</Res3_MASK>
        <Res4_MASK>0x80</Res4_MASK>
      </TIMSK0>
      <PCMSK2>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$6D</MEM_ADDR>
        <PCINT16_MASK>0x01</PCINT16_MASK>
        <PCINT17_MASK>0x02</PCINT17_MASK>
        <PCINT18_MASK>0x04</PCINT18_MASK>
        <PCINT19_MASK>0x08</PCINT19_MASK>
        <PCINT20_MASK>0x10</PCINT20_MASK>
        <PCINT21_MASK>0x20</PCINT21_MASK>
        <PCINT22_MASK>0x40</PCINT22_MASK>
        <PCINT23_MASK>0x80</PCINT23_MASK>
      </PCMSK2>
      <PCMSK1>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$6C</MEM_ADDR>
        <PCINT8_MASK>0x01</PCINT8_MASK>
        <PCINT9_MASK>0x02</PCINT9_MASK>
        <PCINT10_MASK>0x04</PCINT10_MASK>
        <PCINT11_MASK>0x08</PCINT11_MASK>
        <PCINT12_MASK>0x10</PCINT12_MASK>
        <PCINT13_MASK>0x20</PCINT13_MASK>
        <PCINT14_MASK>0x40</PCINT14_MASK>
        <PCINT15_MASK>0x80</PCINT15_MASK>
      </PCMSK1>
      <PCMSK0>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$6B</MEM_ADDR>
        <PCINT0_MASK>0x01</PCINT0_MASK>
        <PCINT1_MASK>0x02</PCINT1_MASK>
        <PCINT2_MASK>0x04</PCINT2_MASK>
        <PCINT3_MASK>0x08</PCINT3_MASK>
        <PCINT4_MASK>0x10</PCINT4_MASK>
        <PCINT5_MASK>0x20</PCINT5_MASK>
        <PCINT6_MASK>0x40</PCINT6_MASK>
        <PCINT7_MASK>0x80</PCINT7_MASK>
      </PCMSK0>
      <EICRB>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$6A</MEM_ADDR>
        <ISC40_MASK>0x01</ISC40_MASK>
        <ISC41_MASK>0x02</ISC41_MASK>
        <ISC50_MASK>0x04</ISC50_MASK>
        <ISC51_MASK>0x08</ISC51_MASK>
        <ISC60_MASK>0x10</ISC60_MASK>
        <ISC61_MASK>0x20</ISC61_MASK>
        <ISC70_MASK>0x40</ISC70_MASK>
        <ISC71_MASK>0x80</ISC71_MASK>
      </EICRB>
      <EICRA>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$69</MEM_ADDR>
        <ISC00_MASK>0x01</ISC00_MASK>
        <ISC01_MASK>0x02</ISC01_MASK>
        <ISC10_MASK>0x04</ISC10_MASK>
        <ISC11_MASK>0x08</ISC11_MASK>
        <ISC20_MASK>0x10</ISC20_MASK>
        <ISC21_MASK>0x20</ISC21_MASK>
        <ISC30_MASK>0x40</ISC30_MASK>
        <ISC31_MASK>0x80</ISC31_MASK>
      </EICRA>
      <PCICR>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$68</MEM_ADDR>
        <PCIE0_MASK>0x01</PCIE0_MASK>
        <PCIE1_MASK>0x02</PCIE1_MASK>
        <PCIE2_MASK>0x04</PCIE2_MASK>
        <Res0_MASK>0x08</Res0_MASK>
        <Res1_MASK>0x10</Res1_MASK>
        <Res2_MASK>0x20</Res2_MASK>
        <Res3_MASK>0x40</Res3_MASK>
        <Res4_MASK>0x80</Res4_MASK>
      </PCICR>
      <BGCR>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$67</MEM_ADDR>
        <BGCAL0_MASK>0x01</BGCAL0_MASK>
        <BGCAL1_MASK>0x02</BGCAL1_MASK>
        <BGCAL2_MASK>0x04</BGCAL2_MASK>
        <BGCAL_FINE0_MASK>0x08</BGCAL_FINE0_MASK>
        <BGCAL_FINE1_MASK>0x10</BGCAL_FINE1_MASK>
        <BGCAL_FINE2_MASK>0x20</BGCAL_FINE2_MASK>
        <BGCAL_FINE3_MASK>0x40</BGCAL_FINE3_MASK>
        <Res_MASK>0x80</Res_MASK>
      </BGCR>
      <OSCCAL>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$66</MEM_ADDR>
        <CAL0_MASK>0x01</CAL0_MASK>
        <CAL1_MASK>0x02</CAL1_MASK>
        <CAL2_MASK>0x04</CAL2_MASK>
        <CAL3_MASK>0x08</CAL3_MASK>
        <CAL4_MASK>0x10</CAL4_MASK>
        <CAL5_MASK>0x20</CAL5_MASK>
        <CAL6_MASK>0x40</CAL6_MASK>
        <CAL7_MASK>0x80</CAL7_MASK>
      </OSCCAL>
      <PRR1>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$65</MEM_ADDR>
        <PRUSART1_MASK>0x01</PRUSART1_MASK>
        <PRUSART2_MASK>0x02</PRUSART2_MASK>
        <PRUSART3_MASK>0x04</PRUSART3_MASK>
        <PRTIM3_MASK>0x08</PRTIM3_MASK>
        <PRTIM4_MASK>0x10</PRTIM4_MASK>
        <PRTIM5_MASK>0x20</PRTIM5_MASK>
        <PRTRX24_MASK>0x40</PRTRX24_MASK>
        <Res_MASK>0x80</Res_MASK>
      </PRR1>
      <PRR0>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$64</MEM_ADDR>
        <PRADC_MASK>0x01</PRADC_MASK>
        <PRUSART0_MASK>0x02</PRUSART0_MASK>
        <PRSPI_MASK>0x04</PRSPI_MASK>
        <PRTIM1_MASK>0x08</PRTIM1_MASK>
        <PRPGA_MASK>0x10</PRPGA_MASK>
        <PRTIM0_MASK>0x20</PRTIM0_MASK>
        <PRTIM2_MASK>0x40</PRTIM2_MASK>
        <PRTWI_MASK>0x80</PRTWI_MASK>
      </PRR0>
      <PRR2>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$63</MEM_ADDR>
        <PRRAM0_MASK>0x01</PRRAM0_MASK>
        <PRRAM1_MASK>0x02</PRRAM1_MASK>
        <PRRAM2_MASK>0x04</PRRAM2_MASK>
        <PRRAM3_MASK>0x08</PRRAM3_MASK>
        <Res0_MASK>0x10</Res0_MASK>
        <Res1_MASK>0x20</Res1_MASK>
        <Res2_MASK>0x40</Res2_MASK>
        <Res3_MASK>0x80</Res3_MASK>
      </PRR2>
      <CLKPR>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$61</MEM_ADDR>
        <CLKPS0_MASK>0x01</CLKPS0_MASK>
        <CLKPS1_MASK>0x02</CLKPS1_MASK>
        <CLKPS2_MASK>0x04</CLKPS2_MASK>
        <CLKPS3_MASK>0x08</CLKPS3_MASK>
        <Res0_MASK>0x10</Res0_MASK>
        <Res1_MASK>0x20</Res1_MASK>
        <Res2_MASK>0x40</Res2_MASK>
        <CLKPCE_MASK>0x80</CLKPCE_MASK>
      </CLKPR>
      <WDTCSR>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$60</MEM_ADDR>
        <WDP0_MASK>0x01</WDP0_MASK>
        <WDP1_MASK>0x02</WDP1_MASK>
        <WDP2_MASK>0x04</WDP2_MASK>
        <WDE_MASK>0x08</WDE_MASK>
        <WDCE_MASK>0x10</WDCE_MASK>
        <WDP3_MASK>0x20</WDP3_MASK>
        <WDIE_MASK>0x40</WDIE_MASK>
        <WDIF_MASK>0x80</WDIF_MASK>
      </WDTCSR>
      <SREG>
        <IO_ADDR>$3F</IO_ADDR>
        <MEM_ADDR>$5F</MEM_ADDR>
        <C_MASK>0x01</C_MASK>
        <Z_MASK>0x02</Z_MASK>
        <N_MASK>0x04</N_MASK>
        <V_MASK>0x08</V_MASK>
        <S_MASK>0x10</S_MASK>
        <H_MASK>0x20</H_MASK>
        <T_MASK>0x40</T_MASK>
        <I_MASK>0x80</I_MASK>
      </SREG>
      <SPH>
        <IO_ADDR>$3E</IO_ADDR>
        <MEM_ADDR>$5E</MEM_ADDR>
        <INIT>0x21</INIT>
        <SP8_MASK>0x01</SP8_MASK>
        <SP9_MASK>0x02</SP9_MASK>
        <SP10_MASK>0x04</SP10_MASK>
        <SP11_MASK>0x08</SP11_MASK>
        <SP12_MASK>0x10</SP12_MASK>
        <SP13_MASK>0x20</SP13_MASK>
        <SP14_MASK>0x40</SP14_MASK>
        <SP15_MASK>0x80</SP15_MASK>
      </SPH>
      <SPL>
        <IO_ADDR>$3D</IO_ADDR>
        <MEM_ADDR>$5D</MEM_ADDR>
        <INIT>0xFF</INIT>
        <SP0_MASK>0x01</SP0_MASK>
        <SP1_MASK>0x02</SP1_MASK>
        <SP2_MASK>0x04</SP2_MASK>
        <SP3_MASK>0x08</SP3_MASK>
        <SP4_MASK>0x10</SP4_MASK>
        <SP5_MASK>0x20</SP5_MASK>
        <SP6_MASK>0x40</SP6_MASK>
        <SP7_MASK>0x80</SP7_MASK>
      </SPL>
      <EIND>
        <IO_ADDR>$3C</IO_ADDR>
        <MEM_ADDR>$5C</MEM_ADDR>
      </EIND>
      <RAMPZ>
        <IO_ADDR>$3B</IO_ADDR>
        <MEM_ADDR>$5B</MEM_ADDR>
        <RAMPZ0_MASK>0x01</RAMPZ0_MASK>
        <RAMPZ1_MASK>0x02</RAMPZ1_MASK>
        <Res0_MASK>0x04</Res0_MASK>
        <Res1_MASK>0x08</Res1_MASK>
        <Res2_MASK>0x10</Res2_MASK>
        <Res3_MASK>0x20</Res3_MASK>
        <Res4_MASK>0x40</Res4_MASK>
        <Res5_MASK>0x80</Res5_MASK>
      </RAMPZ>
      <SPMCSR>
        <IO_ADDR>$37</IO_ADDR>
        <MEM_ADDR>$57</MEM_ADDR>
        <SPMEN_MASK>0x01</SPMEN_MASK>
        <PGERS_MASK>0x02</PGERS_MASK>
        <PGWRT_MASK>0x04</PGWRT_MASK>
        <BLBSET_MASK>0x08</BLBSET_MASK>
        <RWWSRE_MASK>0x10</RWWSRE_MASK>
        <SIGRD_MASK>0x20</SIGRD_MASK>
        <RWWSB_MASK>0x40</RWWSB_MASK>
        <SPMIE_MASK>0x80</SPMIE_MASK>
      </SPMCSR>
      <MCUCR>
        <IO_ADDR>$35</IO_ADDR>
        <MEM_ADDR>$55</MEM_ADDR>
        <JTD_MASK>0x80</JTD_MASK>
        <IVCE_MASK>0x01</IVCE_MASK>
        <IVSEL_MASK>0x02</IVSEL_MASK>
        <Res0_MASK>0x04</Res0_MASK>
        <Res1_MASK>0x08</Res1_MASK>
        <PUD_MASK>0x10</PUD_MASK>
      </MCUCR>
      <MCUSR>
        <IO_ADDR>$34</IO_ADDR>
        <MEM_ADDR>$54</MEM_ADDR>
        <JTRF_MASK>0x10</JTRF_MASK>
        <PORF_MASK>0x01</PORF_MASK>
        <EXTRF_MASK>0x02</EXTRF_MASK>
        <BORF_MASK>0x04</BORF_MASK>
        <WDRF_MASK>0x08</WDRF_MASK>
        <Res0_MASK>0x20</Res0_MASK>
        <Res1_MASK>0x40</Res1_MASK>
        <Res2_MASK>0x80</Res2_MASK>
      </MCUSR>
      <SMCR>
        <IO_ADDR>$33</IO_ADDR>
        <MEM_ADDR>$53</MEM_ADDR>
        <SE_MASK>0x01</SE_MASK>
        <SM0_MASK>0x02</SM0_MASK>
        <SM1_MASK>0x04</SM1_MASK>
        <SM2_MASK>0x08</SM2_MASK>
        <Res0_MASK>0x10</Res0_MASK>
        <Res1_MASK>0x20</Res1_MASK>
        <Res2_MASK>0x40</Res2_MASK>
        <Res3_MASK>0x80</Res3_MASK>
      </SMCR>
      <OCDR>
        <IO_ADDR>$31</IO_ADDR>
        <MEM_ADDR>$51</MEM_ADDR>
        <OCDR0_MASK>0x01</OCDR0_MASK>
        <OCDR1_MASK>0x02</OCDR1_MASK>
        <OCDR2_MASK>0x04</OCDR2_MASK>
        <OCDR3_MASK>0x08</OCDR3_MASK>
        <OCDR4_MASK>0x10</OCDR4_MASK>
        <OCDR5_MASK>0x20</OCDR5_MASK>
        <OCDR6_MASK>0x40</OCDR6_MASK>
        <OCDR7_MASK>0x80</OCDR7_MASK>
      </OCDR>
      <ACSR>
        <IO_ADDR>$30</IO_ADDR>
        <MEM_ADDR>$50</MEM_ADDR>
        <ACIS0_MASK>0x01</ACIS0_MASK>
        <ACIS1_MASK>0x02</ACIS1_MASK>
        <ACIC_MASK>0x04</ACIC_MASK>
        <ACIE_MASK>0x08</ACIE_MASK>
        <ACI_MASK>0x10</ACI_MASK>
        <ACO_MASK>0x20</ACO_MASK>
        <ACBG_MASK>0x40</ACBG_MASK>
        <ACD_MASK>0x80</ACD_MASK>
      </ACSR>
      <SPDR>
        <IO_ADDR>$2E</IO_ADDR>
        <MEM_ADDR>$4E</MEM_ADDR>
        <SPDR0_MASK>0x01</SPDR0_MASK>
        <SPDR1_MASK>0x02</SPDR1_MASK>
        <SPDR2_MASK>0x04</SPDR2_MASK>
        <SPDR3_MASK>0x08</SPDR3_MASK>
        <SPDR4_MASK>0x10</SPDR4_MASK>
        <SPDR5_MASK>0x20</SPDR5_MASK>
        <SPDR6_MASK>0x40</SPDR6_MASK>
        <SPDR7_MASK>0x80</SPDR7_MASK>
      </SPDR>
      <SPSR>
        <IO_ADDR>$2D</IO_ADDR>
        <MEM_ADDR>$4D</MEM_ADDR>
        <SPI2X_MASK>0x01</SPI2X_MASK>
        <Res0_MASK>0x02</Res0_MASK>
        <Res1_MASK>0x04</Res1_MASK>
        <Res2_MASK>0x08</Res2_MASK>
        <Res3_MASK>0x10</Res3_MASK>
        <Res4_MASK>0x20</Res4_MASK>
        <WCOL_MASK>0x40</WCOL_MASK>
        <SPIF_MASK>0x80</SPIF_MASK>
      </SPSR>
      <SPCR>
        <IO_ADDR>$2C</IO_ADDR>
        <MEM_ADDR>$4C</MEM_ADDR>
        <SPR0_MASK>0x01</SPR0_MASK>
        <SPR1_MASK>0x02</SPR1_MASK>
        <CPHA_MASK>0x04</CPHA_MASK>
        <CPOL_MASK>0x08</CPOL_MASK>
        <MSTR_MASK>0x10</MSTR_MASK>
        <DORD_MASK>0x20</DORD_MASK>
        <SPE_MASK>0x40</SPE_MASK>
        <SPIE_MASK>0x80</SPIE_MASK>
      </SPCR>
      <GPIOR2>
        <IO_ADDR>$2B</IO_ADDR>
        <MEM_ADDR>$4B</MEM_ADDR>
        <GPIOR20_MASK>0x01</GPIOR20_MASK>
        <GPIOR21_MASK>0x02</GPIOR21_MASK>
        <GPIOR22_MASK>0x04</GPIOR22_MASK>
        <GPIOR23_MASK>0x08</GPIOR23_MASK>
        <GPIOR24_MASK>0x10</GPIOR24_MASK>
        <GPIOR25_MASK>0x20</GPIOR25_MASK>
        <GPIOR26_MASK>0x40</GPIOR26_MASK>
        <GPIOR27_MASK>0x80</GPIOR27_MASK>
      </GPIOR2>
      <GPIOR1>
        <IO_ADDR>$2A</IO_ADDR>
        <MEM_ADDR>$4A</MEM_ADDR>
        <GPIOR10_MASK>0x01</GPIOR10_MASK>
        <GPIOR11_MASK>0x02</GPIOR11_MASK>
        <GPIOR12_MASK>0x04</GPIOR12_MASK>
        <GPIOR13_MASK>0x08</GPIOR13_MASK>
        <GPIOR14_MASK>0x10</GPIOR14_MASK>
        <GPIOR15_MASK>0x20</GPIOR15_MASK>
        <GPIOR16_MASK>0x40</GPIOR16_MASK>
        <GPIOR17_MASK>0x80</GPIOR17_MASK>
      </GPIOR1>
      <OCR0B>
        <IO_ADDR>$28</IO_ADDR>
        <MEM_ADDR>$48</MEM_ADDR>
        <OCR0B_0_MASK>0x01</OCR0B_0_MASK>
        <OCR0B_1_MASK>0x02</OCR0B_1_MASK>
        <OCR0B_2_MASK>0x04</OCR0B_2_MASK>
        <OCR0B_3_MASK>0x08</OCR0B_3_MASK>
        <OCR0B_4_MASK>0x10</OCR0B_4_MASK>
        <OCR0B_5_MASK>0x20</OCR0B_5_MASK>
        <OCR0B_6_MASK>0x40</OCR0B_6_MASK>
        <OCR0B_7_MASK>0x80</OCR0B_7_MASK>
      </OCR0B>
      <OCR0A>
        <IO_ADDR>$27</IO_ADDR>
        <MEM_ADDR>$47</MEM_ADDR>
        <OCR0A_0_MASK>0x01</OCR0A_0_MASK>
        <OCR0A_1_MASK>0x02</OCR0A_1_MASK>
        <OCR0A_2_MASK>0x04</OCR0A_2_MASK>
        <OCR0A_3_MASK>0x08</OCR0A_3_MASK>
        <OCR0A_4_MASK>0x10</OCR0A_4_MASK>
        <OCR0A_5_MASK>0x20</OCR0A_5_MASK>
        <OCR0A_6_MASK>0x40</OCR0A_6_MASK>
        <OCR0A_7_MASK>0x80</OCR0A_7_MASK>
      </OCR0A>
      <TCNT0>
        <IO_ADDR>$26</IO_ADDR>
        <MEM_ADDR>$46</MEM_ADDR>
        <TCNT0_0_MASK>0x01</TCNT0_0_MASK>
        <TCNT0_1_MASK>0x02</TCNT0_1_MASK>
        <TCNT0_2_MASK>0x04</TCNT0_2_MASK>
        <TCNT0_3_MASK>0x08</TCNT0_3_MASK>
        <TCNT0_4_MASK>0x10</TCNT0_4_MASK>
        <TCNT0_5_MASK>0x20</TCNT0_5_MASK>
        <TCNT0_6_MASK>0x40</TCNT0_6_MASK>
        <TCNT0_7_MASK>0x80</TCNT0_7_MASK>
      </TCNT0>
      <TCCR0B>
        <IO_ADDR>$25</IO_ADDR>
        <MEM_ADDR>$45</MEM_ADDR>
        <CS00_MASK>0x01</CS00_MASK>
        <CS01_MASK>0x02</CS01_MASK>
        <CS02_MASK>0x04</CS02_MASK>
        <WGM02_MASK>0x08</WGM02_MASK>
        <Res0_MASK>0x10</Res0_MASK>
        <Res1_MASK>0x20</Res1_MASK>
        <FOC0B_MASK>0x40</FOC0B_MASK>
        <FOC0A_MASK>0x80</FOC0A_MASK>
      </TCCR0B>
      <TCCR0A>
        <IO_ADDR>$24</IO_ADDR>
        <MEM_ADDR>$44</MEM_ADDR>
        <WGM00_MASK>0x01</WGM00_MASK>
        <WGM01_MASK>0x02</WGM01_MASK>
        <Res0_MASK>0x04</Res0_MASK>
        <Res1_MASK>0x08</Res1_MASK>
        <COM0B0_MASK>0x10</COM0B0_MASK>
        <COM0B1_MASK>0x20</COM0B1_MASK>
        <COM0A0_MASK>0x40</COM0A0_MASK>
        <COM0A1_MASK>0x80</COM0A1_MASK>
      </TCCR0A>
      <GTCCR>
        <IO_ADDR>$23</IO_ADDR>
        <MEM_ADDR>$43</MEM_ADDR>
        <PSRSYNC_MASK>0x01</PSRSYNC_MASK>
        <PSRASY_MASK>0x02</PSRASY_MASK>
        <Res0_MASK>0x04</Res0_MASK>
        <Res1_MASK>0x08</Res1_MASK>
        <Res2_MASK>0x10</Res2_MASK>
        <Res3_MASK>0x20</Res3_MASK>
        <Res4_MASK>0x40</Res4_MASK>
        <TSM_MASK>0x80</TSM_MASK>
      </GTCCR>
      <EEARH>
        <IO_ADDR>$22</IO_ADDR>
        <MEM_ADDR>$42</MEM_ADDR>
        <EEAR8_MASK>0x01</EEAR8_MASK>
        <EEAR9_MASK>0x02</EEAR9_MASK>
        <EEAR10_MASK>0x04</EEAR10_MASK>
        <EEAR11_MASK>0x08</EEAR11_MASK>
        <Res0_MASK>0x10</Res0_MASK>
        <Res1_MASK>0x20</Res1_MASK>
        <Res2_MASK>0x40</Res2_MASK>
        <Res3_MASK>0x80</Res3_MASK>
      </EEARH>
      <EEARL>
        <IO_ADDR>$21</IO_ADDR>
        <MEM_ADDR>$41</MEM_ADDR>
        <EEAR0_MASK>0x01</EEAR0_MASK>
        <EEAR1_MASK>0x02</EEAR1_MASK>
        <EEAR2_MASK>0x04</EEAR2_MASK>
        <EEAR3_MASK>0x08</EEAR3_MASK>
        <EEAR4_MASK>0x10</EEAR4_MASK>
        <EEAR5_MASK>0x20</EEAR5_MASK>
        <EEAR6_MASK>0x40</EEAR6_MASK>
        <EEAR7_MASK>0x80</EEAR7_MASK>
      </EEARL>
      <EEDR>
        <IO_ADDR>$20</IO_ADDR>
        <MEM_ADDR>$40</MEM_ADDR>
        <EEDR0_MASK>0x01</EEDR0_MASK>
        <EEDR1_MASK>0x02</EEDR1_MASK>
        <EEDR2_MASK>0x04</EEDR2_MASK>
        <EEDR3_MASK>0x08</EEDR3_MASK>
        <EEDR4_MASK>0x10</EEDR4_MASK>
        <EEDR5_MASK>0x20</EEDR5_MASK>
        <EEDR6_MASK>0x40</EEDR6_MASK>
        <EEDR7_MASK>0x80</EEDR7_MASK>
      </EEDR>
      <EECR>
        <IO_ADDR>$1F</IO_ADDR>
        <MEM_ADDR>$3F</MEM_ADDR>
        <EERE_MASK>0x01</EERE_MASK>
        <EEPE_MASK>0x02</EEPE_MASK>
        <EEMPE_MASK>0x04</EEMPE_MASK>
        <EERIE_MASK>0x08</EERIE_MASK>
        <EEPM0_MASK>0x10</EEPM0_MASK>
        <EEPM1_MASK>0x20</EEPM1_MASK>
        <Res0_MASK>0x40</Res0_MASK>
        <Res1_MASK>0x80</Res1_MASK>
      </EECR>
      <GPIOR0>
        <IO_ADDR>$1E</IO_ADDR>
        <MEM_ADDR>$3E</MEM_ADDR>
        <GPIOR00_MASK>0x01</GPIOR00_MASK>
        <GPIOR01_MASK>0x02</GPIOR01_MASK>
        <GPIOR02_MASK>0x04</GPIOR02_MASK>
        <GPIOR03_MASK>0x08</GPIOR03_MASK>
        <GPIOR04_MASK>0x10</GPIOR04_MASK>
        <GPIOR05_MASK>0x20</GPIOR05_MASK>
        <GPIOR06_MASK>0x40</GPIOR06_MASK>
        <GPIOR07_MASK>0x80</GPIOR07_MASK>
      </GPIOR0>
      <EIMSK>
        <IO_ADDR>$1D</IO_ADDR>
        <MEM_ADDR>$3D</MEM_ADDR>
        <INT0_MASK>0x01</INT0_MASK>
        <INT1_MASK>0x02</INT1_MASK>
        <INT2_MASK>0x04</INT2_MASK>
        <INT3_MASK>0x08</INT3_MASK>
        <INT4_MASK>0x10</INT4_MASK>
        <INT5_MASK>0x20</INT5_MASK>
        <INT6_MASK>0x40</INT6_MASK>
        <INT7_MASK>0x80</INT7_MASK>
      </EIMSK>
      <EIFR>
        <IO_ADDR>$1C</IO_ADDR>
        <MEM_ADDR>$3C</MEM_ADDR>
        <INTF0_MASK>0x01</INTF0_MASK>
        <INTF1_MASK>0x02</INTF1_MASK>
        <INTF2_MASK>0x04</INTF2_MASK>
        <INTF3_MASK>0x08</INTF3_MASK>
        <INTF4_MASK>0x10</INTF4_MASK>
        <INTF5_MASK>0x20</INTF5_MASK>
        <INTF6_MASK>0x40</INTF6_MASK>
        <INTF7_MASK>0x80</INTF7_MASK>
      </EIFR>
      <PCIFR>
        <IO_ADDR>$1B</IO_ADDR>
        <MEM_ADDR>$3B</MEM_ADDR>
        <PCIF0_MASK>0x01</PCIF0_MASK>
        <PCIF1_MASK>0x02</PCIF1_MASK>
        <PCIF2_MASK>0x04</PCIF2_MASK>
        <Res0_MASK>0x08</Res0_MASK>
        <Res1_MASK>0x10</Res1_MASK>
        <Res2_MASK>0x20</Res2_MASK>
        <Res3_MASK>0x40</Res3_MASK>
        <Res4_MASK>0x80</Res4_MASK>
      </PCIFR>
      <TIFR5>
        <IO_ADDR>$1A</IO_ADDR>
        <MEM_ADDR>$3A</MEM_ADDR>
        <TOV5_MASK>0x01</TOV5_MASK>
        <OCF5A_MASK>0x02</OCF5A_MASK>
        <OCF5B_MASK>0x04</OCF5B_MASK>
        <OCF5C_MASK>0x08</OCF5C_MASK>
        <Res_MASK>0x10</Res_MASK>
        <ICF5_MASK>0x20</ICF5_MASK>
        <Res0_MASK>0x40</Res0_MASK>
        <Res1_MASK>0x80</Res1_MASK>
      </TIFR5>
      <TIFR4>
        <IO_ADDR>$19</IO_ADDR>
        <MEM_ADDR>$39</MEM_ADDR>
        <TOV4_MASK>0x01</TOV4_MASK>
        <OCF4A_MASK>0x02</OCF4A_MASK>
        <OCF4B_MASK>0x04</OCF4B_MASK>
        <OCF4C_MASK>0x08</OCF4C_MASK>
        <Res_MASK>0x10</Res_MASK>
        <ICF4_MASK>0x20</ICF4_MASK>
        <Res0_MASK>0x40</Res0_MASK>
        <Res1_MASK>0x80</Res1_MASK>
      </TIFR4>
      <TIFR3>
        <IO_ADDR>$18</IO_ADDR>
        <MEM_ADDR>$38</MEM_ADDR>
        <TOV3_MASK>0x01</TOV3_MASK>
        <OCF3A_MASK>0x02</OCF3A_MASK>
        <OCF3B_MASK>0x04</OCF3B_MASK>
        <OCF3C_MASK>0x08</OCF3C_MASK>
        <Res_MASK>0x10</Res_MASK>
        <ICF3_MASK>0x20</ICF3_MASK>
        <Res0_MASK>0x40</Res0_MASK>
        <Res1_MASK>0x80</Res1_MASK>
      </TIFR3>
      <TIFR2>
        <IO_ADDR>$17</IO_ADDR>
        <MEM_ADDR>$37</MEM_ADDR>
        <TOV2_MASK>0x01</TOV2_MASK>
        <OCF2A_MASK>0x02</OCF2A_MASK>
        <OCF2B_MASK>0x04</OCF2B_MASK>
        <Res0_MASK>0x08</Res0_MASK>
        <Res1_MASK>0x10</Res1_MASK>
        <Res2_MASK>0x20</Res2_MASK>
        <Res3_MASK>0x40</Res3_MASK>
        <Res4_MASK>0x80</Res4_MASK>
      </TIFR2>
      <TIFR1>
        <IO_ADDR>$16</IO_ADDR>
        <MEM_ADDR>$36</MEM_ADDR>
        <TOV1_MASK>0x01</TOV1_MASK>
        <OCF1A_MASK>0x02</OCF1A_MASK>
        <OCF1B_MASK>0x04</OCF1B_MASK>
        <OCF1C_MASK>0x08</OCF1C_MASK>
        <Res_MASK>0x10</Res_MASK>
        <ICF1_MASK>0x20</ICF1_MASK>
        <Res0_MASK>0x40</Res0_MASK>
        <Res1_MASK>0x80</Res1_MASK>
      </TIFR1>
      <TIFR0>
        <IO_ADDR>$15</IO_ADDR>
        <MEM_ADDR>$35</MEM_ADDR>
        <TOV0_MASK>0x01</TOV0_MASK>
        <OCF0A_MASK>0x02</OCF0A_MASK>
        <OCF0B_MASK>0x04</OCF0B_MASK>
        <Res0_MASK>0x08</Res0_MASK>
        <Res1_MASK>0x10</Res1_MASK>
        <Res2_MASK>0x20</Res2_MASK>
        <Res3_MASK>0x40</Res3_MASK>
        <Res4_MASK>0x80</Res4_MASK>
      </TIFR0>
      <PORTG>
        <IO_ADDR>$14</IO_ADDR>
        <MEM_ADDR>$34</MEM_ADDR>
        <PORTG0_MASK>0x01</PORTG0_MASK>
        <PORTG1_MASK>0x02</PORTG1_MASK>
        <PORTG2_MASK>0x04</PORTG2_MASK>
        <PORTG3_MASK>0x08</PORTG3_MASK>
        <PORTG4_MASK>0x10</PORTG4_MASK>
        <PORTG5_MASK>0x20</PORTG5_MASK>
        <Res0_MASK>0x40</Res0_MASK>
        <Res1_MASK>0x80</Res1_MASK>
      </PORTG>
      <DDRG>
        <IO_ADDR>$13</IO_ADDR>
        <MEM_ADDR>$33</MEM_ADDR>
        <DDG0_MASK>0x01</DDG0_MASK>
        <DDG1_MASK>0x02</DDG1_MASK>
        <DDG2_MASK>0x04</DDG2_MASK>
        <DDG3_MASK>0x08</DDG3_MASK>
        <DDG4_MASK>0x10</DDG4_MASK>
        <DDG5_MASK>0x20</DDG5_MASK>
        <Res0_MASK>0x40</Res0_MASK>
        <Res1_MASK>0x80</Res1_MASK>
      </DDRG>
      <PING>
        <IO_ADDR>$12</IO_ADDR>
        <MEM_ADDR>$32</MEM_ADDR>
        <PING0_MASK>0x01</PING0_MASK>
        <PING1_MASK>0x02</PING1_MASK>
        <PING2_MASK>0x04</PING2_MASK>
        <PING3_MASK>0x08</PING3_MASK>
        <PING4_MASK>0x10</PING4_MASK>
        <PING5_MASK>0x20</PING5_MASK>
        <Res0_MASK>0x40</Res0_MASK>
        <Res1_MASK>0x80</Res1_MASK>
      </PING>
      <PORTF>
        <IO_ADDR>$11</IO_ADDR>
        <MEM_ADDR>$31</MEM_ADDR>
        <PORTF0_MASK>0x01</PORTF0_MASK>
        <PORTF1_MASK>0x02</PORTF1_MASK>
        <PORTF2_MASK>0x04</PORTF2_MASK>
        <PORTF3_MASK>0x08</PORTF3_MASK>
        <PORTF4_MASK>0x10</PORTF4_MASK>
        <PORTF5_MASK>0x20</PORTF5_MASK>
        <PORTF6_MASK>0x40</PORTF6_MASK>
        <PORTF7_MASK>0x80</PORTF7_MASK>
      </PORTF>
      <DDRF>
        <IO_ADDR>$10</IO_ADDR>
        <MEM_ADDR>$30</MEM_ADDR>
        <DDF0_MASK>0x01</DDF0_MASK>
        <DDF1_MASK>0x02</DDF1_MASK>
        <DDF2_MASK>0x04</DDF2_MASK>
        <DDF3_MASK>0x08</DDF3_MASK>
        <DDF4_MASK>0x10</DDF4_MASK>
        <DDF5_MASK>0x20</DDF5_MASK>
        <DDF6_MASK>0x40</DDF6_MASK>
        <DDF7_MASK>0x80</DDF7_MASK>
      </DDRF>
      <PINF>
        <IO_ADDR>$0F</IO_ADDR>
        <MEM_ADDR>$2F</MEM_ADDR>
        <PINF0_MASK>0x01</PINF0_MASK>
        <PINF1_MASK>0x02</PINF1_MASK>
        <PINF2_MASK>0x04</PINF2_MASK>
        <PINF3_MASK>0x08</PINF3_MASK>
        <PINF4_MASK>0x10</PINF4_MASK>
        <PINF5_MASK>0x20</PINF5_MASK>
        <PINF6_MASK>0x40</PINF6_MASK>
        <PINF7_MASK>0x80</PINF7_MASK>
      </PINF>
      <PORTE>
        <IO_ADDR>$0E</IO_ADDR>
        <MEM_ADDR>$2E</MEM_ADDR>
        <PORTE0_MASK>0x01</PORTE0_MASK>
        <PORTE1_MASK>0x02</PORTE1_MASK>
        <PORTE2_MASK>0x04</PORTE2_MASK>
        <PORTE3_MASK>0x08</PORTE3_MASK>
        <PORTE4_MASK>0x10</PORTE4_MASK>
        <PORTE5_MASK>0x20</PORTE5_MASK>
        <PORTE6_MASK>0x40</PORTE6_MASK>
        <PORTE7_MASK>0x80</PORTE7_MASK>
      </PORTE>
      <DDRE>
        <IO_ADDR>$0D</IO_ADDR>
        <MEM_ADDR>$2D</MEM_ADDR>
        <DDE0_MASK>0x01</DDE0_MASK>
        <DDE1_MASK>0x02</DDE1_MASK>
        <DDE2_MASK>0x04</DDE2_MASK>
        <DDE3_MASK>0x08</DDE3_MASK>
        <DDE4_MASK>0x10</DDE4_MASK>
        <DDE5_MASK>0x20</DDE5_MASK>
        <DDE6_MASK>0x40</DDE6_MASK>
        <DDE7_MASK>0x80</DDE7_MASK>
      </DDRE>
      <PINE>
        <IO_ADDR>$0C</IO_ADDR>
        <MEM_ADDR>$2C</MEM_ADDR>
        <PINE0_MASK>0x01</PINE0_MASK>
        <PINE1_MASK>0x02</PINE1_MASK>
        <PINE2_MASK>0x04</PINE2_MASK>
        <PINE3_MASK>0x08</PINE3_MASK>
        <PINE4_MASK>0x10</PINE4_MASK>
        <PINE5_MASK>0x20</PINE5_MASK>
        <PINE6_MASK>0x40</PINE6_MASK>
        <PINE7_MASK>0x80</PINE7_MASK>
      </PINE>
      <PORTD>
        <IO_ADDR>$0B</IO_ADDR>
        <MEM_ADDR>$2B</MEM_ADDR>
        <PORTD0_MASK>0x01</PORTD0_MASK>
        <PORTD1_MASK>0x02</PORTD1_MASK>
        <PORTD2_MASK>0x04</PORTD2_MASK>
        <PORTD3_MASK>0x08</PORTD3_MASK>
        <PORTD4_MASK>0x10</PORTD4_MASK>
        <PORTD5_MASK>0x20</PORTD5_MASK>
        <PORTD6_MASK>0x40</PORTD6_MASK>
        <PORTD7_MASK>0x80</PORTD7_MASK>
      </PORTD>
      <DDRD>
        <IO_ADDR>$0A</IO_ADDR>
        <MEM_ADDR>$2A</MEM_ADDR>
        <DDD0_MASK>0x01</DDD0_MASK>
        <DDD1_MASK>0x02</DDD1_MASK>
        <DDD2_MASK>0x04</DDD2_MASK>
        <DDD3_MASK>0x08</DDD3_MASK>
        <DDD4_MASK>0x10</DDD4_MASK>
        <DDD5_MASK>0x20</DDD5_MASK>
        <DDD6_MASK>0x40</DDD6_MASK>
        <DDD7_MASK>0x80</DDD7_MASK>
      </DDRD>
      <PIND>
        <IO_ADDR>$09</IO_ADDR>
        <MEM_ADDR>$29</MEM_ADDR>
        <PIND0_MASK>0x01</PIND0_MASK>
        <PIND1_MASK>0x02</PIND1_MASK>
        <PIND2_MASK>0x04</PIND2_MASK>
        <PIND3_MASK>0x08</PIND3_MASK>
        <PIND4_MASK>0x10</PIND4_MASK>
        <PIND5_MASK>0x20</PIND5_MASK>
        <PIND6_MASK>0x40</PIND6_MASK>
        <PIND7_MASK>0x80</PIND7_MASK>
      </PIND>
      <PORTC>
        <IO_ADDR>$08</IO_ADDR>
        <MEM_ADDR>$28</MEM_ADDR>
        <PORTC0_MASK>0x01</PORTC0_MASK>
        <PORTC1_MASK>0x02</PORTC1_MASK>
        <PORTC2_MASK>0x04</PORTC2_MASK>
        <PORTC3_MASK>0x08</PORTC3_MASK>
        <PORTC4_MASK>0x10</PORTC4_MASK>
        <PORTC5_MASK>0x20</PORTC5_MASK>
        <PORTC6_MASK>0x40</PORTC6_MASK>
        <PORTC7_MASK>0x80</PORTC7_MASK>
      </PORTC>
      <DDRC>
        <IO_ADDR>$07</IO_ADDR>
        <MEM_ADDR>$27</MEM_ADDR>
        <DDC0_MASK>0x01</DDC0_MASK>
        <DDC1_MASK>0x02</DDC1_MASK>
        <DDC2_MASK>0x04</DDC2_MASK>
        <DDC3_MASK>0x08</DDC3_MASK>
        <DDC4_MASK>0x10</DDC4_MASK>
        <DDC5_MASK>0x20</DDC5_MASK>
        <DDC6_MASK>0x40</DDC6_MASK>
        <DDC7_MASK>0x80</DDC7_MASK>
      </DDRC>
      <PINC>
        <IO_ADDR>$06</IO_ADDR>
        <MEM_ADDR>$26</MEM_ADDR>
        <PINC0_MASK>0x01</PINC0_MASK>
        <PINC1_MASK>0x02</PINC1_MASK>
        <PINC2_MASK>0x04</PINC2_MASK>
        <PINC3_MASK>0x08</PINC3_MASK>
        <PINC4_MASK>0x10</PINC4_MASK>
        <PINC5_MASK>0x20</PINC5_MASK>
        <PINC6_MASK>0x40</PINC6_MASK>
        <PINC7_MASK>0x80</PINC7_MASK>
      </PINC>
      <PORTB>
        <IO_ADDR>$05</IO_ADDR>
        <MEM_ADDR>$25</MEM_ADDR>
        <PORTB0_MASK>0x01</PORTB0_MASK>
        <PORTB1_MASK>0x02</PORTB1_MASK>
        <PORTB2_MASK>0x04</PORTB2_MASK>
        <PORTB3_MASK>0x08</PORTB3_MASK>
        <PORTB4_MASK>0x10</PORTB4_MASK>
        <PORTB5_MASK>0x20</PORTB5_MASK>
        <PORTB6_MASK>0x40</PORTB6_MASK>
        <PORTB7_MASK>0x80</PORTB7_MASK>
      </PORTB>
      <DDRB>
        <IO_ADDR>$04</IO_ADDR>
        <MEM_ADDR>$24</MEM_ADDR>
        <DDB0_MASK>0x01</DDB0_MASK>
        <DDB1_MASK>0x02</DDB1_MASK>
        <DDB2_MASK>0x04</DDB2_MASK>
        <DDB3_MASK>0x08</DDB3_MASK>
        <DDB4_MASK>0x10</DDB4_MASK>
        <DDB5_MASK>0x20</DDB5_MASK>
        <DDB6_MASK>0x40</DDB6_MASK>
        <DDB7_MASK>0x80</DDB7_MASK>
      </DDRB>
      <PINB>
        <IO_ADDR>$03</IO_ADDR>
        <MEM_ADDR>$23</MEM_ADDR>
        <PINB0_MASK>0x01</PINB0_MASK>
        <PINB1_MASK>0x02</PINB1_MASK>
        <PINB2_MASK>0x04</PINB2_MASK>
        <PINB3_MASK>0x08</PINB3_MASK>
        <PINB4_MASK>0x10</PINB4_MASK>
        <PINB5_MASK>0x20</PINB5_MASK>
        <PINB6_MASK>0x40</PINB6_MASK>
        <PINB7_MASK>0x80</PINB7_MASK>
      </PINB>
      <PORTA>
        <IO_ADDR>$02</IO_ADDR>
        <MEM_ADDR>$22</MEM_ADDR>
        <PORTA0_MASK>0x01</PORTA0_MASK>
        <PORTA1_MASK>0x02</PORTA1_MASK>
        <PORTA2_MASK>0x04</PORTA2_MASK>
        <PORTA3_MASK>0x08</PORTA3_MASK>
        <PORTA4_MASK>0x10</PORTA4_MASK>
        <PORTA5_MASK>0x20</PORTA5_MASK>
        <PORTA6_MASK>0x40</PORTA6_MASK>
        <PORTA7_MASK>0x80</PORTA7_MASK>
      </PORTA>
      <DDRA>
        <IO_ADDR>$01</IO_ADDR>
        <MEM_ADDR>$21</MEM_ADDR>
        <DDA0_MASK>0x01</DDA0_MASK>
        <DDA1_MASK>0x02</DDA1_MASK>
        <DDA2_MASK>0x04</DDA2_MASK>
        <DDA3_MASK>0x08</DDA3_MASK>
        <DDA4_MASK>0x10</DDA4_MASK>
        <DDA5_MASK>0x20</DDA5_MASK>
        <DDA6_MASK>0x40</DDA6_MASK>
        <DDA7_MASK>0x80</DDA7_MASK>
      </DDRA>
      <PINA>
        <IO_ADDR>$00</IO_ADDR>
        <MEM_ADDR>$20</MEM_ADDR>
        <PINA0_MASK>0x01</PINA0_MASK>
        <PINA1_MASK>0x02</PINA1_MASK>
        <PINA2_MASK>0x04</PINA2_MASK>
        <PINA3_MASK>0x08</PINA3_MASK>
        <PINA4_MASK>0x10</PINA4_MASK>
        <PINA5_MASK>0x20</PINA5_MASK>
        <PINA6_MASK>0x40</PINA6_MASK>
        <PINA7_MASK>0x80</PINA7_MASK>
      </PINA>
    </IO_MEMORY>
    <BOOT_CONFIG>
      <NRWW_START_ADDR>$F000</NRWW_START_ADDR>
      <NRWW_STOP_ADDR>$FFFF</NRWW_STOP_ADDR>
      <RWW_START_ADDR>$0000</RWW_START_ADDR>
      <RWW_STOP_ADDR>$EFFF</RWW_STOP_ADDR>
      <PAGESIZE>128</PAGESIZE>
      <BOOTSZMODE1>
        <BOOTSIZE>512</BOOTSIZE>
        <PAGES>4</PAGES>
        <APPSTART>$0000</APPSTART>
        <BOOTSTART>$FE00</BOOTSTART>
        <BOOTRESET>$FE00</BOOTRESET>
      </BOOTSZMODE1>
      <BOOTSZMODE2>
        <BOOTSIZE>1024</BOOTSIZE>
        <PAGES>8</PAGES>
        <APPSTART>$0000</APPSTART>
        <BOOTSTART>$FC00</BOOTSTART>
        <BOOTRESET>$FC00</BOOTRESET>
      </BOOTSZMODE2>
      <BOOTSZMODE3>
        <BOOTSIZE>2048</BOOTSIZE>
        <PAGES>16</PAGES>
        <APPSTART>$0000</APPSTART>
        <BOOTSTART>$F800</BOOTSTART>
        <BOOTRESET>$F800</BOOTRESET>
      </BOOTSZMODE3>
      <BOOTSZMODE4>
        <BOOTSIZE>4096</BOOTSIZE>
        <PAGES>32</PAGES>
        <APPSTART>$0000</APPSTART>
        <BOOTSTART>$F000</BOOTSTART>
        <BOOTRESET>$F000</BOOTRESET>
      </BOOTSZMODE4>
    </BOOT_CONFIG>
  </MEMORY>
  <ADMIN>
    <PART_NAME>ATmega128RFA1</PART_NAME>
    <SPEED>16MHZ</SPEED>
    <BUILD>1</BUILD>
    <RELEASE_STATUS>RELEASED</RELEASE_STATUS>
    <SIGNATURE>
      <ADDR000>$1E</ADDR000>
      <ADDR001>$A7</ADDR001>
      <ADDR002>$01</ADDR002>
    </SIGNATURE>
    <OCD_PARAMETERS>
      <OCD_REVISION>3</OCD_REVISION>
      <OCD_REGISTER_ADDRESS>0x31</OCD_REGISTER_ADDRESS>
      <CACHE_TYPE>0</CACHE_TYPE>
      <USE_JTAGID>1</USE_JTAGID>
      <DW_BASE_PC>0x00</DW_BASE_PC>
    </OCD_PARAMETERS>
  </ADMIN>
  <FUSE>
    <LIST>[LOW:HIGH:EXTENDED]</LIST>
    <ID/>
    <ICON/>
    <TEXT/>
    <LOW>
      <NMB_FUSE_BITS>8</NMB_FUSE_BITS>
      <FUSE7>
        <NAME>CKDIV8</NAME>
        <TEXT>Divide clock by 8</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE7>
      <FUSE6>
        <NAME>CKOUT</NAME>
        <TEXT>Clock output</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE6>
      <FUSE5>
        <NAME>SUT1</NAME>
        <TEXT>Select start-up time</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE5>
      <FUSE4>
        <NAME>SUT0</NAME>
        <TEXT>Select start-up time</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE4>
      <FUSE3>
        <NAME>CKSEL3</NAME>
        <TEXT>Select Clock Source</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE3>
      <FUSE2>
        <NAME>CKSEL2</NAME>
        <TEXT>Select Clock Source</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE2>
      <FUSE1>
        <NAME>CKSEL1</NAME>
        <TEXT>Select Clock Source</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE1>
      <FUSE0>
        <NAME>CKSEL0</NAME>
        <TEXT>Select Clock Source</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE0>
      <NMB_TEXT>19</NMB_TEXT>
      <TEXT1>
        <MASK>0x80</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Divide clock by 8 internally; [CKDIV8=0]</TEXT>
      </TEXT1>
      <TEXT2>
        <MASK>0x40</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Clock output on PORTE7; [CKOUT=0]</TEXT>
      </TEXT2>
      <TEXT3>
        <MASK>0x3F</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Ext. Clock; Start-up time: 6 CK + 0 ms; [SUT=00 CKSEL=0000]</TEXT>
      </TEXT3>
      <TEXT4>
        <MASK>0x3F</MASK>
        <VALUE>0x10</VALUE>
        <TEXT>Ext. Clock; Start-up time: 6 CK + 4.1 ms; [SUT=01 CKSEL=0000]</TEXT>
      </TEXT4>
      <TEXT5>
        <MASK>0x3F</MASK>
        <VALUE>0x20</VALUE>
        <TEXT>Ext. Clock; Start-up time: 6 CK + 65 ms; [SUT=10 CKSEL=0000]</TEXT>
      </TEXT5>
      <TEXT6>
        <MASK>0x3F</MASK>
        <VALUE>0x02</VALUE>
        <TEXT>Int. RC Osc.; Start-up time: 6 CK + 0 ms; [SUT=00 CKSEL=0010]</TEXT>
      </TEXT6>
      <TEXT7>
        <MASK>0x3F</MASK>
        <VALUE>0x12</VALUE>
        <TEXT>Int. RC Osc.; Start-up time: 6 CK + 4.1 ms; [SUT=01 CKSEL=0010]</TEXT>
      </TEXT7>
      <TEXT8>
        <MASK>0x3F</MASK>
        <VALUE>0x22</VALUE>
        <TEXT>Int. RC Osc.; Start-up time: 6 CK + 65 ms; [SUT=10 CKSEL=0010]</TEXT>
      </TEXT8>
      <TEXT9>
        <MASK>0x3F</MASK>
        <VALUE>0x03</VALUE>
        <TEXT>Int. 128kHz RC Osc.; Start-up time: 6 CK + 0 ms; [SUT=00 CKSEL=0011]</TEXT>
      </TEXT9>
      <TEXT10>
        <MASK>0x3F</MASK>
        <VALUE>0x13</VALUE>
        <TEXT>Int. 128kHz RC Osc.; Start-up time: 6 CK + 4 ms; [SUT=01 CKSEL=0011]</TEXT>
      </TEXT10>
      <TEXT11>
        <MASK>0x3F</MASK>
        <VALUE>0x23</VALUE>
        <TEXT>Int. 128kHz RC Osc.; Start-up time: 6 CK + 64 ms; [SUT=10 CKSEL=0011]</TEXT>
      </TEXT11>
      <TEXT12>
        <MASK>0x3F</MASK>
        <VALUE>0x06</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 258 CK + 4.1 ms; [SUT=00 CKSEL=0110]</TEXT>
      </TEXT12>
      <TEXT13>
        <MASK>0x3F</MASK>
        <VALUE>0x16</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 258 CK + 65 ms; [SUT=01 CKSEL=0110]</TEXT>
      </TEXT13>
      <TEXT14>
        <MASK>0x3F</MASK>
        <VALUE>0x26</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 1K CK + 0 ms; [SUT=10 CKSEL=0110]</TEXT>
      </TEXT14>
      <TEXT15>
        <MASK>0x3F</MASK>
        <VALUE>0x36</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 1K CK + 4.1 ms; [SUT=11 CKSEL=0110]</TEXT>
      </TEXT15>
      <TEXT16>
        <MASK>0x3F</MASK>
        <VALUE>0x07</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 1K CK + 65 ms; [SUT=00 CKSEL=0111]</TEXT>
      </TEXT16>
      <TEXT17>
        <MASK>0x3F</MASK>
        <VALUE>0x17</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 16K CK + 0 ms; [SUT=01 CKSEL=0111]</TEXT>
      </TEXT17>
      <TEXT18>
        <MASK>0x3F</MASK>
        <VALUE>0x27</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 16K CK + 4.1 ms; [SUT=10 CKSEL=0111]</TEXT>
      </TEXT18>
      <TEXT19>
        <MASK>0x3F</MASK>
        <VALUE>0x37</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 16K CK + 65 ms; [SUT=11 CKSEL=0111]</TEXT>
      </TEXT19>
      <TEXT20>
        <MASK>0x3F</MASK>
        <VALUE>0x08</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 258 CK + 4.1 ms; [SUT=00 CKSEL=1000]</TEXT>
      </TEXT20>
      <TEXT21>
        <MASK>0x3F</MASK>
        <VALUE>0x18</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 258 CK + 65 ms; [SUT=01 CKSEL=1000]</TEXT>
      </TEXT21>
      <TEXT22>
        <MASK>0x3F</MASK>
        <VALUE>0x28</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 1K CK + 0 ms; [SUT=10 CKSEL=1000]</TEXT>
      </TEXT22>
      <TEXT23>
        <MASK>0x3F</MASK>
        <VALUE>0x38</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 1K CK + 4.1 ms; [SUT=11 CKSEL=1000]</TEXT>
      </TEXT23>
      <TEXT24>
        <MASK>0x3F</MASK>
        <VALUE>0x09</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 1K CK + 65 ms; [SUT=00 CKSEL=1001]</TEXT>
      </TEXT24>
      <TEXT25>
        <MASK>0x3F</MASK>
        <VALUE>0x19</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 16K CK + 0 ms; [SUT=01 CKSEL=1001]</TEXT>
      </TEXT25>
      <TEXT26>
        <MASK>0x3F</MASK>
        <VALUE>0x29</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 16K CK + 4.1 ms; [SUT=10 CKSEL=1001]</TEXT>
      </TEXT26>
      <TEXT27>
        <MASK>0x3F</MASK>
        <VALUE>0x39</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 16K CK + 65 ms; [SUT=11 CKSEL=1001]</TEXT>
      </TEXT27>
      <TEXT28>
        <MASK>0x3F</MASK>
        <VALUE>0x0A</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 258 CK + 4.1 ms; [SUT=00 CKSEL=1010]</TEXT>
      </TEXT28>
      <TEXT29>
        <MASK>0x3F</MASK>
        <VALUE>0x1A</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 258 CK + 65 ms; [SUT=01 CKSEL=1010]</TEXT>
      </TEXT29>
      <TEXT30>
        <MASK>0x3F</MASK>
        <VALUE>0x2A</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 1K CK + 0 ms; [SUT=10 CKSEL=1010]</TEXT>
      </TEXT30>
      <TEXT31>
        <MASK>0x3F</MASK>
        <VALUE>0x3A</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 1K CK + 4.1 ms; [SUT=11 CKSEL=1010]</TEXT>
      </TEXT31>
      <TEXT32>
        <MASK>0x3F</MASK>
        <VALUE>0x0B</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 1K CK + 65 ms; [SUT=00 CKSEL=1011]</TEXT>
      </TEXT32>
      <TEXT33>
        <MASK>0x3F</MASK>
        <VALUE>0x1B</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 16K CK + 0 ms; [SUT=01 CKSEL=1011]</TEXT>
      </TEXT33>
      <TEXT34>
        <MASK>0x3F</MASK>
        <VALUE>0x2B</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 16K CK + 4.1 ms; [SUT=10 CKSEL=1011]</TEXT>
      </TEXT34>
      <TEXT35>
        <MASK>0x3F</MASK>
        <VALUE>0x3B</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 16K CK + 65 ms; [SUT=11 CKSEL=1011]</TEXT>
      </TEXT35>
      <TEXT36>
        <MASK>0x3F</MASK>
        <VALUE>0x0C</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 258 CK + 4.1 ms; [SUT=00 CKSEL=1100]</TEXT>
      </TEXT36>
      <TEXT37>
        <MASK>0x3F</MASK>
        <VALUE>0x1C</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 258 CK + 65 ms; [SUT=01 CKSEL=1100]</TEXT>
      </TEXT37>
      <TEXT38>
        <MASK>0x3F</MASK>
        <VALUE>0x2C</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 1K CK + 0 ms; [SUT=10 CKSEL=1100]</TEXT>
      </TEXT38>
      <TEXT39>
        <MASK>0x3F</MASK>
        <VALUE>0x3C</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 1K CK + 4.1 ms; [SUT=11 CKSEL=1100]</TEXT>
      </TEXT39>
      <TEXT40>
        <MASK>0x3F</MASK>
        <VALUE>0x0D</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 1K CK + 65 ms; [SUT=00 CKSEL=1101]</TEXT>
      </TEXT40>
      <TEXT41>
        <MASK>0x3F</MASK>
        <VALUE>0x1D</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 16K CK + 0 ms; [SUT=01 CKSEL=1101]</TEXT>
      </TEXT41>
      <TEXT42>
        <MASK>0x3F</MASK>
        <VALUE>0x2D</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 16K CK + 4.1 ms; [SUT=10 CKSEL=1101]</TEXT>
      </TEXT42>
      <TEXT43>
        <MASK>0x3F</MASK>
        <VALUE>0x3D</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 16K CK + 65 ms; [SUT=11 CKSEL=1101]</TEXT>
      </TEXT43>
      <TEXT44>
        <MASK>0x3F</MASK>
        <VALUE>0x0E</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 258 CK + 4.1 ms; [SUT=00 CKSEL=1110]</TEXT>
      </TEXT44>
      <TEXT45>
        <MASK>0x3F</MASK>
        <VALUE>0x1E</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 258 CK + 65 ms; [SUT=01 CKSEL=1110]</TEXT>
      </TEXT45>
      <TEXT46>
        <MASK>0x3F</MASK>
        <VALUE>0x2E</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 1K CK + 0 ms; [SUT=10 CKSEL=1110]</TEXT>
      </TEXT46>
      <TEXT47>
        <MASK>0x3F</MASK>
        <VALUE>0x3E</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 1K CK + 4.1 ms; [SUT=11 CKSEL=1110]</TEXT>
      </TEXT47>
      <TEXT48>
        <MASK>0x3F</MASK>
        <VALUE>0x0F</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 1K CK + 65 ms; [SUT=00 CKSEL=1111]</TEXT>
      </TEXT48>
      <TEXT49>
        <MASK>0x3F</MASK>
        <VALUE>0x1F</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 16K CK + 0 ms; [SUT=01 CKSEL=1111]</TEXT>
      </TEXT49>
      <TEXT50>
        <MASK>0x3F</MASK>
        <VALUE>0x2F</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 16K CK + 4.1 ms; [SUT=10 CKSEL=1111]</TEXT>
      </TEXT50>
      <TEXT51>
        <MASK>0x3F</MASK>
        <VALUE>0x3F</VALUE>
        <TEXT>Tranceiver Oscillator; Start-up time: 16K CK + 65 ms; [SUT=11 CKSEL=1111]</TEXT>
      </TEXT51>
    </LOW>
    <HIGH>
      <NMB_FUSE_BITS>8</NMB_FUSE_BITS>
      <FUSE7>
        <NAME>OCDEN</NAME>
        <TEXT>Enable OCD</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE7>
      <FUSE6>
        <NAME>JTAGEN</NAME>
        <TEXT>Enable JTAG</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE6>
      <FUSE5>
        <NAME>SPIEN</NAME>
        <TEXT>Enable Serial programming and Data Downloading</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE5>
      <FUSE4>
        <NAME>WDTON</NAME>
        <TEXT>Watchdog timer always on</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE4>
      <FUSE3>
        <NAME>EESAVE</NAME>
        <TEXT>EEPROM memory is preserved through chip erase</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE3>
      <FUSE2>
        <NAME>BOOTSZ1</NAME>
        <TEXT>Select Boot Size</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE2>
      <FUSE1>
        <NAME>BOOTSZ0</NAME>
        <TEXT>Select Boot Size</TEXT>
        <DEFAULT>0</DEFAULT>
      </FUSE1>
      <FUSE0>
        <NAME>BOOTRST</NAME>
        <TEXT>Select Reset Vector</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE0>
      <NMB_TEXT>10</NMB_TEXT>
      <TEXT1>
        <MASK>0x80</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>On-Chip Debug Enabled; [OCDEN=0]</TEXT>
      </TEXT1>
      <TEXT2>
        <MASK>0x40</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>JTAG Interface Enabled; [JTAGEN=0]</TEXT>
      </TEXT2>
      <TEXT3>
        <MASK>0x20</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Serial program downloading (SPI) enabled; [SPIEN=0]</TEXT>
      </TEXT3>
      <TEXT4>
        <MASK>0x10</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Watchdog timer always on; [WDTON=0]</TEXT>
      </TEXT4>
      <TEXT5>
        <MASK>0x08</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Preserve EEPROM memory through the Chip Erase cycle; [EESAVE=0]</TEXT>
      </TEXT5>
      <TEXT6>
        <MASK>0x06</MASK>
        <VALUE>0x06</VALUE>
        <TEXT>Boot Flash section size=512 words Boot start address=$FE00; [BOOTSZ=11]</TEXT>
      </TEXT6>
      <TEXT7>
        <MASK>0x06</MASK>
        <VALUE>0x04</VALUE>
        <TEXT>Boot Flash section size=1024 words Boot start address=$FC00; [BOOTSZ=10]</TEXT>
      </TEXT7>
      <TEXT8>
        <MASK>0x06</MASK>
        <VALUE>0x02</VALUE>
        <TEXT>Boot Flash section size=2048 words Boot start address=$F800; [BOOTSZ=01]</TEXT>
      </TEXT8>
      <TEXT9>
        <MASK>0x06</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Boot Flash section size=4096 words Boot start address=$F000; [BOOTSZ=00] ; default value</TEXT>
      </TEXT9>
      <TEXT10>
        <MASK>0x01</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Boot Reset vector Enabled (default address=$0000); [BOOTRST=0]</TEXT>
      </TEXT10>
    </HIGH>
    <EXTENDED>
      <NMB_FUSE_BITS>3</NMB_FUSE_BITS>
      <FUSE2>
        <NAME>BODLEVEL2</NAME>
        <TEXT>Brown-out Detector trigger level</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE2>
      <FUSE1>
        <NAME>BODLEVEL1</NAME>
        <TEXT>Brown-out Detector trigger level</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE1>
      <FUSE0>
        <NAME>BODLEVEL0</NAME>
        <TEXT>Brown-out Detector trigger level</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE0>
      <NMB_TEXT>4</NMB_TEXT>
      <TEXT1>
        <MASK>0x07</MASK>
        <VALUE>0x07</VALUE>
        <TEXT>Brown-out detection disabled; [BODLEVEL=111]</TEXT>
      </TEXT1>
      <TEXT2>
        <MASK>0x07</MASK>
        <VALUE>0x06</VALUE>
        <TEXT>Brown-out detection level at VCC=1.8 V; [BODLEVEL=110]</TEXT>
      </TEXT2>
      <TEXT3>
        <MASK>0x07</MASK>
        <VALUE>0x05</VALUE>
        <TEXT>Brown-out detection level at VCC=1.9 V; [BODLEVEL=101]</TEXT>
      </TEXT3>
      <TEXT4>
        <MASK>0x07</MASK>
        <VALUE>0x04</VALUE>
        <TEXT>Brown-out detection level at VCC=2.0 V; [BODLEVEL=100]</TEXT>
      </TEXT4>
      <TEXT5>
        <MASK>0x07</MASK>
        <VALUE>0x03</VALUE>
        <TEXT>Brown-out detection level at VCC=2.1 V; [BODLEVEL=011]</TEXT>
      </TEXT5>
      <TEXT6>
        <MASK>0x07</MASK>
        <VALUE>0x02</VALUE>
        <TEXT>Brown-out detection level at VCC=2.2 V; [BODLEVEL=010]</TEXT>
      </TEXT6>
      <TEXT7>
        <MASK>0x07</MASK>
        <VALUE>0x01</VALUE>
        <TEXT>Brown-out detection level at VCC=2.3 V; [BODLEVEL=001]</TEXT>
      </TEXT7>
      <TEXT8>
        <MASK>0x07</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Brown-out detection level at VCC=2.4 V; [BODLEVEL=000]</TEXT>
      </TEXT8>
    </EXTENDED>
  </FUSE>
  <PROGRAMMING>
    <ISPInterface>
      <FuseReadMask>0xff,0xdf</FuseReadMask>
      <FuseProgMask>0xff,0xdf</FuseProgMask>
      <FuseWarning>1,0x40,0x40,WARNING! These fuse settings will disable the JTAG interface!</FuseWarning>
      <FuseWarning>1,0x20,0x20,WARNING! These fuse settings will disable the ISP interface!</FuseWarning>
    </ISPInterface>
    <HVInterface>
      <FuseWarning>1,0x40,0x40,WARNING! These fuse settings will disable the JTAG interface!</FuseWarning>
      <FuseWarning>1,0x20,0x20,WARNING! These fuse settings will disable the ISP interface!</FuseWarning>
    </HVInterface>
    <JTAGInterface>
      <FuseWarning>1,0x40,0x40,WARNING! These fuse settings will disable the JTAG interface!</FuseWarning>
      <FuseWarning>1,0x20,0x20,WARNING! These fuse settings will disable the ISP interface!</FuseWarning>
    </JTAGInterface>
    <OscCal>
      <OCEntry>0x00,8.0 MHz</OCEntry>
    </OscCal>
    <FlashPageSize>256</FlashPageSize>
    <EepromPageSize>8</EepromPageSize>
  </PROGRAMMING>
  <IO_MODULE>
    <MODULE_LIST>[ANALOG_COMPARATOR:USART0:USART1:TWI:SPI:PORTA:PORTB:PORTC:PORTD:PORTE:PORTF:PORTG:TIMER_COUNTER_0:TIMER_COUNTER_2:WATCHDOG:TIMER_COUNTER_5:TIMER_COUNTER_4:TIMER_COUNTER_3:TIMER_COUNTER_1:TRX24:SYMCNT:EEPROM:JTAG:EXTERNAL_INTERRUPT:AD_CONVERTER:BOOT_LOAD:CPU:FLASH:PWRCTRL:USART0_SPI:USART1_SPI]</MODULE_LIST>
    <ANALOG_COMPARATOR>
      <LIST>[ADCSRB:ACSR:DIDR1]</LIST>
      <LINK/>
      <ICON>io_analo.bmp</ICON>
      <ID>AlgComp_01</ID>
      <TEXT/>
      <ADCSRB>
        <NAME>ADCSRB</NAME>
        <DESCRIPTION>ADC Control and Status Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$7B</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT6>
          <NAME>ACME</NAME>
          <DESCRIPTION>Analog Comparator Multiplexer Enable</DESCRIPTION>
          <TEXT>When this bit is written logic one and the ADC is switched off (ADEN in ADCSRA is zero), the ADC multiplexer defines the negative input of the Analog Comparator. When this bit is written logic zero, AIN1 is applied to the negative input of the Analog Comparator. For a detailed description of this bit, see section "Analog Comparator Multiplexed Input".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
      </ADCSRB>
      <ACSR>
        <NAME>ACSR</NAME>
        <DESCRIPTION>Analog Comparator Control And Status Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$30</IO_ADDR>
        <MEM_ADDR>$50</MEM_ADDR>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>ACD</NAME>
          <DESCRIPTION>Analog Comparator Disable</DESCRIPTION>
          <TEXT>When this bit is written logic one, the power to the Analog Comparator is switched off. This bit can be set at any time to turn off the Analog Comparator. This will reduce power consumption in Active and Idle mode. When changing the ACD bit, the Analog Comparator Interrupt must be disabled by clearing the ACIE bit in ACSR. Otherwise an interrupt can occur when the bit is changed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ACBG</NAME>
          <DESCRIPTION>Analog Comparator Bandgap Select</DESCRIPTION>
          <TEXT>When this bit is set, a fixed bandgap reference voltage connects to the positive input of the Analog Comparator. When this bit is cleared, AIN0 is applied to the positive input of the Analog Comparator. When the bandgap reference is used as the input of the Analog Comparator, it will take a certain time for the voltage to stabilize. If not stabilized, the first comparison may give a wrong value. See section "Internal Voltage Reference" for details.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ACO</NAME>
          <DESCRIPTION>Analog Compare Output</DESCRIPTION>
          <TEXT>The output of the analog comparator is synchronized and then directly connected to ACO. The synchronization introduces a delay of 1-2 clock cycles.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>NA</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ACI</NAME>
          <DESCRIPTION>Analog Comparator Interrupt Flag</DESCRIPTION>
          <TEXT>This bit is set by hardware when a comparator output event triggers the interrupt mode defined by ACIS1 and ACIS0. The Analog Comparator Interrupt routine is executed if the ACIE bit is set and the I-bit in SREG is set. ACI is cleared by hard-ware when executing the corresponding interrupt handling vector. Alternatively, ACI is cleared by writing a logic one to the flag.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ACIE</NAME>
          <DESCRIPTION>Analog Comparator Interrupt Enable</DESCRIPTION>
          <TEXT>When the ACIE bit is written logic one and the I-bit in the Status Register is set, the analog comparator interrupt is activated. When written logic zero, the interrupt is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ACIC</NAME>
          <DESCRIPTION>Analog Comparator Input Capture Enable</DESCRIPTION>
          <TEXT>When written logic one, this bit enables the input capture function in Timer/Counter1 to be triggered by the Analog Comparator. The comparator output is in this case directly connected to the input capture front-end logic, making the comparator utilize the noise canceler and edge select features of the Timer/Counter1 Input Capture interrupt. When written logic zero, no connection between the Analog Comparator and the input capture function exists. To make the comparator trigger the Timer/Counter1 Input Capture interrupt, the ICIE1 bit in the Timer Interrupt Mask Register (TIMSK1) must be set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ACIS1</NAME>
          <DESCRIPTION>Analog Comparator Interrupt Mode Select</DESCRIPTION>
          <TEXT>These bits determine which comparator events that trigger the Analog Comparator interrupt. The different settings are shown in the following table. When changing the ACIS1/ACIS0 bits, the Analog Comparator Interrupt must be disabled by clearing its Interrupt Enable bit in the ACSR Register. Otherwise an interrupt can occur when the bits are changed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ACIS0</NAME>
          <DESCRIPTION>Analog Comparator Interrupt Mode Select</DESCRIPTION>
          <TEXT>These bits determine which comparator events that trigger the Analog Comparator interrupt. The different settings are shown in the following table. When changing the ACIS1/ACIS0 bits, the Analog Comparator Interrupt must be disabled by clearing its Interrupt Enable bit in the ACSR Register. Otherwise an interrupt can occur when the bits are changed.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>ANALOG_COMP_INTERRUPT</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ACSR>
      <DIDR1>
        <NAME>DIDR1</NAME>
        <DESCRIPTION>Digital Input Disable Register 1</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$7F</MEM_ADDR>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT1>
          <NAME>AIN1D</NAME>
          <DESCRIPTION>AIN1 Digital Input Disable</DESCRIPTION>
          <TEXT>When this bit is written logic one, the digital input buffer on the AIN1 pin is disabled. The corresponding PIN Register bit will always read as zero when this bit is set. When an analog signal is applied to the AIN1 pin and the digital input from this pin is not needed, this bit should be written logic one to reduce power consumption in the digital input buffer.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>AIN0D</NAME>
          <DESCRIPTION>AIN0 Digital Input Disable</DESCRIPTION>
          <TEXT>When this bit is written logic one, the digital input buffer on the AIN0 pin is disabled. The corresponding PIN Register bit will always read as zero when this bit is set. When an analog signal is applied to the AIN0 pin and the digital input from this pin is not needed, this bit should be written logic one to reduce power consumption in the digital input buffer.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </DIDR1>
    </ANALOG_COMPARATOR>
    <USART0>
      <LIST>[UDR0:UCSR0A:UCSR0B:UCSR0C:UBRR0H:UBRR0L]</LIST>
      <LINK>[UBRR0H:UBRR0L]</LINK>
      <ICON>io_com.bmp</ICON>
      <ID/>
      <TEXT>The Universal Synchronous and Asynchronous serial Receiver and Transmitter (USART) is a highly flexible serial communication device. The main features are: Full Duplex Operation (Independent Serial Receive and Transmit Registers), Asynchronous or Synchronous Operation, Master or Slave Clocked Synchronous Operation, High Resolution Baud Rate Generator, supports Serial Frames with 5, 6, 7, 8, or 9 Data Bits and 1 or 2 Stop Bits, Odd or Even Parity Generation and Parity Check Supported by Hardware, Data OverRun Detection, Framing Error Detection, Noise Filtering includes False Start Bit Detection and Digital Low Pass Filter, three Separate Interrupts on TX Complete, TX Data Register Empty and RX Complete, Multi-processor Communication Mode and Double Speed Asynchronous Communication Mode. The ATmega128RFA1 has two USARTs: USART0 and USART1.</TEXT>
      <UDR0>
        <NAME>UDR0</NAME>
        <DESCRIPTION>USART0 I/O Data Register</DESCRIPTION>
        <TEXT>The USART Transmit Data Buffer Register and USART Receive Data Buffer Registers share the same I/O address referred to as USART Data Register or UDR0. The Transmit Data Buffer Register (TXB) will be the destination for data written to the UDR0 Register location. Reading the UDR0 Register location will return the contents of the Receive Data Buffer Register (RXB). For 5-, 6-, or 7-bit characters the upper unused bits will be ignored by the Transmitter and set to zero by the Receiver. The transmit buffer can only be written when the UDRE0 Flag in the UCSR0A Register is set. Data written to UDR0 when the UDRE0 Flag is not set, will be ignored by the USART Transmitter. When data is written to the transmit buffer and the Transmitter is enabled, the Transmitter will load the data into the Transmit Shift Register when the Shift Register is empty. Then the data will be serially transmitted on the TxD0 pin. The receive buffer consists of a two level FIFO. The FIFO will change its state whenever the receive buffer is accessed. Due to this behavior of the receive buffer, do not use Read-Modify-Write instructions (SBI and CBI) on this location. Be careful when using bit test instructions (SBIC and SBIS), since these also will change the state of the FIFO.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$C6</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <READ_INTRUSIVE/>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>UDR07</NAME>
          <DESCRIPTION>USART I/O Data Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>UDR06</NAME>
          <DESCRIPTION>USART I/O Data Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UDR05</NAME>
          <DESCRIPTION>USART I/O Data Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>UDR04</NAME>
          <DESCRIPTION>USART I/O Data Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>UDR03</NAME>
          <DESCRIPTION>USART I/O Data Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UDR02</NAME>
          <DESCRIPTION>USART I/O Data Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>UDR01</NAME>
          <DESCRIPTION>USART I/O Data Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>UDR00</NAME>
          <DESCRIPTION>USART I/O Data Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>USART_DATA_REG_BITF</ENUM>
        </BIT0>
      </UDR0>
      <UCSR0A>
        <NAME>UCSR0A</NAME>
        <DESCRIPTION>USART0 Control and Status Register A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$C0</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>RXC0</NAME>
          <DESCRIPTION>USART Receive Complete</DESCRIPTION>
          <TEXT>This flag bit is set when there are unread data in the receive buffer and cleared when the receive buffer is empty (i.e., does not contain any unread data). If the Receiver is disabled, the receive buffer will be flushed and consequently the RXC0 bit will become zero. The RXC0 Flag can be used to generate a Receive Complete interrupt (see description of the RXCIE0 bit).</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TXC0</NAME>
          <DESCRIPTION>USART Transmit Complete</DESCRIPTION>
          <TEXT>This flag bit is set when the entire frame in the Transmit Shift Register has been shifted out and there are no new data currently present in the transmit buffer (UDR0). The TXC0 Flag bit is automatically cleared when a transmit complete interrupt is executed, or it can be cleared by writing a one to its bit location. The TXC0 Flag can generate a Transmit Complete interrupt (see description of the TXCIE0 bit).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UDRE0</NAME>
          <DESCRIPTION>USART Data Register Empty</DESCRIPTION>
          <TEXT>The UDRE0 Flag indicates if the transmit buffer (UDR0) is ready to receive new data. If UDRE0 is one, the buffer is empty, and therefore ready to be written. The UDRE0 Flag can generate a Data Register Empty interrupt (see description of the UDRIE0 bit). UDRE0 is set after a reset to indicate that the Transmitter is ready.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>FE0</NAME>
          <DESCRIPTION>Frame Error</DESCRIPTION>
          <TEXT>This bit is set if the next character in the receive buffer had a Frame Error when received. I.e., when the first stop bit of the next character in the receive buffer is zero. This bit is valid until the receive buffer (UDR0) is read. The FE0 bit is zero when the stop bit of received data is one. Always set this bit to zero when writing to UCSR0A.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>DOR0</NAME>
          <DESCRIPTION>Data OverRun</DESCRIPTION>
          <TEXT>This bit is set if a Data OverRun condition is detected. A Data OverRun occurs when the receive buffer is full (two characters), it is a new character waiting in the Receive Shift Register and a new start bit is detected. This bit is valid until the receive buffer (UDR0) is read. Always set this bit to zero when writing to UCSR0A.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UPE0</NAME>
          <DESCRIPTION>USART Parity Error</DESCRIPTION>
          <TEXT>This bit is set if the next character in the receive buffer had a Parity Error when received and the Parity Checking was enabled at that point (UPM01 = 1). This bit is valid until the receive buffer (UDR0) is read. Always set this bit to zero when writing to UCSR0A.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>U2X0</NAME>
          <DESCRIPTION>Double the USART Transmission Speed</DESCRIPTION>
          <TEXT>This bit only has effect for the asynchronous operation. Write this bit to zero when using synchronous operation. Writing this bit to one will reduce the divisor of the baud rate divider from 16 to 8 effectively doubling the transfer rate for asynchronous communication.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>MPCM0</NAME>
          <DESCRIPTION>Multi-processor Communication Mode</DESCRIPTION>
          <TEXT>This bit enables the Multi-processor Communication mode. When the MPCM0 bit is written to one, all the incoming frames received by the USART Receiver that do not contain address information will be ignored. The Transmitter is unaffected by the MPCM0 setting. For more detailed information see section "Multi-processor Communication Mode".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </UCSR0A>
      <UCSR0B>
        <NAME>UCSR0B</NAME>
        <DESCRIPTION>USART0 Control and Status Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$C1</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>RXCIE0</NAME>
          <DESCRIPTION>RX Complete Interrupt Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables interrupt on the RXC0 Flag. A USART Receive Complete interrupt will be generated only if the RXCIE0 bit is written to one, the Global Interrupt Flag in SREG is written to one and the RXC0 bit in UCSR0A is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TXCIE0</NAME>
          <DESCRIPTION>TX Complete Interrupt Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables interrupt on the TXC0 Flag. A USART Transmit Complete interrupt will be generated only if the TXCIE0 bit is written to one, the Global Interrupt Flag in SREG is written to one and the TXC0 bit in UCSR0A is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UDRIE0</NAME>
          <DESCRIPTION>USART Data Register Empty Interrupt Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables interrupt on the UDRE0 Flag. A Data Register Empty interrupt will be generated only if the UDRIE0 bit is written to one, the Global Interrupt Flag in SREG is written to one and the UDRE0 bit in UCSR0A is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>RXEN0</NAME>
          <DESCRIPTION>Receiver Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables the USART Receiver. The Receiver will override normal port operation for the RxD0 pin when enabled. Disabling the Receiver will flush the receive buffer invalidating the FE0, DOR0 and UPE0 Flags.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TXEN0</NAME>
          <DESCRIPTION>Transmitter Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables the USART Transmitter. The Transmitter will override normal port operation for the TxD0 pin when enabled. The disabling of the Transmitter (writing TXEN0 to zero) will not become effective until ongoing and pending transmissions are completed, i.e., when the Transmit Shift Register and Transmit Buffer Register do not contain data to be transmitted. When disabled, the Transmitter will no longer override the TxD0 port.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UCSZ02</NAME>
          <DESCRIPTION>Character Size</DESCRIPTION>
          <TEXT>The UCSZ02 bits combined with the UCSZ01:0 bit in UCSR0C sets the number of data bits (Character Size) in the frame that the Receiver and Transmitter use.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>RXB80</NAME>
          <DESCRIPTION>Receive Data Bit 8</DESCRIPTION>
          <TEXT>RXB80 is the 9th data bit of the received character when operating with serial frames with nine data bits. The bit must be read before reading the lower 8 bits from UDR0.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TXB80</NAME>
          <DESCRIPTION>Transmit Data Bit 8</DESCRIPTION>
          <TEXT>TXB80 is the 9th data bit in the character to be transmitted when operating with serial frames with nine data bits. The bit must be written before writing the lower 8 bits to UDR0.</TEXT>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </UCSR0B>
      <UCSR0C>
        <NAME>UCSR0C</NAME>
        <DESCRIPTION>USART0 Control and Status Register C</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$C2</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>UMSEL01</NAME>
          <ALIAS>UMSEL1</ALIAS>
          <DESCRIPTION>USART Mode Select</DESCRIPTION>
          <TEXT>These bits select the mode of operation of the USART0 as shown in the following table. See section "USART in SPI Mode" for a full description of the Master SPI Mode (MSPIM) operation.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>UMSEL00</NAME>
          <ALIAS>UMSEL0</ALIAS>
          <DESCRIPTION>USART Mode Select</DESCRIPTION>
          <TEXT>These bits select the mode of operation of the USART0 as shown in the following table. See section "USART in SPI Mode" for a full description of the Master SPI Mode (MSPIM) operation.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>COMM_USART_MODE_2BIT_MEGARF</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UPM01</NAME>
          <DESCRIPTION>Parity Mode</DESCRIPTION>
          <TEXT>These bits enable and set type of parity generation and check. If enabled, the Transmitter will automatically generate and send the parity of the transmitted data bits within each frame. The Receiver will generate a parity value for the incoming data and compare it to the UPM0 setting. If a mismatch is detected, the UPE0 Flag in UCSR0A will be set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>UPM00</NAME>
          <DESCRIPTION>Parity Mode</DESCRIPTION>
          <TEXT>These bits enable and set type of parity generation and check. If enabled, the Transmitter will automatically generate and send the parity of the transmitted data bits within each frame. The Receiver will generate a parity value for the incoming data and compare it to the UPM0 setting. If a mismatch is detected, the UPE0 Flag in UCSR0A will be set.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>COMM_UPM_PARITY_MODE</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>USBS0</NAME>
          <DESCRIPTION>Stop Bit Select</DESCRIPTION>
          <TEXT>This bit selects the number of stop bits to be inserted by the Transmitter. The Receiver ignores this setting.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>COMM_STOP_BIT_SEL</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UCSZ01</NAME>
          <ALIAS>UDORD0</ALIAS>
          <DESCRIPTION>Character Size</DESCRIPTION>
          <TEXT>The UCSZ01:0 bits combined with the UCSZ02 bit in UCSR0B sets the number of data bits (Character Size) in the frame that the Receiver and Transmitter use.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>UCSZ00</NAME>
          <ALIAS>UCPHA0</ALIAS>
          <DESCRIPTION>Character Size</DESCRIPTION>
          <TEXT>The UCSZ01:0 bits combined with the UCSZ02 bit in UCSR0B sets the number of data bits (Character Size) in the frame that the Receiver and Transmitter use.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
          <ENUM>USART_CHAR_SIZE_BITF</ENUM>
        </BIT1>
        <BIT0>
          <NAME>UCPOL0</NAME>
          <DESCRIPTION>Clock Polarity</DESCRIPTION>
          <TEXT>This bit is used for synchronous mode only. Write this bit to zero when asynchronous mode is used. The UCPOL0 bit sets the relationship between data output change and data input sample, and the synchronous clock (XCK0).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>USART_CLK_POLARITY_BITF</ENUM>
        </BIT0>
      </UCSR0C>
      <UBRR0H>
        <NAME>UBRR0H</NAME>
        <DESCRIPTION>USART0 Baud Rate Register High Byte</DESCRIPTION>
        <TEXT>UBRR0 is a 12-bit register which contains the USART baud rate. The UBRR0H contains the four most significant bits, and the UBRR0L contains the eight least significant bits of the USART baud rate. Ongoing transmissions by the Transmitter and Receiver will be corrupted if the baud rate is changed. Writing UBRR0L will trigger an immediate update of the baud rate prescaler.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$C5</MEM_ADDR>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>Res3</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res2</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>UBRR11</NAME>
          <DESCRIPTION>USART Baud Rate Register</DESCRIPTION>
          <TEXT>These bits represent bits [11:8] of the Baud Rate Register. Sample values for commonly used clock frequencies can be found in section "Examples of Baud Rate Setting".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UBRR10</NAME>
          <DESCRIPTION>USART Baud Rate Register</DESCRIPTION>
          <TEXT>These bits represent bits [11:8] of the Baud Rate Register. Sample values for commonly used clock frequencies can be found in section "Examples of Baud Rate Setting".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>UBRR9</NAME>
          <DESCRIPTION>USART Baud Rate Register</DESCRIPTION>
          <TEXT>These bits represent bits [11:8] of the Baud Rate Register. Sample values for commonly used clock frequencies can be found in section "Examples of Baud Rate Setting".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>UBRR8</NAME>
          <DESCRIPTION>USART Baud Rate Register</DESCRIPTION>
          <TEXT>These bits represent bits [11:8] of the Baud Rate Register. Sample values for commonly used clock frequencies can be found in section "Examples of Baud Rate Setting".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>USART_BAUD_RATE_HB_BITF</ENUM>
        </BIT0>
      </UBRR0H>
      <UBRR0L>
        <NAME>UBRR0L</NAME>
        <DESCRIPTION>USART0 Baud Rate Register Low Byte</DESCRIPTION>
        <TEXT>UBRR0 is a 12-bit register which contains the USART baud rate. The UBRR0H contains the four most significant bits, and the UBRR0L contains the eight least significant bits of the USART baud rate. Ongoing transmissions by the Transmitter and Receiver will be corrupted if the baud rate is changed. Writing UBRR0L will trigger an immediate update of the baud rate prescaler.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$C4</MEM_ADDR>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>UBRR7</NAME>
          <DESCRIPTION>USART Baud Rate Register</DESCRIPTION>
          <TEXT>These bits represent bits [7:0] of the Baud Rate Register. Sample values for commonly used clock frequencies can be found in section "Examples of Baud Rate Setting".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>UBRR6</NAME>
          <DESCRIPTION>USART Baud Rate Register</DESCRIPTION>
          <TEXT>These bits represent bits [7:0] of the Baud Rate Register. Sample values for commonly used clock frequencies can be found in section "Examples of Baud Rate Setting".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UBRR5</NAME>
          <DESCRIPTION>USART Baud Rate Register</DESCRIPTION>
          <TEXT>These bits represent bits [7:0] of the Baud Rate Register. Sample values for commonly used clock frequencies can be found in section "Examples of Baud Rate Setting".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>UBRR4</NAME>
          <DESCRIPTION>USART Baud Rate Register</DESCRIPTION>
          <TEXT>These bits represent bits [7:0] of the Baud Rate Register. Sample values for commonly used clock frequencies can be found in section "Examples of Baud Rate Setting".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>UBRR3</NAME>
          <DESCRIPTION>USART Baud Rate Register</DESCRIPTION>
          <TEXT>These bits represent bits [7:0] of the Baud Rate Register. Sample values for commonly used clock frequencies can be found in section "Examples of Baud Rate Setting".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UBRR2</NAME>
          <DESCRIPTION>USART Baud Rate Register</DESCRIPTION>
          <TEXT>These bits represent bits [7:0] of the Baud Rate Register. Sample values for commonly used clock frequencies can be found in section "Examples of Baud Rate Setting".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>UBRR1</NAME>
          <DESCRIPTION>USART Baud Rate Register</DESCRIPTION>
          <TEXT>These bits represent bits [7:0] of the Baud Rate Register. Sample values for commonly used clock frequencies can be found in section "Examples of Baud Rate Setting".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>UBRR0</NAME>
          <DESCRIPTION>USART Baud Rate Register</DESCRIPTION>
          <TEXT>These bits represent bits [7:0] of the Baud Rate Register. Sample values for commonly used clock frequencies can be found in section "Examples of Baud Rate Setting".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>USART_BAUD_RATE_LB_BITF</ENUM>
        </BIT0>
      </UBRR0L>
    </USART0>
    <USART1>
      <LIST>[UDR1:UCSR1A:UCSR1B:UCSR1C:UBRR1H:UBRR1L]</LIST>
      <LINK>[UBRR1H:UBRR1L]</LINK>
      <ICON>io_com.bmp</ICON>
      <ID/>
      <TEXT>The Universal Synchronous and Asynchronous serial Receiver and Transmitter (USART) is a highly flexible serial communication device. The main features are: Full Duplex Operation (Independent Serial Receive and Transmit Registers), Asynchronous or Synchronous Operation, Master or Slave Clocked Synchronous Operation, High Resolution Baud Rate Generator, supports Serial Frames with 5, 6, 7, 8, or 9 Data Bits and 1 or 2 Stop Bits, Odd or Even Parity Generation and Parity Check Supported by Hardware, Data OverRun Detection, Framing Error Detection, Noise Filtering includes False Start Bit Detection and Digital Low Pass Filter, three Separate Interrupts on TX Complete, TX Data Register Empty and RX Complete, Multi-processor Communication Mode and Double Speed Asynchronous Communication Mode. The ATmega128RFA1 has two USARTs: USART0 and USART1.</TEXT>
      <UDR1>
        <NAME>UDR1</NAME>
        <DESCRIPTION>USART1 I/O Data Register</DESCRIPTION>
        <TEXT>The USART Transmit Data Buffer Register and USART Receive Data Buffer Registers share the same I/O address referred to as USART Data Register or UDR1. The Transmit Data Buffer Register (TXB) will be the destination for data written to the UDR1 Register location. Reading the UDR1 Register location will return the contents of the Receive Data Buffer Register (RXB). For 5-, 6-, or 7-bit characters the upper unused bits will be ignored by the Transmitter and set to zero by the Receiver. The transmit buffer can only be written when the UDRE1 Flag in the UCSR1A Register is set. Data written to UDR1 when the UDRE1 Flag is not set, will be ignored by the USART Transmitter. When data is written to the transmit buffer and the Transmitter is enabled, the Transmitter will load the data into the Transmit Shift Register when the Shift Register is empty. Then the data will be serially transmitted on the TxD1 pin. The receive buffer consists of a two level FIFO. The FIFO will change its state whenever the receive buffer is accessed. Due to this behavior of the receive buffer, do not use Read-Modify-Write instructions (SBI and CBI) on this location. Be careful when using bit test instructions (SBIC and SBIS), since these also will change the state of the FIFO.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$CE</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <READ_INTRUSIVE/>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>UDR17</NAME>
          <DESCRIPTION>USART I/O Data Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>UDR16</NAME>
          <DESCRIPTION>USART I/O Data Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UDR15</NAME>
          <DESCRIPTION>USART I/O Data Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>UDR14</NAME>
          <DESCRIPTION>USART I/O Data Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>UDR13</NAME>
          <DESCRIPTION>USART I/O Data Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UDR12</NAME>
          <DESCRIPTION>USART I/O Data Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>UDR11</NAME>
          <DESCRIPTION>USART I/O Data Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>UDR10</NAME>
          <DESCRIPTION>USART I/O Data Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>USART_DATA_REG_BITF</ENUM>
        </BIT0>
      </UDR1>
      <UCSR1A>
        <NAME>UCSR1A</NAME>
        <DESCRIPTION>USART1 Control and Status Register A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$C8</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>RXC1</NAME>
          <DESCRIPTION>USART Receive Complete</DESCRIPTION>
          <TEXT>This flag bit is set when there are unread data in the receive buffer and cleared when the receive buffer is empty (i.e., does not contain any unread data). If the Receiver is disabled, the receive buffer will be flushed and consequently the RXC1 bit will become zero. The RXC1 Flag can be used to generate a Receive Complete interrupt (see description of the RXCIE1 bit).</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TXC1</NAME>
          <DESCRIPTION>USART Transmit Complete</DESCRIPTION>
          <TEXT>This flag bit is set when the entire frame in the Transmit Shift Register has been shifted out and there are no new data currently present in the transmit buffer (UDR1). The TXC1 Flag bit is automatically cleared when a transmit complete interrupt is executed, or it can be cleared by writing a one to its bit location. The TXC1 Flag can generate a Transmit Complete interrupt (see description of the TXCIE1 bit).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UDRE1</NAME>
          <DESCRIPTION>USART Data Register Empty</DESCRIPTION>
          <TEXT>The UDRE1 Flag indicates if the transmit buffer (UDR1) is ready to receive new data. If UDRE1 is one, the buffer is empty, and therefore ready to be written. The UDRE1 Flag can generate a Data Register Empty interrupt (see description of the UDRIE1 bit). UDRE1 is set after a reset to indicate that the Transmitter is ready.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>FE1</NAME>
          <DESCRIPTION>Frame Error</DESCRIPTION>
          <TEXT>This bit is set if the next character in the receive buffer had a Frame Error when received. I.e., when the first stop bit of the next character in the receive buffer is zero. This bit is valid until the receive buffer (UDR1) is read. The FE1 bit is zero when the stop bit of received data is one. Always set this bit to zero when writing to UCSR1A.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>DOR1</NAME>
          <DESCRIPTION>Data OverRun</DESCRIPTION>
          <TEXT>This bit is set if a Data OverRun condition is detected. A Data OverRun occurs when the receive buffer is full (two characters), it is a new character waiting in the Receive Shift Register and a new start bit is detected. This bit is valid until the receive buffer (UDR1) is read. Always set this bit to zero when writing to UCSR1A.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UPE1</NAME>
          <DESCRIPTION>USART Parity Error</DESCRIPTION>
          <TEXT>This bit is set if the next character in the receive buffer had a Parity Error when received and the Parity Checking was enabled at that point (UPM11 = 1). This bit is valid until the receive buffer (UDR1) is read. Always set this bit to zero when writing to UCSR1A.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>U2X1</NAME>
          <DESCRIPTION>Double the USART Transmission Speed</DESCRIPTION>
          <TEXT>This bit only has effect for the asynchronous operation. Write this bit to zero when using synchronous operation. Writing this bit to one will reduce the divisor of the baud rate divider from 16 to 8 effectively doubling the transfer rate for asynchronous communication.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>MPCM1</NAME>
          <DESCRIPTION>Multi-processor Communication Mode</DESCRIPTION>
          <TEXT>This bit enables the Multi-processor Communication mode. When the MPCM1 bit is written to one, all the incoming frames received by the USART Receiver that do not contain address information will be ignored. The Transmitter is unaffected by the MPCM1 setting. For more detailed information see section "Multi-processor Communication Mode".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </UCSR1A>
      <UCSR1B>
        <NAME>UCSR1B</NAME>
        <DESCRIPTION>USART1 Control and Status Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$C9</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>RXCIE1</NAME>
          <DESCRIPTION>RX Complete Interrupt Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables interrupt on the RXC1 Flag. A USART Receive Complete interrupt will be generated only if the RXCIE1 bit is written to one, the Global Interrupt Flag in SREG is written to one and the RXC1 bit in UCSR1A is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TXCIE1</NAME>
          <DESCRIPTION>TX Complete Interrupt Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables interrupt on the TXC1 Flag. A USART Transmit Complete interrupt will be generated only if the TXCIE1 bit is written to one, the Global Interrupt Flag in SREG is written to one and the TXC1 bit in UCSR1A is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UDRIE1</NAME>
          <DESCRIPTION>USART Data Register Empty Interrupt Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables interrupt on the UDRE1 Flag. A Data Register Empty interrupt will be generated only if the UDRIE1 bit is written to one, the Global Interrupt Flag in SREG is written to one and the UDRE1 bit in UCSR1A is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>RXEN1</NAME>
          <DESCRIPTION>Receiver Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables the USART Receiver. The Receiver will override normal port operation for the RxD1 pin when enabled. Disabling the Receiver will flush the receive buffer invalidating the FE1, DOR1 and UPE1 Flags.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TXEN1</NAME>
          <DESCRIPTION>Transmitter Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables the USART Transmitter. The Transmitter will override normal port operation for the TxD1 pin when enabled. The disabling of the Transmitter (writing TXEN1 to zero) will not become effective until ongoing and pending transmissions are completed, i.e., when the Transmit Shift Register and Transmit Buffer Register do not contain data to be transmitted. When disabled, the Transmitter will no longer override the TxD1 port.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UCSZ12</NAME>
          <DESCRIPTION>Character Size</DESCRIPTION>
          <TEXT>The UCSZ12 bits combined with the UCSZ11:0 bit in UCSR1C sets the number of data bits (Character Size) in the frame that the Receiver and Transmitter use.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>RXB81</NAME>
          <DESCRIPTION>Receive Data Bit 8</DESCRIPTION>
          <TEXT>RXB81 is the 9th data bit of the received character when operating with serial frames with nine data bits. The bit must be read before reading the lower 8 bits from UDR1.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TXB81</NAME>
          <DESCRIPTION>Transmit Data Bit 8</DESCRIPTION>
          <TEXT>TXB81 is the 9th data bit in the character to be transmitted when operating with serial frames with nine data bits. The bit must be written before writing the lower 8 bits to UDR1.</TEXT>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </UCSR1B>
      <UCSR1C>
        <NAME>UCSR1C</NAME>
        <DESCRIPTION>USART1 Control and Status Register C</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$CA</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>UMSEL11</NAME>
          <DESCRIPTION>USART Mode Select</DESCRIPTION>
          <TEXT>These bits select the mode of operation of the USART1 as shown in the following table. See section "USART in SPI Mode" for a full description of the Master SPI Mode (MSPIM) operation.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>UMSEL10</NAME>
          <DESCRIPTION>USART Mode Select</DESCRIPTION>
          <TEXT>These bits select the mode of operation of the USART1 as shown in the following table. See section "USART in SPI Mode" for a full description of the Master SPI Mode (MSPIM) operation.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>COMM_USART_MODE_2BIT_MEGARF</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UPM11</NAME>
          <DESCRIPTION>Parity Mode</DESCRIPTION>
          <TEXT>These bits enable and set type of parity generation and check. If enabled, the Transmitter will automatically generate and send the parity of the transmitted data bits within each frame. The Receiver will generate a parity value for the incoming data and compare it to the UPM1 setting. If a mismatch is detected, the UPE1 Flag in UCSR1A will be set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>UPM10</NAME>
          <DESCRIPTION>Parity Mode</DESCRIPTION>
          <TEXT>These bits enable and set type of parity generation and check. If enabled, the Transmitter will automatically generate and send the parity of the transmitted data bits within each frame. The Receiver will generate a parity value for the incoming data and compare it to the UPM1 setting. If a mismatch is detected, the UPE1 Flag in UCSR1A will be set.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>COMM_UPM_PARITY_MODE</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>USBS1</NAME>
          <DESCRIPTION>Stop Bit Select</DESCRIPTION>
          <TEXT>This bit selects the number of stop bits to be inserted by the Transmitter. The Receiver ignores this setting.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>COMM_STOP_BIT_SEL</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UCSZ11</NAME>
          <ALIAS>UDORD1</ALIAS>
          <DESCRIPTION>Character Size</DESCRIPTION>
          <TEXT>The UCSZ11:0 bits combined with the UCSZ12 bit in UCSR1B sets the number of data bits (Character Size) in the frame that the Receiver and Transmitter use.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>UCSZ10</NAME>
          <ALIAS>UCPHA1</ALIAS>
          <DESCRIPTION>Character Size</DESCRIPTION>
          <TEXT>The UCSZ11:0 bits combined with the UCSZ12 bit in UCSR1B sets the number of data bits (Character Size) in the frame that the Receiver and Transmitter use.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
          <ENUM>USART_CHAR_SIZE_BITF</ENUM>
        </BIT1>
        <BIT0>
          <NAME>UCPOL1</NAME>
          <DESCRIPTION>Clock Polarity</DESCRIPTION>
          <TEXT>This bit is used for synchronous mode only. Write this bit to zero when asynchronous mode is used. The UCPOL1 bit sets the relationship between data output change and data input sample, and the synchronous clock (XCK1).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>USART_CLK_POLARITY_BITF</ENUM>
        </BIT0>
      </UCSR1C>
      <UBRR1H>
        <NAME>UBRR1H</NAME>
        <DESCRIPTION>USART1 Baud Rate Register High Byte</DESCRIPTION>
        <TEXT>UBRR1 is a 12-bit register which contains the USART baud rate. The UBRR1H contains the four most significant bits, and the UBRR1L contains the eight least significant bits of the USART baud rate. Ongoing transmissions by the Transmitter and Receiver will be corrupted if the baud rate is changed. Writing UBRR1L will trigger an immediate update of the baud rate prescaler.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$CD</MEM_ADDR>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>Res3</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res2</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>UBRR11</NAME>
          <DESCRIPTION>USART Baud Rate Register</DESCRIPTION>
          <TEXT>These bits represent bits [11:8] of the Baud Rate Register. Sample values for commonly used clock frequencies can be found in section "Examples of Baud Rate Setting".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UBRR10</NAME>
          <DESCRIPTION>USART Baud Rate Register</DESCRIPTION>
          <TEXT>These bits represent bits [11:8] of the Baud Rate Register. Sample values for commonly used clock frequencies can be found in section "Examples of Baud Rate Setting".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>UBRR9</NAME>
          <DESCRIPTION>USART Baud Rate Register</DESCRIPTION>
          <TEXT>These bits represent bits [11:8] of the Baud Rate Register. Sample values for commonly used clock frequencies can be found in section "Examples of Baud Rate Setting".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>UBRR8</NAME>
          <DESCRIPTION>USART Baud Rate Register</DESCRIPTION>
          <TEXT>These bits represent bits [11:8] of the Baud Rate Register. Sample values for commonly used clock frequencies can be found in section "Examples of Baud Rate Setting".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>USART_BAUD_RATE_HB_BITF</ENUM>
        </BIT0>
      </UBRR1H>
      <UBRR1L>
        <NAME>UBRR1L</NAME>
        <DESCRIPTION>USART1 Baud Rate Register Low Byte</DESCRIPTION>
        <TEXT>UBRR1 is a 12-bit register which contains the USART baud rate. The UBRR1H contains the four most significant bits, and the UBRR1L contains the eight least significant bits of the USART baud rate. Ongoing transmissions by the Transmitter and Receiver will be corrupted if the baud rate is changed. Writing UBRR1L will trigger an immediate update of the baud rate prescaler.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$CC</MEM_ADDR>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>UBRR7</NAME>
          <DESCRIPTION>USART Baud Rate Register</DESCRIPTION>
          <TEXT>These bits represent bits [7:0] of the Baud Rate Register. Sample values for commonly used clock frequencies can be found in section "Examples of Baud Rate Setting".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>UBRR6</NAME>
          <DESCRIPTION>USART Baud Rate Register</DESCRIPTION>
          <TEXT>These bits represent bits [7:0] of the Baud Rate Register. Sample values for commonly used clock frequencies can be found in section "Examples of Baud Rate Setting".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UBRR5</NAME>
          <DESCRIPTION>USART Baud Rate Register</DESCRIPTION>
          <TEXT>These bits represent bits [7:0] of the Baud Rate Register. Sample values for commonly used clock frequencies can be found in section "Examples of Baud Rate Setting".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>UBRR4</NAME>
          <DESCRIPTION>USART Baud Rate Register</DESCRIPTION>
          <TEXT>These bits represent bits [7:0] of the Baud Rate Register. Sample values for commonly used clock frequencies can be found in section "Examples of Baud Rate Setting".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>UBRR3</NAME>
          <DESCRIPTION>USART Baud Rate Register</DESCRIPTION>
          <TEXT>These bits represent bits [7:0] of the Baud Rate Register. Sample values for commonly used clock frequencies can be found in section "Examples of Baud Rate Setting".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>UBRR2</NAME>
          <DESCRIPTION>USART Baud Rate Register</DESCRIPTION>
          <TEXT>These bits represent bits [7:0] of the Baud Rate Register. Sample values for commonly used clock frequencies can be found in section "Examples of Baud Rate Setting".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>UBRR1</NAME>
          <DESCRIPTION>USART Baud Rate Register</DESCRIPTION>
          <TEXT>These bits represent bits [7:0] of the Baud Rate Register. Sample values for commonly used clock frequencies can be found in section "Examples of Baud Rate Setting".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>UBRR0</NAME>
          <DESCRIPTION>USART Baud Rate Register</DESCRIPTION>
          <TEXT>These bits represent bits [7:0] of the Baud Rate Register. Sample values for commonly used clock frequencies can be found in section "Examples of Baud Rate Setting".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>USART_BAUD_RATE_LB_BITF</ENUM>
        </BIT0>
      </UBRR1L>
    </USART1>
    <TWI>
      <LIST>[TWAMR:TWBR:TWCR:TWSR:TWDR:TWAR]</LIST>
      <LINK/>
      <ICON>io_com.bmp</ICON>
      <ID/>
      <TEXT>The 2-wire Serial Interface (TWI) is ideally suited for typical microcontroller applications. The TWI protocol allows the systems designer to interconnect up to 128 different devices using only two bi-directional bus lines, one for clock (SCL) and one for data (SDA). The only external hardware needed to implement the bus is a single pull-up resistor for each of the TWI bus lines. All devices connected to the bus have individual addresses, and mechanisms for resolving bus contention are inherent in the TWI protocol. Features: Simple yet powerful and flexible communication interface, only two bus lines needed; Both master and slave operation supported; Device can operate as transmitter or receiver; 7-bit address space allows up to 128 different slave addresses; Multi-master arbitration support; Up to 400 kHz data transfer speed; Slew-rate limited output drivers; Noise suppression circuitry rejects spikes on bus lines; Fully programmable slave address with general call support; Address recognition causes wake-up when AVR is in sleep mode.</TEXT>
      <TWAMR>
        <NAME>TWAMR</NAME>
        <DESCRIPTION>TWI (Slave) Address Mask Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$BD</MEM_ADDR>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>TWAM6</NAME>
          <ALIAS>TWAMR6</ALIAS>
          <DESCRIPTION>TWI Address Mask</DESCRIPTION>
          <TEXT>The TWAMR can be loaded with a 7-bit Slave Address mask. Each of the bits in TWAMR can mask (disable) the corresponding address bit in the TWI Address Register (TWAR). If the mask bit is set to one then the address match logic ignores the compare between the incoming address bit and the corresponding bit in TWAR.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TWAM5</NAME>
          <ALIAS>TWAMR5</ALIAS>
          <DESCRIPTION>TWI Address Mask</DESCRIPTION>
          <TEXT>The TWAMR can be loaded with a 7-bit Slave Address mask. Each of the bits in TWAMR can mask (disable) the corresponding address bit in the TWI Address Register (TWAR). If the mask bit is set to one then the address match logic ignores the compare between the incoming address bit and the corresponding bit in TWAR.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TWAM4</NAME>
          <ALIAS>TWAMR4</ALIAS>
          <DESCRIPTION>TWI Address Mask</DESCRIPTION>
          <TEXT>The TWAMR can be loaded with a 7-bit Slave Address mask. Each of the bits in TWAMR can mask (disable) the corresponding address bit in the TWI Address Register (TWAR). If the mask bit is set to one then the address match logic ignores the compare between the incoming address bit and the corresponding bit in TWAR.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TWAM3</NAME>
          <ALIAS>TWAMR3</ALIAS>
          <DESCRIPTION>TWI Address Mask</DESCRIPTION>
          <TEXT>The TWAMR can be loaded with a 7-bit Slave Address mask. Each of the bits in TWAMR can mask (disable) the corresponding address bit in the TWI Address Register (TWAR). If the mask bit is set to one then the address match logic ignores the compare between the incoming address bit and the corresponding bit in TWAR.</TEXT>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TWAM2</NAME>
          <ALIAS>TWAMR2</ALIAS>
          <DESCRIPTION>TWI Address Mask</DESCRIPTION>
          <TEXT>The TWAMR can be loaded with a 7-bit Slave Address mask. Each of the bits in TWAMR can mask (disable) the corresponding address bit in the TWI Address Register (TWAR). If the mask bit is set to one then the address match logic ignores the compare between the incoming address bit and the corresponding bit in TWAR.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TWAM1</NAME>
          <ALIAS>TWAMR1</ALIAS>
          <DESCRIPTION>TWI Address Mask</DESCRIPTION>
          <TEXT>The TWAMR can be loaded with a 7-bit Slave Address mask. Each of the bits in TWAMR can mask (disable) the corresponding address bit in the TWI Address Register (TWAR). If the mask bit is set to one then the address match logic ignores the compare between the incoming address bit and the corresponding bit in TWAR.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TWAM0</NAME>
          <ALIAS>TWAMR0</ALIAS>
          <DESCRIPTION>TWI Address Mask</DESCRIPTION>
          <TEXT>The TWAMR can be loaded with a 7-bit Slave Address mask. Each of the bits in TWAMR can mask (disable) the corresponding address bit in the TWI Address Register (TWAR). If the mask bit is set to one then the address match logic ignores the compare between the incoming address bit and the corresponding bit in TWAR.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>Res</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TWAMR>
      <TWBR>
        <NAME>TWBR</NAME>
        <DESCRIPTION>TWI Bit Rate Register</DESCRIPTION>
        <TEXT>The SCL period is controlled by settings in the TWI Bit Rate Register (TWBR) and the Prescaler bits in the TWI Status Register (TWSR). Slave operation does not depend on Bit Rate or Prescaler settings, but the CPU clock frequency in the Slave must be at least 16 times higher than the SCL frequency.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$B8</MEM_ADDR>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TWBR7</NAME>
          <DESCRIPTION>TWI Bit Rate Register Value</DESCRIPTION>
          <TEXT>The TWBR register selects the division factor for the bit rate generator. The bit rate generator is a frequency divider which generates the SCL clock frequency in the Master modes. See section "Bit Rate Generator Unit" for calculating bit rates.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TWBR6</NAME>
          <DESCRIPTION>TWI Bit Rate Register Value</DESCRIPTION>
          <TEXT>The TWBR register selects the division factor for the bit rate generator. The bit rate generator is a frequency divider which generates the SCL clock frequency in the Master modes. See section "Bit Rate Generator Unit" for calculating bit rates.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TWBR5</NAME>
          <DESCRIPTION>TWI Bit Rate Register Value</DESCRIPTION>
          <TEXT>The TWBR register selects the division factor for the bit rate generator. The bit rate generator is a frequency divider which generates the SCL clock frequency in the Master modes. See section "Bit Rate Generator Unit" for calculating bit rates.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TWBR4</NAME>
          <DESCRIPTION>TWI Bit Rate Register Value</DESCRIPTION>
          <TEXT>The TWBR register selects the division factor for the bit rate generator. The bit rate generator is a frequency divider which generates the SCL clock frequency in the Master modes. See section "Bit Rate Generator Unit" for calculating bit rates.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TWBR3</NAME>
          <DESCRIPTION>TWI Bit Rate Register Value</DESCRIPTION>
          <TEXT>The TWBR register selects the division factor for the bit rate generator. The bit rate generator is a frequency divider which generates the SCL clock frequency in the Master modes. See section "Bit Rate Generator Unit" for calculating bit rates.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TWBR2</NAME>
          <DESCRIPTION>TWI Bit Rate Register Value</DESCRIPTION>
          <TEXT>The TWBR register selects the division factor for the bit rate generator. The bit rate generator is a frequency divider which generates the SCL clock frequency in the Master modes. See section "Bit Rate Generator Unit" for calculating bit rates.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TWBR1</NAME>
          <DESCRIPTION>TWI Bit Rate Register Value</DESCRIPTION>
          <TEXT>The TWBR register selects the division factor for the bit rate generator. The bit rate generator is a frequency divider which generates the SCL clock frequency in the Master modes. See section "Bit Rate Generator Unit" for calculating bit rates.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TWI_BIT_RATE_BITF</ENUM>
        </BIT1>
        <BIT0>
          <NAME>TWBR0</NAME>
          <DESCRIPTION>TWI Bit Rate Register Value</DESCRIPTION>
          <TEXT>The TWBR register selects the division factor for the bit rate generator. The bit rate generator is a frequency divider which generates the SCL clock frequency in the Master modes. See section "Bit Rate Generator Unit" for calculating bit rates.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TWBR>
      <TWCR>
        <NAME>TWCR</NAME>
        <DESCRIPTION>TWI Control Register</DESCRIPTION>
        <TEXT>The TWCR is used to control the operation of the TWI. It is used to enable the TWI, to initiate a Master access by applying a START condition to the bus, to generate a Receiver acknowledge, to generate a stop condition, and to control halting of the bus while the data to be written to the bus are put into the TWDR. It also indicates a write collision if data writing to TWDR is attempted while the register is inaccessible.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$BC</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>TWINT</NAME>
          <DESCRIPTION>TWI Interrupt Flag</DESCRIPTION>
          <TEXT>This bit is set by hardware when the TWI has finished its current job and expects application software response. If the I-bit in SREG and TWIE in TWCR are set, the MCU will jump to the TWI Interrupt Vector. While the TWINT Flag is set, the SCL low period is stretched. The TWINT Flag must be cleared by software by writing a logic one to it. Note that this flag is not automatically cleared by hardware when executing the interrupt routine. Also note that clearing this flag starts the operation of the TWI. So all accesses to the TWI Address Register (TWAR), TWI Status Register (TWSR) and TWI Data Register (TWDR) must be complete before clearing this flag.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TWEA</NAME>
          <DESCRIPTION>TWI Enable Acknowledge Bit</DESCRIPTION>
          <TEXT>The TWEA bit controls the generation of the acknowledge pulse. If the TWEA bit is written to one, the ACK pulse is generated on the TWI bus if the following conditions are met: 1. The devices own slave address has been received; 2. A general call has been received, while the TWGCE bit in the TWAR is set. 3. A data byte has been received in Master Receiver or Slave Receiver mode. By writing the TWEA bit to zero, the device can be virtually disconnected from the 2-wire Serial Bus temporarily. Address recognition can then be resumed by writing the TWEA bit to one again.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TWSTA</NAME>
          <DESCRIPTION>TWI START Condition Bit</DESCRIPTION>
          <TEXT>The application writes the TWSTA bit to one when it desires to become a Master on the 2-wire Serial Bus. The TWI hardware checks if the bus is available and generates a START condition on the bus if it is free. However, if the bus is not free, the TWI waits until a STOP condition is detected and then generates a new START condition to claim the bus Master status. TWSTA must be cleared by software when the START condition has been transmitted.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TWSTO</NAME>
          <DESCRIPTION>TWI STOP Condition Bit</DESCRIPTION>
          <TEXT>Writing the TWSTO bit to one in Master mode will generate a STOP condition on the 2-wire Serial Bus. When the STOP condition is executed on the bus, the TWSTO bit is cleared automatically. In Slave mode, setting the TWSTO bit can be used to recover from an error condition. This will not generate a STOP condition, but the TWI returns to a well-defined not-addressed Slave mode and releases the SCL and SDA lines to a high impedance state.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TWWC</NAME>
          <DESCRIPTION>TWI Write Collision Flag</DESCRIPTION>
          <TEXT>The TWWC bit is set when attempting to write to the TWI Data Register TWDR when TWINT is low. This flag is cleared by writing the TWDR Register when TWINT is high.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TWEN</NAME>
          <DESCRIPTION>TWI Enable Bit</DESCRIPTION>
          <TEXT>The TWEN bit enables TWI operation and activates the TWI interface. When TWEN is written to one, the TWI takes control over the I/O ports connected to the SCL and SDA pins enabling the slew-rate limiters and spike filters. If this bit is written to zero, the TWI is switched off and all TWI transmissions are terminated regardless of any ongoing operation.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>Res</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TWIE</NAME>
          <DESCRIPTION>TWI Interrupt Enable</DESCRIPTION>
          <TEXT>When this bit is written to one and the I-bit in SREG is set, the TWI interrupt request will be activated for as long as the TWINT Flag is high.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TWCR>
      <TWSR>
        <NAME>TWSR</NAME>
        <DESCRIPTION>TWI Status Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$B9</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>TWS7</NAME>
          <DESCRIPTION>TWI Status</DESCRIPTION>
          <TEXT>These 5 bits reflect the status of the TWI logic and the 2-wire Serial Bus. The different status codes for both transmitter and receiver mode are described in the following table. Note that the value read from TWSR contains both the 5-bit status value and the 2-bit prescaler value. The application designer should mask the prescaler bits to zero when checking the Status bits. This makes status checking independent of prescaler setting. This approach is used in this datasheet, unless otherwise noted.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TWS6</NAME>
          <DESCRIPTION>TWI Status</DESCRIPTION>
          <TEXT>These 5 bits reflect the status of the TWI logic and the 2-wire Serial Bus. The different status codes for both transmitter and receiver mode are described in the following table. Note that the value read from TWSR contains both the 5-bit status value and the 2-bit prescaler value. The application designer should mask the prescaler bits to zero when checking the Status bits. This makes status checking independent of prescaler setting. This approach is used in this datasheet, unless otherwise noted.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TWS5</NAME>
          <DESCRIPTION>TWI Status</DESCRIPTION>
          <TEXT>These 5 bits reflect the status of the TWI logic and the 2-wire Serial Bus. The different status codes for both transmitter and receiver mode are described in the following table. Note that the value read from TWSR contains both the 5-bit status value and the 2-bit prescaler value. The application designer should mask the prescaler bits to zero when checking the Status bits. This makes status checking independent of prescaler setting. This approach is used in this datasheet, unless otherwise noted.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TWS4</NAME>
          <DESCRIPTION>TWI Status</DESCRIPTION>
          <TEXT>These 5 bits reflect the status of the TWI logic and the 2-wire Serial Bus. The different status codes for both transmitter and receiver mode are described in the following table. Note that the value read from TWSR contains both the 5-bit status value and the 2-bit prescaler value. The application designer should mask the prescaler bits to zero when checking the Status bits. This makes status checking independent of prescaler setting. This approach is used in this datasheet, unless otherwise noted.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TWS3</NAME>
          <DESCRIPTION>TWI Status</DESCRIPTION>
          <TEXT>These 5 bits reflect the status of the TWI logic and the 2-wire Serial Bus. The different status codes for both transmitter and receiver mode are described in the following table. Note that the value read from TWSR contains both the 5-bit status value and the 2-bit prescaler value. The application designer should mask the prescaler bits to zero when checking the Status bits. This makes status checking independent of prescaler setting. This approach is used in this datasheet, unless otherwise noted.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TWI_STATUS_BITF</ENUM>
        </BIT3>
        <BIT2>
          <NAME>Res</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TWPS1</NAME>
          <DESCRIPTION>TWI Prescaler Bits</DESCRIPTION>
          <TEXT>These bits can be read and written and control the bit rate of the prescaler.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TWPS0</NAME>
          <DESCRIPTION>TWI Prescaler Bits</DESCRIPTION>
          <TEXT>These bits can be read and written and control the bit rate of the prescaler.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>COMM_TWI_PRESACLE</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TWSR>
      <TWDR>
        <NAME>TWDR</NAME>
        <DESCRIPTION>TWI Data Register</DESCRIPTION>
        <TEXT>In Transmit mode, TWDR contains the next byte to be transmitted. In Receive mode, the TWDR contains the last byte received. It is writable while the TWI is not in the process of shifting a byte. This occurs when the TWI Interrupt Flag (TWINT) is set by hardware. Note that the Data Register cannot be initialized by the user before the first interrupt occurs. The data in TWDR remains stable as long as TWINT is set. While data is shifted out, data on the bus is simultaneously shifted in. TWDR always contains the last byte present on the bus, except after a wake up from a sleep mode by the TWI interrupt. In this case, the contents of TWDR is undefined. In the case of a lost bus arbitration, no data is lost in the transition from Master to Slave. Handling of the ACK bit is automatically controlled by the TWI logic. The CPU cannot access the ACK bit directly.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$BB</MEM_ADDR>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TWD7</NAME>
          <DESCRIPTION>TWI Data Register Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TWD6</NAME>
          <DESCRIPTION>TWI Data Register Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TWD5</NAME>
          <DESCRIPTION>TWI Data Register Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TWD4</NAME>
          <DESCRIPTION>TWI Data Register Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TWD3</NAME>
          <DESCRIPTION>TWI Data Register Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TWD2</NAME>
          <DESCRIPTION>TWI Data Register Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TWD1</NAME>
          <DESCRIPTION>TWI Data Register Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TWD0</NAME>
          <DESCRIPTION>TWI Data Register Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
          <ENUM>TWI_DATA_REGISTER_BITF</ENUM>
        </BIT0>
      </TWDR>
      <TWAR>
        <NAME>TWAR</NAME>
        <DESCRIPTION>TWI (Slave) Address Register</DESCRIPTION>
        <TEXT>The TWAR should be loaded with the 7-bit Slave address (in the seven most significant bits of TWAR) to which the TWI will respond when programmed as a Slave Transmitter or Receiver. This register is not needed in the Master modes. In multi-master systems TWAR must be set in Masters which can be addressed as Slaves by other Masters. The LSB of TWAR is used to enable the recognition of the general call address (0x00). There is an associated address comparator that looks for the slave address (or general call address if enabled) in the received serial address. If a match is found, an interrupt request is generated.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$BA</MEM_ADDR>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>TWA6</NAME>
          <DESCRIPTION>TWI (Slave) Address</DESCRIPTION>
          <TEXT>These bits contain the TWI address operated as a Slave device.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TWA5</NAME>
          <DESCRIPTION>TWI (Slave) Address</DESCRIPTION>
          <TEXT>These bits contain the TWI address operated as a Slave device.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TWA4</NAME>
          <DESCRIPTION>TWI (Slave) Address</DESCRIPTION>
          <TEXT>These bits contain the TWI address operated as a Slave device.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TWA3</NAME>
          <DESCRIPTION>TWI (Slave) Address</DESCRIPTION>
          <TEXT>These bits contain the TWI address operated as a Slave device.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TWA2</NAME>
          <DESCRIPTION>TWI (Slave) Address</DESCRIPTION>
          <TEXT>These bits contain the TWI address operated as a Slave device.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TWA1</NAME>
          <DESCRIPTION>TWI (Slave) Address</DESCRIPTION>
          <TEXT>These bits contain the TWI address operated as a Slave device.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TWA0</NAME>
          <DESCRIPTION>TWI (Slave) Address</DESCRIPTION>
          <TEXT>These bits contain the TWI address operated as a Slave device.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TWGCE</NAME>
          <DESCRIPTION>TWI General Call Recognition Enable Bit</DESCRIPTION>
          <TEXT>If set, this bit enables the recognition of a General Call given over the 2-wire Serial Bus.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TWAR>
    </TWI>
    <SPI>
      <LIST>[SPDR:SPSR:SPCR]</LIST>
      <LINK/>
      <ICON>io_com.bmp</ICON>
      <ID/>
      <TEXT>The Serial Peripheral Interface (SPI) allows high-speed synchronous data transfer between the ATmega128RFA1 and peripheral devices or between several AVR devices. The SPI modules includes the following features: Full-duplex, Three-wire Synchronous Data Transfer; Master or Slave Operation; LSB First or MSB First Data Transfer; Seven Programmable Bit Rates; End of Transmission Interrupt Flag; Write Collision Flag Protection; Wake-up from Idle Mode; Double Speed (CK/2) Master SPI Mode. The USART can also be used in Master SPI mode. The Power Reduction SPI bit PRSPI in PRR0 must be written to zero to enable SPI module.</TEXT>
      <SPCR>
        <NAME>SPCR</NAME>
        <DESCRIPTION>SPI Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$2C</IO_ADDR>
        <MEM_ADDR>$4C</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SPIE</NAME>
          <DESCRIPTION>SPI Interrupt Enable</DESCRIPTION>
          <TEXT>This bit causes the SPI interrupt to be executed if SPIF bit in the SPSR Register is set and the if the Global Interrupt Enable bit in SREG is set.s</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SPE</NAME>
          <DESCRIPTION>SPI Enable</DESCRIPTION>
          <TEXT>When the SPE bit is set (one), the SPI is enabled. This bit must be set to enable any SPI operations.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>DORD</NAME>
          <DESCRIPTION>Data Order</DESCRIPTION>
          <TEXT>When the DORD bit is written to one, the LSB of the data word is transmitted first. When the DORD bit is written to zero, the MSB of the data word is transmitted first.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>MSTR</NAME>
          <DESCRIPTION>Master/Slave Select</DESCRIPTION>
          <TEXT>This bit selects Master SPI mode when written to one, and Slave SPI mode when written logic zero. If the Slave Select pin is configured as an input and is driven low while MSTR is set, MSTR will be cleared and SPIF in SPSR are set. The user will then have to set MSTR to re-enable SPI Master mode.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>CPOL</NAME>
          <DESCRIPTION>Clock polarity</DESCRIPTION>
          <TEXT>When this bit is written to one, SCK is high when idle. When CPOL is written to zero, SCK is low when idle. Refer to the "Data Modes" section for an example. The CPOL functionality is summarized below.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>SPI_CPOL_BITF</ENUM>
        </BIT3>
        <BIT2>
          <NAME>CPHA</NAME>
          <DESCRIPTION>Clock Phase</DESCRIPTION>
          <TEXT>The settings of the Clock Phase bit (CPHA) determine if data is sampled on the leading (first) or trailing (last) edge of SCK. Refer to the "Data Modes" section for an example. The CPOL functionality is summarized below.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>SPI_CPHA_BITF</ENUM>
        </BIT2>
        <BIT1>
          <NAME>SPR1</NAME>
          <DESCRIPTION>SPI Clock Rate Select 1 and 0</DESCRIPTION>
          <TEXT>These two bits control the SCK rate of the device configured as a Master. SPR1 and SPR0 have no effect on the Slave. The relationship between SCK and the Oscillator Clock frequency fosc is shown in the following table.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SPR0</NAME>
          <DESCRIPTION>SPI Clock Rate Select 1 and 0</DESCRIPTION>
          <TEXT>These two bits control the SCK rate of the device configured as a Master. SPR1 and SPR0 have no effect on the Slave. The relationship between SCK and the Oscillator Clock frequency fosc is shown in the following table.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>COMM_SCK_RATE_SPI2X</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SPCR>
      <SPSR>
        <NAME>SPSR</NAME>
        <DESCRIPTION>SPI Status Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$2D</IO_ADDR>
        <MEM_ADDR>$4D</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SPIF</NAME>
          <DESCRIPTION>SPI Interrupt Flag</DESCRIPTION>
          <TEXT>When a serial transfer is complete, the SPIF Flag is set. An interrupt is generated if SPIE in SPCR is set and global interrupts are enabled. The SPIF Flag is also set if the Slave Select pin is an input and is driven low when the SPI is in Master mode. SPIF is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, the SPIF bit is cleared by first reading the SPI Status Register with SPIF set and then accessing the SPI Data Register (SPDR).</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>WCOL</NAME>
          <DESCRIPTION>Write Collision Flag</DESCRIPTION>
          <TEXT>The WCOL bit is set if the SPI Data Register (SPDR) is written during a data transfer. The WCOL bit (and the SPIF bit) are cleared by first reading the SPI Status Register with WCOL set and then accessing the SPI Data Register.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>Res4</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res3</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>Res2</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SPI2X</NAME>
          <DESCRIPTION>Double SPI Speed Bit</DESCRIPTION>
          <TEXT>When this bit is written logic one the SPI speed (SCK Frequency) will be doubled when the SPI is in Master mode. This means that the minimum SCK period will be two CPU clock periods. When the SPI is configured as Slave, the SPI is only guaranteed to work at fosc/4 or lower. The SPI interface on the ATmega128RFA1 is also used for program memory and EEPROM downloading or uploading. See section "Serial Downloading" for serial programming and verification.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SPSR>
      <SPDR>
        <NAME>SPDR</NAME>
        <DESCRIPTION>SPI Data Register</DESCRIPTION>
        <TEXT>The SPI Data Register is a read/write register used for data transfer between the Register File and the SPI Shift Register. Writing to the register initiates data transmission. Reading the register causes the Shift Register Receive buffer to be read.</TEXT>
        <IO_ADDR>$2E</IO_ADDR>
        <MEM_ADDR>$4E</MEM_ADDR>
        <READ_INTRUSIVE/>
        <WRITE_INTRUSIVE/>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>SPDR7</NAME>
          <DESCRIPTION>SPI Data Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SPDR6</NAME>
          <DESCRIPTION>SPI Data Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SPDR5</NAME>
          <DESCRIPTION>SPI Data Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SPDR4</NAME>
          <DESCRIPTION>SPI Data Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SPDR3</NAME>
          <DESCRIPTION>SPI Data Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SPDR2</NAME>
          <DESCRIPTION>SPI Data Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SPDR1</NAME>
          <DESCRIPTION>SPI Data Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SPDR0</NAME>
          <DESCRIPTION>SPI Data Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <ENUM>SPI_DATA_REG_BITF</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SPDR>
    </SPI>
    <PORTA>
      <LIST>[PORTA:DDRA:PINA]</LIST>
      <LINK/>
      <ICON>io_port.bmp</ICON>
      <ID>AVRSimIOPort.SimIOPort</ID>
      <TEXT/>
      <PORTA>
        <NAME>PORTA</NAME>
        <DESCRIPTION>Port A Data Register</DESCRIPTION>
        <TEXT>The PORTA register can be used as a General Purpose I/O Register for storing any information.</TEXT>
        <IO_ADDR>$02</IO_ADDR>
        <MEM_ADDR>$22</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PORTA7</NAME>
          <DESCRIPTION>Port A Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PORTA6</NAME>
          <DESCRIPTION>Port A Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PORTA5</NAME>
          <DESCRIPTION>Port A Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PORTA4</NAME>
          <DESCRIPTION>Port A Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PORTA3</NAME>
          <DESCRIPTION>Port A Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PORTA2</NAME>
          <DESCRIPTION>Port A Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PORTA1</NAME>
          <DESCRIPTION>Port A Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PORTA0</NAME>
          <DESCRIPTION>Port A Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PORTA>
      <DDRA>
        <NAME>DDRA</NAME>
        <DESCRIPTION>Port A Data Direction Register</DESCRIPTION>
        <TEXT>The DDRA register can be used as a General Purpose I/O Register for storing any information.</TEXT>
        <IO_ADDR>$01</IO_ADDR>
        <MEM_ADDR>$21</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>DDA7</NAME>
          <DESCRIPTION>Port A Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>DDA6</NAME>
          <DESCRIPTION>Port A Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>DDA5</NAME>
          <DESCRIPTION>Port A Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>DDA4</NAME>
          <DESCRIPTION>Port A Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>DDA3</NAME>
          <DESCRIPTION>Port A Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>DDA2</NAME>
          <DESCRIPTION>Port A Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>DDA1</NAME>
          <DESCRIPTION>Port A Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>DDA0</NAME>
          <DESCRIPTION>Port A Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </DDRA>
      <PINA>
        <NAME>PINA</NAME>
        <DESCRIPTION>Port A Input Pins Address</DESCRIPTION>
        <TEXT>The PINA register is reserved for interal use and cannot be used as a General Purpose I/O Register.</TEXT>
        <IO_ADDR>$00</IO_ADDR>
        <MEM_ADDR>$20</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PINA7</NAME>
          <DESCRIPTION>Port A Input Pins</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PINA6</NAME>
          <DESCRIPTION>Port A Input Pins</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PINA5</NAME>
          <DESCRIPTION>Port A Input Pins</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PINA4</NAME>
          <DESCRIPTION>Port A Input Pins</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PINA3</NAME>
          <DESCRIPTION>Port A Input Pins</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PINA2</NAME>
          <DESCRIPTION>Port A Input Pins</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PINA1</NAME>
          <DESCRIPTION>Port A Input Pins</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PINA0</NAME>
          <DESCRIPTION>Port A Input Pins</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PINA>
    </PORTA>
    <PORTB>
      <LIST>[PORTB:DDRB:PINB]</LIST>
      <LINK/>
      <ICON>io_port.bmp</ICON>
      <ID>AVRSimIOPort.SimIOPort</ID>
      <TEXT/>
      <PORTB>
        <NAME>PORTB</NAME>
        <DESCRIPTION>Port B Data Register</DESCRIPTION>
        <TEXT>If PORTBn is written logic one when the PORTB pin n is configured as an input pin, the pull-up resistor is activated. To switch the pull-up resistor off, PORTBn has to be written logic zero or the pin has to be configured as an output pin. If PORTBn is written logic one when the pin is configured as an output pin, the port pin is driven high (one). If PORTBn is written logic zero when the pin is configured as an output pin, the port pin is driven low (zero).</TEXT>
        <IO_ADDR>$05</IO_ADDR>
        <MEM_ADDR>$25</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PORTB7</NAME>
          <DESCRIPTION>Port B Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PORTB6</NAME>
          <DESCRIPTION>Port B Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PORTB5</NAME>
          <DESCRIPTION>Port B Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PORTB4</NAME>
          <DESCRIPTION>Port B Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PORTB3</NAME>
          <DESCRIPTION>Port B Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PORTB2</NAME>
          <DESCRIPTION>Port B Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PORTB1</NAME>
          <DESCRIPTION>Port B Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PORTB0</NAME>
          <DESCRIPTION>Port B Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>PORT_DATA_REG_BITF</ENUM>
        </BIT0>
      </PORTB>
      <DDRB>
        <NAME>DDRB</NAME>
        <DESCRIPTION>Port B Data Direction Register</DESCRIPTION>
        <TEXT>The DDBn bit in the DDRB Register selects the direction of the PORTB pin n. If DDBn is written logic one, PBn is configured as an output pin. If DDBn is written logic zero, PBn is configured as an input pin.</TEXT>
        <IO_ADDR>$04</IO_ADDR>
        <MEM_ADDR>$24</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>DDB7</NAME>
          <DESCRIPTION>Port B Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>DDB6</NAME>
          <DESCRIPTION>Port B Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>DDB5</NAME>
          <DESCRIPTION>Port B Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>DDB4</NAME>
          <DESCRIPTION>Port B Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>DDB3</NAME>
          <DESCRIPTION>Port B Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>DDB2</NAME>
          <DESCRIPTION>Port B Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>DDB1</NAME>
          <DESCRIPTION>Port B Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>DDB0</NAME>
          <DESCRIPTION>Port B Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>DDR_VALUE_BITF</ENUM>
        </BIT0>
      </DDRB>
      <PINB>
        <NAME>PINB</NAME>
        <DESCRIPTION>Port B Input Pins Address</DESCRIPTION>
        <TEXT>This register allows access to the PORTB pins independent of the setting of the Data Direction bit DDBn. The port pin can be read through the PINBn Register bit, and writing a logic one to PINBn toggles the value of PORTBn.</TEXT>
        <IO_ADDR>$03</IO_ADDR>
        <MEM_ADDR>$23</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PINB7</NAME>
          <DESCRIPTION>Port B Input Pins Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PINB6</NAME>
          <DESCRIPTION>Port B Input Pins Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PINB5</NAME>
          <DESCRIPTION>Port B Input Pins Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PINB4</NAME>
          <DESCRIPTION>Port B Input Pins Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PINB3</NAME>
          <DESCRIPTION>Port B Input Pins Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PINB2</NAME>
          <DESCRIPTION>Port B Input Pins Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PINB1</NAME>
          <DESCRIPTION>Port B Input Pins Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PINB0</NAME>
          <DESCRIPTION>Port B Input Pins Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>PIN_VALUE_BITF</ENUM>
        </BIT0>
      </PINB>
    </PORTB>
    <PORTC>
      <LIST>[PORTC:DDRC:PINC]</LIST>
      <LINK/>
      <ICON>io_port.bmp</ICON>
      <ID>AVRSimIOPort.SimIOPort</ID>
      <TEXT/>
      <PORTC>
        <NAME>PORTC</NAME>
        <DESCRIPTION>Port C Data Register</DESCRIPTION>
        <TEXT>The PORTC register can be used as a General Purpose I/O Register for storing any information.</TEXT>
        <IO_ADDR>$08</IO_ADDR>
        <MEM_ADDR>$28</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PORTC7</NAME>
          <DESCRIPTION>Port C Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PORTC6</NAME>
          <DESCRIPTION>Port C Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PORTC5</NAME>
          <DESCRIPTION>Port C Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PORTC4</NAME>
          <DESCRIPTION>Port C Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PORTC3</NAME>
          <DESCRIPTION>Port C Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PORTC2</NAME>
          <DESCRIPTION>Port C Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PORTC1</NAME>
          <DESCRIPTION>Port C Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PORTC0</NAME>
          <DESCRIPTION>Port C Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PORTC>
      <DDRC>
        <NAME>DDRC</NAME>
        <DESCRIPTION>Port C Data Direction Register</DESCRIPTION>
        <TEXT>The DDRC register can be used as a General Purpose I/O Register for storing any information.</TEXT>
        <IO_ADDR>$07</IO_ADDR>
        <MEM_ADDR>$27</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>DDC7</NAME>
          <DESCRIPTION>Port C Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>DDC6</NAME>
          <DESCRIPTION>Port C Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>DDC5</NAME>
          <DESCRIPTION>Port C Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>DDC4</NAME>
          <DESCRIPTION>Port C Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>DDC3</NAME>
          <DESCRIPTION>Port C Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>DDC2</NAME>
          <DESCRIPTION>Port C Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>DDC1</NAME>
          <DESCRIPTION>Port C Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>DDC0</NAME>
          <DESCRIPTION>Port C Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </DDRC>
      <PINC>
        <NAME>PINC</NAME>
        <DESCRIPTION>Port C Input Pins Address</DESCRIPTION>
        <TEXT>The PINC register is reserved for interal use and cannot be used as a General Purpose I/O Register.</TEXT>
        <IO_ADDR>$06</IO_ADDR>
        <MEM_ADDR>$26</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PINC7</NAME>
          <DESCRIPTION>Port C Input Pins</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PINC6</NAME>
          <DESCRIPTION>Port C Input Pins</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PINC5</NAME>
          <DESCRIPTION>Port C Input Pins</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PINC4</NAME>
          <DESCRIPTION>Port C Input Pins</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PINC3</NAME>
          <DESCRIPTION>Port C Input Pins</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PINC2</NAME>
          <DESCRIPTION>Port C Input Pins</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PINC1</NAME>
          <DESCRIPTION>Port C Input Pins</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PINC0</NAME>
          <DESCRIPTION>Port C Input Pins</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PINC>
    </PORTC>
    <PORTD>
      <LIST>[PORTD:DDRD:PIND]</LIST>
      <LINK/>
      <ICON>io_port.bmp</ICON>
      <ID>AVRSimIOPort.SimIOPort</ID>
      <TEXT/>
      <PORTD>
        <NAME>PORTD</NAME>
        <DESCRIPTION>Port D Data Register</DESCRIPTION>
        <TEXT>If PORTDn is written logic one when the PORTD pin n is configured as an input pin, the pull-up resistor is activated. To switch the pull-up resistor off, PORTDn has to be written logic zero or the pin has to be configured as an output pin. If PORTDn is written logic one when the pin is configured as an output pin, the port pin is driven high (one). If PORTDn is written logic zero when the pin is configured as an output pin, the port pin is driven low (zero).</TEXT>
        <IO_ADDR>$0B</IO_ADDR>
        <MEM_ADDR>$2B</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PORTD7</NAME>
          <DESCRIPTION>Port D Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PORTD6</NAME>
          <DESCRIPTION>Port D Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PORTD5</NAME>
          <DESCRIPTION>Port D Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PORTD4</NAME>
          <DESCRIPTION>Port D Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PORTD3</NAME>
          <DESCRIPTION>Port D Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PORTD2</NAME>
          <DESCRIPTION>Port D Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PORTD1</NAME>
          <DESCRIPTION>Port D Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PORTD0</NAME>
          <DESCRIPTION>Port D Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>PORT_DATA_REG_BITF</ENUM>
        </BIT0>
      </PORTD>
      <DDRD>
        <NAME>DDRD</NAME>
        <DESCRIPTION>Port D Data Direction Register</DESCRIPTION>
        <TEXT>The DDDn bit in the DDRD Register selects the direction of the PORTD pin n. If DDDn is written logic one, PDn is configured as an output pin. If DDDn is written logic zero, PDn is configured as an input pin.</TEXT>
        <IO_ADDR>$0A</IO_ADDR>
        <MEM_ADDR>$2A</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>DDD7</NAME>
          <DESCRIPTION>Port D Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>DDD6</NAME>
          <DESCRIPTION>Port D Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>DDD5</NAME>
          <DESCRIPTION>Port D Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>DDD4</NAME>
          <DESCRIPTION>Port D Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>DDD3</NAME>
          <DESCRIPTION>Port D Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>DDD2</NAME>
          <DESCRIPTION>Port D Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>DDD1</NAME>
          <DESCRIPTION>Port D Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>DDD0</NAME>
          <DESCRIPTION>Port D Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>DDR_VALUE_BITF</ENUM>
        </BIT0>
      </DDRD>
      <PIND>
        <NAME>PIND</NAME>
        <DESCRIPTION>Port D Input Pins Address</DESCRIPTION>
        <TEXT>This register allows access to the PORTD pins independent of the setting of the Data Direction bit DDDn. The port pin can be read through the PINDn Register bit, and writing a logic one to PINDn toggles the value of PORTDn.</TEXT>
        <IO_ADDR>$09</IO_ADDR>
        <MEM_ADDR>$29</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PIND7</NAME>
          <DESCRIPTION>Port D Input Pins Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PIND6</NAME>
          <DESCRIPTION>Port D Input Pins Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PIND5</NAME>
          <DESCRIPTION>Port D Input Pins Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PIND4</NAME>
          <DESCRIPTION>Port D Input Pins Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PIND3</NAME>
          <DESCRIPTION>Port D Input Pins Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PIND2</NAME>
          <DESCRIPTION>Port D Input Pins Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PIND1</NAME>
          <DESCRIPTION>Port D Input Pins Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PIND0</NAME>
          <DESCRIPTION>Port D Input Pins Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>PIN_VALUE_BITF</ENUM>
        </BIT0>
      </PIND>
    </PORTD>
    <PORTE>
      <LIST>[PORTE:DDRE:PINE]</LIST>
      <LINK/>
      <ICON>io_port.bmp</ICON>
      <ID>AVRSimIOPort.SimIOPort</ID>
      <TEXT/>
      <PORTE>
        <NAME>PORTE</NAME>
        <DESCRIPTION>Port E Data Register</DESCRIPTION>
        <TEXT>If PORTEn is written logic one when the PORTE pin n is configured as an input pin, the pull-up resistor is activated. To switch the pull-up resistor off, PORTEn has to be written logic zero or the pin has to be configured as an output pin. If PORTEn is written logic one when the pin is configured as an output pin, the port pin is driven high (one). If PORTEn is written logic zero when the pin is configured as an output pin, the port pin is driven low (zero).</TEXT>
        <IO_ADDR>$0E</IO_ADDR>
        <MEM_ADDR>$2E</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PORTE7</NAME>
          <DESCRIPTION>Port E Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PORTE6</NAME>
          <DESCRIPTION>Port E Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PORTE5</NAME>
          <DESCRIPTION>Port E Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PORTE4</NAME>
          <DESCRIPTION>Port E Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PORTE3</NAME>
          <DESCRIPTION>Port E Data Register Value</DESCRIPTION>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PORTE2</NAME>
          <DESCRIPTION>Port E Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PORTE1</NAME>
          <DESCRIPTION>Port E Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PORTE0</NAME>
          <DESCRIPTION>Port E Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>PORT_DATA_REG_BITF</ENUM>
        </BIT0>
      </PORTE>
      <DDRE>
        <NAME>DDRE</NAME>
        <DESCRIPTION>Port E Data Direction Register</DESCRIPTION>
        <TEXT>The DDEn bit in the DDRE Register selects the direction of the PORTE pin n. If DDEn is written logic one, PEn is configured as an output pin. If DDEn is written logic zero, PEn is configured as an input pin.</TEXT>
        <IO_ADDR>$0D</IO_ADDR>
        <MEM_ADDR>$2D</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>DDE7</NAME>
          <DESCRIPTION>Port E Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>DDE6</NAME>
          <DESCRIPTION>Port E Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>DDE5</NAME>
          <DESCRIPTION>Port E Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>DDE4</NAME>
          <DESCRIPTION>Port E Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>DDE3</NAME>
          <DESCRIPTION>Port E Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>DDE2</NAME>
          <DESCRIPTION>Port E Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>DDE1</NAME>
          <DESCRIPTION>Port E Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>DDE0</NAME>
          <DESCRIPTION>Port E Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>DDR_VALUE_BITF</ENUM>
        </BIT0>
      </DDRE>
      <PINE>
        <NAME>PINE</NAME>
        <DESCRIPTION>Port E Input Pins Address</DESCRIPTION>
        <TEXT>This register allows access to the PORTE pins independent of the setting of the Data Direction bit DDEn. The port pin can be read through the PINEn Register bit, and writing a logic one to PINEn toggles the value of PORTEn.</TEXT>
        <IO_ADDR>$0C</IO_ADDR>
        <MEM_ADDR>$2C</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PINE7</NAME>
          <DESCRIPTION>Port E Input Pins Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PINE6</NAME>
          <DESCRIPTION>Port E Input Pins Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PINE5</NAME>
          <DESCRIPTION>Port E Input Pins Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PINE4</NAME>
          <DESCRIPTION>Port E Input Pins Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PINE3</NAME>
          <DESCRIPTION>Port E Input Pins Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PINE2</NAME>
          <DESCRIPTION>Port E Input Pins Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PINE1</NAME>
          <DESCRIPTION>Port E Input Pins Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PINE0</NAME>
          <DESCRIPTION>Port E Input Pins Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>PIN_VALUE_BITF</ENUM>
        </BIT0>
      </PINE>
    </PORTE>
    <PORTF>
      <LIST>[PORTF:DDRF:PINF]</LIST>
      <LINK/>
      <ICON>io_port.bmp</ICON>
      <ID>AVRSimIOPort.SimIOPort</ID>
      <TEXT/>
      <PORTF>
        <NAME>PORTF</NAME>
        <DESCRIPTION>Port F Data Register</DESCRIPTION>
        <TEXT>If PORTFn is written logic one when the PORTF pin n is configured as an input pin, the pull-up resistor is activated. To switch the pull-up resistor off, PORTFn has to be written logic zero or the pin has to be configured as an output pin. If PORTFn is written logic one when the pin is configured as an output pin, the port pin is driven high (one). If PORTFn is written logic zero when the pin is configured as an output pin, the port pin is driven low (zero).</TEXT>
        <IO_ADDR>$11</IO_ADDR>
        <MEM_ADDR>$31</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PORTF7</NAME>
          <DESCRIPTION>Port F Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PORTF6</NAME>
          <DESCRIPTION>Port F Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PORTF5</NAME>
          <DESCRIPTION>Port F Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PORTF4</NAME>
          <DESCRIPTION>Port F Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PORTF3</NAME>
          <DESCRIPTION>Port F Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PORTF2</NAME>
          <DESCRIPTION>Port F Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PORTF1</NAME>
          <DESCRIPTION>Port F Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PORTF0</NAME>
          <DESCRIPTION>Port F Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>PORT_DATA_REG_BITF</ENUM>
        </BIT0>
      </PORTF>
      <DDRF>
        <NAME>DDRF</NAME>
        <DESCRIPTION>Port F Data Direction Register</DESCRIPTION>
        <TEXT>The DDFn bit in the DDRF Register selects the direction of the PORTF pin n. If DDFn is written logic one, PFn is configured as an output pin. If DDFn is written logic zero, PFn is configured as an input pin.</TEXT>
        <IO_ADDR>$10</IO_ADDR>
        <MEM_ADDR>$30</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>DDF7</NAME>
          <DESCRIPTION>Port F Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>DDF6</NAME>
          <DESCRIPTION>Port F Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>DDF5</NAME>
          <DESCRIPTION>Port F Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>DDF4</NAME>
          <DESCRIPTION>Port F Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>DDF3</NAME>
          <DESCRIPTION>Port F Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>DDF2</NAME>
          <DESCRIPTION>Port F Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>DDF1</NAME>
          <DESCRIPTION>Port F Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>DDF0</NAME>
          <DESCRIPTION>Port F Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>DDR_VALUE_BITF</ENUM>
        </BIT0>
      </DDRF>
      <PINF>
        <NAME>PINF</NAME>
        <DESCRIPTION>Port F Input Pins Address</DESCRIPTION>
        <TEXT>This register allows access to the PORTF pins independent of the setting of the Data Direction bit DDFn. The port pin can be read through the PINFn Register bit, and writing a logic one to PINFn toggles the value of PORTFn.</TEXT>
        <IO_ADDR>$0F</IO_ADDR>
        <MEM_ADDR>$2F</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PINF7</NAME>
          <DESCRIPTION>Port F Input Pins Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PINF6</NAME>
          <DESCRIPTION>Port F Input Pins Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PINF5</NAME>
          <DESCRIPTION>Port F Input Pins Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PINF4</NAME>
          <DESCRIPTION>Port F Input Pins Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PINF3</NAME>
          <DESCRIPTION>Port F Input Pins Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PINF2</NAME>
          <DESCRIPTION>Port F Input Pins Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PINF1</NAME>
          <DESCRIPTION>Port F Input Pins Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PINF0</NAME>
          <DESCRIPTION>Port F Input Pins Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>PIN_VALUE_BITF</ENUM>
        </BIT0>
      </PINF>
    </PORTF>
    <PORTG>
      <LIST>[PORTG:DDRG:PING]</LIST>
      <LINK/>
      <ICON>io_port.bmp</ICON>
      <ID>AVRSimIOPort.SimIOPort</ID>
      <TEXT/>
      <PORTG>
        <NAME>PORTG</NAME>
        <DESCRIPTION>Port G Data Register</DESCRIPTION>
        <TEXT>If PORTGn is written logic one when the PORTG pin n is configured as an input pin, the pull-up resistor is activated. To switch the pull-up resistor off, PORTGn has to be written logic zero or the pin has to be configured as an output pin. If PORTGn is written logic one when the pin is configured as an output pin, the port pin is driven high (one). If PORTGn is written logic zero when the pin is configured as an output pin, the port pin is driven low (zero).</TEXT>
        <IO_ADDR>$14</IO_ADDR>
        <MEM_ADDR>$34</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PORTG5</NAME>
          <DESCRIPTION>Port G Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PORTG4</NAME>
          <DESCRIPTION>Port G Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PORTG3</NAME>
          <DESCRIPTION>Port G Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PORTG2</NAME>
          <DESCRIPTION>Port G Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PORTG1</NAME>
          <DESCRIPTION>Port G Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PORTG0</NAME>
          <DESCRIPTION>Port G Data Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>PORT_DATA_REG2_BITF</ENUM>
        </BIT0>
      </PORTG>
      <DDRG>
        <NAME>DDRG</NAME>
        <DESCRIPTION>Port G Data Direction Register</DESCRIPTION>
        <TEXT>The DDGn bit in the DDRG Register selects the direction of the PORTG pin n. If DDGn is written logic one, PGn is configured as an output pin. If DDGn is written logic zero, PGn is configured as an input pin.</TEXT>
        <IO_ADDR>$13</IO_ADDR>
        <MEM_ADDR>$33</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>DDG5</NAME>
          <DESCRIPTION>Port G Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>DDG4</NAME>
          <DESCRIPTION>Port G Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>DDG3</NAME>
          <DESCRIPTION>Port G Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>DDG2</NAME>
          <DESCRIPTION>Port G Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>DDG1</NAME>
          <DESCRIPTION>Port G Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>DDG0</NAME>
          <DESCRIPTION>Port G Data Direction Register Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>DDR_VALUE2_BITF</ENUM>
        </BIT0>
      </DDRG>
      <PING>
        <NAME>PING</NAME>
        <DESCRIPTION>Port G Input Pins Address</DESCRIPTION>
        <TEXT>This register allows access to the PORTG pins independent of the setting of the Data Direction bit DDGn. The port pin can be read through the PINGn Register bit, and writing a logic one to PINGn toggles the value of PORTGn.</TEXT>
        <IO_ADDR>$12</IO_ADDR>
        <MEM_ADDR>$32</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PING5</NAME>
          <DESCRIPTION>Port G Input Pins Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PING4</NAME>
          <DESCRIPTION>Port G Input Pins Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PING3</NAME>
          <DESCRIPTION>Port G Input Pins Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PING2</NAME>
          <DESCRIPTION>Port G Input Pins Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PING1</NAME>
          <DESCRIPTION>Port G Input Pins Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PING0</NAME>
          <DESCRIPTION>Port G Input Pins Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>PIN_VALUE2_BITF</ENUM>
        </BIT0>
      </PING>
    </PORTG>
    <TIMER_COUNTER_0>
      <LIST>[TIMSK0:TIFR0:TCCR0A:TCCR0B:TCNT0:OCR0A:OCR0B:GTCCR]</LIST>
      <LINK/>
      <ICON>io_timer.bmp</ICON>
      <ID>At8pwm0_01</ID>
      <TEXT/>
      <OCR0B>
        <NAME>OCR0B</NAME>
        <DESCRIPTION>Timer/Counter0 Output Compare Register B</DESCRIPTION>
        <TEXT>The Output Compare Register B contains an 8-bit value that is continuously compared with the counter value (TCNT0). A match can be used to generate an Output Compare interrupt, or to generate a waveform output on the OC0B pin.</TEXT>
        <IO_ADDR>$28</IO_ADDR>
        <MEM_ADDR>$48</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR0B_7</NAME>
          <DESCRIPTION>Output Compare Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR0B_6</NAME>
          <DESCRIPTION>Output Compare Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR0B_5</NAME>
          <DESCRIPTION>Output Compare Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR0B_4</NAME>
          <DESCRIPTION>Output Compare Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR0B_3</NAME>
          <DESCRIPTION>Output Compare Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR0B_2</NAME>
          <DESCRIPTION>Output Compare Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR0B_1</NAME>
          <DESCRIPTION>Output Compare Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR0B_0</NAME>
          <DESCRIPTION>Output Compare Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC0_OCR_BITF</ENUM>
        </BIT0>
      </OCR0B>
      <OCR0A>
        <NAME>OCR0A</NAME>
        <DESCRIPTION>Timer/Counter0 Output Compare Register</DESCRIPTION>
        <TEXT>The Output Compare Register A contains an 8-bit value that is continuously compared with the counter value (TCNT0). A match can be used to generate an Output Compare interrupt, or to generate a waveform output on the OC0A pin.</TEXT>
        <IO_ADDR>$27</IO_ADDR>
        <MEM_ADDR>$47</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR0A_7</NAME>
          <DESCRIPTION>Output Compare Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR0A_6</NAME>
          <DESCRIPTION>Output Compare Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR0A_5</NAME>
          <DESCRIPTION>Output Compare Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR0A_4</NAME>
          <DESCRIPTION>Output Compare Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR0A_3</NAME>
          <DESCRIPTION>Output Compare Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR0A_2</NAME>
          <DESCRIPTION>Output Compare Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR0A_1</NAME>
          <DESCRIPTION>Output Compare Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR0A_0</NAME>
          <DESCRIPTION>Output Compare Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC0_OCR_BITF</ENUM>
        </BIT0>
      </OCR0A>
      <TCNT0>
        <NAME>TCNT0</NAME>
        <DESCRIPTION>Timer/Counter0 Register</DESCRIPTION>
        <TEXT>The Timer/Counter Register gives direct access, both for read and write operations, to the Timer/Counter0 unit 8-bit counter. Writing to the TCNT0 Register blocks (removes) the Compare Match on the following timer clock. Modifying the counter (TCNT0) while the counter is running, introduces a risk of missing a Compare Match between TCNT0 and the OCR0x Registers.</TEXT>
        <IO_ADDR>$26</IO_ADDR>
        <MEM_ADDR>$46</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TCNT0_7</NAME>
          <DESCRIPTION>Timer/Counter0 Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TCNT0_6</NAME>
          <DESCRIPTION>Timer/Counter0 Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TCNT0_5</NAME>
          <DESCRIPTION>Timer/Counter0 Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TCNT0_4</NAME>
          <DESCRIPTION>Timer/Counter0 Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TCNT0_3</NAME>
          <DESCRIPTION>Timer/Counter0 Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TCNT0_2</NAME>
          <DESCRIPTION>Timer/Counter0 Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TCNT0_1</NAME>
          <DESCRIPTION>Timer/Counter0 Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TCNT0_0</NAME>
          <DESCRIPTION>Timer/Counter0 Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC0_TCNT_BITF</ENUM>
        </BIT0>
      </TCNT0>
      <TCCR0B>
        <NAME>TCCR0B</NAME>
        <DESCRIPTION>Timer/Counter0 Control Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$25</IO_ADDR>
        <MEM_ADDR>$45</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>FOC0A</NAME>
          <DESCRIPTION>Force Output Compare A</DESCRIPTION>
          <TEXT>The FOC0A bit is only active when the WGM02:0 bits specify a non-PWM mode. However, for ensuring compatibility with future devices, this bit must be set to zero when TCCR0B is written in a PWM operation mode. When writing a logical one to the FOC0A bit, an immediate Compare Match is forced on the Waveform Generation unit. The OC0A output is changed according to its COM0A1:0 bits setting. Note that the FOC0A bit is implemented as a strobe. Therefore it is the value present in the COM0A1:0 bits that determines the effect of the forced compare. A FOC0A strobe will not generate any interrupt nor will it clear the timer in CTC mode using OCR0A as TOP. The FOC0A bit is always read as zero.</TEXT>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>FOC0B</NAME>
          <DESCRIPTION>Force Output Compare B</DESCRIPTION>
          <TEXT>The FOC0B bit is only active when the WGM02:0 bits specify a non-PWM mode. However, for ensuring compatibility with future devices, this bit must be set to zero when TCCR0B is written in a PWM operation mode. When writing a logical one to the FOC0B bit, an immediate Compare Match is forced on the Waveform Generation unit. The OC0B output is changed according to its COM0B1:0 bits setting. Note that the FOC0B bit is implemented as a strobe. Therefore it is the value present in the COM0B1:0 bits that determines the effect of the forced compare. A FOC0B strobe will not generate any interrupt nor will it clear the timer in CTC mode using OCR0B as TOP. The FOC0B bit is always read as zero.</TEXT>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>WGM02</NAME>
          <DESCRIPTION/>
          <TEXT>Combined with the WGM01:0 bit found in the TCCR0A Register, these bits control the counting sequence of the counter, the source for maximum (TOP) counter value, and what type of waveform generation to be used. Modes of operation supported by the Timer/Counter unit are: Normal mode (counter), Clear Timer on Compare Match (CTC) mode, and two types of Pulse Width Modulation (PWM) modes (see section "Modes of Operation").</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CS02</NAME>
          <DESCRIPTION>Clock Select</DESCRIPTION>
          <TEXT>The three Clock Select bits select the clock source to be used by the Timer/Counter0 according to the following table.If external pin modes are used for Timer/Counter0, transitions on the T0 pin will clock the counter even if the pin is configured as an output. This feature allows software control of the counting.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CS01</NAME>
          <DESCRIPTION>Clock Select</DESCRIPTION>
          <TEXT>The three Clock Select bits select the clock source to be used by the Timer/Counter0 according to the following table.If external pin modes are used for Timer/Counter0, transitions on the T0 pin will clock the counter even if the pin is configured as an output. This feature allows software control of the counting.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CS00</NAME>
          <DESCRIPTION>Clock Select</DESCRIPTION>
          <TEXT>The three Clock Select bits select the clock source to be used by the Timer/Counter0 according to the following table.If external pin modes are used for Timer/Counter0, transitions on the T0 pin will clock the counter even if the pin is configured as an output. This feature allows software control of the counting.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC0_CLK_SEL_3BIT_EXT</ENUM>
        </BIT0>
      </TCCR0B>
      <TCCR0A>
        <NAME>TCCR0A</NAME>
        <DESCRIPTION>Timer/Counter0 Control Register A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$24</IO_ADDR>
        <MEM_ADDR>$44</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>COM0A1</NAME>
          <DESCRIPTION>Compare Match Output A Mode</DESCRIPTION>
          <TEXT>These bits control the Output Compare pin (OC0A) behavior. If one or both of the COM0A1:0 bits are set, the OC0A output overrides the normal port functionality of the I/O pin it is connected to. However, note that the Data Direction Register (DDR) bit corresponding to the OC0A pin must be set in order to enable the output driver. When OC0A is connected to the pin, the function of the COM0A1:0 bits depends on the WGM02:0 bit setting. The following shows the COM0A1:0 bit functionality when the WGM02:0 bits are set to a normal or CTC mode (non-PWM). For the functionality in other modes refer to section "Operating Modes".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>COM0A0</NAME>
          <DESCRIPTION>Compare Match Output A Mode</DESCRIPTION>
          <TEXT>These bits control the Output Compare pin (OC0A) behavior. If one or both of the COM0A1:0 bits are set, the OC0A output overrides the normal port functionality of the I/O pin it is connected to. However, note that the Data Direction Register (DDR) bit corresponding to the OC0A pin must be set in order to enable the output driver. When OC0A is connected to the pin, the function of the COM0A1:0 bits depends on the WGM02:0 bit setting. The following shows the COM0A1:0 bit functionality when the WGM02:0 bits are set to a normal or CTC mode (non-PWM). For the functionality in other modes refer to section "Operating Modes".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC0_COM0A_BITF</ENUM>
        </BIT6>
        <BIT5>
          <NAME>COM0B1</NAME>
          <DESCRIPTION>Compare Match Output B Mode</DESCRIPTION>
          <TEXT>These bits control the Output Compare pin (OC0B) behavior. If one or both of the COM0B1:0 bits are set, the OC0B output overrides the normal port functionality of the I/O pin it is connected to. However, note that the Data Direction Register (DDR) bit corresponding to the OC0B pin must be set in order to enable the output driver. When OC0B is connected to the pin, the function of the COM0B1:0 bits depends on the WGM02:0 bit setting. The following shows the COM0B1:0 bit functionality when the WGM02:0 bits are set to a normal or CTC mode (non-PWM). For the functionality in other modes refer to section "Operating Modes".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>COM0B0</NAME>
          <DESCRIPTION>Compare Match Output B Mode</DESCRIPTION>
          <TEXT>These bits control the Output Compare pin (OC0B) behavior. If one or both of the COM0B1:0 bits are set, the OC0B output overrides the normal port functionality of the I/O pin it is connected to. However, note that the Data Direction Register (DDR) bit corresponding to the OC0B pin must be set in order to enable the output driver. When OC0B is connected to the pin, the function of the COM0B1:0 bits depends on the WGM02:0 bit setting. The following shows the COM0B1:0 bit functionality when the WGM02:0 bits are set to a normal or CTC mode (non-PWM). For the functionality in other modes refer to section "Operating Modes".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC0_COM0B_BITF</ENUM>
        </BIT4>
        <BIT3>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>WGM01</NAME>
          <DESCRIPTION>Waveform Generation Mode</DESCRIPTION>
          <TEXT>Combined with the WGM02 bit found in the TCCR0B Register, these bits control the counting sequence of the counter, the source for maximum (TOP) counter value, and what type of waveform generation to be used according to the following table. Modes of operation supported by the Timer/Counter0 unit are: Normal mode (counter), Clear Timer on Compare Match (CTC) mode, and two types of Pulse Width Modulation (PWM) modes (see section "Modes of Operation" for details).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>WGM00</NAME>
          <DESCRIPTION>Waveform Generation Mode</DESCRIPTION>
          <TEXT>Combined with the WGM02 bit found in the TCCR0B Register, these bits control the counting sequence of the counter, the source for maximum (TOP) counter value, and what type of waveform generation to be used according to the following table. Modes of operation supported by the Timer/Counter0 unit are: Normal mode (counter), Clear Timer on Compare Match (CTC) mode, and two types of Pulse Width Modulation (PWM) modes (see section "Modes of Operation" for details).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC0_WGM_BITF</ENUM>
        </BIT0>
      </TCCR0A>
      <TIMSK0>
        <NAME>TIMSK0</NAME>
        <DESCRIPTION>Timer/Counter0 Interrupt Mask Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$6E</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>Res4</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res3</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>Res2</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCIE0B</NAME>
          <DESCRIPTION>Timer/Counter0 Output Compare Match B Interrupt Enable</DESCRIPTION>
          <TEXT>When the OCIE0B bit is written to one, and the I-bit in the Status Register is set, the Timer/Counter0 Compare Match B interrupt is enabled. The corresponding interrupt is executed if a Compare Match in Timer/Counter0 occurs, i.e., when the OCF0B bit is set in the Timer/Counter0 Interrupt Flag Register TIFR0.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCIE0A</NAME>
          <DESCRIPTION>Timer/Counter0 Output Compare Match A Interrupt Enable</DESCRIPTION>
          <TEXT>When the OCIE0A bit is written to one, and the I-bit in the Status Register is set, the Timer/Counter0 Compare Match A interrupt is enabled. The corresponding interrupt is executed if a Compare Match in Timer/Counter0 occurs, i.e., when the OCF0A bit is set in the Timer/Counter0 Interrupt Flag Register TIFR0.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TOIE0</NAME>
          <DESCRIPTION>Timer/Counter0 Overflow Interrupt Enable</DESCRIPTION>
          <TEXT>When the TOIE0 bit is written to one, and the I-bit in the Status Register is set, the Timer/Counter0 Overflow interrupt is enabled. The corresponding interrupt is executed if an overflow in Timer/Counter0 occurs i.e., when the TOV0 bit is set in the Timer/Counter0 Interrupt Flag Register TIFR0.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TIMSK0>
      <TIFR0>
        <NAME>TIFR0</NAME>
        <DESCRIPTION>Timer/Counter0 Interrupt Flag Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$15</IO_ADDR>
        <MEM_ADDR>$35</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>Res4</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res3</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>Res2</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCF0B</NAME>
          <DESCRIPTION>Timer/Counter0 Output Compare B Match Flag</DESCRIPTION>
          <TEXT>The OCF0B bit is set when a Compare Match occurs between the Timer/Counter0 and the data in OCR0B Output Compare Register. OCF0B is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, OCF0B is cleared by writing a logic one to the flag. When the I-bit in SREG, OCIE0B (Timer/Counter Compare B Match Interrupt Enable) and OCF0B are set, the Timer/Counter Compare Match Interrupt is executed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCF0A</NAME>
          <DESCRIPTION>Timer/Counter0 Output Compare A Match Flag</DESCRIPTION>
          <TEXT>The OCF0A bit is set when a Compare Match occurs between the Timer/Counter0 and the data in OCR0A Output Compare Register. OCF0A is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, OCF0A is cleared by writing a logic one to the flag. When the I-bit in SREG, OCIE0A (Timer/Counter Compare A Match Interrupt Enable) and OCF0A are set, the Timer/Counter Compare Match Interrupt is executed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TOV0</NAME>
          <DESCRIPTION>Timer/Counter0 Overflow Flag</DESCRIPTION>
          <TEXT>The bit TOV0 is set when an overflow occurs in Timer/Counter0. TOV0 is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, TOV0 is cleared by writing a logic one to the flag. When the SREG I-bit, TOIE0 (Timer/Counter0 Overflow Interrupt Enable) and TOV0 are set, the Timer/Counter0 Overflow interrupt is executed. The setting of this flag is dependent of the WGM02:0 bit setting.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TIFR0>
      <GTCCR>
        <NAME>GTCCR</NAME>
        <DESCRIPTION>General Timer/Counter Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$23</IO_ADDR>
        <MEM_ADDR>$43</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>TSM</NAME>
          <DESCRIPTION>Timer/Counter Synchronization Mode</DESCRIPTION>
          <TEXT>Writing the TSM bit to one activates the Timer/Counter Synchronization mode. In this mode the value that is written to the PSRASY and PSRSYNC bits is kept, hence keeping the corresponding prescaler reset signals asserted. This ensures that the corresponding Timer/Counters are halted and can be configured to the same value without the risk of one of them advancing during the configuration. When the TSM bit is written to zero, the PSRASY and PSRSYNC bits are cleared by hardware and the Timer/Counters simultaneously start counting.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res4</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>Res3</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res2</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PSRASY</NAME>
          <DESCRIPTION>Prescaler Reset Timer/Counter2</DESCRIPTION>
          <TEXT>When this bit is one, the Timer/Counter2 prescaler will be reset. This bit is normally cleared immediately by hardware. If the bit is written when Timer/Counter2 is operating in asynchronous mode, the bit will remain one until the prescaler has been reset. The bit will not be cleared by hardware if the TSM bit is set.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PSRSYNC</NAME>
          <ALIAS>PSR10</ALIAS>
          <DESCRIPTION>Prescaler Reset for Synchronous Timer/Counters</DESCRIPTION>
          <TEXT>When this bit is one, the Timer/Counter0, Timer/Counter1, Timer/Counter3, Timer/Counter4 and Timer/Counter5 prescaler will be reset. This bit is normally cleared immediately by hardware, except if the TSM bit is set. Note that Timer/Counter0, Timer/Counter1, Timer/Counter3, Timer/Counter4 and Timer/Counter5 share the same prescaler and a reset of this prescaler will affect all timers.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </GTCCR>
    </TIMER_COUNTER_0>
    <TIMER_COUNTER_2>
      <LIST>[TIMSK2:TIFR2:TCCR2A:TCCR2B:TCNT2:OCR2A:OCR2B:ASSR:GTCCR]</LIST>
      <LINK/>
      <ICON>io_timer.bmp</ICON>
      <ID>At8pwm2_07</ID>
      <TEXT>Timer/Counter2 is a general purpose, single channel, 8-bit Timer/Counter module. The main features are: Single Channel Counter; Clear Timer on Compare Match (Auto Reload); Glitch-free, Phase Correct Pulse Width Modulator (PWM); Frequency Generator; 10-bit Clock Prescaler; Overflow and Compare Match Interrupt Sources (TOV2, OCF2A and OCF2B); Allows Clocking from External 32 kHz Watch Crystal independent of the I/O Clock.</TEXT>
      <TIMSK2>
        <NAME>TIMSK2</NAME>
        <DESCRIPTION>Timer/Counter Interrupt Mask register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$70</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>Res4</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res3</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>Res2</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCIE2B</NAME>
          <DESCRIPTION>Timer/Counter2 Output Compare Match B Interrupt Enable</DESCRIPTION>
          <TEXT>When the OCIE2B bit is written to one and the I-bit in the Status Register is set (one), the Timer/Counter2 Compare Match B interrupt is enabled. The corresponding interrupt is executed if a compare match in Timer/Counter2 occurs, i.e., when the OCF2B bit is set in the Timer/Counter2 Interrupt Flag Register TIFR2.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCIE2A</NAME>
          <DESCRIPTION>Timer/Counter2 Output Compare Match A Interrupt Enable</DESCRIPTION>
          <TEXT>When the OCIE2A bit is written to one and the I-bit in the Status Register is set (one), the Timer/Counter2 Compare Match A interrupt is enabled. The corresponding interrupt is executed if a compare match in Timer/Counter2 occurs, i.e., when the OCF2A bit is set in the Timer/Counter2 Interrupt Flag Register TIFR2.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TOIE2</NAME>
          <ALIAS>TOIE2A</ALIAS>
          <DESCRIPTION>Timer/Counter2 Overflow Interrupt Enable</DESCRIPTION>
          <TEXT>When the TOIE2 bit is written to one and the I-bit in the Status Register is set (one), the Timer/Counter2 Overflow interrupt is enabled. The corresponding interrupt is executed if an overflow in Timer/Counter2 occurs i.e., when the TOV2 bit is set in the Timer/Counter2 Interrupt Flag Register TIFR2.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TIMSK2>
      <TIFR2>
        <NAME>TIFR2</NAME>
        <DESCRIPTION>Timer/Counter Interrupt Flag Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$17</IO_ADDR>
        <MEM_ADDR>$37</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>Res4</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res3</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>Res2</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCF2B</NAME>
          <DESCRIPTION>Output Compare Flag 2 B</DESCRIPTION>
          <TEXT>The OCF2B bit is set (one) when a compare match occurs between the Timer/Counter2 and the data in OCR2B Output Compare Register2. OCF2B is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, OCF2B is cleared by writing a logic one to the flag. When the I-bit in SREG, OCIE2B (Timer/Counter2 Compare Match Interrupt Enable), and OCF2B are set (one), the Timer/Counter2 Compare Match Interrupt is executed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCF2A</NAME>
          <DESCRIPTION>Output Compare Flag 2 A</DESCRIPTION>
          <TEXT>The OCF2A bit is set (one) when a compare match occurs between the Timer/Counter2 and the data in OCR2A Output Compare Register2. OCF2A is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, OCF2A is cleared by writing a logic one to the flag. When the I-bit in SREG, OCIE2A (Timer/Counter2 Compare Match Interrupt Enable), and OCF2A are set (one), the Timer/Counter2 Compare Match Interrupt is executed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TOV2</NAME>
          <DESCRIPTION>Timer/Counter2 Overflow Flag</DESCRIPTION>
          <TEXT>The TOV2 bit is set (one) when an overflow occurs in Timer/Counter2. TOV2 is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, TOV2 is cleared by writing a logic one to the flag. When the SREG I-bit, TOIE2A (Timer/Counter2 Overflow Interrupt Enable), and TOV2 are set (one), the Timer/Counter2 Overflow interrupt is executed. In PWM mode, this bit is set when Timer/Counter2 changes counting direction at 0x00.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TIFR2>
      <TCCR2A>
        <NAME>TCCR2A</NAME>
        <DESCRIPTION>Timer/Counter2 Control Register A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$B0</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>COM2A1</NAME>
          <DESCRIPTION>Compare Match Output A Mode</DESCRIPTION>
          <TEXT>These bits control the Output Compare pin (OC2A) behavior. If one or both of the COM2A1:0 bits are set, the OC2A output overrides the normal port functionality of the I/O pin it is connected to. However, note that the Data Direction Register (DDR) bit corresponding to the OC2A pin must be set in order to enable the output driver. When OC2A is connected to the pin, the function of the COM2A1:0 bits depends on the WGM22:0 bit setting. The following table shows the COM2A1:0 bit functionality when the WGM22:0 bits are set to a normal or CTC mode (non-PWM). Refer to section "Compare Match Output Unit" for a description of the functionality in the other modes.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>COM2A0</NAME>
          <DESCRIPTION>Compare Match Output A Mode</DESCRIPTION>
          <TEXT>These bits control the Output Compare pin (OC2A) behavior. If one or both of the COM2A1:0 bits are set, the OC2A output overrides the normal port functionality of the I/O pin it is connected to. However, note that the Data Direction Register (DDR) bit corresponding to the OC2A pin must be set in order to enable the output driver. When OC2A is connected to the pin, the function of the COM2A1:0 bits depends on the WGM22:0 bit setting. The following table shows the COM2A1:0 bit functionality when the WGM22:0 bits are set to a normal or CTC mode (non-PWM). Refer to section "Compare Match Output Unit" for a description of the functionality in the other modes.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC2_COM2A_BITF</ENUM>
        </BIT6>
        <BIT5>
          <NAME>COM2B1</NAME>
          <DESCRIPTION>Compare Match Output B Mode</DESCRIPTION>
          <TEXT>These bits control the Output Compare pin (OC2B) behavior. If one or both of the COM2B1:0 bits are set, the OC2B output overrides the normal port functionality of the I/O pin it is connected to. However, note that the Data Direction Register (DDR) bit corresponding to the OC2B pin must be set in order to enable the output driver. When OC2B is connected to the pin, the function of the COM2B1:0 bits depends on the WGM22:0 bit setting. The following table shows the COM2B1:0 bit functionality when the WGM22:0 bits are set to a normal or CTC mode (non-PWM). Refer to section "Compare Match Output Unit" for a description of the functionality in the other modes.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>COM2B0</NAME>
          <DESCRIPTION>Compare Match Output B Mode</DESCRIPTION>
          <TEXT>These bits control the Output Compare pin (OC2B) behavior. If one or both of the COM2B1:0 bits are set, the OC2B output overrides the normal port functionality of the I/O pin it is connected to. However, note that the Data Direction Register (DDR) bit corresponding to the OC2B pin must be set in order to enable the output driver. When OC2B is connected to the pin, the function of the COM2B1:0 bits depends on the WGM22:0 bit setting. The following table shows the COM2B1:0 bit functionality when the WGM22:0 bits are set to a normal or CTC mode (non-PWM). Refer to section "Compare Match Output Unit" for a description of the functionality in the other modes.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC2_COM2B_BITF</ENUM>
        </BIT4>
        <BIT3>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>WGM21</NAME>
          <DESCRIPTION>Waveform Generation Mode</DESCRIPTION>
          <TEXT>Combined with the WGM22 bit found in the TCCR2B Register, these bits control the counting sequence of the counter, the source for maximum (TOP) counter value, and what type of waveform generation to be used. Modes of operation supported by the Timer/Counter2 unit are: Normal mode (counter), Clear Timer on Compare Match (CTC) mode, and two types of Pulse Width Modulation (PWM) modes (see section "Modes of Operation" for details).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>WGM20</NAME>
          <DESCRIPTION>Waveform Generation Mode</DESCRIPTION>
          <TEXT>Combined with the WGM22 bit found in the TCCR2B Register, these bits control the counting sequence of the counter, the source for maximum (TOP) counter value, and what type of waveform generation to be used. Modes of operation supported by the Timer/Counter2 unit are: Normal mode (counter), Clear Timer on Compare Match (CTC) mode, and two types of Pulse Width Modulation (PWM) modes (see section "Modes of Operation" for details).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC0_WGM_BITF</ENUM>
        </BIT0>
      </TCCR2A>
      <TCCR2B>
        <NAME>TCCR2B</NAME>
        <DESCRIPTION>Timer/Counter2 Control Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$B1</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>FOC2A</NAME>
          <DESCRIPTION>Force Output Compare A</DESCRIPTION>
          <TEXT>The FOC2A bit is only active when the WGM bits specify a non-PWM mode. However, for ensuring compatibility with future devices, this bit must be set to zero when TCCR2B is written in PWM mode operation. When writing a logical one to the FOC2A bit, an immediate Compare Match is forced on the Waveform Generation unit. The OC2A output is changed according to its COM2A1:0 bits setting. Note that the FOC2A bit is implemented as a strobe. Therefore it is the value present in the COM2A1:0 bits that determines the effect of the forced compare. A FOC2A strobe will not generate any interrupt, nor will it clear the timer in CTC mode using OCR2A as TOP. The FOC2A bit is always read as zero.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>FOC2B</NAME>
          <DESCRIPTION>Force Output Compare B</DESCRIPTION>
          <TEXT>The FOC2B bit is only active when the WGM bits specify a non-PWM mode. However, for ensuring compatibility with future devices, this bit must be set to zero when TCCR2B is written in PWM mode operation. When writing a logical one to the FOC2B bit, an immediate Compare Match is forced on the Waveform Generation unit. The OC2B output is changed according to its COM2B1:0 bits setting. Note that the FOC2B bit is implemented as a strobe. Therefore it is the value present in the COM2B1:0 bits that determines the effect of the forced compare. A FOC2B strobe will not generate any interrupt, nor will it clear the timer in CTC mode using OCR2B as TOP. The FOC2B bit is always read as zero.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>WGM22</NAME>
          <DESCRIPTION>Waveform Generation Mode</DESCRIPTION>
          <TEXT>Combined with the WGM21:0 bits found in the TCCR2A Register, this bit controls the counting sequence of the counter, the source for maximum (TOP) counter value, and what type of waveform generation to be used. See description of "TCCR2A - Timer/Counter2 Control Register A" for details.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CS22</NAME>
          <DESCRIPTION>Clock Select</DESCRIPTION>
          <TEXT>The three Clock Select bits select the clock source to be used by the Timer/Counter2. If external pin modes are used for the Timer/Counter2, transitions on the T2 pin will clock the counter even if the pin is configured as an output. This feature allows software control of the counting.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CS21</NAME>
          <DESCRIPTION>Clock Select</DESCRIPTION>
          <TEXT>The three Clock Select bits select the clock source to be used by the Timer/Counter2. If external pin modes are used for the Timer/Counter2, transitions on the T2 pin will clock the counter even if the pin is configured as an output. This feature allows software control of the counting.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CS20</NAME>
          <DESCRIPTION>Clock Select</DESCRIPTION>
          <TEXT>The three Clock Select bits select the clock source to be used by the Timer/Counter2. If external pin modes are used for the Timer/Counter2, transitions on the T2 pin will clock the counter even if the pin is configured as an output. This feature allows software control of the counting.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>TC2_CLK_SEL_3BIT</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCCR2B>
      <TCNT2>
        <NAME>TCNT2</NAME>
        <DESCRIPTION>Timer/Counter2</DESCRIPTION>
        <TEXT>The Timer/Counter Register gives direct access, both for read and write operations, to the 8-bit counter unit of the Timer/Counter2. Writing to the TCNT2 Register blocks (removes) the Compare Match on the following timer clock. Modifying the counter (TCNT2) while the counter is running, introduces a risk of missing a Compare Match between TCNT2 and the OCR2x Registers. </TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$B2</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TCNT27</NAME>
          <DESCRIPTION>Timer/Counter2 Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TCNT26</NAME>
          <DESCRIPTION>Timer/Counter2 Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TCNT25</NAME>
          <DESCRIPTION>Timer/Counter2 Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TCNT24</NAME>
          <DESCRIPTION>Timer/Counter2 Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TCNT23</NAME>
          <DESCRIPTION>Timer/Counter2 Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TCNT22</NAME>
          <DESCRIPTION>Timer/Counter2 Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TCNT21</NAME>
          <DESCRIPTION>Timer/Counter2 Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TCNT20</NAME>
          <DESCRIPTION>Timer/Counter2 Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC2_TCNT_BITF</ENUM>
        </BIT0>
      </TCNT2>
      <OCR2B>
        <NAME>OCR2B</NAME>
        <DESCRIPTION>Timer/Counter2 Output Compare Register B</DESCRIPTION>
        <TEXT>The Output Compare Register B contains an 8-bit value that is continuously compared with the counter value (TCNT2). A match can be used to generate an Output Compare interrupt, or to generate a waveform output on the OC2B pin.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$B4</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR2B7</NAME>
          <DESCRIPTION>Output Compare Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR2B6</NAME>
          <DESCRIPTION>Output Compare Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR2B5</NAME>
          <DESCRIPTION>Output Compare Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR2B4</NAME>
          <DESCRIPTION>Output Compare Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR2B3</NAME>
          <DESCRIPTION>Output Compare Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR2B2</NAME>
          <DESCRIPTION>Output Compare Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR2B1</NAME>
          <DESCRIPTION>Output Compare Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR2B0</NAME>
          <DESCRIPTION>Output Compare Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC2_OCR_BITF</ENUM>
        </BIT0>
      </OCR2B>
      <OCR2A>
        <NAME>OCR2A</NAME>
        <DESCRIPTION>Timer/Counter2 Output Compare Register A</DESCRIPTION>
        <TEXT>The Output Compare Register A contains an 8-bit value that is continuously compared with the counter value (TCNT2). A match can be used to generate an Output Compare interrupt, or to generate a waveform output on the OC2A pin.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$B3</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR2A7</NAME>
          <DESCRIPTION>Output Compare Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR2A6</NAME>
          <DESCRIPTION>Output Compare Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR2A5</NAME>
          <DESCRIPTION>Output Compare Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR2A4</NAME>
          <DESCRIPTION>Output Compare Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR2A3</NAME>
          <DESCRIPTION>Output Compare Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR2A2</NAME>
          <DESCRIPTION>Output Compare Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR2A1</NAME>
          <DESCRIPTION>Output Compare Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR2A0</NAME>
          <DESCRIPTION>Output Compare Register</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC2_OCR_BITF</ENUM>
        </BIT0>
      </OCR2A>
      <ASSR>
        <NAME>ASSR</NAME>
        <DESCRIPTION>Asynchronous Status Register</DESCRIPTION>
        <TEXT>The register ASSR controls the asynchronous clocks for Timer/Counter2 and enables the asynchronous 32kHz clock for the symbol counter. Three bits (AS2,EXCLK,EXCLKAMR) are used to control the clocks. Note, to prevent clock spikes on asynchronous clock wires, every access to ASSR should change only one of the three bits.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$B6</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>EXCLKAMR</NAME>
          <DESCRIPTION>Enable External Clock Input for AMR</DESCRIPTION>
          <TEXT>The bit EXCLKAMR extends the available clock sources for Timer/Counter2. If this bit is written to one, and asynchronous clock is selected (bit AS2 set), AMR functionality is enabled and Timer/Counter2 is clocked by pin AMR.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>EXCLK</NAME>
          <DESCRIPTION>Enable External Clock Input</DESCRIPTION>
          <TEXT>When EXCLK is written to one, and asynchronous clock is selected, the external clock input buffer is enabled and an external clock can be input on Timer Oscillator 1 (TOSC1) pin instead of a 32 kHz crystal. Writing to EXCLK should be done before asynchronous operation is selected. Note that the crystal Oscillator will only run when this bit is zero.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>AS2</NAME>
          <DESCRIPTION>Timer/Counter2 Asynchronous Mode</DESCRIPTION>
          <TEXT>When AS2 is written to zero, Timer/Counter2 is clocked from the I/O clock, clkI/O. When AS2 is written to one, Timer/Counter2 is clocked from a crystal Oscillator connected to the Timer Oscillator 1 (TOSC1) pin. When the value of AS2 is changed, the contents of TCNT2, OCR2A, OCR2B, TCCR2A and TCCR2B might be corrupted.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TCN2UB</NAME>
          <DESCRIPTION>Timer/Counter2 Update Busy</DESCRIPTION>
          <TEXT>When Timer/Counter2 operates asynchronously and TCNT2 is written, this bit becomes set. When TCNT2 has been updated from the temporary storage register, this bit is cleared by hardware. A logical zero in this bit indicates that TCNT2 is ready to be updated with a new value.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR2AUB</NAME>
          <DESCRIPTION>Timer/Counter2 Output Compare Register A Update Busy</DESCRIPTION>
          <TEXT>When Timer/Counter2 operates asynchronously and OCR2A is written, this bit becomes set. When OCR2A has been updated from the temporary storage register, this bit is cleared by hardware. A logical zero in this bit indicates that OCR2A is ready to be updated with a new value.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR2BUB</NAME>
          <DESCRIPTION>Timer/Counter2 Output Compare Register B Update Busy</DESCRIPTION>
          <TEXT>When Timer/Counter2 operates asynchronously and OCR2B is written, this bit becomes set. When OCR2B has been updated from the temporary storage register, this bit is cleared by hardware. A logical zero in this bit indicates that OCR2B is ready to be updated with a new value.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TCR2AUB</NAME>
          <DESCRIPTION>Timer/Counter2 Control Register A Update Busy</DESCRIPTION>
          <TEXT>When Timer/Counter2 operates asynchronously and TCCR2A is written, this bit becomes set. When TCCR2A has been updated from the temporary storage register, this bit is cleared by hardware. A logical zero in this bit indicates that TCCR2A is ready to be updated with a new value.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TCR2BUB</NAME>
          <DESCRIPTION>Timer/Counter2 Control Register B Update Busy</DESCRIPTION>
          <TEXT>When Timer/Counter2 operates asynchronously and TCCR2B is written, this bit becomes set. When TCCR2B has been updated from the temporary storage register, this bit is cleared by hardware. A logical zero in this bit indicates that TCCR2B is ready to be updated with a new value.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ASSR>
      <GTCCR>
        <NAME>GTCCR</NAME>
        <DESCRIPTION>General Timer Counter Control register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$23</IO_ADDR>
        <MEM_ADDR>$43</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>TSM</NAME>
          <DESCRIPTION>Timer/Counter Synchronization Mode</DESCRIPTION>
          <TEXT>Writing the TSM bit to one activates the Timer/Counter Synchronization mode. In this mode the value that is written to the PSRASY and PSRSYNC bits is kept, hence keeping the corresponding prescaler reset signals asserted. This ensures that the corresponding Timer/Counters are halted and can be configured to the same value without the risk of one of them advancing during the configuration. When the TSM bit is written to zero, the PSRASY and PSRSYNC bits are cleared by hardware and the Timer/Counters simultaneously start counting.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT1>
          <NAME>PSRASY</NAME>
          <ALIAS>PSR2</ALIAS>
          <DESCRIPTION>Prescaler Reset Timer/Counter2</DESCRIPTION>
          <TEXT>When this bit is one, the Timer/Counter2 prescaler will be reset. This bit is normally cleared immediately by hardware. If the bit is written when Timer/Counter2 is operating in asynchronous mode, the bit will remain one until the prescaler has been reset. The bit will not be cleared by hardware if the TSM bit is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
      </GTCCR>
    </TIMER_COUNTER_2>
    <WATCHDOG>
      <LIST>[WDTCSR]</LIST>
      <LINK/>
      <ICON>io_watch.bmp</ICON>
      <ID/>
      <TEXT/>
      <WDTCSR>
        <NAME>WDTCSR</NAME>
        <DESCRIPTION>Watchdog Timer Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$60</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>WDIF</NAME>
          <DESCRIPTION>Watchdog Timeout Interrupt Flag</DESCRIPTION>
          <TEXT>This bit is set when a time-out occurs in the Watchdog Timer and the Watchdog Timer is configured for interrupt. WDIF is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, WDIF is cleared by writing a logic one to the flag. When the I-bit in SREG and WDIE are set, the Watchdog Time-out Interrupt is executed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>WDIE</NAME>
          <DESCRIPTION>Watchdog Timeout Interrupt Enable</DESCRIPTION>
          <TEXT>When this bit is written to one and the I-bit in the Status Register is set, the Watchdog Interrupt is enabled. If WDE is cleared in combination with this setting, the Watchdog Timer is in Interrupt Mode, and the corresponding interrupt is executed if time-out in the Watchdog Timer occurs. If WDE is set, the Watchdog Timer is in Interrupt and System Reset Mode. The first time-out in the Watchdog Timer will set WDIF. Executing the corresponding interrupt vector will clear WDIE and WDIF automatically by hardware (the Watchdog goes to System Reset Mode). This is useful for keeping the Watchdog Timer security while using the interrupt. To stay in Interrupt and System Reset Mode, WDIE must be set after each interrupt. This should however not be done within the interrupt service routine itself, as this might compromise the safety-function of the Watchdog System Reset mode. If the interrupt is not executed before the next time-out, a System Reset will be applied.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>WDP3</NAME>
          <DESCRIPTION>Watchdog Timer Prescaler Bit 3</DESCRIPTION>
          <TEXT>The WDP3:0 bits determine the Watchdog Timer prescaling when the Watchdog Timer is running. The following table also shows approximate time-out values.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>WDCE</NAME>
          <DESCRIPTION>Watchdog Change Enable</DESCRIPTION>
          <TEXT>This bit is used in timed sequences for changing WDE and prescaler bits. To clear the WDE bit, and/or change the prescaler bits, WDCE must be set. Once written to one, hardware will clear WDCE after four clock cycles.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>WDE</NAME>
          <DESCRIPTION>Watch Dog Enable</DESCRIPTION>
          <TEXT>When the WDE is set (one) the Watchdog Timer is enabled. WDE is overridden by WDRF in MCUSR. This means that WDE is always set when WDRF is set. To clear WDE, WDRF must be cleared first. This feature ensures multiple resets during conditions causing failure, and a safe start-up after the failure.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>WDP2</NAME>
          <DESCRIPTION>Watch Dog Timer Prescaler bit 2</DESCRIPTION>
          <TEXT>The WDP3:0 bits determine the Watchdog Timer prescaling when the Watchdog Timer is running. The following table also shows approximate time-out values.</TEXT>
          <ENUM>WDOG_TIMER_PRESCALE_4BITS</ENUM>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>WDP1</NAME>
          <DESCRIPTION>Watch Dog Timer Prescaler bit 1</DESCRIPTION>
          <TEXT>The WDP3:0 bits determine the Watchdog Timer prescaling when the Watchdog Timer is running. The following table also shows approximate time-out values.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>WDP0</NAME>
          <DESCRIPTION>Watch Dog Timer Prescaler bit 0</DESCRIPTION>
          <TEXT>The WDP3:0 bits determine the Watchdog Timer prescaling when the Watchdog Timer is running. The following table also shows approximate time-out values.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </WDTCSR>
    </WATCHDOG>
    <TIMER_COUNTER_5>
      <LIST>[TIMSK5:TIFR5:TCCR5A:TCCR5B:TCCR5C:TCNT5H:TCNT5L:OCR5AH:OCR5AL:OCR5BH:OCR5BL:ICR5H:ICR5L:OCR5CH:OCR5CL]</LIST>
      <LINK>[TCNT5H:TCNT5L];[OCR5AH:OCR5AL];[OCR5BH:OCR5BL];[OCR5CH:OCR5CL];[ICR5H:ICR3L]</LINK>
      <ICON>io_timer.bmp</ICON>
      <ID>ATmegaAllRFA1_t16pwm5_00.xml</ID>
      <TEXT/>
      <TCCR5A>
        <NAME>TCCR5A</NAME>
        <DESCRIPTION>Timer/Counter5 Control Register A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$120</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>COM5A1</NAME>
          <DESCRIPTION>Compare Output Mode for Channel A</DESCRIPTION>
          <TEXT>The Timer/Counter5 has only limited functionality. Therefore the COM5A1:0 bits do not control the output compare behavior of any pin. The following table shows the COM5A1:0 bit functionality when the WGM53:0 bits are set to a normal or a CTC mode (non-PWM). For the other functionality refer to section "Modes of Operation".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>COM5A0</NAME>
          <DESCRIPTION>Compare Output Mode for Channel A</DESCRIPTION>
          <TEXT>The Timer/Counter5 has only limited functionality. Therefore the COM5A1:0 bits do not control the output compare behavior of any pin. The following table shows the COM5A1:0 bit functionality when the WGM53:0 bits are set to a normal or a CTC mode (non-PWM). For the other functionality refer to section "Modes of Operation".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC4_COMNX_BITF</ENUM>
        </BIT6>
        <BIT5>
          <NAME>COM5B1</NAME>
          <DESCRIPTION>Compare Output Mode for Channel B</DESCRIPTION>
          <TEXT>The Timer/Counter5 has only limited functionality. Therefore the COM5B1:0 bits do not control the output compare behavior of any pin. The following table shows the COM5B1:0 bit functionality when the WGM53:0 bits are set to a normal or a CTC mode (non-PWM). For the other functionality refer to section "Modes of Operation".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>COM5B0</NAME>
          <DESCRIPTION>Compare Output Mode for Channel B</DESCRIPTION>
          <TEXT>The Timer/Counter5 has only limited functionality. Therefore the COM5B1:0 bits do not control the output compare behavior of any pin. The following table shows the COM5B1:0 bit functionality when the WGM53:0 bits are set to a normal or a CTC mode (non-PWM). For the other functionality refer to section "Modes of Operation".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC4_COMNX_BITF</ENUM>
        </BIT4>
        <BIT3>
          <NAME>COM5C1</NAME>
          <DESCRIPTION>Compare Output Mode for Channel C</DESCRIPTION>
          <TEXT>The Timer/Counter5 has only limited functionality. Therefore the COM5C1:0 bits do not control the output compare behavior of any pin. The following table shows the COM5C1:0 bit functionality when the WGM53:0 bits are set to a normal or a CTC mode (non-PWM). For the other functionality refer to section "Modes of Operation".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>COM5C0</NAME>
          <DESCRIPTION>Compare Output Mode for Channel C</DESCRIPTION>
          <TEXT>The Timer/Counter5 has only limited functionality. Therefore the COM5C1:0 bits do not control the output compare behavior of any pin. The following table shows the COM5C1:0 bit functionality when the WGM53:0 bits are set to a normal or a CTC mode (non-PWM). For the other functionality refer to section "Modes of Operation".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC4_COMNX_BITF</ENUM>
        </BIT2>
        <BIT1>
          <NAME>WGM51</NAME>
          <DESCRIPTION>Waveform Generation Mode</DESCRIPTION>
          <TEXT>Combined with the WGM53:2 bits found in the TCCR5B Register, these bits control the counting sequence of the counter, the source for maximum (TOP) counter value, and what type of waveform generation to be used. Modes of operation supported by the Timer/Counter unit are: Normal mode (counter), Clear Timer on Compare match (CTC) mode, and three types of Pulse Width Modulation (PWM) modes.  For more information on the different modes see section "Modes of Operation". Note that Timer/Counter5 has only limited functionality. It cannot be connected to any I/O pin.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>WGM50</NAME>
          <DESCRIPTION>Waveform Generation Mode</DESCRIPTION>
          <TEXT>Combined with the WGM53:2 bits found in the TCCR5B Register, these bits control the counting sequence of the counter, the source for maximum (TOP) counter value, and what type of waveform generation to be used. Modes of operation supported by the Timer/Counter unit are: Normal mode (counter), Clear Timer on Compare match (CTC) mode, and three types of Pulse Width Modulation (PWM) modes.  For more information on the different modes see section "Modes of Operation". Note that Timer/Counter5 has only limited functionality. It cannot be connected to any I/O pin.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_WGMX_BITF</ENUM>
        </BIT0>
      </TCCR5A>
      <TCCR5B>
        <NAME>TCCR5B</NAME>
        <DESCRIPTION>Timer/Counter5 Control Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$121</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>ICNC5</NAME>
          <DESCRIPTION>Input Capture 5 Noise Canceller</DESCRIPTION>
          <TEXT>Timer/Counter5 has only limited functionality. It is not connected to any Input Capture Pin. Therefore this bit has no meaningful function.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ICES5</NAME>
          <DESCRIPTION>Input Capture 5 Edge Select</DESCRIPTION>
          <TEXT>Timer/Counter5 has only limited functionality. It is not connected to any Input Capture Pin. Therefore this bit has no meaningful function.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>Res</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>WGM53</NAME>
          <DESCRIPTION>Waveform Generation Mode</DESCRIPTION>
          <TEXT>Combined with the WGM51:0 bits found in the TCCR5A Register, these bits control the counting sequence of the counter, the source for maximum (TOP) counter value, and what type of waveform generation to be used. Modes of operation supported by the Timer/Counter unit are: Normal mode (counter), Clear Timer on Compare match (CTC) mode, and three types of Pulse Width Modulation (PWM) modes. For more information on the different modes see section "Modes of Operation". Note that Timer/Counter5 has only limited functionality. It cannot be connected to any I/O pin.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>WGM52</NAME>
          <DESCRIPTION>Waveform Generation Mode</DESCRIPTION>
          <TEXT>Combined with the WGM51:0 bits found in the TCCR5A Register, these bits control the counting sequence of the counter, the source for maximum (TOP) counter value, and what type of waveform generation to be used. Modes of operation supported by the Timer/Counter unit are: Normal mode (counter), Clear Timer on Compare match (CTC) mode, and three types of Pulse Width Modulation (PWM) modes. For more information on the different modes see section "Modes of Operation". Note that Timer/Counter5 has only limited functionality. It cannot be connected to any I/O pin.</TEXT>
          <ENUM>TC1_WGMX_BITF</ENUM>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CS52</NAME>
          <DESCRIPTION>Clock Select</DESCRIPTION>
          <TEXT>The three clock select bits select the clock source to be used by the Timer/Counter5 according to the following table. External pin modes cannot be used for the Timer/Counter5.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CS51</NAME>
          <DESCRIPTION>Clock Select</DESCRIPTION>
          <TEXT>The three clock select bits select the clock source to be used by the Timer/Counter5 according to the following table. External pin modes cannot be used for the Timer/Counter5.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CS50</NAME>
          <DESCRIPTION>Clock Select</DESCRIPTION>
          <TEXT>The three clock select bits select the clock source to be used by the Timer/Counter5 according to the following table. External pin modes cannot be used for the Timer/Counter5.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>CLK_SEL_3BIT_NOEXT_MEGARF</ENUM>
        </BIT0>
      </TCCR5B>
      <TCCR5C>
        <NAME>TCCR5C</NAME>
        <DESCRIPTION>Timer/Counter5 Control Register C</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$122</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>FOC5A</NAME>
          <DESCRIPTION>Force Output Compare for Channel A</DESCRIPTION>
          <TEXT>The FOC5A bit is only active when the WGM53:0 bits specify a non-PWM mode. When writing a logical one to the FOC5A bit, an immediate compare match is forced. Due to the limited functionality of the Timer/Counter5 the match has no direct impact on any output pin. Note that the FOC5A bits are implemented as strobes. Therefore it is the value present in the COM5A1:0 bits that determine the effect of the forced compare. A FOC5A strobe will not generate any interrupt nor will it clear the timer in Clear Timer on Compare Match (CTC) mode using OCR5A as TOP. The FOC5A bits are always read as zero.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>FOC5B</NAME>
          <DESCRIPTION>Force Output Compare for Channel B</DESCRIPTION>
          <TEXT>The FOC5B bit is only active when the WGM53:0 bits specify a non-PWM mode. When writing a logical one to the FOC5B bit, an immediate compare match is forced. Due to the limited functionality of the Timer/Counter5 the match has no direct impact on any output pin. Note that the FOC5B bits are implemented as strobes. Therefore it is the value present in the COM5B1:0 bits that determine the effect of the forced compare. A FOC5B strobe will not generate any interrupt nor will it clear the timer in Clear Timer on Compare Match (CTC) mode using OCR5B as TOP. The FOC5B bits are always read as zero.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>FOC5C</NAME>
          <DESCRIPTION>Force Output Compare for Channel C</DESCRIPTION>
          <TEXT>The FOC5C bit is only active when the WGM53:0 bits specify a non-PWM mode. When writing a logical one to the FOC5C bit, an immediate compare match is forced. Due to the limited functionality of the Timer/Counter5 the match has no direct impact on any output pin. Note that the FOC5C bits are implemented as strobes. Therefore it is the value present in the COM5C1:0 bits that determine the effect of the forced compare. A FOC5C strobe will not generate any interrupt nor will it clear the timer in Clear Timer on Compare Match (CTC) mode using OCR5C as TOP. The FOC5C bits are always read as zero.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res4</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>Res3</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>Res2</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCCR5C>
      <TCNT5H>
        <NAME>TCNT5H</NAME>
        <DESCRIPTION>Timer/Counter5 High Byte</DESCRIPTION>
        <TEXT>The two Timer/Counter I/O locations (TCNT5H and TCNT5L, combined TCNT5) give direct access, both for read and for write operations, to the Timer/Counter unit 16-bit counter. To ensure that both the high and low bytes are read and written simultaneously when the CPU accesses these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details. Modifying the counter (TCNT5) while the counter is running introduces a risk of missing a compare match between TCNT5 and one of the OCR5x Registers. Writing to the TCNT5 Register blocks (removes) the compare match on the following timer clock for all compare units.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$125</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TCNT5H7</NAME>
          <DESCRIPTION>Timer/Counter5 High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TCNT5H6</NAME>
          <DESCRIPTION>Timer/Counter5 High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TCNT5H5</NAME>
          <DESCRIPTION>Timer/Counter5 High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TCNT5H4</NAME>
          <DESCRIPTION>Timer/Counter5 High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TCNT5H3</NAME>
          <DESCRIPTION>Timer/Counter5 High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TCNT5H2</NAME>
          <DESCRIPTION>Timer/Counter5 High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TCNT5H1</NAME>
          <DESCRIPTION>Timer/Counter5 High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TCNT5H0</NAME>
          <DESCRIPTION>Timer/Counter5 High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_TCNTxHn_BITF</ENUM>
        </BIT0>
      </TCNT5H>
      <TCNT5L>
        <NAME>TCNT5L</NAME>
        <DESCRIPTION>Timer/Counter5 Low Byte</DESCRIPTION>
        <TEXT>The two Timer/Counter I/O locations (TCNT5H and TCNT5L, combined TCNT5) give direct access, both for read and for write operations, to the Timer/Counter unit 16-bit counter. To ensure that both the high and low bytes are read and written simultaneously when the CPU accesses these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details. Modifying the counter (TCNT5) while the counter is running introduces a risk of missing a compare match between TCNT5 and one of the OCR5x Registers. Writing to the TCNT5 Register blocks (removes) the compare match on the following timer clock for all compare units.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$124</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TCNT5L7</NAME>
          <DESCRIPTION>Timer/Counter5 Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TCNT5L6</NAME>
          <DESCRIPTION>Timer/Counter5 Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TCNT5L5</NAME>
          <DESCRIPTION>Timer/Counter5 Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TCNT5L4</NAME>
          <DESCRIPTION>Timer/Counter5 Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TCNT5L3</NAME>
          <DESCRIPTION>Timer/Counter5 Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TCNT5L2</NAME>
          <DESCRIPTION>Timer/Counter5 Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TCNT5L1</NAME>
          <DESCRIPTION>Timer/Counter5 Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TCNT5L0</NAME>
          <DESCRIPTION>Timer/Counter5 Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_TCNTxLn_BITF</ENUM>
        </BIT0>
      </TCNT5L>
      <OCR5AH>
        <NAME>OCR5AH</NAME>
        <DESCRIPTION>Timer/Counter5 Output Compare Register A High Byte</DESCRIPTION>
        <TEXT>The Output Compare Registers contain a 16-bit value that is continuously compared with the counter value (TCNT5). A match can be used to generate an Output Compare interrupt. The Output Compare Registers are 16-bit in size. To ensure that both the high and low bytes are written simultaneously when the CPU writes to these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$129</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR5AH7</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR5AH6</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR5AH5</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR5AH4</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR5AH3</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR5AH2</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR5AH1</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR5AH0</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_OCRxnH_BITF</ENUM>
        </BIT0>
      </OCR5AH>
      <OCR5AL>
        <NAME>OCR5AL</NAME>
        <DESCRIPTION>Timer/Counter5 Output Compare Register A Low Byte</DESCRIPTION>
        <TEXT>The Output Compare Registers contain a 16-bit value that is continuously compared with the counter value (TCNT5). A match can be used to generate an Output Compare interrupt. The Output Compare Registers are 16-bit in size. To ensure that both the high and low bytes are written simultaneously when the CPU writes to these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$128</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR5AL7</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR5AL6</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR5AL5</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR5AL4</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR5AL3</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR5AL2</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR5AL1</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR5AL0</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_OCRxnL_BITF</ENUM>
        </BIT0>
      </OCR5AL>
      <OCR5BH>
        <NAME>OCR5BH</NAME>
        <DESCRIPTION>Timer/Counter5 Output Compare Register B High Byte</DESCRIPTION>
        <TEXT>The Output Compare Registers contain a 16-bit value that is continuously compared with the counter value (TCNT5). A match can be used to generate an Output Compare interrupt. The Output Compare Registers are 16-bit in size. To ensure that both the high and low bytes are written simultaneously when the CPU writes to these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$12B</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR5BH7</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR5BH6</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR5BH5</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR5BH4</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR5BH3</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR5BH2</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR5BH1</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR5BH0</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_OCRxnH_BITF</ENUM>
        </BIT0>
      </OCR5BH>
      <OCR5BL>
        <NAME>OCR5BL</NAME>
        <DESCRIPTION>Timer/Counter5 Output Compare Register B Low Byte</DESCRIPTION>
        <TEXT>The Output Compare Registers contain a 16-bit value that is continuously compared with the counter value (TCNT5). A match can be used to generate an Output Compare interrupt. The Output Compare Registers are 16-bit in size. To ensure that both the high and low bytes are written simultaneously when the CPU writes to these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$12A</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR5BL7</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR5BL6</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR5BL5</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR5BL4</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR5BL3</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR5BL2</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR5BL1</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR5BL0</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_OCRxnL_BITF</ENUM>
        </BIT0>
      </OCR5BL>
      <OCR5CH>
        <NAME>OCR5CH</NAME>
        <DESCRIPTION>Timer/Counter5 Output Compare Register C High Byte</DESCRIPTION>
        <TEXT>The Output Compare Registers contain a 16-bit value that is continuously compared with the counter value (TCNT5). A match can be used to generate an Output Compare interrupt. The Output Compare Registers are 16-bit in size. To ensure that both the high and low bytes are written simultaneously when the CPU writes to these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$12D</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR5CH7</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR5CH6</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR5CH5</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR5CH4</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR5CH3</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR5CH2</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR5CH1</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR5CH0</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_OCRxnH_BITF</ENUM>
        </BIT0>
      </OCR5CH>
      <OCR5CL>
        <NAME>OCR5CL</NAME>
        <DESCRIPTION>Timer/Counter5 Output Compare Register C Low Byte</DESCRIPTION>
        <TEXT>The Output Compare Registers contain a 16-bit value that is continuously compared with the counter value (TCNT5). A match can be used to generate an Output Compare interrupt. The Output Compare Registers are 16-bit in size. To ensure that both the high and low bytes are written simultaneously when the CPU writes to these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$12C</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR5CL7</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR5CL6</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR5CL5</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR5CL4</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR5CL3</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR5CL2</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR5CL1</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR5CL0</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_OCRxnL_BITF</ENUM>
        </BIT0>
      </OCR5CL>
      <ICR5H>
        <NAME>ICR5H</NAME>
        <DESCRIPTION>Timer/Counter5 Input Capture Register High Byte</DESCRIPTION>
        <TEXT>The Timer/Counter5 has only limited functionality. It is not connected to any I/O pin. Therefore the contents of this register is never updated with the counter (TCNT5) value. The Input Capture Register is 16-bit in size. To ensure that both the high and low bytes are read simultaneously when the CPU accesses these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$127</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>ICR5H7</NAME>
          <DESCRIPTION>Timer/Counter5 Input Capture Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ICR5H6</NAME>
          <DESCRIPTION>Timer/Counter5 Input Capture Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ICR5H5</NAME>
          <DESCRIPTION>Timer/Counter5 Input Capture Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ICR5H4</NAME>
          <DESCRIPTION>Timer/Counter5 Input Capture Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ICR5H3</NAME>
          <DESCRIPTION>Timer/Counter5 Input Capture Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ICR5H2</NAME>
          <DESCRIPTION>Timer/Counter5 Input Capture Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ICR5H1</NAME>
          <DESCRIPTION>Timer/Counter5 Input Capture Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ICR5H0</NAME>
          <DESCRIPTION>Timer/Counter5 Input Capture Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_ICRxnH_BITF</ENUM>
        </BIT0>
      </ICR5H>
      <ICR5L>
        <NAME>ICR5L</NAME>
        <DESCRIPTION>Timer/Counter5 Input Capture Register Low Byte</DESCRIPTION>
        <TEXT>The Timer/Counter5 has only limited functionality. It is not connected to any I/O pin. Therefore the contents of this register is never updated with the counter (TCNT5) value. The Input Capture Register is 16-bit in size. To ensure that both the high and low bytes are read simultaneously when the CPU accesses these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$126</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>ICR5L7</NAME>
          <DESCRIPTION>Timer/Counter5 Input Capture Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ICR5L6</NAME>
          <DESCRIPTION>Timer/Counter5 Input Capture Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ICR5L5</NAME>
          <DESCRIPTION>Timer/Counter5 Input Capture Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ICR5L4</NAME>
          <DESCRIPTION>Timer/Counter5 Input Capture Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ICR5L3</NAME>
          <DESCRIPTION>Timer/Counter5 Input Capture Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ICR5L2</NAME>
          <DESCRIPTION>Timer/Counter5 Input Capture Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ICR5L1</NAME>
          <DESCRIPTION>Timer/Counter5 Input Capture Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ICR5L0</NAME>
          <DESCRIPTION>Timer/Counter5 Input Capture Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_ICRxnL_BITF</ENUM>
        </BIT0>
      </ICR5L>
      <TIMSK5>
        <NAME>TIMSK5</NAME>
        <DESCRIPTION>Timer/Counter5 Interrupt Mask Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$73</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ICIE5</NAME>
          <DESCRIPTION>Timer/Counter5 Input Capture Interrupt Enable</DESCRIPTION>
          <TEXT>The Timer/Counter5 has only limited functionality. It does not have an Input Capture pin. Therefore this bit has no useful meaning.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCIE5C</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare C Match Interrupt Enable</DESCRIPTION>
          <TEXT>When this bit is written to one, and the I-flag in the Status Register is set (interrupts globally enabled), the Timer/Counter5 Output Compare C Match interrupt is enabled. The corresponding Interrupt Vector is executed when the OCF5C Flag, located in TIFR5, is set.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCIE5B</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare B Match Interrupt Enable</DESCRIPTION>
          <TEXT>When this bit is written to one, and the I-flag in the Status Register is set (interrupts globally enabled), the Timer/Counter5 Output Compare B Match interrupt is enabled. The corresponding Interrupt Vector is executed when the OCF5B Flag, located in TIFR5, is set.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCIE5A</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare A Match Interrupt Enable</DESCRIPTION>
          <TEXT>When this bit is written to one, and the I-flag in the Status Register is set (interrupts globally enabled), the Timer/Counter5 Output Compare A Match interrupt is enabled. The corresponding Interrupt Vector is executed when the OCF5A Flag, located in TIFR5, is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TOIE5</NAME>
          <DESCRIPTION>Timer/Counter5 Overflow Interrupt Enable</DESCRIPTION>
          <TEXT>When this bit is written to one, and the I-flag in the Status Register is set (interrupts globally enabled), the Timer/Counter5 Overflow interrupt is enabled. The corresponding Interrupt Vector is executed when the TOV5 Flag, located in TIFR5, is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TIMSK5>
      <TIFR5>
        <NAME>TIFR5</NAME>
        <DESCRIPTION>Timer/Counter5 Interrupt Flag Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$1A</IO_ADDR>
        <MEM_ADDR>$3A</MEM_ADDR>
        <READ_INTRUSIVE/>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ICF5</NAME>
          <DESCRIPTION>Timer/Counter5 Input Capture Flag</DESCRIPTION>
          <TEXT>The Timer/Counter5 has only limited functionality. It does not have an Input Capture pin. Therefore this bit has no useful meaning.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCF5C</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare C Match Flag</DESCRIPTION>
          <TEXT>This flag is set in the timer clock cycle after the counter (TCNT5) value matches the Output Compare Register C (OCR5C). Note that a Forced Output Compare (FOC5C) strobe will not set the OCF5C Flag. OCF5C is automatically cleared when the Output Compare Match C Interrupt Vector is executed. Alternatively, OCF5C can be cleared by writing a logic one to its bit location.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCF5B</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare B Match Flag</DESCRIPTION>
          <TEXT>This flag is set in the timer clock cycle after the counter (TCNT5) value matches the Output Compare Register B (OCR5B). Note that a Forced Output Compare (FOC5B) strobe will not set the OCF5B Flag. OCF5B is automatically cleared when the Output Compare Match B Interrupt Vector is executed. Alternatively, OCF5B can be cleared by writing a logic one to its bit location.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCF5A</NAME>
          <DESCRIPTION>Timer/Counter5 Output Compare A Match Flag</DESCRIPTION>
          <TEXT>This flag is set in the timer clock cycle after the counter (TCNT5) value matches the Output Compare Register A (OCR5A). Note that a Forced Output Compare (FOC5A) strobe will not set the OCF5A Flag. OCF5A is automatically cleared when the Output Compare Match A Interrupt Vector is executed. Alternatively, OCF5A can be cleared by writing a logic one to its bit location.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TOV5</NAME>
          <DESCRIPTION>Timer/Counter5 Overflow Flag</DESCRIPTION>
          <TEXT>The setting of this flag is dependent of the WGM53:0 bits setting of the Timer/Counter5 Control Register. In Normal and CTC modes, the TOV5 Flag is set when the timer overflows.  TOV5 is automatically cleared when the Timer/Counter5 Overflow Interrupt Vector is executed. Alternatively, TOV5 can be cleared by writing a logic one to its bit location.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TIFR5>
    </TIMER_COUNTER_5>
    <TIMER_COUNTER_4>
      <LIST>[TIMSK4:TIFR4:TCCR4A:TCCR4B:TCCR4C:TCNT4H:TCNT4L:OCR4AH:OCR4AL:OCR4BH:OCR4BL:ICR4H:ICR4L:OCR4CH:OCR4CL]</LIST>
      <LINK>[TCNT4H:TCNT4L];[OCR4AH:OCR4AL];[OCR4BH:OCR4BL];[OCR4CH:OCR4CL];[ICR4H:ICR4L]</LINK>
      <ICON>io_timer.bmp</ICON>
      <ID>ATmegaAllRFA1_t16pwm4_00.xml</ID>
      <TEXT/>
      <TCCR4A>
        <NAME>TCCR4A</NAME>
        <DESCRIPTION>Timer/Counter4 Control Register A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$A0</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>COM4A1</NAME>
          <DESCRIPTION>Compare Output Mode for Channel A</DESCRIPTION>
          <TEXT>The Timer/Counter4 has only limited functionality. Therefore the COM4A1:0 bits do not control the output compare behavior of any pin. The following table shows the COM4A1:0 bit functionality when the WGM43:0 bits are set to a normal or a CTC mode (non-PWM). For the other functionality refer to section "Modes of Operation".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>COM4A0</NAME>
          <DESCRIPTION>Compare Output Mode for Channel A</DESCRIPTION>
          <TEXT>The Timer/Counter4 has only limited functionality. Therefore the COM4A1:0 bits do not control the output compare behavior of any pin. The following table shows the COM4A1:0 bit functionality when the WGM43:0 bits are set to a normal or a CTC mode (non-PWM). For the other functionality refer to section "Modes of Operation".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC4_COMNX_BITF</ENUM>
        </BIT6>
        <BIT5>
          <NAME>COM4B1</NAME>
          <DESCRIPTION>Compare Output Mode for Channel B</DESCRIPTION>
          <TEXT>The Timer/Counter4 has only limited functionality. Therefore the COM4B1:0 bits do not control the output compare behavior of any pin. The following table shows the COM4B1:0 bit functionality when the WGM43:0 bits are set to a normal or a CTC mode (non-PWM). For the other functionality refer to section "Modes of Operation".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>COM4B0</NAME>
          <DESCRIPTION>Compare Output Mode for Channel B</DESCRIPTION>
          <TEXT>The Timer/Counter4 has only limited functionality. Therefore the COM4B1:0 bits do not control the output compare behavior of any pin. The following table shows the COM4B1:0 bit functionality when the WGM43:0 bits are set to a normal or a CTC mode (non-PWM). For the other functionality refer to section "Modes of Operation".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC4_COMNX_BITF</ENUM>
        </BIT4>
        <BIT3>
          <NAME>COM4C1</NAME>
          <DESCRIPTION>Compare Output Mode for Channel C</DESCRIPTION>
          <TEXT>The Timer/Counter4 has only limited functionality. Therefore the COM4C1:0 bits do not control the output compare behavior of any pin. The following table shows the COM4C1:0 bit functionality when the WGM43:0 bits are set to a normal or a CTC mode (non-PWM). For the other functionality refer to section "Modes of Operation".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>COM4C0</NAME>
          <DESCRIPTION>Compare Output Mode for Channel C</DESCRIPTION>
          <TEXT>The Timer/Counter4 has only limited functionality. Therefore the COM4C1:0 bits do not control the output compare behavior of any pin. The following table shows the COM4C1:0 bit functionality when the WGM43:0 bits are set to a normal or a CTC mode (non-PWM). For the other functionality refer to section "Modes of Operation".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC4_COMNX_BITF</ENUM>
        </BIT2>
        <BIT1>
          <NAME>WGM41</NAME>
          <DESCRIPTION>Waveform Generation Mode</DESCRIPTION>
          <TEXT>Combined with the WGM43:2 bits found in the TCCR4B Register, these bits control the counting sequence of the counter, the source for maximum (TOP) counter value, and what type of waveform generation to be used. Modes of operation supported by the Timer/Counter unit are: Normal mode (counter), Clear Timer on Compare match (CTC) mode, and three types of Pulse Width Modulation (PWM) modes.  For more information on the different modes see section "Modes of Operation". Note that Timer/Counter4 has only limited functionality. It cannot be connected to any I/O pin.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>WGM40</NAME>
          <DESCRIPTION>Waveform Generation Mode</DESCRIPTION>
          <TEXT>Combined with the WGM43:2 bits found in the TCCR4B Register, these bits control the counting sequence of the counter, the source for maximum (TOP) counter value, and what type of waveform generation to be used. Modes of operation supported by the Timer/Counter unit are: Normal mode (counter), Clear Timer on Compare match (CTC) mode, and three types of Pulse Width Modulation (PWM) modes.  For more information on the different modes see section "Modes of Operation". Note that Timer/Counter4 has only limited functionality. It cannot be connected to any I/O pin.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_WGMX_BITF</ENUM>
        </BIT0>
      </TCCR4A>
      <TCCR4B>
        <NAME>TCCR4B</NAME>
        <DESCRIPTION>Timer/Counter4 Control Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$A1</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>ICNC4</NAME>
          <DESCRIPTION>Input Capture 4 Noise Canceller</DESCRIPTION>
          <TEXT>Timer/Counter4 has only limited functionality. It is not connected to any Input Capture Pin. Therefore this bit has no meaningful function.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ICES4</NAME>
          <DESCRIPTION>Input Capture 4 Edge Select</DESCRIPTION>
          <TEXT>Timer/Counter4 has only limited functionality. It is not connected to any Input Capture Pin. Therefore this bit has no meaningful function.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>Res</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>WGM43</NAME>
          <DESCRIPTION>Waveform Generation Mode</DESCRIPTION>
          <TEXT>Combined with the WGM41:0 bits found in the TCCR4A Register, these bits control the counting sequence of the counter, the source for maximum (TOP) counter value, and what type of waveform generation to be used. Modes of operation supported by the Timer/Counter unit are: Normal mode (counter), Clear Timer on Compare match (CTC) mode, and three types of Pulse Width Modulation (PWM) modes. For more information on the different modes see section "Modes of Operation". Note that Timer/Counter4 has only limited functionality. It cannot be connected to any I/O pin.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>WGM42</NAME>
          <DESCRIPTION>Waveform Generation Mode</DESCRIPTION>
          <TEXT>Combined with the WGM41:0 bits found in the TCCR4A Register, these bits control the counting sequence of the counter, the source for maximum (TOP) counter value, and what type of waveform generation to be used. Modes of operation supported by the Timer/Counter unit are: Normal mode (counter), Clear Timer on Compare match (CTC) mode, and three types of Pulse Width Modulation (PWM) modes. For more information on the different modes see section "Modes of Operation". Note that Timer/Counter4 has only limited functionality. It cannot be connected to any I/O pin.</TEXT>
          <ENUM>TC1_WGMX_BITF</ENUM>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CS42</NAME>
          <DESCRIPTION>Clock Select</DESCRIPTION>
          <TEXT>The three clock select bits select the clock source to be used by the Timer/Counter4 according to the following table. External pin modes cannot be used for the Timer/Counter4.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CS41</NAME>
          <DESCRIPTION>Clock Select</DESCRIPTION>
          <TEXT>The three clock select bits select the clock source to be used by the Timer/Counter4 according to the following table. External pin modes cannot be used for the Timer/Counter4.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CS40</NAME>
          <DESCRIPTION>Clock Select</DESCRIPTION>
          <TEXT>The three clock select bits select the clock source to be used by the Timer/Counter4 according to the following table. External pin modes cannot be used for the Timer/Counter4.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>CLK_SEL_3BIT_NOEXT_MEGARF</ENUM>
        </BIT0>
      </TCCR4B>
      <TCCR4C>
        <NAME>TCCR4C</NAME>
        <DESCRIPTION>Timer/Counter4 Control Register C</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$A2</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>FOC4A</NAME>
          <DESCRIPTION>Force Output Compare for Channel A</DESCRIPTION>
          <TEXT>The FOC4A bit is only active when the WGM43:0 bits specify a non-PWM mode. When writing a logical one to the FOC4A bit, an immediate compare match is forced. Due to the limited functionality of the Timer/Counter4 the match has no direct impact on any output pin. Note that the FOC4A bits are implemented as strobes. Therefore it is the value present in the COM4A1:0 bits that determine the effect of the forced compare. A FOC4A strobe will not generate any interrupt nor will it clear the timer in Clear Timer on Compare Match (CTC) mode using OCR4A as TOP. The FOC4A bits are always read as zero.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>FOC4B</NAME>
          <DESCRIPTION>Force Output Compare for Channel B</DESCRIPTION>
          <TEXT>The FOC4B bit is only active when the WGM43:0 bits specify a non-PWM mode. When writing a logical one to the FOC4B bit, an immediate compare match is forced. Due to the limited functionality of the Timer/Counter4 the match has no direct impact on any output pin. Note that the FOC4B bits are implemented as strobes. Therefore it is the value present in the COM4B1:0 bits that determine the effect of the forced compare. A FOC4B strobe will not generate any interrupt nor will it clear the timer in Clear Timer on Compare Match (CTC) mode using OCR4B as TOP. The FOC4B bits are always read as zero.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>FOC4C</NAME>
          <DESCRIPTION>Force Output Compare for Channel C</DESCRIPTION>
          <TEXT>The FOC4C bit is only active when the WGM43:0 bits specify a non-PWM mode. When writing a logical one to the FOC4C bit, an immediate compare match is forced. Due to the limited functionality of the Timer/Counter4 the match has no direct impact on any output pin. Note that the FOC4C bits are implemented as strobes. Therefore it is the value present in the COM4C1:0 bits that determine the effect of the forced compare. A FOC4C strobe will not generate any interrupt nor will it clear the timer in Clear Timer on Compare Match (CTC) mode using OCR4C as TOP. The FOC4C bits are always read as zero.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res4</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>Res3</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>Res2</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCCR4C>
      <TCNT4H>
        <NAME>TCNT4H</NAME>
        <DESCRIPTION>Timer/Counter4 High Byte</DESCRIPTION>
        <TEXT>The two Timer/Counter I/O locations (TCNT4H and TCNT4L, combined TCNT4) give direct access, both for read and for write operations, to the Timer/Counter unit 16-bit counter. To ensure that both the high and low bytes are read and written simultaneously when the CPU accesses these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details. Modifying the counter (TCNT4) while the counter is running introduces a risk of missing a compare match between TCNT4 and one of the OCR4x Registers. Writing to the TCNT4 Register blocks (removes) the compare match on the following timer clock for all compare units.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$A5</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TCNT4H7</NAME>
          <DESCRIPTION>Timer/Counter4 High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TCNT4H6</NAME>
          <DESCRIPTION>Timer/Counter4 High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TCNT4H5</NAME>
          <DESCRIPTION>Timer/Counter4 High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TCNT4H4</NAME>
          <DESCRIPTION>Timer/Counter4 High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TCNT4H3</NAME>
          <DESCRIPTION>Timer/Counter4 High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TCNT4H2</NAME>
          <DESCRIPTION>Timer/Counter4 High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TCNT4H1</NAME>
          <DESCRIPTION>Timer/Counter4 High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TCNT4H0</NAME>
          <DESCRIPTION>Timer/Counter4 High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_TCNTxHn_BITF</ENUM>
        </BIT0>
      </TCNT4H>
      <TCNT4L>
        <NAME>TCNT4L</NAME>
        <DESCRIPTION>Timer/Counter4 Low Byte</DESCRIPTION>
        <TEXT>The two Timer/Counter I/O locations (TCNT4H and TCNT4L, combined TCNT4) give direct access, both for read and for write operations, to the Timer/Counter unit 16-bit counter. To ensure that both the high and low bytes are read and written simultaneously when the CPU accesses these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details. Modifying the counter (TCNT4) while the counter is running introduces a risk of missing a compare match between TCNT4 and one of the OCR4x Registers. Writing to the TCNT4 Register blocks (removes) the compare match on the following timer clock for all compare units.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$A4</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TCNT4L7</NAME>
          <DESCRIPTION>Timer/Counter4 Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TCNT4L6</NAME>
          <DESCRIPTION>Timer/Counter4 Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TCNT4L5</NAME>
          <DESCRIPTION>Timer/Counter4 Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TCNT4L4</NAME>
          <DESCRIPTION>Timer/Counter4 Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TCNT4L3</NAME>
          <DESCRIPTION>Timer/Counter4 Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TCNT4L2</NAME>
          <DESCRIPTION>Timer/Counter4 Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TCNT4L1</NAME>
          <DESCRIPTION>Timer/Counter4 Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TCNT4L0</NAME>
          <DESCRIPTION>Timer/Counter4 Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_TCNTxLn_BITF</ENUM>
        </BIT0>
      </TCNT4L>
      <OCR4AH>
        <NAME>OCR4AH</NAME>
        <DESCRIPTION>Timer/Counter4 Output Compare Register A High Byte</DESCRIPTION>
        <TEXT>The Output Compare Registers contain a 16-bit value that is continuously compared with the counter value (TCNT4). A match can be used to generate an Output Compare interrupt. The Output Compare Registers are 16-bit in size. To ensure that both the high and low bytes are written simultaneously when the CPU writes to these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$A9</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR4AH7</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR4AH6</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR4AH5</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR4AH4</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR4AH3</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR4AH2</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR4AH1</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR4AH0</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_OCRxnH_BITF</ENUM>
        </BIT0>
      </OCR4AH>
      <OCR4AL>
        <NAME>OCR4AL</NAME>
        <DESCRIPTION>Timer/Counter4 Output Compare Register A Low Byte</DESCRIPTION>
        <TEXT>The Output Compare Registers contain a 16-bit value that is continuously compared with the counter value (TCNT4). A match can be used to generate an Output Compare interrupt. The Output Compare Registers are 16-bit in size. To ensure that both the high and low bytes are written simultaneously when the CPU writes to these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$A8</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR4AL7</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR4AL6</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR4AL5</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR4AL4</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR4AL3</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR4AL2</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR4AL1</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR4AL0</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_OCRxnL_BITF</ENUM>
        </BIT0>
      </OCR4AL>
      <OCR4BH>
        <NAME>OCR4BH</NAME>
        <DESCRIPTION>Timer/Counter4 Output Compare Register B High Byte</DESCRIPTION>
        <TEXT>The Output Compare Registers contain a 16-bit value that is continuously compared with the counter value (TCNT4). A match can be used to generate an Output Compare interrupt. The Output Compare Registers are 16-bit in size. To ensure that both the high and low bytes are written simultaneously when the CPU writes to these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$AB</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR4BH7</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR4BH6</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR4BH5</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR4BH4</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR4BH3</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR4BH2</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR4BH1</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR4BH0</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_OCRxnH_BITF</ENUM>
        </BIT0>
      </OCR4BH>
      <OCR4BL>
        <NAME>OCR4BL</NAME>
        <DESCRIPTION>Timer/Counter4 Output Compare Register B Low Byte</DESCRIPTION>
        <TEXT>The Output Compare Registers contain a 16-bit value that is continuously compared with the counter value (TCNT4). A match can be used to generate an Output Compare interrupt. The Output Compare Registers are 16-bit in size. To ensure that both the high and low bytes are written simultaneously when the CPU writes to these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$AA</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR4BL7</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR4BL6</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR4BL5</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR4BL4</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR4BL3</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR4BL2</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR4BL1</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR4BL0</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_OCRxnL_BITF</ENUM>
        </BIT0>
      </OCR4BL>
      <OCR4CH>
        <NAME>OCR4CH</NAME>
        <DESCRIPTION>Timer/Counter4 Output Compare Register C High Byte</DESCRIPTION>
        <TEXT>The Output Compare Registers contain a 16-bit value that is continuously compared with the counter value (TCNT4). A match can be used to generate an Output Compare interrupt. The Output Compare Registers are 16-bit in size. To ensure that both the high and low bytes are written simultaneously when the CPU writes to these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$AD</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR4CH7</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR4CH6</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR4CH5</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR4CH4</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR4CH3</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR4CH2</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR4CH1</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR4CH0</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_OCRxnH_BITF</ENUM>
        </BIT0>
      </OCR4CH>
      <OCR4CL>
        <NAME>OCR4CL</NAME>
        <DESCRIPTION>Timer/Counter4 Output Compare Register C Low Byte</DESCRIPTION>
        <TEXT>The Output Compare Registers contain a 16-bit value that is continuously compared with the counter value (TCNT4). A match can be used to generate an Output Compare interrupt. The Output Compare Registers are 16-bit in size. To ensure that both the high and low bytes are written simultaneously when the CPU writes to these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$AC</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR4CL7</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR4CL6</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR4CL5</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR4CL4</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR4CL3</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR4CL2</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR4CL1</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR4CL0</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_OCRxnL_BITF</ENUM>
        </BIT0>
      </OCR4CL>
      <ICR4H>
        <NAME>ICR4H</NAME>
        <DESCRIPTION>Timer/Counter4 Input Capture Register High Byte</DESCRIPTION>
        <TEXT>The Timer/Counter4 has only limited functionality. It is not connected to any I/O pin. Therefore the contents of this register is never updated with the counter (TCNT4) value. The Input Capture Register is 16-bit in size. To ensure that both the high and low bytes are read simultaneously when the CPU accesses these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$A7</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>ICR4H7</NAME>
          <DESCRIPTION>Timer/Counter4 Input Capture Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ICR4H6</NAME>
          <DESCRIPTION>Timer/Counter4 Input Capture Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ICR4H5</NAME>
          <DESCRIPTION>Timer/Counter4 Input Capture Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ICR4H4</NAME>
          <DESCRIPTION>Timer/Counter4 Input Capture Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ICR4H3</NAME>
          <DESCRIPTION>Timer/Counter4 Input Capture Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ICR4H2</NAME>
          <DESCRIPTION>Timer/Counter4 Input Capture Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ICR4H1</NAME>
          <DESCRIPTION>Timer/Counter4 Input Capture Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ICR4H0</NAME>
          <DESCRIPTION>Timer/Counter4 Input Capture Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_ICRxnH_BITF</ENUM>
        </BIT0>
      </ICR4H>
      <ICR4L>
        <NAME>ICR4L</NAME>
        <DESCRIPTION>Timer/Counter4 Input Capture Register Low Byte</DESCRIPTION>
        <TEXT>The Timer/Counter4 has only limited functionality. It is not connected to any I/O pin. Therefore the contents of this register is never updated with the counter (TCNT4) value. The Input Capture Register is 16-bit in size. To ensure that both the high and low bytes are read simultaneously when the CPU accesses these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$A6</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>ICR4L7</NAME>
          <DESCRIPTION>Timer/Counter4 Input Capture Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ICR4L6</NAME>
          <DESCRIPTION>Timer/Counter4 Input Capture Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ICR4L5</NAME>
          <DESCRIPTION>Timer/Counter4 Input Capture Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ICR4L4</NAME>
          <DESCRIPTION>Timer/Counter4 Input Capture Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ICR4L3</NAME>
          <DESCRIPTION>Timer/Counter4 Input Capture Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ICR4L2</NAME>
          <DESCRIPTION>Timer/Counter4 Input Capture Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ICR4L1</NAME>
          <DESCRIPTION>Timer/Counter4 Input Capture Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ICR4L0</NAME>
          <DESCRIPTION>Timer/Counter4 Input Capture Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_ICRxnL_BITF</ENUM>
        </BIT0>
      </ICR4L>
      <TIMSK4>
        <NAME>TIMSK4</NAME>
        <DESCRIPTION>Timer/Counter4 Interrupt Mask Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$72</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ICIE4</NAME>
          <DESCRIPTION>Timer/Counter4 Input Capture Interrupt Enable</DESCRIPTION>
          <TEXT>The Timer/Counter4 has only limited functionality. It does not have an Input Capture pin. Therefore this bit has no useful meaning.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCIE4C</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare C Match Interrupt Enable</DESCRIPTION>
          <TEXT>When this bit is written to one, and the I-flag in the Status Register is set (interrupts globally enabled), the Timer/Counter4 Output Compare C Match interrupt is enabled. The corresponding Interrupt Vector is executed when the OCF4C Flag, located in TIFR4, is set.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCIE4B</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare B Match Interrupt Enable</DESCRIPTION>
          <TEXT>When this bit is written to one, and the I-flag in the Status Register is set (interrupts globally enabled), the Timer/Counter4 Output Compare B Match interrupt is enabled. The corresponding Interrupt Vector is executed when the OCF4B Flag, located in TIFR4, is set.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCIE4A</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare A Match Interrupt Enable</DESCRIPTION>
          <TEXT>When this bit is written to one, and the I-flag in the Status Register is set (interrupts globally enabled), the Timer/Counter4 Output Compare A Match interrupt is enabled. The corresponding Interrupt Vector is executed when the OCF4A Flag, located in TIFR4, is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TOIE4</NAME>
          <DESCRIPTION>Timer/Counter4 Overflow Interrupt Enable</DESCRIPTION>
          <TEXT>When this bit is written to one, and the I-flag in the Status Register is set (interrupts globally enabled), the Timer/Counter4 Overflow interrupt is enabled. The corresponding Interrupt Vector is executed when the TOV4 Flag, located in TIFR4, is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TIMSK4>
      <TIFR4>
        <NAME>TIFR4</NAME>
        <DESCRIPTION>Timer/Counter4 Interrupt Flag Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$19</IO_ADDR>
        <MEM_ADDR>$39</MEM_ADDR>
        <READ_INTRUSIVE/>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ICF4</NAME>
          <DESCRIPTION>Timer/Counter4 Input Capture Flag</DESCRIPTION>
          <TEXT>The Timer/Counter4 has only limited functionality. It does not have an Input Capture pin. Therefore this bit has no useful meaning.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCF4C</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare C Match Flag</DESCRIPTION>
          <TEXT>This flag is set in the timer clock cycle after the counter (TCNT4) value matches the Output Compare Register C (OCR4C). Note that a Forced Output Compare (FOC4C) strobe will not set the OCF4C Flag. OCF4C is automatically cleared when the Output Compare Match C Interrupt Vector is executed. Alternatively, OCF4C can be cleared by writing a logic one to its bit location.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCF4B</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare B Match Flag</DESCRIPTION>
          <TEXT>This flag is set in the timer clock cycle after the counter (TCNT4) value matches the Output Compare Register B (OCR4B). Note that a Forced Output Compare (FOC4B) strobe will not set the OCF4B Flag. OCF4B is automatically cleared when the Output Compare Match B Interrupt Vector is executed. Alternatively, OCF4B can be cleared by writing a logic one to its bit location.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCF4A</NAME>
          <DESCRIPTION>Timer/Counter4 Output Compare A Match Flag</DESCRIPTION>
          <TEXT>This flag is set in the timer clock cycle after the counter (TCNT4) value matches the Output Compare Register A (OCR4A). Note that a Forced Output Compare (FOC4A) strobe will not set the OCF4A Flag. OCF4A is automatically cleared when the Output Compare Match A Interrupt Vector is executed. Alternatively, OCF4A can be cleared by writing a logic one to its bit location.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TOV4</NAME>
          <DESCRIPTION>Timer/Counter4 Overflow Flag</DESCRIPTION>
          <TEXT>The setting of this flag is dependent of the WGM43:0 bits setting of the Timer/Counter4 Control Register. In Normal and CTC modes, the TOV4 Flag is set when the timer overflows.  TOV4 is automatically cleared when the Timer/Counter4 Overflow Interrupt Vector is executed. Alternatively, TOV4 can be cleared by writing a logic one to its bit location.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TIFR4>
    </TIMER_COUNTER_4>
    <TIMER_COUNTER_3>
      <LIST>[TIMSK3:TIFR3:TCCR3A:TCCR3B:TCCR3C:TCNT3H:TCNT3L:OCR3AH:OCR3AL:OCR3BH:OCR3BL:ICR3H:ICR3L:OCR3CH:OCR3CL]</LIST>
      <LINK>[TCNT3H:TCNT3L];[OCR3AH:OCR3AL];[OCR3BH:OCR3BL];[OCR3CH:OCR3CL];[ICR3H:ICR3L]</LINK>
      <ICON>io_timer.bmp</ICON>
      <ID>ATmegaAllRFA1_t16pwm3_03.xml</ID>
      <TEXT/>
      <TCCR3A>
        <NAME>TCCR3A</NAME>
        <DESCRIPTION>Timer/Counter3 Control Register A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$90</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>COM3A1</NAME>
          <DESCRIPTION>Compare Output Mode for Channel A</DESCRIPTION>
          <TEXT>The COM3A1:0 bits control the output compare behavior of pin OC3A. If one or both of the COM3A1:0 bits are written to one, the OC3A output overrides the normal port functionality of the I/O pin it is connected to. However note that the Data Direction Register (DDR) bit corresponding to the OC3A pin must be set in order to enable the output driver. When the OC3A is connected to the pin, the function of the COM3A1:0 bits is dependent of the WGM33:0 bits setting. The following table shows the COM3A1:0 bit functionality when the WGM33:0 bits are set to a normal or a CTC mode (non-PWM). For the other functionality refer to section "Modes of Operation".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>COM3A0</NAME>
          <DESCRIPTION>Compare Output Mode for Channel A</DESCRIPTION>
          <TEXT>The COM3A1:0 bits control the output compare behavior of pin OC3A. If one or both of the COM3A1:0 bits are written to one, the OC3A output overrides the normal port functionality of the I/O pin it is connected to. However note that the Data Direction Register (DDR) bit corresponding to the OC3A pin must be set in order to enable the output driver. When the OC3A is connected to the pin, the function of the COM3A1:0 bits is dependent of the WGM33:0 bits setting. The following table shows the COM3A1:0 bit functionality when the WGM33:0 bits are set to a normal or a CTC mode (non-PWM). For the other functionality refer to section "Modes of Operation".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_COMNX_BITF</ENUM>
        </BIT6>
        <BIT5>
          <NAME>COM3B1</NAME>
          <DESCRIPTION>Compare Output Mode for Channel B</DESCRIPTION>
          <TEXT>The COM3B1:0 bits control the output compare behavior of pin OC3B. If one or both of the COM3B1:0 bits are written to one, the OC3B output overrides the normal port functionality of the I/O pin it is connected to. However note that the Data Direction Register (DDR) bit corresponding to the OC3B pin must be set in order to enable the output driver. When the OC3B is connected to the pin, the function of the COM3B1:0 bits is dependent of the WGM33:0 bits setting. The following table shows the COM3B1:0 bit functionality when the WGM33:0 bits are set to a normal or a CTC mode (non-PWM). For the other functionality refer to section "Modes of Operation".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>COM3B0</NAME>
          <DESCRIPTION>Compare Output Mode for Channel B</DESCRIPTION>
          <TEXT>The COM3B1:0 bits control the output compare behavior of pin OC3B. If one or both of the COM3B1:0 bits are written to one, the OC3B output overrides the normal port functionality of the I/O pin it is connected to. However note that the Data Direction Register (DDR) bit corresponding to the OC3B pin must be set in order to enable the output driver. When the OC3B is connected to the pin, the function of the COM3B1:0 bits is dependent of the WGM33:0 bits setting. The following table shows the COM3B1:0 bit functionality when the WGM33:0 bits are set to a normal or a CTC mode (non-PWM). For the other functionality refer to section "Modes of Operation".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_COMNX_BITF</ENUM>
        </BIT4>
        <BIT3>
          <NAME>COM3C1</NAME>
          <DESCRIPTION>Compare Output Mode for Channel C</DESCRIPTION>
          <TEXT>The COM3C1:0 bits control the output compare behavior of pin OC3C. If one or both of the COM3C1:0 bits are written to one, the OC3C output overrides the normal port functionality of the I/O pin it is connected to. However note that the Data Direction Register (DDR) bit corresponding to the OC3C pin must be set in order to enable the output driver. When the OC3C is connected to the pin, the function of the COM3C1:0 bits is dependent of the WGM33:0 bits setting. The following table shows the COM3C1:0 bit functionality when the WGM33:0 bits are set to a normal or a CTC mode (non-PWM). For the other functionality refer to section "Modes of Operation".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>COM3C0</NAME>
          <DESCRIPTION>Compare Output Mode for Channel C</DESCRIPTION>
          <TEXT>The COM3C1:0 bits control the output compare behavior of pin OC3C. If one or both of the COM3C1:0 bits are written to one, the OC3C output overrides the normal port functionality of the I/O pin it is connected to. However note that the Data Direction Register (DDR) bit corresponding to the OC3C pin must be set in order to enable the output driver. When the OC3C is connected to the pin, the function of the COM3C1:0 bits is dependent of the WGM33:0 bits setting. The following table shows the COM3C1:0 bit functionality when the WGM33:0 bits are set to a normal or a CTC mode (non-PWM). For the other functionality refer to section "Modes of Operation".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_COMNX_BITF</ENUM>
        </BIT2>
        <BIT1>
          <NAME>WGM31</NAME>
          <DESCRIPTION>Waveform Generation Mode</DESCRIPTION>
          <TEXT>Combined with the WGM33:2 bits found in the TCCR3B Register, these bits control the counting sequence of the counter, the source for maximum (TOP) counter value, and what type of waveform generation to be used. Modes of operation supported by the Timer/Counter unit are: Normal mode (counter), Clear Timer on Compare match (CTC) mode, and three types of Pulse Width Modulation (PWM) modes. For more information on the different modes see section "Modes of Operation".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>WGM30</NAME>
          <DESCRIPTION>Waveform Generation Mode</DESCRIPTION>
          <TEXT>Combined with the WGM33:2 bits found in the TCCR3B Register, these bits control the counting sequence of the counter, the source for maximum (TOP) counter value, and what type of waveform generation to be used. Modes of operation supported by the Timer/Counter unit are: Normal mode (counter), Clear Timer on Compare match (CTC) mode, and three types of Pulse Width Modulation (PWM) modes. For more information on the different modes see section "Modes of Operation".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_WGMX_BITF</ENUM>
        </BIT0>
      </TCCR3A>
      <TCCR3B>
        <NAME>TCCR3B</NAME>
        <DESCRIPTION>Timer/Counter3 Control Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$91</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>ICNC3</NAME>
          <DESCRIPTION>Input Capture 3 Noise Canceller</DESCRIPTION>
          <TEXT>Setting this bit (to one) activates the Input Capture Noise Canceler. When the Noise Canceler is activated, the input from the Input Capture Pin (ICP3) is filtered. The filter function requires four successive equal valued samples of the ICP3 pin for changing its output. The input capture is therefore delayed by four Oscillator cycles when the noise canceler is enabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ICES3</NAME>
          <DESCRIPTION>Input Capture 3 Edge Select</DESCRIPTION>
          <TEXT>This bit selects which edge on the Input Capture Pin (ICP3) that is used to trigger a capture event. When the ICES3 bit is written to zero, a falling (negative) edge is used as trigger. When the ICES3 bit is written to one, a rising (positive) edge will trigger the capture. When a capture is triggered according to the ICES3 setting, the counter value is copied into the Input Capture Register (ICR3). The event will also set the Input Capture Flag (ICF3). This can be used to cause an Input Capture Interrupt, if this interrupt is enabled. When the ICR3 is used as TOP value (see description of the WGM33:0 bits located in the TCCR3A and the TCCR3B Register), the ICP3 is disconnected and consequently the input capture function is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>Res</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>WGM33</NAME>
          <DESCRIPTION>Waveform Generation Mode</DESCRIPTION>
          <TEXT>Combined with the WGM31:0 bits found in the TCCR3A Register, these bits control the counting sequence of the counter, the source for maximum (TOP) counter value, and what type of waveform generation to be used. Modes of operation supported by the Timer/Counter unit are: Normal mode (counter), Clear Timer on Compare match (CTC) mode, and three types of Pulse Width Modulation (PWM) modes. For more information on the different modes see section "Modes of Operation".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>WGM32</NAME>
          <DESCRIPTION>Waveform Generation Mode</DESCRIPTION>
          <TEXT>Combined with the WGM31:0 bits found in the TCCR3A Register, these bits control the counting sequence of the counter, the source for maximum (TOP) counter value, and what type of waveform generation to be used. Modes of operation supported by the Timer/Counter unit are: Normal mode (counter), Clear Timer on Compare match (CTC) mode, and three types of Pulse Width Modulation (PWM) modes. For more information on the different modes see section "Modes of Operation".</TEXT>
          <ENUM>TC1_WGMX_BITF</ENUM>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CS32</NAME>
          <DESCRIPTION>Clock Select</DESCRIPTION>
          <TEXT>The three clock select bits select the clock source to be used by the Timer/Counter3 according to the following table. If external pin modes are used for the Timer/Counter3, transitions on the T3 pin will clock the counter even if the pin is configured as an output. This feature allows software control of the counting.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CS31</NAME>
          <DESCRIPTION>Clock Select</DESCRIPTION>
          <TEXT>The three clock select bits select the clock source to be used by the Timer/Counter3 according to the following table. If external pin modes are used for the Timer/Counter3, transitions on the T3 pin will clock the counter even if the pin is configured as an output. This feature allows software control of the counting.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CS30</NAME>
          <DESCRIPTION>Clock Select</DESCRIPTION>
          <TEXT>The three clock select bits select the clock source to be used by the Timer/Counter3 according to the following table. If external pin modes are used for the Timer/Counter3, transitions on the T3 pin will clock the counter even if the pin is configured as an output. This feature allows software control of the counting.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>CLK_SEL_3BIT_EXT_MEGARF</ENUM>
        </BIT0>
      </TCCR3B>
      <TCCR3C>
        <NAME>TCCR3C</NAME>
        <DESCRIPTION>Timer/Counter3 Control Register C</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$92</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>FOC3A</NAME>
          <DESCRIPTION>Force Output Compare for Channel A</DESCRIPTION>
          <TEXT>The FOC3A bit is only active when the WGM33:0 bits specify a non-PWM mode. When writing a logical one to the FOC3A bit, an immediate compare match is forced on the waveform generation unit. The OC3A output is changed according to its COM3A1:0 bits setting. Note that the FOC3A bits are implemented as strobes. Therefore it is the value present in the COM3A1:0 bits that determine the effect of the forced compare. A FOC3A strobe will not generate any interrupt nor will it clear the timer in Clear Timer on Compare Match (CTC) mode using OCR3A as TOP. The FOC3A bits are always read as zero.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>FOC3B</NAME>
          <DESCRIPTION>Force Output Compare for Channel B</DESCRIPTION>
          <TEXT>The FOC3B bit is only active when the WGM33:0 bits specify a non-PWM mode. When writing a logical one to the FOC3B bit, an immediate compare match is forced on the waveform generation unit. The OC3B output is changed according to its COM3B1:0 bits setting. Note that the FOC3B bits are implemented as strobes. Therefore it is the value present in the COM3B1:0 bits that determine the effect of the forced compare. A FOC3B strobe will not generate any interrupt nor will it clear the timer in Clear Timer on Compare Match (CTC) mode using OCR1B as TOP. The FOC3B bits are always read as zero.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>FOC3C</NAME>
          <DESCRIPTION>Force Output Compare for Channel C</DESCRIPTION>
          <TEXT>The FOC3C bit is only active when the WGM33:0 bits specify a non-PWM mode. When writing a logical one to the FOC3C bit, an immediate compare match is forced on the waveform generation unit. The OC3C output is changed according to its COM3C1:0 bits setting. Note that the FOC3C bits are implemented as strobes. Therefore it is the value present in the COM3C1:0 bits that determine the effect of the forced compare. A FOC3C strobe will not generate any interrupt nor will it clear the timer in Clear Timer on Compare Match (CTC) mode using OCR3C as TOP. The FOC3C bits are always read as zero.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res4</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>Res3</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>Res2</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCCR3C>
      <TCNT3H>
        <NAME>TCNT3H</NAME>
        <DESCRIPTION>Timer/Counter3 High Byte</DESCRIPTION>
        <TEXT>The two Timer/Counter I/O locations (TCNT3H and TCNT3L, combined TCNT3) give direct access, both for read and for write operations, to the Timer/Counter unit 16-bit counter. To ensure that both the high and low bytes are read and written simultaneously when the CPU accesses these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details. Modifying the counter (TCNT3) while the counter is running introduces a risk of missing a compare match between TCNT3 and one of the OCR3x Registers. Writing to the TCNT3 Register blocks (removes) the compare match on the following timer clock for all compare units.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$95</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TCNT3H7</NAME>
          <DESCRIPTION>Timer/Counter3 High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TCNT3H6</NAME>
          <DESCRIPTION>Timer/Counter3 High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TCNT3H5</NAME>
          <DESCRIPTION>Timer/Counter3 High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TCNT3H4</NAME>
          <DESCRIPTION>Timer/Counter3 High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TCNT3H3</NAME>
          <DESCRIPTION>Timer/Counter3 High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TCNT3H2</NAME>
          <DESCRIPTION>Timer/Counter3 High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TCNT3H1</NAME>
          <DESCRIPTION>Timer/Counter3 High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TCNT3H0</NAME>
          <DESCRIPTION>Timer/Counter3 High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_TCNTxHn_BITF</ENUM>
        </BIT0>
      </TCNT3H>
      <TCNT3L>
        <NAME>TCNT3L</NAME>
        <DESCRIPTION>Timer/Counter3 Low Byte</DESCRIPTION>
        <TEXT>The two Timer/Counter I/O locations (TCNT3H and TCNT3L, combined TCNT3) give direct access, both for read and for write operations, to the Timer/Counter unit 16-bit counter. To ensure that both the high and low bytes are read and written simultaneously when the CPU accesses these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details. Modifying the counter (TCNT3) while the counter is running introduces a risk of missing a compare match between TCNT3 and one of the OCR3x Registers. Writing to the TCNT3 Register blocks (removes) the compare match on the following timer clock for all compare units.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$94</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TCNT3L7</NAME>
          <DESCRIPTION>Timer/Counter3 Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TCNT3L6</NAME>
          <DESCRIPTION>Timer/Counter3 Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TCNT3L5</NAME>
          <DESCRIPTION>Timer/Counter3 Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TCNT3L4</NAME>
          <DESCRIPTION>Timer/Counter3 Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TCNT3L3</NAME>
          <DESCRIPTION>Timer/Counter3 Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TCNT3L2</NAME>
          <DESCRIPTION>Timer/Counter3 Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TCNT3L1</NAME>
          <DESCRIPTION>Timer/Counter3 Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TCNT3L0</NAME>
          <DESCRIPTION>Timer/Counter3 Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_TCNTxLn_BITF</ENUM>
        </BIT0>
      </TCNT3L>
      <OCR3AH>
        <NAME>OCR3AH</NAME>
        <DESCRIPTION>Timer/Counter3 Output Compare Register A High Byte</DESCRIPTION>
        <TEXT>The Output Compare Registers contain a 16-bit value that is continuously compared with the counter value (TCNT3). A match can be used to generate an Output Compare interrupt, or to generate a waveform output on the OC3A pin. The Output Compare Registers are 16-bit in size. To ensure that both the high and low bytes are written simultaneously when the CPU writes to these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$99</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR3AH7</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR3AH6</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR3AH5</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR3AH4</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR3AH3</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR3AH2</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR3AH1</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR3AH0</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_OCRxnH_BITF</ENUM>
        </BIT0>
      </OCR3AH>
      <OCR3AL>
        <NAME>OCR3AL</NAME>
        <DESCRIPTION>Timer/Counter3 Output Compare Register A Low Byte</DESCRIPTION>
        <TEXT>The Output Compare Registers contain a 16-bit value that is continuously compared with the counter value (TCNT3). A match can be used to generate an Output Compare interrupt, or to generate a waveform output on the OC3A pin. The Output Compare Registers are 16-bit in size. To ensure that both the high and low bytes are written simultaneously when the CPU writes to these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$98</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR3AL7</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR3AL6</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR3AL5</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR3AL4</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR3AL3</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR3AL2</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR3AL1</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR3AL0</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_OCRxnL_BITF</ENUM>
        </BIT0>
      </OCR3AL>
      <OCR3BH>
        <NAME>OCR3BH</NAME>
        <DESCRIPTION>Timer/Counter3 Output Compare Register B High Byte</DESCRIPTION>
        <TEXT>The Output Compare Registers contain a 16-bit value that is continuously compared with the counter value (TCNT3). A match can be used to generate an Output Compare interrupt, or to generate a waveform output on the OC3B pin. The Output Compare Registers are 16-bit in size. To ensure that both the high and low bytes are written simultaneously when the CPU writes to these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$9B</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR3BH7</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR3BH6</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR3BH5</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR3BH4</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR3BH3</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR3BH2</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR3BH1</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR3BH0</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_OCRxnH_BITF</ENUM>
        </BIT0>
      </OCR3BH>
      <OCR3BL>
        <NAME>OCR3BL</NAME>
        <DESCRIPTION>Timer/Counter3 Output Compare Register B Low Byte</DESCRIPTION>
        <TEXT>The Output Compare Registers contain a 16-bit value that is continuously compared with the counter value (TCNT3). A match can be used to generate an Output Compare interrupt, or to generate a waveform output on the OC3B pin. The Output Compare Registers are 16-bit in size. To ensure that both the high and low bytes are written simultaneously when the CPU writes to these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$9A</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR3BL7</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR3BL6</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR3BL5</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR3BL4</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR3BL3</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR3BL2</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR3BL1</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR3BL0</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_OCRxnL_BITF</ENUM>
        </BIT0>
      </OCR3BL>
      <OCR3CH>
        <NAME>OCR3CH</NAME>
        <DESCRIPTION>Timer/Counter3 Output Compare Register C High Byte</DESCRIPTION>
        <TEXT>The Output Compare Registers contain a 16-bit value that is continuously compared with the counter value (TCNT3). A match can be used to generate an Output Compare interrupt, or to generate a waveform output on the OC3C pin. The Output Compare Registers are 16-bit in size. To ensure that both the high and low bytes are written simultaneously when the CPU writes to these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$9D</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR3CH7</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR3CH6</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR3CH5</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR3CH4</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR3CH3</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR3CH2</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR3CH1</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR3CH0</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_OCRxnH_BITF</ENUM>
        </BIT0>
      </OCR3CH>
      <OCR3CL>
        <NAME>OCR3CL</NAME>
        <DESCRIPTION>Timer/Counter3 Output Compare Register C Low Byte</DESCRIPTION>
        <TEXT>The Output Compare Registers contain a 16-bit value that is continuously compared with the counter value (TCNT3). A match can be used to generate an Output Compare interrupt, or to generate a waveform output on the OC3C pin. The Output Compare Registers are 16-bit in size. To ensure that both the high and low bytes are written simultaneously when the CPU writes to these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$9C</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR3CL7</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR3CL6</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR3CL5</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR3CL4</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR3CL3</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR3CL2</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR3CL1</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR3CL0</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_OCRxnL_BITF</ENUM>
        </BIT0>
      </OCR3CL>
      <ICR3H>
        <NAME>ICR3H</NAME>
        <DESCRIPTION>Timer/Counter3 Input Capture Register High Byte</DESCRIPTION>
        <TEXT>The Input Capture Register is updated with the counter (TCNT3) value each time an event occurs on the ICP3 pin. The Input Capture Register can be used for defining the counter TOP value. The Input Capture Register is 16-bit in size. To ensure that both the high and low bytes are read simultaneously when the CPU accesses these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$97</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>ICR3H7</NAME>
          <DESCRIPTION>Timer/Counter3 Input Capture Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ICR3H6</NAME>
          <DESCRIPTION>Timer/Counter3 Input Capture Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ICR3H5</NAME>
          <DESCRIPTION>Timer/Counter3 Input Capture Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ICR3H4</NAME>
          <DESCRIPTION>Timer/Counter3 Input Capture Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ICR3H3</NAME>
          <DESCRIPTION>Timer/Counter3 Input Capture Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ICR3H2</NAME>
          <DESCRIPTION>Timer/Counter3 Input Capture Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ICR3H1</NAME>
          <DESCRIPTION>Timer/Counter3 Input Capture Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ICR3H0</NAME>
          <DESCRIPTION>Timer/Counter3 Input Capture Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_ICRxnH_BITF</ENUM>
        </BIT0>
      </ICR3H>
      <ICR3L>
        <NAME>ICR3L</NAME>
        <DESCRIPTION>Timer/Counter3 Input Capture Register Low Byte</DESCRIPTION>
        <TEXT>The Input Capture Register is updated with the counter (TCNT3) value each time an event occurs on the ICP3 pin. The Input Capture Register can be used for defining the counter TOP value. The Input Capture Register is 16-bit in size. To ensure that both the high and low bytes are read simultaneously when the CPU accesses these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$96</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>ICR3L7</NAME>
          <DESCRIPTION>Timer/Counter3 Input Capture Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ICR3L6</NAME>
          <DESCRIPTION>Timer/Counter3 Input Capture Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ICR3L5</NAME>
          <DESCRIPTION>Timer/Counter3 Input Capture Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ICR3L4</NAME>
          <DESCRIPTION>Timer/Counter3 Input Capture Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ICR3L3</NAME>
          <DESCRIPTION>Timer/Counter3 Input Capture Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ICR3L2</NAME>
          <DESCRIPTION>Timer/Counter3 Input Capture Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ICR3L1</NAME>
          <DESCRIPTION>Timer/Counter3 Input Capture Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ICR3L0</NAME>
          <DESCRIPTION>Timer/Counter3 Input Capture Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_ICRxnL_BITF</ENUM>
        </BIT0>
      </ICR3L>
      <TIMSK3>
        <NAME>TIMSK3</NAME>
        <DESCRIPTION>Timer/Counter3 Interrupt Mask Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$71</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ICIE3</NAME>
          <DESCRIPTION>Timer/Counter3 Input Capture Interrupt Enable</DESCRIPTION>
          <TEXT>When this bit is written to one, and the I-flag in the Status Register is set (interrupts globally enabled), the Timer/Counter3 Input Capture interrupt is enabled. The corresponding Interrupt Vector is executed when the ICF3 Flag, located in TIFR3, is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCIE3C</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare C Match Interrupt Enable</DESCRIPTION>
          <TEXT>When this bit is written to one, and the I-flag in the Status Register is set (interrupts globally enabled), the Timer/Counter3 Output Compare C Match interrupt is enabled. The corresponding Interrupt Vector is executed when the OCF3C Flag, located in TIFR3, is set.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCIE3B</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare B Match Interrupt Enable</DESCRIPTION>
          <TEXT>When this bit is written to one, and the I-flag in the Status Register is set (interrupts globally enabled), the Timer/Counter3 Output Compare B Match interrupt is enabled. The corresponding Interrupt Vector is executed when the OCF3B Flag, located in TIFR3, is set.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCIE3A</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare A Match Interrupt Enable</DESCRIPTION>
          <TEXT>When this bit is written to one, and the I-flag in the Status Register is set (interrupts globally enabled), the Timer/Counter3 Output Compare A Match interrupt is enabled. The corresponding Interrupt Vector is executed when the OCF3A Flag, located in TIFR3, is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TOIE3</NAME>
          <DESCRIPTION>Timer/Counter3 Overflow Interrupt Enable</DESCRIPTION>
          <TEXT>When this bit is written to one, and the I-flag in the Status Register is set (interrupts globally enabled), the Timer/Counter3 Overflow interrupt is enabled. The corresponding Interrupt Vector is executed when the TOV3 Flag, located in TIFR3, is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TIMSK3>
      <TIFR3>
        <NAME>TIFR3</NAME>
        <DESCRIPTION>Timer/Counter3 Interrupt Flag Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$18</IO_ADDR>
        <MEM_ADDR>$38</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ICF3</NAME>
          <DESCRIPTION>Timer/Counter3 Input Capture Flag</DESCRIPTION>
          <TEXT>This flag is set when a capture event occurs on the ICP3 pin. When the Input Capture Register (ICR3) is set by the WGM33:0 to be used as the TOP value, the ICF3 Flag is set when the counter reaches the TOP value. ICF3 is automatically cleared when the Input Capture Interrupt Vector is executed. Alternatively, ICF3 can be cleared by writing a logic one to its bit location.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCF3C</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare C Match Flag</DESCRIPTION>
          <TEXT>This flag is set in the timer clock cycle after the counter (TCNT3) value matches the Output Compare Register C (OCR3C). Note that a Forced Output Compare (FOC3C) strobe will not set the OCF3C Flag. OCF3C is automatically cleared when the Output Compare Match C Interrupt Vector is executed. Alternatively, OCF3C can be cleared by writing a logic one to its bit location.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCF3B</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare B Match Flag</DESCRIPTION>
          <TEXT>This flag is set in the timer clock cycle after the counter (TCNT3) value matches the Output Compare Register B (OCR3B). Note that a Forced Output Compare (FOC3B) strobe will not set the OCF3B Flag. OCF3B is automatically cleared when the Output Compare Match B Interrupt Vector is executed. Alternatively, OCF3B can be cleared by writing a logic one to its bit location.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCF3A</NAME>
          <DESCRIPTION>Timer/Counter3 Output Compare A Match Flag</DESCRIPTION>
          <TEXT>This flag is set in the timer clock cycle after the counter (TCNT3) value matches the Output Compare Register A (OCR3A). Note that a Forced Output Compare (FOC3A) strobe will not set the OCF3A Flag. OCF3A is automatically cleared when the Output Compare Match A Interrupt Vector is executed. Alternatively, OCF3A can be cleared by writing a logic one to its bit location.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TOV3</NAME>
          <DESCRIPTION>Timer/Counter3 Overflow Flag</DESCRIPTION>
          <TEXT>The setting of this flag is dependent of the WGM33:0 bits setting of the Timer/Counter3 Control Register. In Normal and CTC modes, the TOV3 Flag is set when the timer overflows.  TOV3 is automatically cleared when the Timer/Counter3 Overflow Interrupt Vector is executed. Alternatively, TOV3 can be cleared by writing a logic one to its bit location.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TIFR3>
    </TIMER_COUNTER_3>
    <TIMER_COUNTER_1>
      <LIST>[TIMSK1:TIFR1:TCCR1A:TCCR1B:TCCR1C:TCNT1H:TCNT1L:OCR1AH:OCR1AL:OCR1BH:OCR1BL:ICR1H:ICR1L:OCR1CH:OCR1CL]</LIST>
      <LINK>[TCNT1H:TCNT1L];[OCR1AH:OCR1AL];[OCR1BH:OCR1BL];[OCR1CH:OCR1CL];[ICR1H:ICR1L]</LINK>
      <ICON>io_timer.bmp</ICON>
      <ID>ATmegaAllRFA1_t16pwm1_14.xml</ID>
      <TEXT/>
      <TCCR1A>
        <NAME>TCCR1A</NAME>
        <DESCRIPTION>Timer/Counter1 Control Register A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$80</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>COM1A1</NAME>
          <DESCRIPTION>Compare Output Mode for Channel A</DESCRIPTION>
          <TEXT>The COM1A1:0 bits control the output compare behavior of pin OC1A. If one or both of the COM1A1:0 bits are written to one, the OC1A output overrides the normal port functionality of the I/O pin it is connected to. However note that the Data Direction Register (DDR) bit corresponding to the OC1A pin must be set in order to enable the output driver. When the OC1A is connected to the pin, the function of the COM1A1:0 bits is dependent of the WGM13:0 bits setting. The following table shows the COM1A1:0 bit functionality when the WGM13:0 bits are set to a normal or a CTC mode (non-PWM). For the other functionality refer to section "Modes of Operation".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>COM1A0</NAME>
          <DESCRIPTION>Compare Output Mode for Channel A</DESCRIPTION>
          <TEXT>The COM1A1:0 bits control the output compare behavior of pin OC1A. If one or both of the COM1A1:0 bits are written to one, the OC1A output overrides the normal port functionality of the I/O pin it is connected to. However note that the Data Direction Register (DDR) bit corresponding to the OC1A pin must be set in order to enable the output driver. When the OC1A is connected to the pin, the function of the COM1A1:0 bits is dependent of the WGM13:0 bits setting. The following table shows the COM1A1:0 bit functionality when the WGM13:0 bits are set to a normal or a CTC mode (non-PWM). For the other functionality refer to section "Modes of Operation".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_COMNX_BITF</ENUM>
        </BIT6>
        <BIT5>
          <NAME>COM1B1</NAME>
          <DESCRIPTION>Compare Output Mode for Channel B</DESCRIPTION>
          <TEXT>The COM1B1:0 bits control the output compare behavior of pin OC1B. If one or both of the COM1B1:0 bits are written to one, the OC1B output overrides the normal port functionality of the I/O pin it is connected to. However note that the Data Direction Register (DDR) bit corresponding to the OC1B pin must be set in order to enable the output driver. When the OC1A is connected to the pin, the function of the COM1B1:0 bits is dependent of the WGM13:0 bits setting. The following table shows the COM1B1:0 bit functionality when the WGM13:0 bits are set to a normal or a CTC mode (non-PWM). For the other functionality refer to section "Modes of Operation".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>COM1B0</NAME>
          <DESCRIPTION>Compare Output Mode for Channel B</DESCRIPTION>
          <TEXT>The COM1B1:0 bits control the output compare behavior of pin OC1B. If one or both of the COM1B1:0 bits are written to one, the OC1B output overrides the normal port functionality of the I/O pin it is connected to. However note that the Data Direction Register (DDR) bit corresponding to the OC1B pin must be set in order to enable the output driver. When the OC1A is connected to the pin, the function of the COM1B1:0 bits is dependent of the WGM13:0 bits setting. The following table shows the COM1B1:0 bit functionality when the WGM13:0 bits are set to a normal or a CTC mode (non-PWM). For the other functionality refer to section "Modes of Operation".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_COMNX_BITF</ENUM>
        </BIT4>
        <BIT3>
          <NAME>COM1C1</NAME>
          <DESCRIPTION>Compare Output Mode for Channel C</DESCRIPTION>
          <TEXT>The COM1C1:0 bits control the output compare behavior of pin OC1C. If one or both of the COM1C1:0 bits are written to one, the OC1C output overrides the normal port functionality of the I/O pin it is connected to. However note that the Data Direction Register (DDR) bit corresponding to the OC1C pin must be set in order to enable the output driver. When the OC1A is connected to the pin, the function of the COM1C1:0 bits is dependent of the WGM13:0 bits setting. The following table shows the COM1C1:0 bit functionality when the WGM13:0 bits are set to a normal or a CTC mode (non-PWM). For the other functionality refer to section "Modes of Operation".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>COM1C0</NAME>
          <DESCRIPTION>Compare Output Mode for Channel C</DESCRIPTION>
          <TEXT>The COM1C1:0 bits control the output compare behavior of pin OC1C. If one or both of the COM1C1:0 bits are written to one, the OC1C output overrides the normal port functionality of the I/O pin it is connected to. However note that the Data Direction Register (DDR) bit corresponding to the OC1C pin must be set in order to enable the output driver. When the OC1A is connected to the pin, the function of the COM1C1:0 bits is dependent of the WGM13:0 bits setting. The following table shows the COM1C1:0 bit functionality when the WGM13:0 bits are set to a normal or a CTC mode (non-PWM). For the other functionality refer to section "Modes of Operation".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_COMNX_BITF</ENUM>
        </BIT2>
        <BIT1>
          <NAME>WGM11</NAME>
          <DESCRIPTION>Waveform Generation Mode</DESCRIPTION>
          <TEXT>Combined with the WGM13:2 bits found in the TCCR1B Register, these bits control the counting sequence of the counter, the source for maximum (TOP) counter value, and what type of waveform generation to be used. Modes of operation supported by the Timer/Counter unit are: Normal mode (counter), Clear Timer on Compare match (CTC) mode, and three types of Pulse Width Modulation (PWM) modes. For more information on the different modes see section "Modes of Operation".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>WGM10</NAME>
          <DESCRIPTION>Waveform Generation Mode</DESCRIPTION>
          <TEXT>Combined with the WGM13:2 bits found in the TCCR1B Register, these bits control the counting sequence of the counter, the source for maximum (TOP) counter value, and what type of waveform generation to be used. Modes of operation supported by the Timer/Counter unit are: Normal mode (counter), Clear Timer on Compare match (CTC) mode, and three types of Pulse Width Modulation (PWM) modes. For more information on the different modes see section "Modes of Operation".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_WGMX_BITF</ENUM>
        </BIT0>
      </TCCR1A>
      <TCCR1B>
        <NAME>TCCR1B</NAME>
        <DESCRIPTION>Timer/Counter1 Control Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$81</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>ICNC1</NAME>
          <DESCRIPTION>Input Capture 1 Noise Canceller</DESCRIPTION>
          <TEXT>Setting this bit (to one) activates the Input Capture Noise Canceler. When the Noise Canceler is activated, the input from the Input Capture Pin (ICP1) is filtered. The filter function requires four successive equal valued samples of the ICP1 pin for changing its output. The input capture is therefore delayed by four Oscillator cycles when the noise canceler is enabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ICES1</NAME>
          <DESCRIPTION>Input Capture 1 Edge Select</DESCRIPTION>
          <TEXT>This bit selects which edge on the Input Capture Pin (ICP1) that is used to trigger a capture event. When the ICES1 bit is written to zero, a falling (negative) edge is used as trigger. When the ICES1 bit is written to one, a rising (positive) edge will trigger the capture. When a capture is triggered according to the ICES1 setting, the counter value is copied into the Input Capture Register (ICR1). The event will also set the Input Capture Flag (ICF1). This can be used to cause an Input Capture Interrupt, if this interrupt is enabled. When the ICR1 is used as TOP value (see description of the WGM13:0 bits located in the TCCR1A and the TCCR1B Register), the ICP1 is disconnected and consequently the input capture function is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>Res</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>WGM13</NAME>
          <DESCRIPTION>Waveform Generation Mode</DESCRIPTION>
          <TEXT>Combined with the WGM11:0 bits found in the TCCR1A Register, these bits control the counting sequence of the counter, the source for maximum (TOP) counter value, and what type of waveform generation to be used. Modes of operation supported by the Timer/Counter unit are: Normal mode (counter), Clear Timer on Compare match (CTC) mode, and three types of Pulse Width Modulation (PWM) modes. For more information on the different modes see section "Modes of Operation".</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>WGM12</NAME>
          <DESCRIPTION>Waveform Generation Mode</DESCRIPTION>
          <TEXT>Combined with the WGM11:0 bits found in the TCCR1A Register, these bits control the counting sequence of the counter, the source for maximum (TOP) counter value, and what type of waveform generation to be used. Modes of operation supported by the Timer/Counter unit are: Normal mode (counter), Clear Timer on Compare match (CTC) mode, and three types of Pulse Width Modulation (PWM) modes. For more information on the different modes see section "Modes of Operation".</TEXT>
          <ENUM>TC1_WGMX_BITF</ENUM>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CS12</NAME>
          <DESCRIPTION>Clock Select</DESCRIPTION>
          <TEXT>The three clock select bits select the clock source to be used by the Timer/Counter1 according to the following table. If external pin modes are used for the Timer/Counter1, transitions on the T1 pin will clock the counter even if the pin is configured as an output. This feature allows software control of the counting.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CS11</NAME>
          <DESCRIPTION>Clock Select</DESCRIPTION>
          <TEXT>The three clock select bits select the clock source to be used by the Timer/Counter1 according to the following table. If external pin modes are used for the Timer/Counter1, transitions on the T1 pin will clock the counter even if the pin is configured as an output. This feature allows software control of the counting.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CS10</NAME>
          <DESCRIPTION>Clock Select</DESCRIPTION>
          <TEXT>The three clock select bits select the clock source to be used by the Timer/Counter1 according to the following table. If external pin modes are used for the Timer/Counter1, transitions on the T1 pin will clock the counter even if the pin is configured as an output. This feature allows software control of the counting.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>CLK_SEL_3BIT_EXT_MEGARF</ENUM>
        </BIT0>
      </TCCR1B>
      <TCCR1C>
        <NAME>TCCR1C</NAME>
        <DESCRIPTION>Timer/Counter1 Control Register C</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$82</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>FOC1A</NAME>
          <DESCRIPTION>Force Output Compare for Channel A</DESCRIPTION>
          <TEXT>The FOC1A bit is only active when the WGM13:0 bits specify a non-PWM mode. When writing a logical one to the FOC1A bit, an immediate compare match is forced on the waveform generation unit. The OC1A output is changed according to its COM1A1:0 bits setting. Note that the FOC1A bits are implemented as strobes. Therefore it is the value present in the COM1A1:0 bits that determine the effect of the forced compare. A FOC1A strobe will not generate any interrupt nor will it clear the timer in Clear Timer on Compare Match (CTC) mode using OCR1A as TOP. The FOC1A bits are always read as zero.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>FOC1B</NAME>
          <DESCRIPTION>Force Output Compare for Channel B</DESCRIPTION>
          <TEXT>The FOC1B bit is only active when the WGM13:0 bits specify a non-PWM mode. When writing a logical one to the FOC1B bit, an immediate compare match is forced on the waveform generation unit. The OC1B output is changed according to its COM1B1:0 bits setting. Note that the FOC1B bits are implemented as strobes. Therefore it is the value present in the COM1B1:0 bits that determine the effect of the forced compare. A FOC1B strobe will not generate any interrupt nor will it clear the timer in Clear Timer on Compare Match (CTC) mode using OCR1B as TOP. The FOC1B bits are always read as zero.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>FOC1C</NAME>
          <DESCRIPTION>Force Output Compare for Channel C</DESCRIPTION>
          <TEXT>The FOC1C bit is only active when the WGM13:0 bits specify a non-PWM mode. When writing a logical one to the FOC1C bit, an immediate compare match is forced on the waveform generation unit. The OC1C output is changed according to its COM1C1:0 bits setting. Note that the FOC1C bits are implemented as strobes. Therefore it is the value present in the COM1C1:0 bits that determine the effect of the forced compare. A FOC1C strobe will not generate any interrupt nor will it clear the timer in Clear Timer on Compare Match (CTC) mode using OCR1C as TOP. The FOC1C bits are always read as zero.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res4</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>Res3</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>Res2</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCCR1C>
      <TCNT1H>
        <NAME>TCNT1H</NAME>
        <DESCRIPTION>Timer/Counter1 High Byte</DESCRIPTION>
        <TEXT>The two Timer/Counter I/O locations (TCNT1H and TCNT1L, combined TCNT1) give direct access, both for read and for write operations, to the Timer/Counter unit 16-bit counter. To ensure that both the high and low bytes are read and written simultaneously when the CPU accesses these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details. Modifying the counter (TCNT1) while the counter is running introduces a risk of missing a compare match between TCNT1 and one of the OCR1x Registers. Writing to the TCNT1 Register blocks (removes) the compare match on the following timer clock for all compare units.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$85</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TCNT1H7</NAME>
          <DESCRIPTION>Timer/Counter1 High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TCNT1H6</NAME>
          <DESCRIPTION>Timer/Counter1 High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TCNT1H5</NAME>
          <DESCRIPTION>Timer/Counter1 High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TCNT1H4</NAME>
          <DESCRIPTION>Timer/Counter1 High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TCNT1H3</NAME>
          <DESCRIPTION>Timer/Counter1 High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TCNT1H2</NAME>
          <DESCRIPTION>Timer/Counter1 High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TCNT1H1</NAME>
          <DESCRIPTION>Timer/Counter1 High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TCNT1H0</NAME>
          <DESCRIPTION>Timer/Counter1 High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_TCNTxHn_BITF</ENUM>
        </BIT0>
      </TCNT1H>
      <TCNT1L>
        <NAME>TCNT1L</NAME>
        <DESCRIPTION>Timer/Counter1 Low Byte</DESCRIPTION>
        <TEXT>The two Timer/Counter I/O locations (TCNT1H and TCNT1L, combined TCNT1) give direct access, both for read and for write operations, to the Timer/Counter unit 16-bit counter. To ensure that both the high and low bytes are read and written simultaneously when the CPU accesses these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details. Modifying the counter (TCNT1) while the counter is running introduces a risk of missing a compare match between TCNT1 and one of the OCR1x Registers. Writing to the TCNT1 Register blocks (removes) the compare match on the following timer clock for all compare units.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$84</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TCNT1L7</NAME>
          <DESCRIPTION>Timer/Counter1 Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TCNT1L6</NAME>
          <DESCRIPTION>Timer/Counter1 Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TCNT1L5</NAME>
          <DESCRIPTION>Timer/Counter1 Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TCNT1L4</NAME>
          <DESCRIPTION>Timer/Counter1 Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TCNT1L3</NAME>
          <DESCRIPTION>Timer/Counter1 Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TCNT1L2</NAME>
          <DESCRIPTION>Timer/Counter1 Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TCNT1L1</NAME>
          <DESCRIPTION>Timer/Counter1 Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TCNT1L0</NAME>
          <DESCRIPTION>Timer/Counter1 Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_TCNTxLn_BITF</ENUM>
        </BIT0>
      </TCNT1L>
      <OCR1AH>
        <NAME>OCR1AH</NAME>
        <DESCRIPTION>Timer/Counter1 Output Compare Register A High Byte</DESCRIPTION>
        <TEXT>The Output Compare Registers contain a 16-bit value that is continuously compared with the counter value (TCNT1). A match can be used to generate an Output Compare interrupt, or to generate a waveform output on the OC1A pin. The Output Compare Registers are 16-bit in size. To ensure that both the high and low bytes are written simultaneously when the CPU writes to these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$89</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR1AH7</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR1AH6</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR1AH5</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR1AH4</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR1AH3</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR1AH2</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR1AH1</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR1AH0</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_OCRxnH_BITF</ENUM>
        </BIT0>
      </OCR1AH>
      <OCR1AL>
        <NAME>OCR1AL</NAME>
        <DESCRIPTION>Timer/Counter1 Output Compare Register A Low Byte</DESCRIPTION>
        <TEXT>The Output Compare Registers contain a 16-bit value that is continuously compared with the counter value (TCNT1). A match can be used to generate an Output Compare interrupt, or to generate a waveform output on the OC1A pin. The Output Compare Registers are 16-bit in size. To ensure that both the high and low bytes are written simultaneously when the CPU writes to these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$88</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR1AL7</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR1AL6</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR1AL5</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR1AL4</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR1AL3</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR1AL2</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR1AL1</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR1AL0</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_OCRxnL_BITF</ENUM>
        </BIT0>
      </OCR1AL>
      <OCR1BH>
        <NAME>OCR1BH</NAME>
        <DESCRIPTION>Timer/Counter1 Output Compare Register B High Byte</DESCRIPTION>
        <TEXT>The Output Compare Registers contain a 16-bit value that is continuously compared with the counter value (TCNT1). A match can be used to generate an Output Compare interrupt, or to generate a waveform output on the OC1B pin. The Output Compare Registers are 16-bit in size. To ensure that both the high and low bytes are written simultaneously when the CPU writes to these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$8B</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR1BH7</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR1BH6</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR1BH5</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR1BH4</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR1BH3</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR1BH2</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR1BH1</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR1BH0</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_OCRxnH_BITF</ENUM>
        </BIT0>
      </OCR1BH>
      <OCR1BL>
        <NAME>OCR1BL</NAME>
        <DESCRIPTION>Timer/Counter1 Output Compare Register B Low Byte</DESCRIPTION>
        <TEXT>The Output Compare Registers contain a 16-bit value that is continuously compared with the counter value (TCNT1). A match can be used to generate an Output Compare interrupt, or to generate a waveform output on the OC1B pin. The Output Compare Registers are 16-bit in size. To ensure that both the high and low bytes are written simultaneously when the CPU writes to these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$8A</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR1BL7</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR1BL6</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR1BL5</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR1BL4</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR1BL3</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR1BL2</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR1BL1</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR1BL0</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_OCRxnL_BITF</ENUM>
        </BIT0>
      </OCR1BL>
      <OCR1CH>
        <NAME>OCR1CH</NAME>
        <DESCRIPTION>Timer/Counter1 Output Compare Register C High Byte</DESCRIPTION>
        <TEXT>The Output Compare Registers contain a 16-bit value that is continuously compared with the counter value (TCNT1). A match can be used to generate an Output Compare interrupt, or to generate a waveform output on the OC1C pin. The Output Compare Registers are 16-bit in size. To ensure that both the high and low bytes are written simultaneously when the CPU writes to these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$8D</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR1CH7</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR1CH6</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR1CH5</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR1CH4</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR1CH3</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR1CH2</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR1CH1</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR1CH0</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_OCRxnH_BITF</ENUM>
        </BIT0>
      </OCR1CH>
      <OCR1CL>
        <NAME>OCR1CL</NAME>
        <DESCRIPTION>Timer/Counter1 Output Compare Register C Low Byte</DESCRIPTION>
        <TEXT>The Output Compare Registers contain a 16-bit value that is continuously compared with the counter value (TCNT1). A match can be used to generate an Output Compare interrupt, or to generate a waveform output on the OC1C pin. The Output Compare Registers are 16-bit in size. To ensure that both the high and low bytes are written simultaneously when the CPU writes to these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$8C</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR1CL7</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR1CL6</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR1CL5</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR1CL4</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR1CL3</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR1CL2</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR1CL1</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR1CL0</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_OCRxnL_BITF</ENUM>
        </BIT0>
      </OCR1CL>
      <ICR1H>
        <NAME>ICR1H</NAME>
        <DESCRIPTION>Timer/Counter1 Input Capture Register High Byte</DESCRIPTION>
        <TEXT>The Input Capture Register is updated with the counter (TCNT1) value each time an event occurs on the ICP1 pin or on the Analog Comparator output. The Input Capture Register can be used for defining the counter TOP value. The Input Capture Register is 16-bit in size. To ensure that both the high and low bytes are read simultaneously when the CPU accesses these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$87</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>ICR1H7</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ICR1H6</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ICR1H5</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ICR1H4</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ICR1H3</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ICR1H2</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ICR1H1</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ICR1H0</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_ICRxnH_BITF</ENUM>
        </BIT0>
      </ICR1H>
      <ICR1L>
        <NAME>ICR1L</NAME>
        <DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte</DESCRIPTION>
        <TEXT>The Input Capture Register is updated with the counter (TCNT1) value each time an event occurs on the ICP1 pin or on the Analog Comparator output. The Input Capture Register can be used for defining the counter TOP value. The Input Capture Register is 16-bit in size. To ensure that both the high and low bytes are read simultaneously when the CPU accesses these registers, the access is performed using an 8-bit temporary High Byte Register (TEMP). This temporary register is shared by all the other 16-bit registers. See section "Accessing 16-bit Registers" for details.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$86</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>ICR1L7</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ICR1L6</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ICR1L5</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ICR1L4</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ICR1L3</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ICR1L2</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ICR1L1</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ICR1L0</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TC1_ICRxnL_BITF</ENUM>
        </BIT0>
      </ICR1L>
      <TIMSK1>
        <NAME>TIMSK1</NAME>
        <DESCRIPTION>Timer/Counter1 Interrupt Mask Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$6F</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ICIE1</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Interrupt Enable</DESCRIPTION>
          <TEXT>When this bit is written to one, and the I-flag in the Status Register is set (interrupts globally enabled), the Timer/Counter1 Input Capture interrupt is enabled. The corresponding Interrupt Vector is executed when the ICF1 Flag, located in TIFR1, is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCIE1C</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare C Match Interrupt Enable</DESCRIPTION>
          <TEXT>When this bit is written to one, and the I-flag in the Status Register is set (interrupts globally enabled), the Timer/Counter1 Output Compare C Match interrupt is enabled. The corresponding Interrupt Vector is executed when the OCF1C Flag, located in TIFR1, is set.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCIE1B</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare B Match Interrupt Enable</DESCRIPTION>
          <TEXT>When this bit is written to one, and the I-flag in the Status Register is set (interrupts globally enabled), the Timer/Counter1 Output Compare B Match interrupt is enabled. The corresponding Interrupt Vector is executed when the OCF1B Flag, located in TIFR1, is set.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCIE1A</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare A Match Interrupt Enable</DESCRIPTION>
          <TEXT>When this bit is written to one, and the I-flag in the Status Register is set (interrupts globally enabled), the Timer/Counter1 Output Compare A Match interrupt is enabled. The corresponding Interrupt Vector is executed when the OCF1A Flag, located in TIFR1, is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TOIE1</NAME>
          <DESCRIPTION>Timer/Counter1 Overflow Interrupt Enable</DESCRIPTION>
          <TEXT>When this bit is written to one, and the I-flag in the Status Register is set (interrupts globally enabled), the Timer/Counter1 Overflow interrupt is enabled. The corresponding Interrupt Vector is executed when the TOV1 Flag, located in TIFR1, is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TIMSK1>
      <TIFR1>
        <NAME>TIFR1</NAME>
        <DESCRIPTION>Timer/Counter1 Interrupt Flag Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$16</IO_ADDR>
        <MEM_ADDR>$36</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ICF1</NAME>
          <DESCRIPTION>Timer/Counter1 Input Capture Flag</DESCRIPTION>
          <TEXT>This flag is set when a capture event occurs on the ICP1 pin. When the Input Capture Register (ICR1) is set by the WGM13:0 to be used as the TOP value, the ICF1 Flag is set when the counter reaches the TOP value. ICF1 is automatically cleared when the Input Capture Interrupt Vector is executed. Alternatively, ICF1 can be cleared by writing a logic one to its bit location.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCF1C</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare C Match Flag</DESCRIPTION>
          <TEXT>This flag is set in the timer clock cycle after the counter (TCNT1) value matches the Output Compare Register C (OCR1C). Note that a Forced Output Compare (FOC1C) strobe will not set the OCF1C Flag. OCF1C is automatically cleared when the Output Compare Match C Interrupt Vector is executed. Alternatively, OCF1C can be cleared by writing a logic one to its bit location.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCF1B</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare B Match Flag</DESCRIPTION>
          <TEXT>This flag is set in the timer clock cycle after the counter (TCNT1) value matches the Output Compare Register B (OCR1B). Note that a Forced Output Compare (FOC1B) strobe will not set the OCF1B Flag. OCF1B is automatically cleared when the Output Compare Match B Interrupt Vector is executed. Alternatively, OCF1B can be cleared by writing a logic one to its bit location.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCF1A</NAME>
          <DESCRIPTION>Timer/Counter1 Output Compare A Match Flag</DESCRIPTION>
          <TEXT>This flag is set in the timer clock cycle after the counter (TCNT1) value matches the Output Compare Register A (OCR1A). Note that a Forced Output Compare (FOC1A) strobe will not set the OCF1A Flag. OCF1A is automatically cleared when the Output Compare Match A Interrupt Vector is executed. Alternatively, OCF1A can be cleared by writing a logic one to its bit location.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TOV1</NAME>
          <DESCRIPTION>Timer/Counter1 Overflow Flag</DESCRIPTION>
          <TEXT>The setting of this flag is dependent of the WGM13:0 bits setting of the Timer/Counter1 Control Register. In Normal and CTC modes, the TOV1 Flag is set when the timer overflows.  TOV1 is automatically cleared when the Timer/Counter1 Overflow Interrupt Vector is executed. Alternatively, TOV1 can be cleared by writing a logic one to its bit location.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TIFR1>
    </TIMER_COUNTER_1>
    <TRX24>
      <LIST>[AES_CTRL:AES_STATUS:AES_STATE:AES_KEY:TRX_STATUS:TRX_STATE:TRX_CTRL_0:TRX_CTRL_1:PHY_TX_PWR:PHY_RSSI:PHY_ED_LEVEL:PHY_CC_CCA:CCA_THRES:RX_CTRL:SFD_VALUE:TRX_CTRL_2:ANT_DIV:IRQ_MASK:IRQ_STATUS:VREG_CTRL:BATMON:XOSC_CTRL:RX_SYN:XAH_CTRL_1:FTN_CTRL:PLL_CF:PLL_DCU:PART_NUM:VERSION_NUM:MAN_ID_0:MAN_ID_1:SHORT_ADDR_0:SHORT_ADDR_1:PAN_ID_0:PAN_ID_1:IEEE_ADDR_0:IEEE_ADDR_1:IEEE_ADDR_2:IEEE_ADDR_3:IEEE_ADDR_4:IEEE_ADDR_5:IEEE_ADDR_6:IEEE_ADDR_7:XAH_CTRL_0:CSMA_SEED_0:CSMA_SEED_1:CSMA_BE:TST_CTRL_DIGI:TST_RX_LENGTH:TRXFBST:TRXFBEND]</LIST>
      <LINK/>
      <ICON>io_trx24.bmp</ICON>
      <ID/>
      <TEXT/>
      <AES_CTRL>
        <NAME>AES_CTRL</NAME>
        <DESCRIPTION>AES Control Register</DESCRIPTION>
        <TEXT>This register controls the operation of the security module. Do not access this register during AES operation to read the AES core status. A read or write access to the register stops the ongoing processing. To read the AES status use bit AES_DONE of register AES_STATUS. Note that the AES_CTRL register is cleared when entering the radio transceiver SLEEP state.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$13C</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>AES_REQUEST</NAME>
          <DESCRIPTION>Request AES Operation.</DESCRIPTION>
          <TEXT>A write access with AES_REQUEST = 1 initiates the AES operation.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. The result of a read access is undefined. The register bit must always be written with the reset value.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>AES_MODE</NAME>
          <DESCRIPTION>Set AES Operation Mode</DESCRIPTION>
          <TEXT>This register bit sets the AES operation mode (ECB/CBC Mode).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>AES_MODE_BITF</ENUM>
        </BIT5>
        <BIT4>
          <NAME>Res</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. The result of a read access is undefined. The register bit must always be written with the reset value.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>AES_DIR</NAME>
          <DESCRIPTION>Set AES Operation Direction</DESCRIPTION>
          <TEXT>This register bit sets the AES operation direction to either encryption or decryption.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>AES_DIRECTION_BITF</ENUM>
        </BIT3>
        <BIT2>
          <NAME>AES_IM</NAME>
          <DESCRIPTION>AES Interrupt Enable</DESCRIPTION>
          <TEXT>This register bit is used to enable the AES interrupt.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>These bits are reserved for future use. The result of a read access is undefined. The register bits must always be written with the reset value.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>These bits are reserved for future use. The result of a read access is undefined. The register bits must always be written with the reset value.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </AES_CTRL>
      <AES_STATUS>
        <NAME>AES_STATUS</NAME>
        <DESCRIPTION>AES Status Register</DESCRIPTION>
        <TEXT>This read-only register signals the status of the security module and operation. Note that the AES_STATUS register is cleared when entering the radio transceiver SLEEP state.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$13D</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>AES_ER</NAME>
          <DESCRIPTION>AES Operation Finished with Error</DESCRIPTION>
          <TEXT>This register bit indicates an error during AES module run. An error occurs if accessing AES_CTRL while an AES operation is running or if AES_KEY or AES_STATE Memory is not loaded completely or less than 16 Byte read from AES_STATE.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res5</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>Res4</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res3</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>Res2</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>AES_DONE</NAME>
          <DESCRIPTION>AES Operation Finished with Success</DESCRIPTION>
          <TEXT>This register bit indicates a successfully finished operation of the AES module.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </AES_STATUS>
      <AES_STATE>
        <NAME>AES_STATE</NAME>
        <DESCRIPTION>AES Plain and Cipher Text Buffer Register</DESCRIPTION>
        <TEXT>The AES_STATE register accesses a 16 byte internal data buffer. The buffer is accessed by reading or writing 16 times to the same address location (AES_STATE). If the buffer is not completely read or written an error occurs when an AES operation is started. Note that the AES_STATE register is cleared when entering the radio transceiver SLEEP state.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$13E</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>AES_STATE7</NAME>
          <DESCRIPTION>AES Plain and Cipher Text Buffer</DESCRIPTION>
          <TEXT>These bits represent the data buffer for the AES operation.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>AES_STATE6</NAME>
          <DESCRIPTION>AES Plain and Cipher Text Buffer</DESCRIPTION>
          <TEXT>These bits represent the data buffer for the AES operation.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>AES_STATE5</NAME>
          <DESCRIPTION>AES Plain and Cipher Text Buffer</DESCRIPTION>
          <TEXT>These bits represent the data buffer for the AES operation.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>AES_STATE4</NAME>
          <DESCRIPTION>AES Plain and Cipher Text Buffer</DESCRIPTION>
          <TEXT>These bits represent the data buffer for the AES operation.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>AES_STATE3</NAME>
          <DESCRIPTION>AES Plain and Cipher Text Buffer</DESCRIPTION>
          <TEXT>These bits represent the data buffer for the AES operation.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>AES_STATE2</NAME>
          <DESCRIPTION>AES Plain and Cipher Text Buffer</DESCRIPTION>
          <TEXT>These bits represent the data buffer for the AES operation.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>AES_STATE1</NAME>
          <DESCRIPTION>AES Plain and Cipher Text Buffer</DESCRIPTION>
          <TEXT>These bits represent the data buffer for the AES operation.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>AES_STATE0</NAME>
          <DESCRIPTION>AES Plain and Cipher Text Buffer</DESCRIPTION>
          <TEXT>These bits represent the data buffer for the AES operation.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </AES_STATE>
      <AES_KEY>
        <NAME>AES_KEY</NAME>
        <DESCRIPTION>AES Encryption and Decryption Key Buffer Register</DESCRIPTION>
        <TEXT>The AES key register accesses a 128 Bit internal buffer that holds the Encryption or Decryption Key. The AES_KEY buffer is a 16 Byte buffer. The buffer is accessed by reading or writing 16 fold to the same address location (AES_KEY). A read access to registers AES_KEY returns the last round key of the preceding security operation. This is the key that is required for the corresponding ECB decryption operation after an ECB encryption operation. However, the initial AES key written to the security module in advance of an AES run is not modified during an AES operation. This initial key is used for the next AES run even if it cannot be read from AES_KEY register. Note that the AES_KEY register is cleared when entering the radio transceiver SLEEP state.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$13F</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>AES_KEY7</NAME>
          <DESCRIPTION>AES Encryption/Decryption Key Buffer</DESCRIPTION>
          <TEXT>These bits represent the data buffer for the AES Encryption/Decryption key.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>AES_KEY6</NAME>
          <DESCRIPTION>AES Encryption/Decryption Key Buffer</DESCRIPTION>
          <TEXT>These bits represent the data buffer for the AES Encryption/Decryption key.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>AES_KEY5</NAME>
          <DESCRIPTION>AES Encryption/Decryption Key Buffer</DESCRIPTION>
          <TEXT>These bits represent the data buffer for the AES Encryption/Decryption key.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>AES_KEY4</NAME>
          <DESCRIPTION>AES Encryption/Decryption Key Buffer</DESCRIPTION>
          <TEXT>These bits represent the data buffer for the AES Encryption/Decryption key.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>AES_KEY3</NAME>
          <DESCRIPTION>AES Encryption/Decryption Key Buffer</DESCRIPTION>
          <TEXT>These bits represent the data buffer for the AES Encryption/Decryption key.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>AES_KEY2</NAME>
          <DESCRIPTION>AES Encryption/Decryption Key Buffer</DESCRIPTION>
          <TEXT>These bits represent the data buffer for the AES Encryption/Decryption key.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>AES_KEY1</NAME>
          <DESCRIPTION>AES Encryption/Decryption Key Buffer</DESCRIPTION>
          <TEXT>These bits represent the data buffer for the AES Encryption/Decryption key.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>AES_KEY0</NAME>
          <DESCRIPTION>AES Encryption/Decryption Key Buffer</DESCRIPTION>
          <TEXT>These bits represent the data buffer for the AES Encryption/Decryption key.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </AES_KEY>
      <TRX_STATUS>
        <NAME>TRX_STATUS</NAME>
        <DESCRIPTION>Transceiver Status Register</DESCRIPTION>
        <TEXT>This read-only register signals the present state of the radio transceiver as well as the status of the CCA operation. A state change is initiated by writing a state transition command to the TRX_CMD bits of register TRX_STATE. The register is not accessible in SLEEP state.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$141</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>CCA_DONE</NAME>
          <DESCRIPTION>CCA Algorithm Status</DESCRIPTION>
          <TEXT>This bit indicates if a CCA request is completed. This is also indicated by a TRX24_CCA_ED_DONE interrupt. Note that register bit CCA_DONE is cleared in response to a CCA_REQUEST.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>CCA_DONE_bitf</ENUM>
        </BIT7>
        <BIT6>
          <NAME>CCA_STATUS</NAME>
          <DESCRIPTION>CCA Status Result</DESCRIPTION>
          <TEXT>The result of the CCA measurement is available in register bit CCA_STATUS after a CCA request is completed. Note that register bit CCA_STATUS is cleared in response to a CCA_REQUEST.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>CCA_STATUS_bitf</ENUM>
        </BIT6>
        <BIT5>
          <NAME>TST_STATUS</NAME>
          <DESCRIPTION>Test mode status</DESCRIPTION>
          <TEXT>This bit is reserved for internal use. It indicates the status of the test mode.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TST_STATUS_bitf</ENUM>
        </BIT5>
        <BIT4>
          <NAME>TRX_STATUS4</NAME>
          <DESCRIPTION>Transceiver Main Status</DESCRIPTION>
          <TEXT>The register bits TRX_STATUS signal the current radio transceiver status.  Do not try to initiate a further state change while the radio transceiver is in STATE_TRANSITION_IN_PROGRESS state. Values not listed in the following table are reserved.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TRX_STATUS3</NAME>
          <DESCRIPTION>Transceiver Main Status</DESCRIPTION>
          <TEXT>The register bits TRX_STATUS signal the current radio transceiver status.  Do not try to initiate a further state change while the radio transceiver is in STATE_TRANSITION_IN_PROGRESS state. Values not listed in the following table are reserved.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TRX_STATUS2</NAME>
          <DESCRIPTION>Transceiver Main Status</DESCRIPTION>
          <TEXT>The register bits TRX_STATUS signal the current radio transceiver status.  Do not try to initiate a further state change while the radio transceiver is in STATE_TRANSITION_IN_PROGRESS state. Values not listed in the following table are reserved.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TRX_STATUS1</NAME>
          <DESCRIPTION>Transceiver Main Status</DESCRIPTION>
          <TEXT>The register bits TRX_STATUS signal the current radio transceiver status.  Do not try to initiate a further state change while the radio transceiver is in STATE_TRANSITION_IN_PROGRESS state. Values not listed in the following table are reserved.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TRX_STATUS0</NAME>
          <DESCRIPTION>Transceiver Main Status</DESCRIPTION>
          <TEXT>The register bits TRX_STATUS signal the current radio transceiver status.  Do not try to initiate a further state change while the radio transceiver is in STATE_TRANSITION_IN_PROGRESS state. Values not listed in the following table are reserved.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TRX_STATUS_bitf</ENUM>
        </BIT0>
      </TRX_STATUS>
      <TRX_STATE>
        <NAME>TRX_STATE</NAME>
        <DESCRIPTION>Transceiver State Control Register</DESCRIPTION>
        <TEXT>The states of the radio transceiver are controlled via register TRX_STATE using register bits TRX_CMD. The read-only register bits TRAC_STATUS indicate the status or result of an Extended Operating Mode transaction. A successful state transition shall be confirmed by reading register bits TRX_STATUS. This register is used for both Basic and Extended Operating Mode.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$142</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>TRAC_STATUS2</NAME>
          <DESCRIPTION>Transaction Status</DESCRIPTION>
          <TEXT>The status of the RX_AACK and TX_ARET procedure is indicated by register bits TRAC_STATUS. TRAC_STATUS is only valid in Extended Operating Modes. Details of the algorithm and a description of the status information are given in the RX_AACK_ON and TX_ARET_ON sections of the data-sheet. Even though the reset value for register bits TRAC_STATUS is 0, the RX_AACK and TX_ARET procedures set the register bits to TRAC_STATUS = 7 (INVALID) when it is started. Not all status values are used in both RX_AACK and TX_ARET transactions. In TX_ARET the status SUCCESS_DATA_PENDING indicates a successful reception of an ACK frame with frame pending bit set to 1. In RX_AACK the status SUCCESS_WAIT_FOR_ACK indicates an ACK frame is about to sent in RX_AACK slotted acknowledgment. Slotted acknowledgment operation must be enabled with the SLOTTED_OPERATION bit of register XAH_CTRL_0. The application software must set the SLPTR bit of register TRXPWR at the next back-off slot boundary in order to initiate a transmission of the ACK frame. For details refer to IEEE 802.15.4-2006, chapter 5.5.4.1. Values not listed in the following table are reserved.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TRAC_STATUS1</NAME>
          <DESCRIPTION>Transaction Status</DESCRIPTION>
          <TEXT>The status of the RX_AACK and TX_ARET procedure is indicated by register bits TRAC_STATUS. TRAC_STATUS is only valid in Extended Operating Modes. Details of the algorithm and a description of the status information are given in the RX_AACK_ON and TX_ARET_ON sections of the data-sheet. Even though the reset value for register bits TRAC_STATUS is 0, the RX_AACK and TX_ARET procedures set the register bits to TRAC_STATUS = 7 (INVALID) when it is started. Not all status values are used in both RX_AACK and TX_ARET transactions. In TX_ARET the status SUCCESS_DATA_PENDING indicates a successful reception of an ACK frame with frame pending bit set to 1. In RX_AACK the status SUCCESS_WAIT_FOR_ACK indicates an ACK frame is about to sent in RX_AACK slotted acknowledgment. Slotted acknowledgment operation must be enabled with the SLOTTED_OPERATION bit of register XAH_CTRL_0. The application software must set the SLPTR bit of register TRXPWR at the next back-off slot boundary in order to initiate a transmission of the ACK frame. For details refer to IEEE 802.15.4-2006, chapter 5.5.4.1. Values not listed in the following table are reserved.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TRAC_STATUS0</NAME>
          <DESCRIPTION>Transaction Status</DESCRIPTION>
          <TEXT>The status of the RX_AACK and TX_ARET procedure is indicated by register bits TRAC_STATUS. TRAC_STATUS is only valid in Extended Operating Modes. Details of the algorithm and a description of the status information are given in the RX_AACK_ON and TX_ARET_ON sections of the data-sheet. Even though the reset value for register bits TRAC_STATUS is 0, the RX_AACK and TX_ARET procedures set the register bits to TRAC_STATUS = 7 (INVALID) when it is started. Not all status values are used in both RX_AACK and TX_ARET transactions. In TX_ARET the status SUCCESS_DATA_PENDING indicates a successful reception of an ACK frame with frame pending bit set to 1. In RX_AACK the status SUCCESS_WAIT_FOR_ACK indicates an ACK frame is about to sent in RX_AACK slotted acknowledgment. Slotted acknowledgment operation must be enabled with the SLOTTED_OPERATION bit of register XAH_CTRL_0. The application software must set the SLPTR bit of register TRXPWR at the next back-off slot boundary in order to initiate a transmission of the ACK frame. For details refer to IEEE 802.15.4-2006, chapter 5.5.4.1. Values not listed in the following table are reserved.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TRAC_STATUS_bitf</ENUM>
        </BIT5>
        <BIT4>
          <NAME>TRX_CMD4</NAME>
          <DESCRIPTION>State Control Command</DESCRIPTION>
          <TEXT>A write access to register bits TRX_CMD initiates a state transition of the radio transceiver towards the new state as defined by the write access. Do not try to initiate a further state change while the radio transceiver is in STATE_TRANSITION_IN_PROGRESS state (see TRX_STATUS register). FORCE_PLL_ON is not valid for the SLEEP state as well as during STATE_TRANSITION_IN_PROGRESS towards the SLEEP state. Values not listed in the following table are reserved and mapped to NOP.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TRX_CMD3</NAME>
          <DESCRIPTION>State Control Command</DESCRIPTION>
          <TEXT>A write access to register bits TRX_CMD initiates a state transition of the radio transceiver towards the new state as defined by the write access. Do not try to initiate a further state change while the radio transceiver is in STATE_TRANSITION_IN_PROGRESS state (see TRX_STATUS register). FORCE_PLL_ON is not valid for the SLEEP state as well as during STATE_TRANSITION_IN_PROGRESS towards the SLEEP state. Values not listed in the following table are reserved and mapped to NOP.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TRX_CMD2</NAME>
          <DESCRIPTION>State Control Command</DESCRIPTION>
          <TEXT>A write access to register bits TRX_CMD initiates a state transition of the radio transceiver towards the new state as defined by the write access. Do not try to initiate a further state change while the radio transceiver is in STATE_TRANSITION_IN_PROGRESS state (see TRX_STATUS register). FORCE_PLL_ON is not valid for the SLEEP state as well as during STATE_TRANSITION_IN_PROGRESS towards the SLEEP state. Values not listed in the following table are reserved and mapped to NOP.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TRX_CMD1</NAME>
          <DESCRIPTION>State Control Command</DESCRIPTION>
          <TEXT>A write access to register bits TRX_CMD initiates a state transition of the radio transceiver towards the new state as defined by the write access. Do not try to initiate a further state change while the radio transceiver is in STATE_TRANSITION_IN_PROGRESS state (see TRX_STATUS register). FORCE_PLL_ON is not valid for the SLEEP state as well as during STATE_TRANSITION_IN_PROGRESS towards the SLEEP state. Values not listed in the following table are reserved and mapped to NOP.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TRX_CMD0</NAME>
          <DESCRIPTION>State Control Command</DESCRIPTION>
          <TEXT>A write access to register bits TRX_CMD initiates a state transition of the radio transceiver towards the new state as defined by the write access. Do not try to initiate a further state change while the radio transceiver is in STATE_TRANSITION_IN_PROGRESS state (see TRX_STATUS register). FORCE_PLL_ON is not valid for the SLEEP state as well as during STATE_TRANSITION_IN_PROGRESS towards the SLEEP state. Values not listed in the following table are reserved and mapped to NOP.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TRX_CMD_bitf</ENUM>
        </BIT0>
      </TRX_STATE>
      <TRX_CTRL_0>
        <NAME>TRX_CTRL_0</NAME>
        <DESCRIPTION>Reserved</DESCRIPTION>
        <TEXT>This register is reserved for future use.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$143</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>Res7</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res6</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>Res5</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res4</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>Res3</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>Res2</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT0>
      </TRX_CTRL_0>
      <TRX_CTRL_1>
        <NAME>TRX_CTRL_1</NAME>
        <DESCRIPTION>Transceiver Control Register 1</DESCRIPTION>
        <TEXT>The TRX_CTRL_1 register is a multi purpose register to control various operating modes and settings of the radio transceiver.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$144</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>PA_EXT_EN</NAME>
          <DESCRIPTION>External PA support enable</DESCRIPTION>
          <TEXT>This register bit enables pin DIG3 and pin DIG4 to indicate the transmit state of the radio transceiver. The control of the external RF front-end is disabled when this bit is 0. Both pins DIG3 and DIG4 are then low. The control of the external front-end is enabled when this bit is 1. DIG3 and DIG4 then indicate the state of the radio transceiver. Pin DIG3 is high and pin DIG4 is low in the state TX_BUSY. In all other states pin DIG3 is low and pin DIG4 is high. It is recommended to set PA_EXT_EN=1 only in receive or transmit states to reduce the power consumption or avoid leakage current of external RF switches or other building blocks especially during SLEEP state.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>IRQ_2_EXT_EN</NAME>
          <DESCRIPTION>Connect Frame Start IRQ to TC1</DESCRIPTION>
          <TEXT>When this bit is set to one the capture input of Timer/Counter 1 is connected to the RX frame start signal and pin DIG2 becomes an output, driving the RX frame start signal. Antenna Diversity RF switch control (ANT_EXT_SW_EN=1) shall not be used at the same time, because it shares the same device pin. The function IRQ_2_EXT_EN is available for alternate frame time stamping using Timer/Counter 1. In general the preferred method for frame time stamping is using the symbol counter.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TX_AUTO_CRC_ON</NAME>
          <DESCRIPTION>Enable Automatic CRC Calculation</DESCRIPTION>
          <TEXT>This register bit controls the automatic FCS generation for TX operations. The automatic FCS algorithm is performed autonomously by the radio transceiver if register bit TX_AUTO_CRC_ON=1.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res4</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>Res3</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>Res2</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TRX_CTRL_1>
      <PHY_TX_PWR>
        <NAME>PHY_TX_PWR</NAME>
        <DESCRIPTION>Transceiver Transmit Power Control Register</DESCRIPTION>
        <TEXT>This register controls the output power and the ramping of the transmitter.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$145</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>PA_BUF_LT1</NAME>
          <DESCRIPTION>Power Amplifier Buffer Lead Time</DESCRIPTION>
          <TEXT>These register bits control the enable lead time of the internal PA buffer relative to the enable time of the internal PA. This time is further used to derive a control signal for an external RF front-end to switch between receive and transmit.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PA_BUF_LT0</NAME>
          <DESCRIPTION>Power Amplifier Buffer Lead Time</DESCRIPTION>
          <TEXT>These register bits control the enable lead time of the internal PA buffer relative to the enable time of the internal PA. This time is further used to derive a control signal for an external RF front-end to switch between receive and transmit.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
          <ENUM>PA_BUF_LT_bitf</ENUM>
        </BIT6>
        <BIT5>
          <NAME>PA_LT1</NAME>
          <DESCRIPTION>Power Amplifier Lead Time</DESCRIPTION>
          <TEXT>These register bits control the enable lead time of the internal power amplifier relative to the beginning of the transmitted frame (SHR).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PA_LT0</NAME>
          <DESCRIPTION>Power Amplifier Lead Time</DESCRIPTION>
          <TEXT>These register bits control the enable lead time of the internal power amplifier relative to the beginning of the transmitted frame (SHR).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>PA_LT_bitf</ENUM>
        </BIT4>
        <BIT3>
          <NAME>TX_PWR3</NAME>
          <DESCRIPTION>Transmit Power Setting</DESCRIPTION>
          <TEXT>These register bits determine the TX output power of the radio transceiver.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TX_PWR2</NAME>
          <DESCRIPTION>Transmit Power Setting</DESCRIPTION>
          <TEXT>These register bits determine the TX output power of the radio transceiver.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TX_PWR1</NAME>
          <DESCRIPTION>Transmit Power Setting</DESCRIPTION>
          <TEXT>These register bits determine the TX output power of the radio transceiver.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TX_PWR0</NAME>
          <DESCRIPTION>Transmit Power Setting</DESCRIPTION>
          <TEXT>These register bits determine the TX output power of the radio transceiver.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TX_PWR_bitf</ENUM>
        </BIT0>
      </PHY_TX_PWR>
      <PHY_RSSI>
        <NAME>PHY_RSSI</NAME>
        <DESCRIPTION>Receiver Signal Strength Indicator Register</DESCRIPTION>
        <TEXT>The PHY_RSSI register is a multi purpose register that indicates FCS validity, provides random numbers and shows the current RSSI value.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$146</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>RX_CRC_VALID</NAME>
          <DESCRIPTION>Received Frame CRC Status</DESCRIPTION>
          <TEXT>Reading this register bit indicates whether the last received frame has a valid FCS or not. The register bit is updated when issuing a TRX24_RX_END interrupt and remains valid until the next TRX24_RX_END interrupt is issued, caused by a new frame reception.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>RX_CRC_VALID_bitf</ENUM>
        </BIT7>
        <BIT6>
          <NAME>RND_VALUE1</NAME>
          <DESCRIPTION>Random Value</DESCRIPTION>
          <TEXT>
					A 2-bit random value can be retrieved by reading register bits RND_VALUE. The value can be used for random numbers for security applications. Note that the radio transceiver shall be in Basic Operating Mode receive state. The values are updated every 1 &#xB5;s.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>RND_VALUE0</NAME>
          <DESCRIPTION>Random Value</DESCRIPTION>
          <TEXT>
					A 2-bit random value can be retrieved by reading register bits RND_VALUE. The value can be used for random numbers for security applications. Note that the radio transceiver shall be in Basic Operating Mode receive state. The values are updated every 1 &#xB5;s.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>RSSI4</NAME>
          <DESCRIPTION>Receiver Signal Strength Indicator</DESCRIPTION>
          <TEXT>The result of the automated RSSI measurement is stored in these register bits. The value is updated every 2&#xB5;s in receive states. The read value is a number between 0 and 28 indicating the received signal strength as a linear curve on a logarithmic input power scale (dBm) with a resolution of 3 dB. A RSSI value of 0 indicates a RF input power lower than RSSI_BASE_VAL (-90 dBm). A value of 28 marks a power higher or equal to -10 dBm.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>RSSI3</NAME>
          <DESCRIPTION>Receiver Signal Strength Indicator</DESCRIPTION>
          <TEXT>The result of the automated RSSI measurement is stored in these register bits. The value is updated every 2&#xB5;s in receive states. The read value is a number between 0 and 28 indicating the received signal strength as a linear curve on a logarithmic input power scale (dBm) with a resolution of 3 dB. A RSSI value of 0 indicates a RF input power lower than RSSI_BASE_VAL (-90 dBm). A value of 28 marks a power higher or equal to -10 dBm.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>RSSI2</NAME>
          <DESCRIPTION>Receiver Signal Strength Indicator</DESCRIPTION>
          <TEXT>The result of the automated RSSI measurement is stored in these register bits. The value is updated every 2&#xB5;s in receive states. The read value is a number between 0 and 28 indicating the received signal strength as a linear curve on a logarithmic input power scale (dBm) with a resolution of 3 dB. A RSSI value of 0 indicates a RF input power lower than RSSI_BASE_VAL (-90 dBm). A value of 28 marks a power higher or equal to -10 dBm.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>RSSI1</NAME>
          <DESCRIPTION>Receiver Signal Strength Indicator</DESCRIPTION>
          <TEXT>The result of the automated RSSI measurement is stored in these register bits. The value is updated every 2&#xB5;s in receive states. The read value is a number between 0 and 28 indicating the received signal strength as a linear curve on a logarithmic input power scale (dBm) with a resolution of 3 dB. A RSSI value of 0 indicates a RF input power lower than RSSI_BASE_VAL (-90 dBm). A value of 28 marks a power higher or equal to -10 dBm.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>RSSI0</NAME>
          <DESCRIPTION>Receiver Signal Strength Indicator</DESCRIPTION>
          <TEXT>The result of the automated RSSI measurement is stored in these register bits. The value is updated every 2&#xB5;s in receive states. The read value is a number between 0 and 28 indicating the received signal strength as a linear curve on a logarithmic input power scale (dBm) with a resolution of 3 dB. A RSSI value of 0 indicates a RF input power lower than RSSI_BASE_VAL (-90 dBm). A value of 28 marks a power higher or equal to -10 dBm.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>RSSI_VALUE_BITF</ENUM>
        </BIT0>
      </PHY_RSSI>
      <PHY_ED_LEVEL>
        <NAME>PHY_ED_LEVEL</NAME>
        <DESCRIPTION>Transceiver Energy Detection Level Register</DESCRIPTION>
        <TEXT>This register contains the result of an Energy Detection measurement.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$147</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>ED_LEVEL7</NAME>
          <DESCRIPTION>Energy Detection Level</DESCRIPTION>
          <TEXT>The minimum ED value (ED_LEVEL = 0) indicates a receiver power less than or equal to RSSI_BASE_VAL. The range is 84 dB with a resolution of 1 dB and an absolute accuracy of &#xB1;5 dB. A manual ED measurement can be initiated by a write access to this register. A value of 0xFF signals that no measurement has yet been started (reset value). The measurement duration is 8 symbol periods (128 &#xB5;s) for a data rate of 250 kb/s. For High Data Rate Modes the automated measurement duration is reduced to 32 &#xB5;s. For manually initiated ED measurements in these modes the measurement period is still 128 &#xB5;s as long as the receiver is in RX_ON state. A value other than 0xFF indicates the result of the last ED measurement.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ED_LEVEL6</NAME>
          <DESCRIPTION>Energy Detection Level</DESCRIPTION>
          <TEXT>The minimum ED value (ED_LEVEL = 0) indicates a receiver power less than or equal to RSSI_BASE_VAL. The range is 84 dB with a resolution of 1 dB and an absolute accuracy of &#xB1;5 dB. A manual ED measurement can be initiated by a write access to this register. A value of 0xFF signals that no measurement has yet been started (reset value). The measurement duration is 8 symbol periods (128 &#xB5;s) for a data rate of 250 kb/s. For High Data Rate Modes the automated measurement duration is reduced to 32 &#xB5;s. For manually initiated ED measurements in these modes the measurement period is still 128 &#xB5;s as long as the receiver is in RX_ON state. A value other than 0xFF indicates the result of the last ED measurement.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ED_LEVEL5</NAME>
          <DESCRIPTION>Energy Detection Level</DESCRIPTION>
          <TEXT>The minimum ED value (ED_LEVEL = 0) indicates a receiver power less than or equal to RSSI_BASE_VAL. The range is 84 dB with a resolution of 1 dB and an absolute accuracy of &#xB1;5 dB. A manual ED measurement can be initiated by a write access to this register. A value of 0xFF signals that no measurement has yet been started (reset value). The measurement duration is 8 symbol periods (128 &#xB5;s) for a data rate of 250 kb/s. For High Data Rate Modes the automated measurement duration is reduced to 32 &#xB5;s. For manually initiated ED measurements in these modes the measurement period is still 128 &#xB5;s as long as the receiver is in RX_ON state. A value other than 0xFF indicates the result of the last ED measurement.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ED_LEVEL4</NAME>
          <DESCRIPTION>Energy Detection Level</DESCRIPTION>
          <TEXT>The minimum ED value (ED_LEVEL = 0) indicates a receiver power less than or equal to RSSI_BASE_VAL. The range is 84 dB with a resolution of 1 dB and an absolute accuracy of &#xB1;5 dB. A manual ED measurement can be initiated by a write access to this register. A value of 0xFF signals that no measurement has yet been started (reset value). The measurement duration is 8 symbol periods (128 &#xB5;s) for a data rate of 250 kb/s. For High Data Rate Modes the automated measurement duration is reduced to 32 &#xB5;s. For manually initiated ED measurements in these modes the measurement period is still 128 &#xB5;s as long as the receiver is in RX_ON state. A value other than 0xFF indicates the result of the last ED measurement.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ED_LEVEL3</NAME>
          <DESCRIPTION>Energy Detection Level</DESCRIPTION>
          <TEXT>The minimum ED value (ED_LEVEL = 0) indicates a receiver power less than or equal to RSSI_BASE_VAL. The range is 84 dB with a resolution of 1 dB and an absolute accuracy of &#xB1;5 dB. A manual ED measurement can be initiated by a write access to this register. A value of 0xFF signals that no measurement has yet been started (reset value). The measurement duration is 8 symbol periods (128 &#xB5;s) for a data rate of 250 kb/s. For High Data Rate Modes the automated measurement duration is reduced to 32 &#xB5;s. For manually initiated ED measurements in these modes the measurement period is still 128 &#xB5;s as long as the receiver is in RX_ON state. A value other than 0xFF indicates the result of the last ED measurement.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ED_LEVEL2</NAME>
          <DESCRIPTION>Energy Detection Level</DESCRIPTION>
          <TEXT>The minimum ED value (ED_LEVEL = 0) indicates a receiver power less than or equal to RSSI_BASE_VAL. The range is 84 dB with a resolution of 1 dB and an absolute accuracy of &#xB1;5 dB. A manual ED measurement can be initiated by a write access to this register. A value of 0xFF signals that no measurement has yet been started (reset value). The measurement duration is 8 symbol periods (128 &#xB5;s) for a data rate of 250 kb/s. For High Data Rate Modes the automated measurement duration is reduced to 32 &#xB5;s. For manually initiated ED measurements in these modes the measurement period is still 128 &#xB5;s as long as the receiver is in RX_ON state. A value other than 0xFF indicates the result of the last ED measurement.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ED_LEVEL1</NAME>
          <DESCRIPTION>Energy Detection Level</DESCRIPTION>
          <TEXT>The minimum ED value (ED_LEVEL = 0) indicates a receiver power less than or equal to RSSI_BASE_VAL. The range is 84 dB with a resolution of 1 dB and an absolute accuracy of &#xB1;5 dB. A manual ED measurement can be initiated by a write access to this register. A value of 0xFF signals that no measurement has yet been started (reset value). The measurement duration is 8 symbol periods (128 &#xB5;s) for a data rate of 250 kb/s. For High Data Rate Modes the automated measurement duration is reduced to 32 &#xB5;s. For manually initiated ED measurements in these modes the measurement period is still 128 &#xB5;s as long as the receiver is in RX_ON state. A value other than 0xFF indicates the result of the last ED measurement.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ED_LEVEL0</NAME>
          <DESCRIPTION>Energy Detection Level</DESCRIPTION>
          <TEXT>The minimum ED value (ED_LEVEL = 0) indicates a receiver power less than or equal to RSSI_BASE_VAL. The range is 84 dB with a resolution of 1 dB and an absolute accuracy of &#xB1;5 dB. A manual ED measurement can be initiated by a write access to this register. A value of 0xFF signals that no measurement has yet been started (reset value). The measurement duration is 8 symbol periods (128 &#xB5;s) for a data rate of 250 kb/s. For High Data Rate Modes the automated measurement duration is reduced to 32 &#xB5;s. For manually initiated ED measurements in these modes the measurement period is still 128 &#xB5;s as long as the receiver is in RX_ON state. A value other than 0xFF indicates the result of the last ED measurement.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>1</INIT_VAL>
          <ENUM>ED_LEVEL_BITF</ENUM>
        </BIT0>
      </PHY_ED_LEVEL>
      <PHY_CC_CCA>
        <NAME>PHY_CC_CCA</NAME>
        <DESCRIPTION>Transceiver Clear Channel Assessment (CCA) Control Register</DESCRIPTION>
        <TEXT>This register is provided to initiate and control a CCA measurement.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$148</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>CCA_REQUEST</NAME>
          <DESCRIPTION>Manual CCA Measurement Request</DESCRIPTION>
          <TEXT>A manual CCA measurement is initiated with setting CCA_REQUEST=1. The end of the CCA measurement is indicated by the TRX24_CCA_ED_DONE interrupt. Register bits CCA_DONE and CCA_STATUS of register TRX_STATUS are updated after a CCA_REQUEST. The register bit is automatically cleared after requesting a CCA measurement with CCA_REQUEST=1.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>CCA_MODE1</NAME>
          <DESCRIPTION>Select CCA Measurement Mode</DESCRIPTION>
          <TEXT>The CCA mode can be selected using these register bits. Note that IEEE 802.15.4-2006 CCA Mode 3 defines the logical combination of CCA Mode 1 and 2 with the logical operators AND or OR. This can be selected with CCA_MODE=0 for logical operation OR and CCA_MODE=3 for logical operation AND.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>CCA_MODE0</NAME>
          <DESCRIPTION>Select CCA Measurement Mode</DESCRIPTION>
          <TEXT>The CCA mode can be selected using these register bits. Note that IEEE 802.15.4-2006 CCA Mode 3 defines the logical combination of CCA Mode 1 and 2 with the logical operators AND or OR. This can be selected with CCA_MODE=0 for logical operation OR and CCA_MODE=3 for logical operation AND.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
          <ENUM>CCA_MODE_bitf</ENUM>
        </BIT5>
        <BIT4>
          <NAME>CHANNEL4</NAME>
          <DESCRIPTION>RX/TX Channel Selection</DESCRIPTION>
          <TEXT>These register bits define the RX/TX channel. The channel assignment is according to IEEE 802.15.4.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>CHANNEL3</NAME>
          <DESCRIPTION>RX/TX Channel Selection</DESCRIPTION>
          <TEXT>These register bits define the RX/TX channel. The channel assignment is according to IEEE 802.15.4.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CHANNEL2</NAME>
          <DESCRIPTION>RX/TX Channel Selection</DESCRIPTION>
          <TEXT>These register bits define the RX/TX channel. The channel assignment is according to IEEE 802.15.4.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CHANNEL1</NAME>
          <DESCRIPTION>RX/TX Channel Selection</DESCRIPTION>
          <TEXT>These register bits define the RX/TX channel. The channel assignment is according to IEEE 802.15.4.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CHANNEL0</NAME>
          <DESCRIPTION>RX/TX Channel Selection</DESCRIPTION>
          <TEXT>These register bits define the RX/TX channel. The channel assignment is according to IEEE 802.15.4.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
          <ENUM>CHANNEL_bitf</ENUM>
        </BIT0>
      </PHY_CC_CCA>
      <CCA_THRES>
        <NAME>CCA_THRES</NAME>
        <DESCRIPTION>Transceiver CCA Threshold Setting Register</DESCRIPTION>
        <TEXT>This register sets the threshold level for the Energy Detection (ED) of the Clear Channel Assessment (CCA).</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$149</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>CCA_CS_THRES3</NAME>
          <DESCRIPTION>CS Threshold Level for CCA Measurement</DESCRIPTION>
          <TEXT>These bits are reserved for internal use.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>CCA_CS_THRES2</NAME>
          <DESCRIPTION>CS Threshold Level for CCA Measurement</DESCRIPTION>
          <TEXT>These bits are reserved for internal use.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>CCA_CS_THRES1</NAME>
          <DESCRIPTION>CS Threshold Level for CCA Measurement</DESCRIPTION>
          <TEXT>These bits are reserved for internal use.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>CCA_CS_THRES0</NAME>
          <DESCRIPTION>CS Threshold Level for CCA Measurement</DESCRIPTION>
          <TEXT>These bits are reserved for internal use.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>CCA_ED_THRES3</NAME>
          <DESCRIPTION>ED Threshold Level for CCA Measurement</DESCRIPTION>
          <TEXT>These bits define the received power threshold of the Energy above threshold algorithm. The threshold is calculated by RSSI_BASE_VAL + 2CCA_ED_THRES [dBm]. Any received power above this level is interpreted as a busy channel.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CCA_ED_THRES2</NAME>
          <DESCRIPTION>ED Threshold Level for CCA Measurement</DESCRIPTION>
          <TEXT>These bits define the received power threshold of the Energy above threshold algorithm. The threshold is calculated by RSSI_BASE_VAL + 2CCA_ED_THRES [dBm]. Any received power above this level is interpreted as a busy channel.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CCA_ED_THRES1</NAME>
          <DESCRIPTION>ED Threshold Level for CCA Measurement</DESCRIPTION>
          <TEXT>These bits define the received power threshold of the Energy above threshold algorithm. The threshold is calculated by RSSI_BASE_VAL + 2CCA_ED_THRES [dBm]. Any received power above this level is interpreted as a busy channel.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CCA_ED_THRES0</NAME>
          <DESCRIPTION>ED Threshold Level for CCA Measurement</DESCRIPTION>
          <TEXT>These bits define the received power threshold of the Energy above threshold algorithm. The threshold is calculated by RSSI_BASE_VAL + 2CCA_ED_THRES [dBm]. Any received power above this level is interpreted as a busy channel.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT0>
      </CCA_THRES>
      <RX_CTRL>
        <NAME>RX_CTRL</NAME>
        <DESCRIPTION>Transceiver Receive Control Register</DESCRIPTION>
        <TEXT>The register controls the sensitivity of the Antenna Diversity Mode. Note that in High Data Rate modes the ACR module will always be disabled.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$14A</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT3>
          <NAME>PDT_THRES3</NAME>
          <DESCRIPTION>Receiver Sensitivity Control</DESCRIPTION>
          <TEXT>These register bits control the sensitivity of the receiver correlation unit. If the Antenna Diversity algorithm is enabled the value shall be set to PDT_THRES = 3. Otherwise it shall be set back to the reset value. Values not listed in the following table are reserved.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PDT_THRES2</NAME>
          <DESCRIPTION>Receiver Sensitivity Control</DESCRIPTION>
          <TEXT>These register bits control the sensitivity of the receiver correlation unit. If the Antenna Diversity algorithm is enabled the value shall be set to PDT_THRES = 3. Otherwise it shall be set back to the reset value. Values not listed in the following table are reserved.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PDT_THRES1</NAME>
          <DESCRIPTION>Receiver Sensitivity Control</DESCRIPTION>
          <TEXT>These register bits control the sensitivity of the receiver correlation unit. If the Antenna Diversity algorithm is enabled the value shall be set to PDT_THRES = 3. Otherwise it shall be set back to the reset value. Values not listed in the following table are reserved.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PDT_THRES0</NAME>
          <DESCRIPTION>Receiver Sensitivity Control</DESCRIPTION>
          <TEXT>These register bits control the sensitivity of the receiver correlation unit. If the Antenna Diversity algorithm is enabled the value shall be set to PDT_THRES = 3. Otherwise it shall be set back to the reset value. Values not listed in the following table are reserved.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
          <ENUM>PDT_THRES_bitf</ENUM>
        </BIT0>
      </RX_CTRL>
      <SFD_VALUE>
        <NAME>SFD_VALUE</NAME>
        <DESCRIPTION>Start of Frame Delimiter Value Register</DESCRIPTION>
        <TEXT>This register contains the one octet start-of-frame delimiter (SFD) to synchronize to a received frame. The lower 4 bits must not be all zero to avoid decoding conflicts.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$14B</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SFD_VALUE7</NAME>
          <DESCRIPTION>Start of Frame Delimiter Value</DESCRIPTION>
          <TEXT>For compliant IEEE 802.15.4 networks set SFD_VALUE = 0xA7. This is the default value of the register. To establish non IEEE 802.15.4 compliant networks the SFD value can be changed to any other value. If enabled a RX_START interrupt is issued only if the received SFD matches the register content of SFD_VALUE and a valid PHR is received.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SFD_VALUE6</NAME>
          <DESCRIPTION>Start of Frame Delimiter Value</DESCRIPTION>
          <TEXT>For compliant IEEE 802.15.4 networks set SFD_VALUE = 0xA7. This is the default value of the register. To establish non IEEE 802.15.4 compliant networks the SFD value can be changed to any other value. If enabled a RX_START interrupt is issued only if the received SFD matches the register content of SFD_VALUE and a valid PHR is received.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SFD_VALUE5</NAME>
          <DESCRIPTION>Start of Frame Delimiter Value</DESCRIPTION>
          <TEXT>For compliant IEEE 802.15.4 networks set SFD_VALUE = 0xA7. This is the default value of the register. To establish non IEEE 802.15.4 compliant networks the SFD value can be changed to any other value. If enabled a RX_START interrupt is issued only if the received SFD matches the register content of SFD_VALUE and a valid PHR is received.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SFD_VALUE4</NAME>
          <DESCRIPTION>Start of Frame Delimiter Value</DESCRIPTION>
          <TEXT>For compliant IEEE 802.15.4 networks set SFD_VALUE = 0xA7. This is the default value of the register. To establish non IEEE 802.15.4 compliant networks the SFD value can be changed to any other value. If enabled a RX_START interrupt is issued only if the received SFD matches the register content of SFD_VALUE and a valid PHR is received.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SFD_VALUE3</NAME>
          <DESCRIPTION>Start of Frame Delimiter Value</DESCRIPTION>
          <TEXT>For compliant IEEE 802.15.4 networks set SFD_VALUE = 0xA7. This is the default value of the register. To establish non IEEE 802.15.4 compliant networks the SFD value can be changed to any other value. If enabled a RX_START interrupt is issued only if the received SFD matches the register content of SFD_VALUE and a valid PHR is received.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SFD_VALUE2</NAME>
          <DESCRIPTION>Start of Frame Delimiter Value</DESCRIPTION>
          <TEXT>For compliant IEEE 802.15.4 networks set SFD_VALUE = 0xA7. This is the default value of the register. To establish non IEEE 802.15.4 compliant networks the SFD value can be changed to any other value. If enabled a RX_START interrupt is issued only if the received SFD matches the register content of SFD_VALUE and a valid PHR is received.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SFD_VALUE1</NAME>
          <DESCRIPTION>Start of Frame Delimiter Value</DESCRIPTION>
          <TEXT>For compliant IEEE 802.15.4 networks set SFD_VALUE = 0xA7. This is the default value of the register. To establish non IEEE 802.15.4 compliant networks the SFD value can be changed to any other value. If enabled a RX_START interrupt is issued only if the received SFD matches the register content of SFD_VALUE and a valid PHR is received.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SFD_VALUE0</NAME>
          <DESCRIPTION>Start of Frame Delimiter Value</DESCRIPTION>
          <TEXT>For compliant IEEE 802.15.4 networks set SFD_VALUE = 0xA7. This is the default value of the register. To establish non IEEE 802.15.4 compliant networks the SFD value can be changed to any other value. If enabled a RX_START interrupt is issued only if the received SFD matches the register content of SFD_VALUE and a valid PHR is received.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
          <ENUM>SFD_VALUE_BITF</ENUM>
        </BIT0>
      </SFD_VALUE>
      <TRX_CTRL_2>
        <NAME>TRX_CTRL_2</NAME>
        <DESCRIPTION>Transceiver Control Register 2</DESCRIPTION>
        <TEXT>This register controls the data rate setting of the radio transceiver.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$14C</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>RX_SAFE_MODE</NAME>
          <DESCRIPTION>RX Safe Mode</DESCRIPTION>
          <TEXT>If this bit is set, the next received frame will be protected and not overwritten by following frames. Set this bit to 0 to release the buffer (and set it again for further protection).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res4</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>Res3</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res2</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OQPSK_DATA_RATE1</NAME>
          <DESCRIPTION>Data Rate Selection</DESCRIPTION>
          <TEXT>A write access to these register bits sets the OQPSK PSDU data rate used by the radio transceiver. The reset value OQPSK_DATA_RATE = 0 is the PSDU data rate according to IEEE 802.15.4. All other values are used in High Data Rate Modes.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OQPSK_DATA_RATE0</NAME>
          <DESCRIPTION>Data Rate Selection</DESCRIPTION>
          <TEXT>A write access to these register bits sets the OQPSK PSDU data rate used by the radio transceiver. The reset value OQPSK_DATA_RATE = 0 is the PSDU data rate according to IEEE 802.15.4. All other values are used in High Data Rate Modes.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>OQPSK_DATA_RATE_bitf</ENUM>
        </BIT0>
      </TRX_CTRL_2>
      <ANT_DIV>
        <NAME>ANT_DIV</NAME>
        <DESCRIPTION>Antenna Diversity Control Register</DESCRIPTION>
        <TEXT>This register controls the Antenna Diversity.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$14D</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>ANT_SEL</NAME>
          <DESCRIPTION>Antenna Diversity Antenna Status</DESCRIPTION>
          <TEXT>This register bit signals the currently selected antenna path. The selection may be based either on the last antenna diversity cycle (ANT_DIV_EN = 1) or on the content of register bits ANT_CTRL.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>ANT_SEL_bitf</ENUM>
        </BIT7>
        <BIT6>
          <NAME>Res2</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ANT_DIV_EN</NAME>
          <DESCRIPTION>Enable Antenna Diversity</DESCRIPTION>
          <TEXT>If this register bit is set the Antenna Diversity algorithm is enabled. On reception of a frame the algorithm selects an antenna autonomously during SHR search. This selection is kept until
1. a new SHR search starts or
2. receive states are left or
3. a manually programming of bits ANT_CTRL occurred. If ANT_DIV_EN = 1 the bit ANT_EXT_SW_EN shall also be set to 1.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>ANT_DIV_EN_bitf</ENUM>
        </BIT3>
        <BIT2>
          <NAME>ANT_EXT_SW_EN</NAME>
          <DESCRIPTION>Enable External Antenna Switch Control</DESCRIPTION>
          <TEXT>If enabled, pin DIG1 and pin DIG2 become output pins and provide a differential control signal for an external Antenna Diversity switch. The selection of a specific antenna is done either by the automatic Antenna Diversity algorithm (ANT_DIV_EN = 1) or according to bits ANT_CTRL if the Antenna Diversity algorithm is disabled. Do not enable Antenna Diversity RF switch control (ANT_EXT_SW_EN = 1) and RX Frame Time Stamping (IRQ_2_EXT_EN = 1, see register TRX_CTRL_1) at the same time. If this bit is set the control pins DIG1/DIG2 are activated in all radio transceiver states as long as bit ANT_EXT_SW_EN is also set. If the radio transceiver is not in a receive or transmit state, it is recommended to disable bit ANT_EXT_SW_EN to reduce the power consumption or avoid leakage current of an external RF switch especially during SLEEP state. The output pins DIG1 and DIG2 are pulled-down to digital ground if bit ANT_EXT_SW_EN = 0.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>ANT_EXT_SW_EN_bitf</ENUM>
        </BIT2>
        <BIT1>
          <NAME>ANT_CTRL1</NAME>
          <DESCRIPTION>Static Antenna Diversity Switch Control</DESCRIPTION>
          <TEXT>These bits provide a static control of an Antenna Diversity switch. This register setting defines the selected antenna if ANT_DIV_EN is set to 0 (Antenna Diversity disabled). Register values 1 and 2 are valid for ANT_EXT_SW_EN = 1.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ANT_CTRL0</NAME>
          <DESCRIPTION>Static Antenna Diversity Switch Control</DESCRIPTION>
          <TEXT>These bits provide a static control of an Antenna Diversity switch. This register setting defines the selected antenna if ANT_DIV_EN is set to 0 (Antenna Diversity disabled). Register values 1 and 2 are valid for ANT_EXT_SW_EN = 1.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
          <ENUM>ANT_CTRL_bitf</ENUM>
        </BIT0>
      </ANT_DIV>
      <IRQ_MASK>
        <NAME>IRQ_MASK</NAME>
        <DESCRIPTION>Transceiver Interrupt Enable Register</DESCRIPTION>
        <TEXT>This register is used to enable or disable individual interrupts of the radio transceiver.  An interrupt is enabled if the corresponding bit is set to 1. All interrupts are disabled after the power up sequence or reset. If an interrupt is enabled it is recommended to read the interrupt status register IRQ_STATUS first to clear the history.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$14E</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>AWAKE_EN</NAME>
          <DESCRIPTION>Awake Interrupt Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TX_END_EN</NAME>
          <DESCRIPTION>TX_END Interrupt Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>AMI_EN</NAME>
          <DESCRIPTION>Address Match Interrupt Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>CCA_ED_DONE_EN</NAME>
          <DESCRIPTION>End of ED Measurement Interrupt Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>RX_END_EN</NAME>
          <DESCRIPTION>RX_END Interrupt Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>RX_START_EN</NAME>
          <DESCRIPTION>RX_START Interrupt Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PLL_UNLOCK_EN</NAME>
          <DESCRIPTION>PLL Unlock Interrupt Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PLL_LOCK_EN</NAME>
          <DESCRIPTION>PLL Lock Interrupt Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </IRQ_MASK>
      <IRQ_STATUS>
        <NAME>IRQ_STATUS</NAME>
        <DESCRIPTION>Transceiver Interrupt Status Register</DESCRIPTION>
        <TEXT>This register contains the status of the pending interrupt requests. An interrupt is pending if the associated bit has a value of one. Such a pending interrupts can be manually cleared by writing a 1 to that register bit. Interrupts are automatically cleared when the corresponding interrupt service routine is being executed.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$14F</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>AWAKE</NAME>
          <DESCRIPTION>Awake Interrupt Status</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TX_END</NAME>
          <DESCRIPTION>TX_END Interrupt Status</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>AMI</NAME>
          <DESCRIPTION>Address Match Interrupt Status</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>CCA_ED_DONE</NAME>
          <DESCRIPTION>End of ED Measurement Interrupt Status</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>RX_END</NAME>
          <DESCRIPTION>RX_END Interrupt Status</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>RX_START</NAME>
          <DESCRIPTION>RX_START Interrupt Status</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PLL_UNLOCK</NAME>
          <DESCRIPTION>PLL Unlock Interrupt Status</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PLL_LOCK</NAME>
          <DESCRIPTION>PLL Lock Interrupt Status</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </IRQ_STATUS>
      <VREG_CTRL>
        <NAME>VREG_CTRL</NAME>
        <DESCRIPTION>Voltage Regulator Control and Status Register</DESCRIPTION>
        <TEXT>This register controls the use of the voltage regulators and indicates their status.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$150</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>AVREG_EXT</NAME>
          <DESCRIPTION>Use External AVDD Regulator</DESCRIPTION>
          <TEXT>If set, this register bit disables the internal analog voltage regulator to apply an external regulated 1.8V supply for the analog building blocks.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>AVREG_EXT_BITF</ENUM>
        </BIT7>
        <BIT6>
          <NAME>AVDD_OK</NAME>
          <DESCRIPTION>AVDD Supply Voltage Valid</DESCRIPTION>
          <TEXT>This register bit indicates if the internal 1.8V regulated voltage supply AVDD has settled. The bit is set to logic high if AVREG_EXT = 1.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>AVDD_OK_BITF</ENUM>
        </BIT6>
        <BIT3>
          <NAME>DVREG_EXT</NAME>
          <DESCRIPTION>Use External DVDD Regulator</DESCRIPTION>
          <TEXT>If set this register bit disables the internal digital voltage regulator to apply an external regulated 1.8V supply for the digital building blocks.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>DVREG_EXT_BITF</ENUM>
        </BIT3>
        <BIT2>
          <NAME>DVDD_OK</NAME>
          <DESCRIPTION>DVDD Supply Voltage Valid</DESCRIPTION>
          <TEXT>This register bit indicates if the internal 1.8V regulated voltage supply DVDD has settled. The bit is set to logic high if DVREG_EXT = 1.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>DVDD_OK_BITF</ENUM>
        </BIT2>
      </VREG_CTRL>
      <BATMON>
        <NAME>BATMON</NAME>
        <DESCRIPTION>Battery Monitor Control and Status Register</DESCRIPTION>
        <TEXT>This register configures the battery monitor to observe the supply voltage at EVDD. The status of the EVDD supply voltage is accessible by reading bit BATMON_OK with respect to the actual BATMON settings. Furthermore the Battery Monitor Interrupt can be controlled with the bits BAT_LOW and BAT_LOW_EN similar to the function of the IRQ_STATUS and IRQ_MASK register for other radio transceiver interrupts.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$151</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>BAT_LOW</NAME>
          <DESCRIPTION>Battery Monitor Interrupt Status</DESCRIPTION>
          <TEXT>A BATMON Interrupt is pending if this bit is set. Writing one to this bit if it has been at one will clear the interrupt.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>BAT_LOW_EN</NAME>
          <DESCRIPTION>Battery Monitor Interrupt Enable</DESCRIPTION>
          <TEXT>The Battery Monitor Interrupt is enabled if this bit is set to one. The Battery Monitor will not generate an interrupt if this bit is zero.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>BATMON_OK</NAME>
          <DESCRIPTION>Battery Monitor Status</DESCRIPTION>
          <TEXT>The register bit BATMON_OK indicates the level of the external supply voltage with respect to the programmed threshold BATMON_VTH.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>BATMON_OK_bitf</ENUM>
        </BIT5>
        <BIT4>
          <NAME>BATMON_HR</NAME>
          <DESCRIPTION>Battery Monitor Voltage Range</DESCRIPTION>
          <TEXT>This bit sets the range and resolution of the battery monitor.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>BATMON_HR_bitf</ENUM>
        </BIT4>
        <BIT3>
          <NAME>BATMON_VTH3</NAME>
          <DESCRIPTION>Battery Monitor Threshold Voltage</DESCRIPTION>
          <TEXT>The threshold values for the battery monitor are set by these register bits according to the following table.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>BATMON_VTH2</NAME>
          <DESCRIPTION>Battery Monitor Threshold Voltage</DESCRIPTION>
          <TEXT>The threshold values for the battery monitor are set by these register bits according to the following table.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>BATMON_VTH1</NAME>
          <DESCRIPTION>Battery Monitor Threshold Voltage</DESCRIPTION>
          <TEXT>The threshold values for the battery monitor are set by these register bits according to the following table.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>BATMON_VTH0</NAME>
          <DESCRIPTION>Battery Monitor Threshold Voltage</DESCRIPTION>
          <TEXT>The threshold values for the battery monitor are set by these register bits according to the following table.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>BATMON_VTH_bitf</ENUM>
        </BIT0>
      </BATMON>
      <XOSC_CTRL>
        <NAME>XOSC_CTRL</NAME>
        <DESCRIPTION>Crystal Oscillator Control Register</DESCRIPTION>
        <TEXT>This register controls the operation of the 16MHz crystal oscillator.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$152</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>XTAL_MODE3</NAME>
          <DESCRIPTION>Crystal Oscillator Operating Mode</DESCRIPTION>
          <TEXT>These register bits set the operating mode of the 16 MHz crystal oscillator. For normal operation the default value is set to XTAL_MODE = 0xF after reset. For use with an external clock source it is recommended to set XTAL_MODE = 0x4.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>XTAL_MODE2</NAME>
          <DESCRIPTION>Crystal Oscillator Operating Mode</DESCRIPTION>
          <TEXT>These register bits set the operating mode of the 16 MHz crystal oscillator. For normal operation the default value is set to XTAL_MODE = 0xF after reset. For use with an external clock source it is recommended to set XTAL_MODE = 0x4.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>XTAL_MODE1</NAME>
          <DESCRIPTION>Crystal Oscillator Operating Mode</DESCRIPTION>
          <TEXT>These register bits set the operating mode of the 16 MHz crystal oscillator. For normal operation the default value is set to XTAL_MODE = 0xF after reset. For use with an external clock source it is recommended to set XTAL_MODE = 0x4.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>XTAL_MODE0</NAME>
          <DESCRIPTION>Crystal Oscillator Operating Mode</DESCRIPTION>
          <TEXT>These register bits set the operating mode of the 16 MHz crystal oscillator. For normal operation the default value is set to XTAL_MODE = 0xF after reset. For use with an external clock source it is recommended to set XTAL_MODE = 0x4.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
          <ENUM>XTAL_MODE_BITF</ENUM>
        </BIT4>
        <BIT3>
          <NAME>XTAL_TRIM3</NAME>
          <DESCRIPTION>Crystal Oscillator Load Capacitance Trimming</DESCRIPTION>
          <TEXT>These register bits control two internal capacitance arrays connected to pins XTAL1 and XTAL2. A capacitance value in the range from 0 pF to 4.5 pF is selectable with a resolution of 0.3 pF.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>XTAL_TRIM2</NAME>
          <DESCRIPTION>Crystal Oscillator Load Capacitance Trimming</DESCRIPTION>
          <TEXT>These register bits control two internal capacitance arrays connected to pins XTAL1 and XTAL2. A capacitance value in the range from 0 pF to 4.5 pF is selectable with a resolution of 0.3 pF.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>XTAL_TRIM1</NAME>
          <DESCRIPTION>Crystal Oscillator Load Capacitance Trimming</DESCRIPTION>
          <TEXT>These register bits control two internal capacitance arrays connected to pins XTAL1 and XTAL2. A capacitance value in the range from 0 pF to 4.5 pF is selectable with a resolution of 0.3 pF.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>XTAL_TRIM0</NAME>
          <DESCRIPTION>Crystal Oscillator Load Capacitance Trimming</DESCRIPTION>
          <TEXT>These register bits control two internal capacitance arrays connected to pins XTAL1 and XTAL2. A capacitance value in the range from 0 pF to 4.5 pF is selectable with a resolution of 0.3 pF.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>XTAL_TRIM_bitf</ENUM>
        </BIT0>
      </XOSC_CTRL>
      <RX_SYN>
        <NAME>RX_SYN</NAME>
        <DESCRIPTION>Transceiver Receiver Sensitivity Control Register</DESCRIPTION>
        <TEXT>This register controls the sensitivity threshold of the receiver.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$155</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>RX_PDT_DIS</NAME>
          <DESCRIPTION>Prevent Frame Reception</DESCRIPTION>
          <TEXT>RX_PDT_DIS = 1 prevents the reception of a frame even if the radio transceiver is in receive modes. An ongoing frame reception is not affected. This operation mode is independent of the setting of register bits RX_PDT_LEVEL.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res2</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>RX_PDT_LEVEL3</NAME>
          <DESCRIPTION>Reduce Receiver Sensitivity</DESCRIPTION>
          <TEXT>These register bits reduce the receiver sensitivity such that frames with a RSSI level below the RX_PDT_LEVEL threshold level are not received (RX_PDT_LEVEL&gt;0). The threshold level can be calculated according to the following formula: RX_THRES &gt; RSSI_BASE_VAL+3&#xB7;(RX_PDT_LEVEL-1), for RX_PDT_LEVEL&gt;0. If register bits RX_PDT_LEVEL&gt;0 the current consumption of the receiver in states RX_ON and RX_AACK_ON is reduced by 500 &#xB5;A. If register bits RX_PDT_LEVEL=0 (reset value) all frames with a valid SHR and PHR are received, independently of their signal strength. Examples for certain register settings are given in the following table.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>RX_PDT_LEVEL2</NAME>
          <DESCRIPTION>Reduce Receiver Sensitivity</DESCRIPTION>
          <TEXT>These register bits reduce the receiver sensitivity such that frames with a RSSI level below the RX_PDT_LEVEL threshold level are not received (RX_PDT_LEVEL&gt;0). The threshold level can be calculated according to the following formula: RX_THRES &gt; RSSI_BASE_VAL+3&#xB7;(RX_PDT_LEVEL-1), for RX_PDT_LEVEL&gt;0. If register bits RX_PDT_LEVEL&gt;0 the current consumption of the receiver in states RX_ON and RX_AACK_ON is reduced by 500 &#xB5;A. If register bits RX_PDT_LEVEL=0 (reset value) all frames with a valid SHR and PHR are received, independently of their signal strength. Examples for certain register settings are given in the following table.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>RX_PDT_LEVEL1</NAME>
          <DESCRIPTION>Reduce Receiver Sensitivity</DESCRIPTION>
          <TEXT>These register bits reduce the receiver sensitivity such that frames with a RSSI level below the RX_PDT_LEVEL threshold level are not received (RX_PDT_LEVEL&gt;0). The threshold level can be calculated according to the following formula: RX_THRES &gt; RSSI_BASE_VAL+3&#xB7;(RX_PDT_LEVEL-1), for RX_PDT_LEVEL&gt;0. If register bits RX_PDT_LEVEL&gt;0 the current consumption of the receiver in states RX_ON and RX_AACK_ON is reduced by 500 &#xB5;A. If register bits RX_PDT_LEVEL=0 (reset value) all frames with a valid SHR and PHR are received, independently of their signal strength. Examples for certain register settings are given in the following table.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>RX_PDT_LEVEL0</NAME>
          <DESCRIPTION>Reduce Receiver Sensitivity</DESCRIPTION>
          <TEXT>These register bits reduce the receiver sensitivity such that frames with a RSSI level below the RX_PDT_LEVEL threshold level are not received (RX_PDT_LEVEL&gt;0). The threshold level can be calculated according to the following formula: RX_THRES &gt; RSSI_BASE_VAL+3&#xB7;(RX_PDT_LEVEL-1), for RX_PDT_LEVEL&gt;0. If register bits RX_PDT_LEVEL&gt;0 the current consumption of the receiver in states RX_ON and RX_AACK_ON is reduced by 500 &#xB5;A. If register bits RX_PDT_LEVEL=0 (reset value) all frames with a valid SHR and PHR are received, independently of their signal strength. Examples for certain register settings are given in the following table.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>RX_PDT_LEVEL_BITF</ENUM>
        </BIT0>
      </RX_SYN>
      <XAH_CTRL_1>
        <NAME>XAH_CTRL_1</NAME>
        <DESCRIPTION>Transceiver Acknowledgment Frame Control Register 1</DESCRIPTION>
        <TEXT>This register is a multi-purpose control register for various RX_AACK settings.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$157</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. The result of a read access is undefined. The register bit must always be written with the reset value.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. The result of a read access is undefined. The register bit must always be written with the reset value.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>AACK_FLTR_RES_FT</NAME>
          <DESCRIPTION>Filter Reserved Frames</DESCRIPTION>
          <TEXT>This register bit shall only be set if AACK_UPLD_RES_FT = 1. If AACK_FLTR_RES_FT = 1 reserved frame types are filtered similar to data frames as specified in IEEE 802.15.4-2006. Reserved frame types are explained in IEEE 802.15.4 section 7.2.1.1.1. If AACK_FLTR_RES_FT = 0 a received, reserved frame is only checked for a valid FCS.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>AACK_UPLD_RES_FT</NAME>
          <DESCRIPTION>Process Reserved Frames</DESCRIPTION>
          <TEXT>If AACK_UPLD_RES_FT = 1 received frames indicated as reserved are further processed. A RX_END interrupt is generated if the FCS of those frames is valid.  In conjunction with the configuration bit AACK_FLTR_RES_FT set, these frames are handled like IEEE 802.15.4 compliant data frames during RX_AACK transaction. An AMI interrupt is issued if the address in the received frame matches the node address.  That means if a reserved frame passes the third level filter rules, an acknowledgment frame is generated and transmitted if it was requested by the received frame. If this is not wanted bit AACK_DIS_ACK in register CSMA_SEED_1 has to be set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>Res</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. The result of a read access is undefined. The register bit must always be written with the reset value.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>AACK_ACK_TIME</NAME>
          <DESCRIPTION>Reduce Acknowledgment Time</DESCRIPTION>
          <TEXT>According to IEEE 802.15.4, section 7.5.6.4.2 the transmission of an acknowledgment frame shall commence 12 symbols (aTurnaroundTime) after the reception of the last symbol of a data or MAC command frame. This is achieved with the reset value of the register bit AACK_ACK_TIME. If AACK_ACK_TIME = 1 an acknowledgment frame is alternatively sent already 2 symbol periods (32 &#xB5;s) after the reception of the last symbol of a data or MAC command frame. This may be applied to proprietary networks or networks using the High Data Rate Modes to increase battery lifetime and to improve the overall data throughput. This setting affects also to acknowledgment frame response time for slotted acknowledgment operation.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>AACK_ACK_TIME_bitf</ENUM>
        </BIT2>
        <BIT1>
          <NAME>AACK_PROM_MODE</NAME>
          <DESCRIPTION>Enable Promiscuous Mode</DESCRIPTION>
          <TEXT>This register bit enables the promiscuous mode within the RX_AACK mode; refer to IEEE 802.15.4-2006 chapter 7.5.6.5. If this bit is set, every incoming frame with a valid PHR finishes with a RX_END interrupt even if the third level filter rules do not match or the FCS is not valid. The bit RX_CRC_VALID of register PHY_RSSI is set accordingly. If this bit is set and a frame passes the third level filter rules, an acknowledgment frame is generated and transmitted unless disabled by bit AACK_DIS_ACK of register CSMA_SEED_1.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>Res</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. The result of a read access is undefined. The register bit must always be written with the reset value.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </XAH_CTRL_1>
      <FTN_CTRL>
        <NAME>FTN_CTRL</NAME>
        <DESCRIPTION>Transceiver Filter Tuning Control Register</DESCRIPTION>
        <TEXT>This register controls the operation of the calibration loop of the filter tuning network.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$158</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>FTN_START</NAME>
          <DESCRIPTION>Start Calibration Loop of Filter Tuning Network</DESCRIPTION>
          <TEXT>FTN_START = 1 initiates the calibration of the filter tuning network. When the calibration cycle has finished after at most 25 &#xB5;s the register bit is automatically reset to 0.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
      </FTN_CTRL>
      <PLL_CF>
        <NAME>PLL_CF</NAME>
        <DESCRIPTION>Transceiver Center Frequency Calibration Control Register</DESCRIPTION>
        <TEXT>This register controls the operation of the center frequency calibration loop.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$15A</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>PLL_CF_START</NAME>
          <DESCRIPTION>Start Center Frequency Calibration</DESCRIPTION>
          <TEXT>PLL_CF_START = 1 initiates the center frequency calibration. The calibration cycle has finished after 35 &#xB5;s (typical). The register bit is cleared immediately after finishing the calibration.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
      </PLL_CF>
      <PLL_DCU>
        <NAME>PLL_DCU</NAME>
        <DESCRIPTION>Transceiver Delay Cell Calibration Control Register</DESCRIPTION>
        <TEXT>This register controls the operation of the calibration loop of the delay cell.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$15B</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>PLL_DCU_START</NAME>
          <DESCRIPTION>Start Delay Cell Calibration</DESCRIPTION>
          <TEXT>PLL_DCU_START = 1 initiates the delay cell calibration. The calibration cycle has finished after at most 6 &#xB5;s. The register bit is cleared immediately after finishing the calibration.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
      </PLL_DCU>
      <PART_NUM>
        <NAME>PART_NUM</NAME>
        <DESCRIPTION>Device Identification Register (Part Number)</DESCRIPTION>
        <TEXT>This register contains the part number of the device.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$15C</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>PART_NUM7</NAME>
          <DESCRIPTION>Part Number</DESCRIPTION>
          <TEXT>These bits decode the part number of the device according to the following table.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PART_NUM6</NAME>
          <DESCRIPTION>Part Number</DESCRIPTION>
          <TEXT>These bits decode the part number of the device according to the following table.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PART_NUM5</NAME>
          <DESCRIPTION>Part Number</DESCRIPTION>
          <TEXT>These bits decode the part number of the device according to the following table.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PART_NUM4</NAME>
          <DESCRIPTION>Part Number</DESCRIPTION>
          <TEXT>These bits decode the part number of the device according to the following table.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PART_NUM3</NAME>
          <DESCRIPTION>Part Number</DESCRIPTION>
          <TEXT>These bits decode the part number of the device according to the following table.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PART_NUM2</NAME>
          <DESCRIPTION>Part Number</DESCRIPTION>
          <TEXT>These bits decode the part number of the device according to the following table.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PART_NUM1</NAME>
          <DESCRIPTION>Part Number</DESCRIPTION>
          <TEXT>These bits decode the part number of the device according to the following table.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PART_NUM0</NAME>
          <DESCRIPTION>Part Number</DESCRIPTION>
          <TEXT>These bits decode the part number of the device according to the following table.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>1</INIT_VAL>
          <ENUM>PART_NUM_bitf</ENUM>
        </BIT0>
      </PART_NUM>
      <VERSION_NUM>
        <NAME>VERSION_NUM</NAME>
        <DESCRIPTION>Device Identification Register (Version Number)</DESCRIPTION>
        <TEXT>This register contains the version number of the device.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$15D</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>VERSION_NUM7</NAME>
          <DESCRIPTION>Version Number</DESCRIPTION>
          <TEXT>These bits decode the version number of the device according to the following table.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>VERSION_NUM6</NAME>
          <DESCRIPTION>Version Number</DESCRIPTION>
          <TEXT>These bits decode the version number of the device according to the following table.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>VERSION_NUM5</NAME>
          <DESCRIPTION>Version Number</DESCRIPTION>
          <TEXT>These bits decode the version number of the device according to the following table.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>VERSION_NUM4</NAME>
          <DESCRIPTION>Version Number</DESCRIPTION>
          <TEXT>These bits decode the version number of the device according to the following table.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>VERSION_NUM3</NAME>
          <DESCRIPTION>Version Number</DESCRIPTION>
          <TEXT>These bits decode the version number of the device according to the following table.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>VERSION_NUM2</NAME>
          <DESCRIPTION>Version Number</DESCRIPTION>
          <TEXT>These bits decode the version number of the device according to the following table.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>VERSION_NUM1</NAME>
          <DESCRIPTION>Version Number</DESCRIPTION>
          <TEXT>These bits decode the version number of the device according to the following table.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>VERSION_NUM0</NAME>
          <DESCRIPTION>Version Number</DESCRIPTION>
          <TEXT>These bits decode the version number of the device according to the following table.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>1</INIT_VAL>
          <ENUM>VERSION_NUM_BITF</ENUM>
        </BIT0>
      </VERSION_NUM>
      <MAN_ID_0>
        <NAME>MAN_ID_0</NAME>
        <DESCRIPTION>Device Identification Register (Manufacture ID Low Byte)</DESCRIPTION>
        <TEXT>Bits [7:0] of the 32-bit JEDEC manufacturer ID are stored in this register. Bits [15:8] are stored in register MAN_ID_1. The highest 16 bits of the JEDEC ID are not stored in registers.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$15E</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>MAN_ID_07</NAME>
          <DESCRIPTION>Manufacturer ID (Low Byte)</DESCRIPTION>
          <TEXT>These bits contain bits [7:0] of the 32-bit JEDEC manufacturer ID.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>MAN_ID_06</NAME>
          <DESCRIPTION>Manufacturer ID (Low Byte)</DESCRIPTION>
          <TEXT>These bits contain bits [7:0] of the 32-bit JEDEC manufacturer ID.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>MAN_ID_05</NAME>
          <DESCRIPTION>Manufacturer ID (Low Byte)</DESCRIPTION>
          <TEXT>These bits contain bits [7:0] of the 32-bit JEDEC manufacturer ID.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>MAN_ID_04</NAME>
          <DESCRIPTION>Manufacturer ID (Low Byte)</DESCRIPTION>
          <TEXT>These bits contain bits [7:0] of the 32-bit JEDEC manufacturer ID.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>MAN_ID_03</NAME>
          <DESCRIPTION>Manufacturer ID (Low Byte)</DESCRIPTION>
          <TEXT>These bits contain bits [7:0] of the 32-bit JEDEC manufacturer ID.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>MAN_ID_02</NAME>
          <DESCRIPTION>Manufacturer ID (Low Byte)</DESCRIPTION>
          <TEXT>These bits contain bits [7:0] of the 32-bit JEDEC manufacturer ID.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>MAN_ID_01</NAME>
          <DESCRIPTION>Manufacturer ID (Low Byte)</DESCRIPTION>
          <TEXT>These bits contain bits [7:0] of the 32-bit JEDEC manufacturer ID.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>MAN_ID_00</NAME>
          <DESCRIPTION>Manufacturer ID (Low Byte)</DESCRIPTION>
          <TEXT>These bits contain bits [7:0] of the 32-bit JEDEC manufacturer ID.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>1</INIT_VAL>
          <ENUM>MAN_ID_0_BITF</ENUM>
        </BIT0>
      </MAN_ID_0>
      <MAN_ID_1>
        <NAME>MAN_ID_1</NAME>
        <DESCRIPTION>Device Identification Register (Manufacture ID High Byte)</DESCRIPTION>
        <TEXT>Bits [15:8] of the 32-bit JEDEC manufacturer ID are stored in this register. Bits [7:0] are stored in register MAN_ID_0. The highest 16 bits of the JEDEC ID are not stored in registers.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$15F</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>MAN_ID_17</NAME>
          <DESCRIPTION>Manufacturer ID (High Byte)</DESCRIPTION>
          <TEXT>These bits contain bits [15:8] of the 32-bit JEDEC manufacturer ID.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>MAN_ID_16</NAME>
          <DESCRIPTION>Manufacturer ID (High Byte)</DESCRIPTION>
          <TEXT>These bits contain bits [15:8] of the 32-bit JEDEC manufacturer ID.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>MAN_ID_15</NAME>
          <DESCRIPTION>Manufacturer ID (High Byte)</DESCRIPTION>
          <TEXT>These bits contain bits [15:8] of the 32-bit JEDEC manufacturer ID.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>MAN_ID_14</NAME>
          <DESCRIPTION>Manufacturer ID (High Byte)</DESCRIPTION>
          <TEXT>These bits contain bits [15:8] of the 32-bit JEDEC manufacturer ID.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>MAN_ID_13</NAME>
          <DESCRIPTION>Manufacturer ID (High Byte)</DESCRIPTION>
          <TEXT>These bits contain bits [15:8] of the 32-bit JEDEC manufacturer ID.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>MAN_ID_12</NAME>
          <DESCRIPTION>Manufacturer ID (High Byte)</DESCRIPTION>
          <TEXT>These bits contain bits [15:8] of the 32-bit JEDEC manufacturer ID.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>MAN_ID_11</NAME>
          <DESCRIPTION>Manufacturer ID (High Byte)</DESCRIPTION>
          <TEXT>These bits contain bits [15:8] of the 32-bit JEDEC manufacturer ID.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>MAN_ID_10</NAME>
          <DESCRIPTION>Manufacturer ID (High Byte)</DESCRIPTION>
          <TEXT>These bits contain bits [15:8] of the 32-bit JEDEC manufacturer ID.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>MAN_ID_1_BITF</ENUM>
        </BIT0>
      </MAN_ID_1>
      <SHORT_ADDR_0>
        <NAME>SHORT_ADDR_0</NAME>
        <DESCRIPTION>Transceiver MAC Short Address Register (Low Byte)</DESCRIPTION>
        <TEXT>This register contains the lower 8 bits of the MAC short address for Frame Filter address recognition.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$160</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SHORT_ADDR_07</NAME>
          <DESCRIPTION>MAC Short Address</DESCRIPTION>
          <TEXT>These bits contain the bits [7:0] of the MAC short address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SHORT_ADDR_06</NAME>
          <DESCRIPTION>MAC Short Address</DESCRIPTION>
          <TEXT>These bits contain the bits [7:0] of the MAC short address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SHORT_ADDR_05</NAME>
          <DESCRIPTION>MAC Short Address</DESCRIPTION>
          <TEXT>These bits contain the bits [7:0] of the MAC short address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SHORT_ADDR_04</NAME>
          <DESCRIPTION>MAC Short Address</DESCRIPTION>
          <TEXT>These bits contain the bits [7:0] of the MAC short address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SHORT_ADDR_03</NAME>
          <DESCRIPTION>MAC Short Address</DESCRIPTION>
          <TEXT>These bits contain the bits [7:0] of the MAC short address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SHORT_ADDR_02</NAME>
          <DESCRIPTION>MAC Short Address</DESCRIPTION>
          <TEXT>These bits contain the bits [7:0] of the MAC short address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SHORT_ADDR_01</NAME>
          <DESCRIPTION>MAC Short Address</DESCRIPTION>
          <TEXT>These bits contain the bits [7:0] of the MAC short address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SHORT_ADDR_00</NAME>
          <DESCRIPTION>MAC Short Address</DESCRIPTION>
          <TEXT>These bits contain the bits [7:0] of the MAC short address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT0>
      </SHORT_ADDR_0>
      <SHORT_ADDR_1>
        <NAME>SHORT_ADDR_1</NAME>
        <DESCRIPTION>Transceiver MAC Short Address Register (High Byte)</DESCRIPTION>
        <TEXT>This register contains the upper 8 bits of the MAC short address for Frame Filter address recognition.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$161</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SHORT_ADDR_17</NAME>
          <DESCRIPTION>MAC Short Address</DESCRIPTION>
          <TEXT>These bits contain the bits [15:8] of the MAC short address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SHORT_ADDR_16</NAME>
          <DESCRIPTION>MAC Short Address</DESCRIPTION>
          <TEXT>These bits contain the bits [15:8] of the MAC short address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SHORT_ADDR_15</NAME>
          <DESCRIPTION>MAC Short Address</DESCRIPTION>
          <TEXT>These bits contain the bits [15:8] of the MAC short address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SHORT_ADDR_14</NAME>
          <DESCRIPTION>MAC Short Address</DESCRIPTION>
          <TEXT>These bits contain the bits [15:8] of the MAC short address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SHORT_ADDR_13</NAME>
          <DESCRIPTION>MAC Short Address</DESCRIPTION>
          <TEXT>These bits contain the bits [15:8] of the MAC short address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SHORT_ADDR_12</NAME>
          <DESCRIPTION>MAC Short Address</DESCRIPTION>
          <TEXT>These bits contain the bits [15:8] of the MAC short address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SHORT_ADDR_11</NAME>
          <DESCRIPTION>MAC Short Address</DESCRIPTION>
          <TEXT>These bits contain the bits [15:8] of the MAC short address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SHORT_ADDR_10</NAME>
          <DESCRIPTION>MAC Short Address</DESCRIPTION>
          <TEXT>These bits contain the bits [15:8] of the MAC short address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT0>
      </SHORT_ADDR_1>
      <PAN_ID_0>
        <NAME>PAN_ID_0</NAME>
        <DESCRIPTION>Transceiver Personal Area Network ID Register (Low Byte)</DESCRIPTION>
        <TEXT>This register contains the lower 8 bits of the MAC PAN ID for Frame Filter address recognition.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$162</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>PAN_ID_07</NAME>
          <DESCRIPTION>MAC Personal Area Network ID</DESCRIPTION>
          <TEXT>These bits contain the bits [7:0] of the MAC PAN ID.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PAN_ID_06</NAME>
          <DESCRIPTION>MAC Personal Area Network ID</DESCRIPTION>
          <TEXT>These bits contain the bits [7:0] of the MAC PAN ID.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PAN_ID_05</NAME>
          <DESCRIPTION>MAC Personal Area Network ID</DESCRIPTION>
          <TEXT>These bits contain the bits [7:0] of the MAC PAN ID.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PAN_ID_04</NAME>
          <DESCRIPTION>MAC Personal Area Network ID</DESCRIPTION>
          <TEXT>These bits contain the bits [7:0] of the MAC PAN ID.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PAN_ID_03</NAME>
          <DESCRIPTION>MAC Personal Area Network ID</DESCRIPTION>
          <TEXT>These bits contain the bits [7:0] of the MAC PAN ID.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PAN_ID_02</NAME>
          <DESCRIPTION>MAC Personal Area Network ID</DESCRIPTION>
          <TEXT>These bits contain the bits [7:0] of the MAC PAN ID.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PAN_ID_01</NAME>
          <DESCRIPTION>MAC Personal Area Network ID</DESCRIPTION>
          <TEXT>These bits contain the bits [7:0] of the MAC PAN ID.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PAN_ID_00</NAME>
          <DESCRIPTION>MAC Personal Area Network ID</DESCRIPTION>
          <TEXT>These bits contain the bits [7:0] of the MAC PAN ID.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT0>
      </PAN_ID_0>
      <PAN_ID_1>
        <NAME>PAN_ID_1</NAME>
        <DESCRIPTION>Transceiver Personal Area Network ID Register (High Byte)</DESCRIPTION>
        <TEXT>This register contains the upper 8 bits of the MAC PAN ID for Frame Filter address recognition.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$163</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>PAN_ID_17</NAME>
          <DESCRIPTION>MAC Personal Area Network ID</DESCRIPTION>
          <TEXT>These bits contain the bits [15:8] of the MAC PAN ID.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PAN_ID_16</NAME>
          <DESCRIPTION>MAC Personal Area Network ID</DESCRIPTION>
          <TEXT>These bits contain the bits [15:8] of the MAC PAN ID.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PAN_ID_15</NAME>
          <DESCRIPTION>MAC Personal Area Network ID</DESCRIPTION>
          <TEXT>These bits contain the bits [15:8] of the MAC PAN ID.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PAN_ID_14</NAME>
          <DESCRIPTION>MAC Personal Area Network ID</DESCRIPTION>
          <TEXT>These bits contain the bits [15:8] of the MAC PAN ID.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PAN_ID_13</NAME>
          <DESCRIPTION>MAC Personal Area Network ID</DESCRIPTION>
          <TEXT>These bits contain the bits [15:8] of the MAC PAN ID.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PAN_ID_12</NAME>
          <DESCRIPTION>MAC Personal Area Network ID</DESCRIPTION>
          <TEXT>These bits contain the bits [15:8] of the MAC PAN ID.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PAN_ID_11</NAME>
          <DESCRIPTION>MAC Personal Area Network ID</DESCRIPTION>
          <TEXT>These bits contain the bits [15:8] of the MAC PAN ID.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PAN_ID_10</NAME>
          <DESCRIPTION>MAC Personal Area Network ID</DESCRIPTION>
          <TEXT>These bits contain the bits [15:8] of the MAC PAN ID.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT0>
      </PAN_ID_1>
      <IEEE_ADDR_0>
        <NAME>IEEE_ADDR_0</NAME>
        <DESCRIPTION>Transceiver MAC IEEE Address Register 0</DESCRIPTION>
        <TEXT>This register contains the bits [7:0] of the MAC IEEE address for Frame Filter address recognition.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$164</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>IEEE_ADDR_07</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [7:0] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>IEEE_ADDR_06</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [7:0] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>IEEE_ADDR_05</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [7:0] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>IEEE_ADDR_04</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [7:0] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>IEEE_ADDR_03</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [7:0] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>IEEE_ADDR_02</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [7:0] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>IEEE_ADDR_01</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [7:0] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>IEEE_ADDR_00</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [7:0] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </IEEE_ADDR_0>
      <IEEE_ADDR_1>
        <NAME>IEEE_ADDR_1</NAME>
        <DESCRIPTION>Transceiver MAC IEEE Address Register 1</DESCRIPTION>
        <TEXT>This register contains the bits [15:8] of the MAC IEEE address for Frame Filter address recognition.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$165</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>IEEE_ADDR_17</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [15:8] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>IEEE_ADDR_16</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [15:8] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>IEEE_ADDR_15</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [15:8] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>IEEE_ADDR_14</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [15:8] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>IEEE_ADDR_13</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [15:8] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>IEEE_ADDR_12</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [15:8] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>IEEE_ADDR_11</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [15:8] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>IEEE_ADDR_10</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [15:8] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </IEEE_ADDR_1>
      <IEEE_ADDR_2>
        <NAME>IEEE_ADDR_2</NAME>
        <DESCRIPTION>Transceiver MAC IEEE Address Register 2</DESCRIPTION>
        <TEXT>This register contains the bits [23:16] of the MAC IEEE address for Frame Filter address recognition.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$166</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>IEEE_ADDR_27</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [23:16] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>IEEE_ADDR_26</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [23:16] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>IEEE_ADDR_25</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [23:16] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>IEEE_ADDR_24</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [23:16] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>IEEE_ADDR_23</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [23:16] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>IEEE_ADDR_22</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [23:16] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>IEEE_ADDR_21</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [23:16] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>IEEE_ADDR_20</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [23:16] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </IEEE_ADDR_2>
      <IEEE_ADDR_3>
        <NAME>IEEE_ADDR_3</NAME>
        <DESCRIPTION>Transceiver MAC IEEE Address Register 3</DESCRIPTION>
        <TEXT>This register contains the bits [31:24] of the MAC IEEE address for Frame Filter address recognition.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$167</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>IEEE_ADDR_37</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [31:24] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>IEEE_ADDR_36</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [31:24] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>IEEE_ADDR_35</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [31:24] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>IEEE_ADDR_34</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [31:24] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>IEEE_ADDR_33</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [31:24] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>IEEE_ADDR_32</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [31:24] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>IEEE_ADDR_31</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [31:24] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>IEEE_ADDR_30</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [31:24] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </IEEE_ADDR_3>
      <IEEE_ADDR_4>
        <NAME>IEEE_ADDR_4</NAME>
        <DESCRIPTION>Transceiver MAC IEEE Address Register 4</DESCRIPTION>
        <TEXT>This register contains the bits [39:32] of the MAC IEEE address for Frame Filter address recognition.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$168</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>IEEE_ADDR_47</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [39:32] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>IEEE_ADDR_46</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [39:32] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>IEEE_ADDR_45</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [39:32] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>IEEE_ADDR_44</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [39:32] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>IEEE_ADDR_43</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [39:32] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>IEEE_ADDR_42</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [39:32] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>IEEE_ADDR_41</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [39:32] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>IEEE_ADDR_40</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [39:32] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </IEEE_ADDR_4>
      <IEEE_ADDR_5>
        <NAME>IEEE_ADDR_5</NAME>
        <DESCRIPTION>Transceiver MAC IEEE Address Register 5</DESCRIPTION>
        <TEXT>This register contains the bits [47:40] of the MAC IEEE address for Frame Filter address recognition.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$169</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>IEEE_ADDR_57</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [47:40] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>IEEE_ADDR_56</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [47:40] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>IEEE_ADDR_55</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [47:40] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>IEEE_ADDR_54</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [47:40] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>IEEE_ADDR_53</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [47:40] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>IEEE_ADDR_52</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [47:40] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>IEEE_ADDR_51</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [47:40] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>IEEE_ADDR_50</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [47:40] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </IEEE_ADDR_5>
      <IEEE_ADDR_6>
        <NAME>IEEE_ADDR_6</NAME>
        <DESCRIPTION>Transceiver MAC IEEE Address Register 6</DESCRIPTION>
        <TEXT>This register contains the bits [55:48] of the MAC IEEE address for Frame Filter address recognition.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$16A</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>IEEE_ADDR_67</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [55:48] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>IEEE_ADDR_66</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [55:48] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>IEEE_ADDR_65</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [55:48] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>IEEE_ADDR_64</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [55:48] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>IEEE_ADDR_63</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [55:48] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>IEEE_ADDR_62</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [55:48] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>IEEE_ADDR_61</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [55:48] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>IEEE_ADDR_60</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [55:48] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </IEEE_ADDR_6>
      <IEEE_ADDR_7>
        <NAME>IEEE_ADDR_7</NAME>
        <DESCRIPTION>Transceiver MAC IEEE Address Register 7</DESCRIPTION>
        <TEXT>This register contains the bits [63:56] of the MAC IEEE address for Frame Filter address recognition.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$16B</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>IEEE_ADDR_77</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [63:56] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>IEEE_ADDR_76</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [63:56] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>IEEE_ADDR_75</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [63:56] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>IEEE_ADDR_74</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [63:56] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>IEEE_ADDR_73</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [63:56] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>IEEE_ADDR_72</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [63:56] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>IEEE_ADDR_71</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [63:56] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>IEEE_ADDR_70</NAME>
          <DESCRIPTION>MAC IEEE Address</DESCRIPTION>
          <TEXT>These bits map to the bits [63:56] of the 64 bit MAC IEEE address.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </IEEE_ADDR_7>
      <XAH_CTRL_0>
        <NAME>XAH_CTRL_0</NAME>
        <DESCRIPTION>Transceiver Extended Operating Mode Control Register</DESCRIPTION>
        <TEXT>This register is used to control various settings of the Extended Operating Mode.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$16C</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>MAX_FRAME_RETRIES3</NAME>
          <DESCRIPTION>Maximum Number of Frame Re-transmission Attempts</DESCRIPTION>
          <TEXT>The setting of MAX_FRAME_RETRIES in TX_ARET mode specifies the number of attempts to retransmit a frame when it was not acknowledged by the recipient. The transaction gets canceled if the number of attempts exceeds MAX_FRAME_RETRIES.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>MAX_FRAME_RETRIES2</NAME>
          <DESCRIPTION>Maximum Number of Frame Re-transmission Attempts</DESCRIPTION>
          <TEXT>The setting of MAX_FRAME_RETRIES in TX_ARET mode specifies the number of attempts to retransmit a frame when it was not acknowledged by the recipient. The transaction gets canceled if the number of attempts exceeds MAX_FRAME_RETRIES.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>MAX_FRAME_RETRIES1</NAME>
          <DESCRIPTION>Maximum Number of Frame Re-transmission Attempts</DESCRIPTION>
          <TEXT>The setting of MAX_FRAME_RETRIES in TX_ARET mode specifies the number of attempts to retransmit a frame when it was not acknowledged by the recipient. The transaction gets canceled if the number of attempts exceeds MAX_FRAME_RETRIES.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>MAX_FRAME_RETRIES0</NAME>
          <DESCRIPTION>Maximum Number of Frame Re-transmission Attempts</DESCRIPTION>
          <TEXT>The setting of MAX_FRAME_RETRIES in TX_ARET mode specifies the number of attempts to retransmit a frame when it was not acknowledged by the recipient. The transaction gets canceled if the number of attempts exceeds MAX_FRAME_RETRIES.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
          <ENUM>MAX_FRAME_RETRIES_bitf</ENUM>
        </BIT4>
        <BIT3>
          <NAME>MAX_CSMA_RETRIES2</NAME>
          <DESCRIPTION>Maximum Number of CSMA-CA Procedure Repetition Attempts</DESCRIPTION>
          <TEXT>MAX_CSMA_RETRIES specifies the number of retries in TX_ARET mode to repeat the CSMA-CA procedure before the transaction gets canceled. According to IEEE 802.15.4 the valid range of MAX_CSMA_RETRIES is 0 to 5. A value of MAX_CSMA_RETRIES = 7 initiates an immediate frame transmission without performing CSMA-CA. This may especially be required for slotted acknowledgment operation. MAX_CSMA_RETRIES = 6 is reserved.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>MAX_CSMA_RETRIES1</NAME>
          <DESCRIPTION>Maximum Number of CSMA-CA Procedure Repetition Attempts</DESCRIPTION>
          <TEXT>MAX_CSMA_RETRIES specifies the number of retries in TX_ARET mode to repeat the CSMA-CA procedure before the transaction gets canceled. According to IEEE 802.15.4 the valid range of MAX_CSMA_RETRIES is 0 to 5. A value of MAX_CSMA_RETRIES = 7 initiates an immediate frame transmission without performing CSMA-CA. This may especially be required for slotted acknowledgment operation. MAX_CSMA_RETRIES = 6 is reserved.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>MAX_CSMA_RETRIES0</NAME>
          <DESCRIPTION>Maximum Number of CSMA-CA Procedure Repetition Attempts</DESCRIPTION>
          <TEXT>MAX_CSMA_RETRIES specifies the number of retries in TX_ARET mode to repeat the CSMA-CA procedure before the transaction gets canceled. According to IEEE 802.15.4 the valid range of MAX_CSMA_RETRIES is 0 to 5. A value of MAX_CSMA_RETRIES = 7 initiates an immediate frame transmission without performing CSMA-CA. This may especially be required for slotted acknowledgment operation. MAX_CSMA_RETRIES = 6 is reserved.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>MAX_CSMA_RETRIES_bitf</ENUM>
        </BIT1>
        <BIT0>
          <NAME>SLOTTED_OPERATION</NAME>
          <DESCRIPTION>Set Slotted Acknowledgment</DESCRIPTION>
          <TEXT>When using RX_AACK mode in networks operating in beacon or slotted mode according to IEEE 802.15.4-2006, chapter 5.5.1 the register bit SLOTTED_OPERATION indicates that acknowledgment frames are to be sent on back-off slot boundaries (slotted acknowledgment). If this register bit is set the acknowledgment frame transmission has to be initiated by the application software using bit SLPTR of register TRXPR. This waiting state is signaled in sub register TRAC_STATUS of register TRX_STATE with value SUCCESS_WAIT_FOR_ACK.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>SLOTTED_OPERATION_BITF</ENUM>
        </BIT0>
      </XAH_CTRL_0>
      <CSMA_SEED_0>
        <NAME>CSMA_SEED_0</NAME>
        <DESCRIPTION>Transceiver CSMA-CA Random Number Generator Seed Register</DESCRIPTION>
        <TEXT>This register contains the lower 8 bits of the CSMA_SEED. The upper 3 bits are part of register CSMA_SEED_1. CSMA_SEED is the seed for the random number generation that determines the length of the back-off period in the CSMA-CA algorithm. It is recommended to initialize registers CSMA_SEED by random values. This can be done using the bits RND_VALUE of register PHY_RSSI. Note: The register CSMA_SEED_0/1 content initializes the TX_ARET random backoff generator after the wakeup from TRX24 SLEEP state. To prevent a reinitialization with the same value it is recommended to reinitialize both register before every TRX24 SLEEP state with a random value.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$16D</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>CSMA_SEED_07</NAME>
          <DESCRIPTION>Seed Value for CSMA Random Number Generator</DESCRIPTION>
          <TEXT>These bits contain the bits [7:0] of the CSMA_SEED.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>CSMA_SEED_06</NAME>
          <DESCRIPTION>Seed Value for CSMA Random Number Generator</DESCRIPTION>
          <TEXT>These bits contain the bits [7:0] of the CSMA_SEED.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>CSMA_SEED_05</NAME>
          <DESCRIPTION>Seed Value for CSMA Random Number Generator</DESCRIPTION>
          <TEXT>These bits contain the bits [7:0] of the CSMA_SEED.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>CSMA_SEED_04</NAME>
          <DESCRIPTION>Seed Value for CSMA Random Number Generator</DESCRIPTION>
          <TEXT>These bits contain the bits [7:0] of the CSMA_SEED.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>CSMA_SEED_03</NAME>
          <DESCRIPTION>Seed Value for CSMA Random Number Generator</DESCRIPTION>
          <TEXT>These bits contain the bits [7:0] of the CSMA_SEED.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CSMA_SEED_02</NAME>
          <DESCRIPTION>Seed Value for CSMA Random Number Generator</DESCRIPTION>
          <TEXT>These bits contain the bits [7:0] of the CSMA_SEED.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CSMA_SEED_01</NAME>
          <DESCRIPTION>Seed Value for CSMA Random Number Generator</DESCRIPTION>
          <TEXT>These bits contain the bits [7:0] of the CSMA_SEED.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CSMA_SEED_00</NAME>
          <DESCRIPTION>Seed Value for CSMA Random Number Generator</DESCRIPTION>
          <TEXT>These bits contain the bits [7:0] of the CSMA_SEED.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </CSMA_SEED_0>
      <CSMA_SEED_1>
        <NAME>CSMA_SEED_1</NAME>
        <DESCRIPTION>Transceiver Acknowledgment Frame Control Register 2</DESCRIPTION>
        <TEXT>This register is a control register for RX_AACK and contains a part of the CSMA_SEED for the CSMA-CA algorithm.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$16E</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>AACK_FVN_MODE1</NAME>
          <DESCRIPTION>Acknowledgment Frame Filter Mode</DESCRIPTION>
          <TEXT>The frame control field of the MAC header (MHR) contains a frame version subfield. The setting of AACK_FVN_MODE specifies the frame filtering behavior of the radio transceiver. According to the content of these register bits the radio transceiver passes frames with a specific frame version number, number group or independent of the frame version number. Thus the register bits AACK_FVN_MODE define the maximum acceptable frame version. Received frames with a higher frame version number than configured do not pass the address filter and are not acknowledged.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>AACK_FVN_MODE0</NAME>
          <DESCRIPTION>Acknowledgment Frame Filter Mode</DESCRIPTION>
          <TEXT>The frame control field of the MAC header (MHR) contains a frame version subfield. The setting of AACK_FVN_MODE specifies the frame filtering behavior of the radio transceiver. According to the content of these register bits the radio transceiver passes frames with a specific frame version number, number group or independent of the frame version number. Thus the register bits AACK_FVN_MODE define the maximum acceptable frame version. Received frames with a higher frame version number than configured do not pass the address filter and are not acknowledged.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
          <ENUM>AACK_FVN_MODE_bitf</ENUM>
        </BIT6>
        <BIT5>
          <NAME>AACK_SET_PD</NAME>
          <DESCRIPTION>Set Frame Pending Sub-field</DESCRIPTION>
          <TEXT>The content of AACK_SET_PD bit is copied into the frame pending subfield of the acknowledgment frame if the acknowledgment is the answer to a data request MAC command frame. If in addition the bits AACK_FVN_MODE of this register are configured to accept frames with a frame version other than 0 or 1, the content of register bit AACK_SET_PD is also copied into the frame pending subfield of the acknowledgment frame for any MAC command frame with a frame version of 2 or 3 that have the security enabled subfield set to 1. This is done in the assumption that a future version of the IEEE 802.15.4 standard might change the length or structure of the auxiliary security header, so that it is not possible to safely detect whether the MAC command frame is actually a data request command or not.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>AACK_DIS_ACK</NAME>
          <DESCRIPTION>Disable Acknowledgment Frame Transmission</DESCRIPTION>
          <TEXT>If this bit is set no acknowledgment frames are transmitted in RX_AACK Extended Operating Mode even if requested.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>AACK_I_AM_COORD</NAME>
          <DESCRIPTION>Set Personal Area Network Coordinator</DESCRIPTION>
          <TEXT>This register bit has to be set if the node is a PAN coordinator. It is used for address filtering in RX_AACK.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CSMA_SEED_12</NAME>
          <DESCRIPTION>Seed Value for CSMA Random Number Generator</DESCRIPTION>
          <TEXT>These bits contain the bits [10:8] of the CSMA_SEED. The lower part is defined in register CSMA_SEED_0. See register CSMA_SEED_0 for details.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CSMA_SEED_11</NAME>
          <DESCRIPTION>Seed Value for CSMA Random Number Generator</DESCRIPTION>
          <TEXT>These bits contain the bits [10:8] of the CSMA_SEED. The lower part is defined in register CSMA_SEED_0. See register CSMA_SEED_0 for details.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CSMA_SEED_10</NAME>
          <DESCRIPTION>Seed Value for CSMA Random Number Generator</DESCRIPTION>
          <TEXT>These bits contain the bits [10:8] of the CSMA_SEED. The lower part is defined in register CSMA_SEED_0. See register CSMA_SEED_0 for details.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </CSMA_SEED_1>
      <CSMA_BE>
        <NAME>CSMA_BE</NAME>
        <DESCRIPTION>Transceiver CSMA-CA Back-off Exponent Control Register</DESCRIPTION>
        <TEXT>This register controls the back-off exponent for the CSMA-CA procedure.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$16F</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>MAX_BE3</NAME>
          <DESCRIPTION>Maximum Back-off Exponent</DESCRIPTION>
          <TEXT>These register bits define the maximum back-off exponent used in the CSMA-CA algorithm to generate a pseudo random number for back off the CCA. For details refer to IEEE 802.15.4-2006, section 7.5.1.4. Valid values are 3 to 8.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>MAX_BE2</NAME>
          <DESCRIPTION>Maximum Back-off Exponent</DESCRIPTION>
          <TEXT>These register bits define the maximum back-off exponent used in the CSMA-CA algorithm to generate a pseudo random number for back off the CCA. For details refer to IEEE 802.15.4-2006, section 7.5.1.4. Valid values are 3 to 8.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>MAX_BE1</NAME>
          <DESCRIPTION>Maximum Back-off Exponent</DESCRIPTION>
          <TEXT>These register bits define the maximum back-off exponent used in the CSMA-CA algorithm to generate a pseudo random number for back off the CCA. For details refer to IEEE 802.15.4-2006, section 7.5.1.4. Valid values are 3 to 8.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>MAX_BE0</NAME>
          <DESCRIPTION>Maximum Back-off Exponent</DESCRIPTION>
          <TEXT>These register bits define the maximum back-off exponent used in the CSMA-CA algorithm to generate a pseudo random number for back off the CCA. For details refer to IEEE 802.15.4-2006, section 7.5.1.4. Valid values are 3 to 8.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
          <ENUM>MAX_BE_bitf</ENUM>
        </BIT4>
        <BIT3>
          <NAME>MIN_BE3</NAME>
          <DESCRIPTION>Minimum Back-off Exponent</DESCRIPTION>
          <TEXT>These register bits define the minimum back-off exponent used in the CSMA-CA algorithm to generate a pseudo random number for back off the CCA. For details refer to IEEE 802.15.4-2006, section 7.5.1.4.  Valid values are MAX_BE, MAX_BE-1), ..., 0. If MIN_BE = 0 and MAX_BE = 0 the CCA back off period is always set to 0.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>MIN_BE2</NAME>
          <DESCRIPTION>Minimum Back-off Exponent</DESCRIPTION>
          <TEXT>These register bits define the minimum back-off exponent used in the CSMA-CA algorithm to generate a pseudo random number for back off the CCA. For details refer to IEEE 802.15.4-2006, section 7.5.1.4.  Valid values are MAX_BE, MAX_BE-1), ..., 0. If MIN_BE = 0 and MAX_BE = 0 the CCA back off period is always set to 0.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>MIN_BE1</NAME>
          <DESCRIPTION>Minimum Back-off Exponent</DESCRIPTION>
          <TEXT>These register bits define the minimum back-off exponent used in the CSMA-CA algorithm to generate a pseudo random number for back off the CCA. For details refer to IEEE 802.15.4-2006, section 7.5.1.4.  Valid values are MAX_BE, MAX_BE-1), ..., 0. If MIN_BE = 0 and MAX_BE = 0 the CCA back off period is always set to 0.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>MIN_BE0</NAME>
          <DESCRIPTION>Minimum Back-off Exponent</DESCRIPTION>
          <TEXT>These register bits define the minimum back-off exponent used in the CSMA-CA algorithm to generate a pseudo random number for back off the CCA. For details refer to IEEE 802.15.4-2006, section 7.5.1.4.  Valid values are MAX_BE, MAX_BE-1), ..., 0. If MIN_BE = 0 and MAX_BE = 0 the CCA back off period is always set to 0.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
          <ENUM>MIN_BE_bitf</ENUM>
        </BIT0>
      </CSMA_BE>
      <TST_CTRL_DIGI>
        <NAME>TST_CTRL_DIGI</NAME>
        <DESCRIPTION>Transceiver Digital Test Control Register</DESCRIPTION>
        <TEXT>This register takes part in the activation sequence of the continuous transmission test mode. Other functionality of this register is reserved for internal use.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$176</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT3>
          <NAME>TST_CTRL_DIG3</NAME>
          <DESCRIPTION>Digital Test Controller Register</DESCRIPTION>
          <TEXT>This sub-register selects a test controller function. All values not listed int the following table are reserved for internal use.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TST_CTRL_DIG2</NAME>
          <DESCRIPTION>Digital Test Controller Register</DESCRIPTION>
          <TEXT>This sub-register selects a test controller function. All values not listed int the following table are reserved for internal use.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TST_CTRL_DIG1</NAME>
          <DESCRIPTION>Digital Test Controller Register</DESCRIPTION>
          <TEXT>This sub-register selects a test controller function. All values not listed int the following table are reserved for internal use.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TST_CTRL_DIG0</NAME>
          <DESCRIPTION>Digital Test Controller Register</DESCRIPTION>
          <TEXT>This sub-register selects a test controller function. All values not listed int the following table are reserved for internal use.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>TST_CTRL_DIG_BITF</ENUM>
        </BIT0>
      </TST_CTRL_DIGI>
      <TST_RX_LENGTH>
        <NAME>TST_RX_LENGTH</NAME>
        <DESCRIPTION>Transceiver Received Frame Length Register</DESCRIPTION>
        <TEXT>This register contains the frame length information of a received frame. This information is not stored in the frame buffer. The frame length information is written to this register after the last received octet.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$17B</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>RX_LENGTH7</NAME>
          <DESCRIPTION>Received Frame Length</DESCRIPTION>
          <TEXT>These bits contain the length of the last received frame.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>RX_LENGTH6</NAME>
          <DESCRIPTION>Received Frame Length</DESCRIPTION>
          <TEXT>These bits contain the length of the last received frame.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>RX_LENGTH5</NAME>
          <DESCRIPTION>Received Frame Length</DESCRIPTION>
          <TEXT>These bits contain the length of the last received frame.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>RX_LENGTH4</NAME>
          <DESCRIPTION>Received Frame Length</DESCRIPTION>
          <TEXT>These bits contain the length of the last received frame.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>RX_LENGTH3</NAME>
          <DESCRIPTION>Received Frame Length</DESCRIPTION>
          <TEXT>These bits contain the length of the last received frame.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>RX_LENGTH2</NAME>
          <DESCRIPTION>Received Frame Length</DESCRIPTION>
          <TEXT>These bits contain the length of the last received frame.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>RX_LENGTH1</NAME>
          <DESCRIPTION>Received Frame Length</DESCRIPTION>
          <TEXT>These bits contain the length of the last received frame.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>RX_LENGTH0</NAME>
          <DESCRIPTION>Received Frame Length</DESCRIPTION>
          <TEXT>These bits contain the length of the last received frame.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TST_RX_LENGTH>
      <TRXFBST>
        <NAME>TRXFBST</NAME>
        <DESCRIPTION>Start of frame buffer</DESCRIPTION>
        <TEXT>First byte of the 128 byte long frame buffer of the TRX24.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$180</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TRXFBST7</NAME>
          <DESCRIPTION>Frame Buffer Start Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TRXFBST6</NAME>
          <DESCRIPTION>Frame Buffer Start Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TRXFBST5</NAME>
          <DESCRIPTION>Frame Buffer Start Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TRXFBST4</NAME>
          <DESCRIPTION>Frame Buffer Start Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TRXFBST3</NAME>
          <DESCRIPTION>Frame Buffer Start Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TRXFBST2</NAME>
          <DESCRIPTION>Frame Buffer Start Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TRXFBST1</NAME>
          <DESCRIPTION>Frame Buffer Start Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TRXFBST0</NAME>
          <DESCRIPTION>Frame Buffer Start Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TRXFBST>
      <TRXFBEND>
        <NAME>TRXFBEND</NAME>
        <DESCRIPTION>End of frame buffer</DESCRIPTION>
        <TEXT>This register is the last byte of the 128 byte long frame buffer of the radio transceiver.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$1FF</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TRXFBEND7</NAME>
          <DESCRIPTION>Frame Buffer End Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TRXFBEND6</NAME>
          <DESCRIPTION>Frame Buffer End Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TRXFBEND5</NAME>
          <DESCRIPTION>Frame Buffer End Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TRXFBEND4</NAME>
          <DESCRIPTION>Frame Buffer End Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TRXFBEND3</NAME>
          <DESCRIPTION>Frame Buffer End Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TRXFBEND2</NAME>
          <DESCRIPTION>Frame Buffer End Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TRXFBEND1</NAME>
          <DESCRIPTION>Frame Buffer End Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TRXFBEND0</NAME>
          <DESCRIPTION>Frame Buffer End Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TRXFBEND>
    </TRX24>
    <SYMCNT>
      <LIST>[SCOCR1HH:SCOCR1HL:SCOCR1LH:SCOCR1LL:SCOCR2HH:SCOCR2HL:SCOCR2LH:SCOCR2LL:SCOCR3HH:SCOCR3HL:SCOCR3LH:SCOCR3LL:SCTSRHH:SCTSRHL:SCTSRLH:SCTSRLL:SCBTSRHH:SCBTSRHL:SCBTSRLH:SCBTSRLL:SCCNTHH:SCCNTHL:SCCNTLH:SCCNTLL:SCCR0:SCCR1:SCSR:SCIRQS:SCIRQM]</LIST>
      <LINK/>
      <ICON>io_symcnt.bmp</ICON>
      <ID/>
      <TEXT/>
      <SCOCR1HH>
        <NAME>SCOCR1HH</NAME>
        <DESCRIPTION>Symbol Counter Output Compare Register 1 HH-Byte</DESCRIPTION>
        <TEXT>This register contains the most significant byte of the 32 bit compare value for the first compare unit</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$F8</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SCOCR1HH7</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 1 HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SCOCR1HH6</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 1 HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SCOCR1HH5</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 1 HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SCOCR1HH4</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 1 HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SCOCR1HH3</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 1 HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SCOCR1HH2</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 1 HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SCOCR1HH1</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 1 HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SCOCR1HH0</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 1 HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SCOCR1HH>
      <SCOCR1HL>
        <NAME>SCOCR1HL</NAME>
        <DESCRIPTION>Symbol Counter Output Compare Register 1 HL-Byte</DESCRIPTION>
        <TEXT>This register contains the second most significant byte of the 32 bit compare value for the first compare unit</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$F7</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SCOCR1HL7</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 1 HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SCOCR1HL6</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 1 HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SCOCR1HL5</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 1 HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SCOCR1HL4</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 1 HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SCOCR1HL3</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 1 HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SCOCR1HL2</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 1 HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SCOCR1HL1</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 1 HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SCOCR1HL0</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 1 HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SCOCR1HL>
      <SCOCR1LH>
        <NAME>SCOCR1LH</NAME>
        <DESCRIPTION>Symbol Counter Output Compare Register 1 LH-Byte</DESCRIPTION>
        <TEXT>This register contains the second least significant byte of the 32 bit compare value for the first compare unit</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$F6</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SCOCR1LH7</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 1 LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SCOCR1LH6</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 1 LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SCOCR1LH5</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 1 LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SCOCR1LH4</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 1 LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SCOCR1LH3</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 1 LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SCOCR1LH2</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 1 LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SCOCR1LH1</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 1 LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SCOCR1LH0</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 1 LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SCOCR1LH>
      <SCOCR1LL>
        <NAME>SCOCR1LL</NAME>
        <DESCRIPTION>Symbol Counter Output Compare Register 1 LL-Byte</DESCRIPTION>
        <TEXT>This register contains the least significant byte of the 32 bit compare value for the first compare unit</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$F5</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SCOCR1LL7</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 1 LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SCOCR1LL6</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 1 LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SCOCR1LL5</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 1 LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SCOCR1LL4</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 1 LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SCOCR1LL3</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 1 LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SCOCR1LL2</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 1 LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SCOCR1LL1</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 1 LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SCOCR1LL0</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 1 LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SCOCR1LL>
      <SCOCR2HH>
        <NAME>SCOCR2HH</NAME>
        <DESCRIPTION>Symbol Counter Output Compare Register 2 HH-Byte</DESCRIPTION>
        <TEXT>This register contains the most significant byte of the 32 bit compare value for the second compare unit</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$F4</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SCOCR2HH7</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 2 HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SCOCR2HH6</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 2 HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SCOCR2HH5</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 2 HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SCOCR2HH4</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 2 HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SCOCR2HH3</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 2 HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SCOCR2HH2</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 2 HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SCOCR2HH1</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 2 HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SCOCR2HH0</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 2 HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SCOCR2HH>
      <SCOCR2HL>
        <NAME>SCOCR2HL</NAME>
        <DESCRIPTION>Symbol Counter Output Compare Register 2 HL-Byte</DESCRIPTION>
        <TEXT>This register contains the second most significant byte of the 32 bit compare value for the second compare unit</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$F3</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SCOCR2HL7</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 2 HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SCOCR2HL6</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 2 HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SCOCR2HL5</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 2 HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SCOCR2HL4</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 2 HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SCOCR2HL3</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 2 HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SCOCR2HL2</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 2 HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SCOCR2HL1</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 2 HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SCOCR2HL0</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 2 HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SCOCR2HL>
      <SCOCR2LH>
        <NAME>SCOCR2LH</NAME>
        <DESCRIPTION>Symbol Counter Output Compare Register 2 LH-Byte</DESCRIPTION>
        <TEXT>This register contains the second least significant byte of the 32 bit compare value for the second compare unit</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$F2</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SCOCR2LH7</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 2 LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SCOCR2LH6</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 2 LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SCOCR2LH5</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 2 LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SCOCR2LH4</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 2 LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SCOCR2LH3</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 2 LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SCOCR2LH2</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 2 LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SCOCR2LH1</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 2 LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SCOCR2LH0</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 2 LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SCOCR2LH>
      <SCOCR2LL>
        <NAME>SCOCR2LL</NAME>
        <DESCRIPTION>Symbol Counter Output Compare Register 2 LL-Byte</DESCRIPTION>
        <TEXT>This register contains the least significant byte of the 32 bit compare value for the second compare unit</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$F1</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SCOCR2LL7</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 2 LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SCOCR2LL6</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 2 LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SCOCR2LL5</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 2 LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SCOCR2LL4</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 2 LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SCOCR2LL3</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 2 LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SCOCR2LL2</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 2 LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SCOCR2LL1</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 2 LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SCOCR2LL0</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 2 LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SCOCR2LL>
      <SCOCR3HH>
        <NAME>SCOCR3HH</NAME>
        <DESCRIPTION>Symbol Counter Output Compare Register 3 HH-Byte</DESCRIPTION>
        <TEXT>This register contains the most significant byte of the 32 bit compare value for the third compare unit</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$F0</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SCOCR3HH7</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 3 HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SCOCR3HH6</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 3 HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SCOCR3HH5</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 3 HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SCOCR3HH4</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 3 HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SCOCR3HH3</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 3 HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SCOCR3HH2</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 3 HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SCOCR3HH1</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 3 HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SCOCR3HH0</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 3 HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SCOCR3HH>
      <SCOCR3HL>
        <NAME>SCOCR3HL</NAME>
        <DESCRIPTION>Symbol Counter Output Compare Register 3 HL-Byte</DESCRIPTION>
        <TEXT>This register contains the second most significant byte of the 32 bit compare value for the third compare unit</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$EF</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SCOCR3HL7</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 3 HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SCOCR3HL6</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 3 HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SCOCR3HL5</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 3 HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SCOCR3HL4</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 3 HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SCOCR3HL3</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 3 HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SCOCR3HL2</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 3 HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SCOCR3HL1</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 3 HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SCOCR3HL0</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 3 HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SCOCR3HL>
      <SCOCR3LH>
        <NAME>SCOCR3LH</NAME>
        <DESCRIPTION>Symbol Counter Output Compare Register 3 LH-Byte</DESCRIPTION>
        <TEXT>This register contains the second least significant byte of the 32 bit compare value for the third compare unit</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$EE</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SCOCR3LH7</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 3 LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SCOCR3LH6</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 3 LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SCOCR3LH5</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 3 LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SCOCR3LH4</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 3 LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SCOCR3LH3</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 3 LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SCOCR3LH2</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 3 LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SCOCR3LH1</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 3 LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SCOCR3LH0</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 3 LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SCOCR3LH>
      <SCOCR3LL>
        <NAME>SCOCR3LL</NAME>
        <DESCRIPTION>Symbol Counter Output Compare Register 3 LL-Byte</DESCRIPTION>
        <TEXT>This register contains the least significant byte of the 32 bit compare value for the third compare unit</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$ED</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SCOCR3LL7</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 3 LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SCOCR3LL6</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 3 LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SCOCR3LL5</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 3 LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SCOCR3LL4</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 3 LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SCOCR3LL3</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 3 LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SCOCR3LL2</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 3 LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SCOCR3LL1</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 3 LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SCOCR3LL0</NAME>
          <DESCRIPTION>Symbol Counter Output Compare Register 3 LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SCOCR3LL>
      <SCTSRHH>
        <NAME>SCTSRHH</NAME>
        <DESCRIPTION>Symbol Counter Frame Timestamp Register HH-Byte</DESCRIPTION>
        <TEXT>This register contains the most significant byte of the 32 bit frame (SFD) timestamp register</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$EC</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SCTSRHH7</NAME>
          <DESCRIPTION>Symbol Counter Frame Timestamp Register HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SCTSRHH6</NAME>
          <DESCRIPTION>Symbol Counter Frame Timestamp Register HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SCTSRHH5</NAME>
          <DESCRIPTION>Symbol Counter Frame Timestamp Register HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SCTSRHH4</NAME>
          <DESCRIPTION>Symbol Counter Frame Timestamp Register HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SCTSRHH3</NAME>
          <DESCRIPTION>Symbol Counter Frame Timestamp Register HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SCTSRHH2</NAME>
          <DESCRIPTION>Symbol Counter Frame Timestamp Register HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SCTSRHH1</NAME>
          <DESCRIPTION>Symbol Counter Frame Timestamp Register HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SCTSRHH0</NAME>
          <DESCRIPTION>Symbol Counter Frame Timestamp Register HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SCTSRHH>
      <SCTSRHL>
        <NAME>SCTSRHL</NAME>
        <DESCRIPTION>Symbol Counter Frame Timestamp Register HL-Byte</DESCRIPTION>
        <TEXT>This register contains the second most significant byte of the 32 bit Frame (SFD) Timestamp Register</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$EB</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SCTSRHL7</NAME>
          <DESCRIPTION>Symbol Counter Frame Timestamp Register HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SCTSRHL6</NAME>
          <DESCRIPTION>Symbol Counter Frame Timestamp Register HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SCTSRHL5</NAME>
          <DESCRIPTION>Symbol Counter Frame Timestamp Register HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SCTSRHL4</NAME>
          <DESCRIPTION>Symbol Counter Frame Timestamp Register HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SCTSRHL3</NAME>
          <DESCRIPTION>Symbol Counter Frame Timestamp Register HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SCTSRHL2</NAME>
          <DESCRIPTION>Symbol Counter Frame Timestamp Register HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SCTSRHL1</NAME>
          <DESCRIPTION>Symbol Counter Frame Timestamp Register HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SCTSRHL0</NAME>
          <DESCRIPTION>Symbol Counter Frame Timestamp Register HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SCTSRHL>
      <SCTSRLH>
        <NAME>SCTSRLH</NAME>
        <DESCRIPTION>Symbol Counter Frame Timestamp Register LH-Byte</DESCRIPTION>
        <TEXT>This register contains the second least significant byte of the 32 bit Frame (SFD) Timestamp Register</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$EA</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SCTSRLH7</NAME>
          <DESCRIPTION>Symbol Counter Frame Timestamp Register LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SCTSRLH6</NAME>
          <DESCRIPTION>Symbol Counter Frame Timestamp Register LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SCTSRLH5</NAME>
          <DESCRIPTION>Symbol Counter Frame Timestamp Register LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SCTSRLH4</NAME>
          <DESCRIPTION>Symbol Counter Frame Timestamp Register LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SCTSRLH3</NAME>
          <DESCRIPTION>Symbol Counter Frame Timestamp Register LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SCTSRLH2</NAME>
          <DESCRIPTION>Symbol Counter Frame Timestamp Register LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SCTSRLH1</NAME>
          <DESCRIPTION>Symbol Counter Frame Timestamp Register LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SCTSRLH0</NAME>
          <DESCRIPTION>Symbol Counter Frame Timestamp Register LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SCTSRLH>
      <SCTSRLL>
        <NAME>SCTSRLL</NAME>
        <DESCRIPTION>Symbol Counter Frame Timestamp Register LL-Byte</DESCRIPTION>
        <TEXT>This register contains the least significant byte of the 32 bit Frame (SFD) Timestamp Register</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$E9</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SCTSRLL7</NAME>
          <DESCRIPTION>Symbol Counter Frame Timestamp Register LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SCTSRLL6</NAME>
          <DESCRIPTION>Symbol Counter Frame Timestamp Register LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SCTSRLL5</NAME>
          <DESCRIPTION>Symbol Counter Frame Timestamp Register LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SCTSRLL4</NAME>
          <DESCRIPTION>Symbol Counter Frame Timestamp Register LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SCTSRLL3</NAME>
          <DESCRIPTION>Symbol Counter Frame Timestamp Register LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SCTSRLL2</NAME>
          <DESCRIPTION>Symbol Counter Frame Timestamp Register LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SCTSRLL1</NAME>
          <DESCRIPTION>Symbol Counter Frame Timestamp Register LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SCTSRLL0</NAME>
          <DESCRIPTION>Symbol Counter Frame Timestamp Register LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SCTSRLL>
      <SCBTSRHH>
        <NAME>SCBTSRHH</NAME>
        <DESCRIPTION>Symbol Counter Beacon Timestamp Register HH-Byte</DESCRIPTION>
        <TEXT>This register contains the most significant byte of the 32 bit Beacon Timestamp Register. The Beacon Timestamp Register is updated with the contents of the Frame Timestamp Register if the received frame was a valid beacon frame with matching source PAN identifier or register {PAN_ID_1, PAN_ID_0} = 0xFFFF.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$E8</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SCBTSRHH7</NAME>
          <DESCRIPTION>Symbol Counter Beacon Timestamp Register HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SCBTSRHH6</NAME>
          <DESCRIPTION>Symbol Counter Beacon Timestamp Register HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SCBTSRHH5</NAME>
          <DESCRIPTION>Symbol Counter Beacon Timestamp Register HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SCBTSRHH4</NAME>
          <DESCRIPTION>Symbol Counter Beacon Timestamp Register HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SCBTSRHH3</NAME>
          <DESCRIPTION>Symbol Counter Beacon Timestamp Register HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SCBTSRHH2</NAME>
          <DESCRIPTION>Symbol Counter Beacon Timestamp Register HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SCBTSRHH1</NAME>
          <DESCRIPTION>Symbol Counter Beacon Timestamp Register HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SCBTSRHH0</NAME>
          <DESCRIPTION>Symbol Counter Beacon Timestamp Register HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SCBTSRHH>
      <SCBTSRHL>
        <NAME>SCBTSRHL</NAME>
        <DESCRIPTION>Symbol Counter Beacon Timestamp Register HL-Byte</DESCRIPTION>
        <TEXT>This register contains the second most significant byte of the 32 bit Beacon Timestamp Register.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$E7</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SCBTSRHL7</NAME>
          <DESCRIPTION>Symbol Counter Beacon Timestamp Register HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SCBTSRHL6</NAME>
          <DESCRIPTION>Symbol Counter Beacon Timestamp Register HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SCBTSRHL5</NAME>
          <DESCRIPTION>Symbol Counter Beacon Timestamp Register HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SCBTSRHL4</NAME>
          <DESCRIPTION>Symbol Counter Beacon Timestamp Register HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SCBTSRHL3</NAME>
          <DESCRIPTION>Symbol Counter Beacon Timestamp Register HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SCBTSRHL2</NAME>
          <DESCRIPTION>Symbol Counter Beacon Timestamp Register HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SCBTSRHL1</NAME>
          <DESCRIPTION>Symbol Counter Beacon Timestamp Register HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SCBTSRHL0</NAME>
          <DESCRIPTION>Symbol Counter Beacon Timestamp Register HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SCBTSRHL>
      <SCBTSRLH>
        <NAME>SCBTSRLH</NAME>
        <DESCRIPTION>Symbol Counter Beacon Timestamp Register LH-Byte</DESCRIPTION>
        <TEXT>This register contains the second least significant byte of the 32 bit Beacon Timestamp Register.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$E6</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SCBTSRLH7</NAME>
          <DESCRIPTION>Symbol Counter Beacon Timestamp Register LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SCBTSRLH6</NAME>
          <DESCRIPTION>Symbol Counter Beacon Timestamp Register LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SCBTSRLH5</NAME>
          <DESCRIPTION>Symbol Counter Beacon Timestamp Register LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SCBTSRLH4</NAME>
          <DESCRIPTION>Symbol Counter Beacon Timestamp Register LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SCBTSRLH3</NAME>
          <DESCRIPTION>Symbol Counter Beacon Timestamp Register LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SCBTSRLH2</NAME>
          <DESCRIPTION>Symbol Counter Beacon Timestamp Register LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SCBTSRLH1</NAME>
          <DESCRIPTION>Symbol Counter Beacon Timestamp Register LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SCBTSRLH0</NAME>
          <DESCRIPTION>Symbol Counter Beacon Timestamp Register LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SCBTSRLH>
      <SCBTSRLL>
        <NAME>SCBTSRLL</NAME>
        <DESCRIPTION>Symbol Counter Beacon Timestamp Register LL-Byte</DESCRIPTION>
        <TEXT>This register contains the least significant byte of the 32 bit Beacon Timestamp Register.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$E5</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SCBTSRLL7</NAME>
          <DESCRIPTION>Symbol Counter Beacon Timestamp Register LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SCBTSRLL6</NAME>
          <DESCRIPTION>Symbol Counter Beacon Timestamp Register LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SCBTSRLL5</NAME>
          <DESCRIPTION>Symbol Counter Beacon Timestamp Register LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SCBTSRLL4</NAME>
          <DESCRIPTION>Symbol Counter Beacon Timestamp Register LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SCBTSRLL3</NAME>
          <DESCRIPTION>Symbol Counter Beacon Timestamp Register LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SCBTSRLL2</NAME>
          <DESCRIPTION>Symbol Counter Beacon Timestamp Register LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SCBTSRLL1</NAME>
          <DESCRIPTION>Symbol Counter Beacon Timestamp Register LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SCBTSRLL0</NAME>
          <DESCRIPTION>Symbol Counter Beacon Timestamp Register LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SCBTSRLL>
      <SCCNTHH>
        <NAME>SCCNTHH</NAME>
        <DESCRIPTION>Symbol Counter Register HH-Byte</DESCRIPTION>
        <TEXT>This register contains the most significant byte of the 32 bit Symbol Counter.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$E4</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SCCNTHH7</NAME>
          <DESCRIPTION>Symbol Counter Register HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SCCNTHH6</NAME>
          <DESCRIPTION>Symbol Counter Register HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SCCNTHH5</NAME>
          <DESCRIPTION>Symbol Counter Register HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SCCNTHH4</NAME>
          <DESCRIPTION>Symbol Counter Register HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SCCNTHH3</NAME>
          <DESCRIPTION>Symbol Counter Register HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SCCNTHH2</NAME>
          <DESCRIPTION>Symbol Counter Register HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SCCNTHH1</NAME>
          <DESCRIPTION>Symbol Counter Register HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SCCNTHH0</NAME>
          <DESCRIPTION>Symbol Counter Register HH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SCCNTHH>
      <SCCNTHL>
        <NAME>SCCNTHL</NAME>
        <DESCRIPTION>Symbol Counter Register HL-Byte</DESCRIPTION>
        <TEXT>This register contains the second most significant byte of the 32 bit Symbol Counter.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$E3</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SCCNTHL7</NAME>
          <DESCRIPTION>Symbol Counter Register HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SCCNTHL6</NAME>
          <DESCRIPTION>Symbol Counter Register HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SCCNTHL5</NAME>
          <DESCRIPTION>Symbol Counter Register HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SCCNTHL4</NAME>
          <DESCRIPTION>Symbol Counter Register HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SCCNTHL3</NAME>
          <DESCRIPTION>Symbol Counter Register HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SCCNTHL2</NAME>
          <DESCRIPTION>Symbol Counter Register HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SCCNTHL1</NAME>
          <DESCRIPTION>Symbol Counter Register HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SCCNTHL0</NAME>
          <DESCRIPTION>Symbol Counter Register HL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SCCNTHL>
      <SCCNTLH>
        <NAME>SCCNTLH</NAME>
        <DESCRIPTION>Symbol Counter Register LH-Byte</DESCRIPTION>
        <TEXT>This register contains the second least significant byte of the 32 bit Symbol Counter.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$E2</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SCCNTLH7</NAME>
          <DESCRIPTION>Symbol Counter Register LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SCCNTLH6</NAME>
          <DESCRIPTION>Symbol Counter Register LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SCCNTLH5</NAME>
          <DESCRIPTION>Symbol Counter Register LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SCCNTLH4</NAME>
          <DESCRIPTION>Symbol Counter Register LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SCCNTLH3</NAME>
          <DESCRIPTION>Symbol Counter Register LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SCCNTLH2</NAME>
          <DESCRIPTION>Symbol Counter Register LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SCCNTLH1</NAME>
          <DESCRIPTION>Symbol Counter Register LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SCCNTLH0</NAME>
          <DESCRIPTION>Symbol Counter Register LH-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SCCNTLH>
      <SCCNTLL>
        <NAME>SCCNTLL</NAME>
        <DESCRIPTION>Symbol Counter Register LL-Byte</DESCRIPTION>
        <TEXT>This register contains the least significant byte of the 32 bit Symbol Counter.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$E1</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SCCNTLL7</NAME>
          <DESCRIPTION>Symbol Counter Register LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SCCNTLL6</NAME>
          <DESCRIPTION>Symbol Counter Register LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SCCNTLL5</NAME>
          <DESCRIPTION>Symbol Counter Register LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SCCNTLL4</NAME>
          <DESCRIPTION>Symbol Counter Register LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SCCNTLL3</NAME>
          <DESCRIPTION>Symbol Counter Register LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SCCNTLL2</NAME>
          <DESCRIPTION>Symbol Counter Register LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SCCNTLL1</NAME>
          <DESCRIPTION>Symbol Counter Register LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SCCNTLL0</NAME>
          <DESCRIPTION>Symbol Counter Register LL-Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SCCNTLL>
      <SCIRQS>
        <NAME>SCIRQS</NAME>
        <DESCRIPTION>Symbol Counter Interrupt Status Register</DESCRIPTION>
        <TEXT>The Interrupt Status Register indicates pending interrupt requests. If the corresponding interrupt mask bit is set, an interrupt service routine is called and the status bit is cleared automatically. It is also possible to clear the status bit by writing "1" to the selected bit.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$E0</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>Res2</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. The result of a read access is undefined. The register bit must always be written with the reset value.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. The result of a read access is undefined. The register bit must always be written with the reset value.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. The result of a read access is undefined. The register bit must always be written with the reset value.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>IRQSBO</NAME>
          <DESCRIPTION>Backoff Slot Counter IRQ</DESCRIPTION>
          <TEXT>This interrupt is generated every 320 &#xB5;s, that means every 20 symbols.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>IRQSOF</NAME>
          <DESCRIPTION>Symbol Counter Overflow IRQ</DESCRIPTION>
          <TEXT>This interrupt is generated when the 32 bit counter turns from 0xFFFFFFF to 0x00000000.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>IRQSCP3</NAME>
          <DESCRIPTION> Compare Unit 3 Compare Match IRQ</DESCRIPTION>
          <TEXT>This interrupt indicates a compare match on compare unit 3.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>IRQSCP2</NAME>
          <DESCRIPTION> Compare Unit 2 Compare Match IRQ</DESCRIPTION>
          <TEXT>This interrupt indicates a compare match on compare unit 2.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>IRQSCP1</NAME>
          <DESCRIPTION> Compare Unit 1 Compare Match IRQ</DESCRIPTION>
          <TEXT>This interrupt indicates a compare match on compare unit 1.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SCIRQS>
      <SCIRQM>
        <NAME>SCIRQM</NAME>
        <DESCRIPTION>Symbol Counter Interrupt Mask Register</DESCRIPTION>
        <TEXT>The Interrupt Mask Register is used to enable corresponding interrupts. After reset all interrupts are disabled. Disabled interrupts are still captured in the interrupt status register SCIRQS, but no interrupt is requested. Before enabling an interrupt, the corresponding interrupt status bit should be cleared by writing a 1. If the status bit is set and the IRQ gets enabled, the IRQ handler is called immediatly.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$DF</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>Res2</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. The result of a read access is undefined. The register bit must always be written with the reset value.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. The result of a read access is undefined. The register bit must always be written with the reset value.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. The result of a read access is undefined. The register bit must always be written with the reset value.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>IRQMBO</NAME>
          <DESCRIPTION>Backoff Slot Counter IRQ enable</DESCRIPTION>
          <TEXT>This bit enables the SCNT_BACKOFF interrupt.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>IRQMOF</NAME>
          <DESCRIPTION>Symbol Counter Overflow IRQ enable</DESCRIPTION>
          <TEXT>This bit enables the SCNT_OVFL interrupt.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>IRQMCP3</NAME>
          <DESCRIPTION>Symbol Counter Compare Match 3 IRQ enable</DESCRIPTION>
          <TEXT>This bit enables the SCNT_CMP3 interrupt.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>IRQMCP2</NAME>
          <DESCRIPTION>Symbol Counter Compare Match 2 IRQ enable</DESCRIPTION>
          <TEXT>This bit enables the SCNT_CMP2 interrupt.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>IRQMCP1</NAME>
          <DESCRIPTION>Symbol Counter Compare Match 1 IRQ enable</DESCRIPTION>
          <TEXT>This bit enables the SCNT_CMP1 interrupt.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SCIRQM>
      <SCSR>
        <NAME>SCSR</NAME>
        <DESCRIPTION>Symbol Counter Status Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$DE</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>Res6</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. The result of a read access is undefined. The register bit must always be written with the reset value.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res5</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. The result of a read access is undefined. The register bit must always be written with the reset value.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>Res4</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. The result of a read access is undefined. The register bit must always be written with the reset value.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res3</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. The result of a read access is undefined. The register bit must always be written with the reset value.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>Res2</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. The result of a read access is undefined. The register bit must always be written with the reset value.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. The result of a read access is undefined. The register bit must always be written with the reset value.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. The result of a read access is undefined. The register bit must always be written with the reset value.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SCBSY</NAME>
          <DESCRIPTION>Symbol Counter busy</DESCRIPTION>
          <TEXT>This bit is set if a write operation to the symbol counter register is pending. This bit is set after writing the counter low byte (SCCNTLL) until the symbol counter is updated with the new value. This update process can take up to 16 &#xB5;s and during this time no read or write access to the 32 bit counter register should occure.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SCSR>
      <SCCR1>
        <NAME>SCCR1</NAME>
        <DESCRIPTION>Symbol Counter Control Register 1</DESCRIPTION>
        <TEXT>This register is used to enable the backoff slot counter.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$DD</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>Res6</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. The result of a read access is undefined. The register bit must always be written with the reset value.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res5</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. The result of a read access is undefined. The register bit must always be written with the reset value.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>Res4</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. The result of a read access is undefined. The register bit must always be written with the reset value.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res3</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. The result of a read access is undefined. The register bit must always be written with the reset value.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>Res2</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. The result of a read access is undefined. The register bit must always be written with the reset value.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. The result of a read access is undefined. The register bit must always be written with the reset value.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. The result of a read access is undefined. The register bit must always be written with the reset value.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SCENBO</NAME>
          <DESCRIPTION>Backoff Slot Counter enable</DESCRIPTION>
          <TEXT> If this bit is set, the backoff slot counter starts working. To enable the corresponding IRQ the SCIRQM register must be updated.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SCCR1>
      <SCCR0>
        <NAME>SCCR0</NAME>
        <DESCRIPTION>Symbol Counter Control Register 0</DESCRIPTION>
        <TEXT>The Control Register 0 is used to setup the operating mode of the symbol counter and the compare units</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$DC</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SCRES</NAME>
          <DESCRIPTION>Symbol Counter Synchronization</DESCRIPTION>
          <TEXT>If this bit is set to 1, the 16 MHz clock prescaler as well as the backoff slot counter is cleared. This function can be used to align the symbol timing within one 16 &#xB5;s symbol period and to restart the backoff slot counter with a complete 320 &#xB5;s period. This feature works only if the symbol counter module operates with the 16 MHz clock from XTAL1. After switching to RTC clock source, the symbol period synchronization is lost. This bit is cleared automatically.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SCMBTS</NAME>
          <DESCRIPTION>Manual Beacon Timestamp</DESCRIPTION>
          <TEXT>With this bit a manual beacon timestamp can be generated. If set to 1, the current symbol counter value is stored into the beacon timestamp register. The bit is cleared afterwards. The manual beacon timestamping can be used in conjunction with the relative compare mode of the three compare units to generate compare match interrupts without having a beacon frame received.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SCEN</NAME>
          <DESCRIPTION>Symbol Counter enable</DESCRIPTION>
          <TEXT>This bit activates the symbol counter module. If the bit is not set, the counter, backoff slot counter and the compare unit are disabled and disconnected from the clock. In this way the power consumption can be reduced. All registers can be accessed, but write access to the counter register SCCNT is not possible.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SCCKSEL</NAME>
          <DESCRIPTION>Symbol Counter Clock Source select</DESCRIPTION>
          <TEXT>With this bit the clock source for the symbol counter can be selected.  If the bit is one, the RTC clock from TOSC1 is selected, otherwise the symbol counter operates with the clock from XTAL1. During transceiver sleep modes the clock falls back to the RTC clock source, regardless of the selected clock. After wakeup, it switches back to the previosly selected clock source.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SCTSE</NAME>
          <DESCRIPTION>Symbol Counter Automatic Timestamping enable</DESCRIPTION>
          <TEXT>This bit enables automatic SFD and Beacon Timestamping. If the bit is zero, no automatic timestamp capturing is possible. Only manual beacon timestamping can be used.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SCCMP3</NAME>
          <DESCRIPTION>Symbol Counter Compare Unit 3 Mode select</DESCRIPTION>
          <TEXT>This bit enables the relative compare mode for compare unit 3. If enabled, the counter value is compared against the content of the beacon timestamp register plus the content of the compare register 3 (SCCNT == SCBTS+SCOCR3). Otherwise, the counter is compared against the compare register 3 (SCCNT == SCOCR3).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SCCMP2</NAME>
          <DESCRIPTION>Symbol Counter Compare Unit 2 Mode select</DESCRIPTION>
          <TEXT>This bit enables the relative compare mode for compare unit 2. If enabled, the counter value is compared against the content of the beacon timestamp register plus the content of the compare register 2 (SCCNT == SCBTS+SCOCR2). Otherwise, the counter is compared against the compare register 2 (SCCNT == SCOCR2).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SCCMP1</NAME>
          <DESCRIPTION>Symbol Counter Compare Unit 1 Mode select</DESCRIPTION>
          <TEXT>This bit enables the relative compare mode for compare unit 1. If enabled, the counter value is compared against the content of the beacon timestamp register plus the content of the compare register 1 (SCCNT == SCBTS+SCOCR1). Otherwise, the counter is compared against the compare register 1 (SCCNT == SCOCR1).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SCCR0>
    </SYMCNT>
    <EEPROM>
      <LIST>[EEARH:EEARL:EEDR:EECR]</LIST>
      <LINK/>
      <ICON>io_cpu.bmp</ICON>
      <ID/>
      <TEXT>The EEPROM is the nonvolatile data memory of the device. It is organized as a separate data space, in which single bytes can be read and written. The EEPROM Access Registers are accessible in the I/O space. A self-timing function lets the user software detect when the next byte can be written. If the user code contains instructions that write the EEPROM, some precautions must be taken. In order to prevent unintentional EEPROM writes, a specific write procedure must be followed. When the EEPROM is read, the CPU is halted for four clock cycles before the next instruction is executed. When the EEPROM is written, the CPU is halted for two clock cycles before the next instruction is executed. The calibrated Oscillator is used to time the EEPROM accesses.</TEXT>
      <EEARH>
        <NAME>EEARH</NAME>
        <DESCRIPTION>EEPROM Address Register High Byte</DESCRIPTION>
        <TEXT>The EEPROM Address Registers  EEARH and EEARL specify the EEPROM address in the 4K bytes EEPROM space. The EEPROM data bytes are addressed linearly between 0 and 4096. The initial value of EEAR is undefined. A proper value must be written before the EEPROM may be accessed.</TEXT>
        <IO_ADDR>$22</IO_ADDR>
        <MEM_ADDR>$42</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>Res3</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res2</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>EEAR11</NAME>
          <DESCRIPTION>EEPROM Address</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>EEAR10</NAME>
          <DESCRIPTION>EEPROM Address</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>EEAR9</NAME>
          <DESCRIPTION>EEPROM Address</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>EEAR8</NAME>
          <DESCRIPTION>EEPROM Address</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
          <ENUM>EEPROM_ADDRESS_BITF</ENUM>
        </BIT0>
      </EEARH>
      <EEARL>
        <NAME>EEARL</NAME>
        <DESCRIPTION>EEPROM Address Register Low Byte</DESCRIPTION>
        <TEXT>The EEPROM Address Registers  EEARH and EEARL specify the EEPROM address in the 4K bytes EEPROM space. The EEPROM data bytes are addressed linearly between 0 and 4096. The initial value of EEAR is undefined. A proper value must be written before the EEPROM may be accessed.</TEXT>
        <IO_ADDR>$21</IO_ADDR>
        <MEM_ADDR>$41</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>EEAR7</NAME>
          <DESCRIPTION>EEPROM Address</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>EEAR6</NAME>
          <DESCRIPTION>EEPROM Address</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>EEAR5</NAME>
          <DESCRIPTION>EEPROM Address</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>EEAR4</NAME>
          <DESCRIPTION>EEPROM Address</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>EEAR3</NAME>
          <DESCRIPTION>EEPROM Address</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>EEAR2</NAME>
          <DESCRIPTION>EEPROM Address</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>EEAR1</NAME>
          <DESCRIPTION>EEPROM Address</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>EEAR0</NAME>
          <DESCRIPTION>EEPROM Address</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
          <ENUM>EEPROM_ADDRESS_BITF</ENUM>
        </BIT0>
      </EEARL>
      <EEDR>
        <NAME>EEDR</NAME>
        <DESCRIPTION>EEPROM Data Register</DESCRIPTION>
        <TEXT>For the EEPROM write operation, the EEDR Register contains the data to be written to the EEPROM in the address given by the EEAR Register. For the EEPROM read operation, the EEDR contains the data read out from the EEPROM at the address given by EEAR.</TEXT>
        <IO_ADDR>$20</IO_ADDR>
        <MEM_ADDR>$40</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>EEDR7</NAME>
          <DESCRIPTION>EEPROM Data</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>EEDR6</NAME>
          <DESCRIPTION>EEPROM Data</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>EEDR5</NAME>
          <DESCRIPTION>EEPROM Data</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>EEDR4</NAME>
          <DESCRIPTION>EEPROM Data</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>EEDR3</NAME>
          <DESCRIPTION>EEPROM Data</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>EEDR2</NAME>
          <DESCRIPTION>EEPROM Data</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>EEDR1</NAME>
          <DESCRIPTION>EEPROM Data</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>EEDR0</NAME>
          <DESCRIPTION>EEPROM Data</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>EEPROM_DATA_BITF</ENUM>
        </BIT0>
      </EEDR>
      <EECR>
        <NAME>EECR</NAME>
        <DESCRIPTION>EEPROM Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$1F</IO_ADDR>
        <MEM_ADDR>$3F</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>EEPM1</NAME>
          <DESCRIPTION>EEPROM Programming Mode</DESCRIPTION>
          <TEXT>The EEPROM Programming mode bit setting defines which programming action will be triggered when writing EEPE. It is possible to program data in one atomic operation (erase the old value and program the new value) or to split the Erase and Write operations in two different operations. While EEPE is set, any write to EEPM1:0 will be ignored. During reset, the EEPM1:0 bits will be reset to 0 unless the EEPROM is busy programming.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>EEPM0</NAME>
          <DESCRIPTION>EEPROM Programming Mode</DESCRIPTION>
          <TEXT>The EEPROM Programming mode bit setting defines which programming action will be triggered when writing EEPE. It is possible to program data in one atomic operation (erase the old value and program the new value) or to split the Erase and Write operations in two different operations. While EEPE is set, any write to EEPM1:0 will be ignored. During reset, the EEPM1:0 bits will be reset to 0 unless the EEPROM is busy programming.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>EEP_MODE2</ENUM>
          <INIT_VAL>X</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>EERIE</NAME>
          <DESCRIPTION>EEPROM Ready Interrupt Enable</DESCRIPTION>
          <TEXT>Writing EERIE to one enables the EEPROM Ready Interrupt if the I bit in SREG is set. Writing EERIE to zero disables the interrupt. The EEPROM Ready interrupt generates a constant interrupt when EEPE is cleared.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>EEMPE</NAME>
          <DESCRIPTION>EEPROM Master Write Enable</DESCRIPTION>
          <TEXT>The EEMPE bit determines whether setting EEPE to one causes the EEPROM to be written. When EEMPE is set, setting EEPE within four clock cycles will write data to the EEPROM at the selected address If EEMPE is zero, setting EEPE will have no effect. When EEMPE has been written to one by software, hardware clears the bit to zero after four clock cycles. See the description of the EEPE bit for an EEPROM write procedure.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>EEPE</NAME>
          <DESCRIPTION>EEPROM Programming Enable</DESCRIPTION>
          <TEXT>The EEPROM Write Enable Signal EEPE is the write strobe to the EEPROM. When address and data are correctly set up, the EEPE bit must be written to one to write the value into the EEPROM. The EEMPE bit must be written to one before a logical one is written to EEPE, otherwise no EEPROM write takes place. The following procedure should be adopted when writing the EEPROM (the order of steps 3 and 4 is not essential):
1. Wait until EEPE becomes zero.
2. Wait until SPMEN in SPMCSR becomes zero.
3. Write new EEPROM address to EEAR (optional).
4. Write new EEPROM data to EEDR (optional).
5. Write a logical one to the EEMPE bit while writing a zero to EEPE in EECR.
6. Within four clock cycles after setting EEMPE, write a logical one to EEPE.
The EEPROM can not be programmed during a CPU write to the Flash memory. The software must check that the Flash programming is completed before initiating a new EEPROM write. Step 2 is only relevant if the software contains a Boot Loader allowing the CPU to program the Flash. If the Flash is never being updated by the CPU, step 2 can be omitted.
Caution: an interrupt between step 5 and step 6 will make the write cycle fail, since the EEPROM Master Write Enable will time-out. If an interrupt routine accessing the EEPROM is interrupting another EEPROM access, the EEAR or EEDR Register will be modified, causing the interrupted EEPROM access to fail. It is recommended to have the Global Interrupt Flag cleared during all steps to avoid these problems.
When the write access time has elapsed, the EEPE bit is cleared by hardware. The user software can poll this bit and wait for a zero before writing the next byte. When EEPE has been set, the CPU is halted for two cycles before the next instruction is executed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>EERE</NAME>
          <DESCRIPTION>EEPROM Read Enable</DESCRIPTION>
          <TEXT>The EEPROM Read Enable Signal EERE is the read strobe to the EEPROM. When the correct address is set up in the EEAR Register, the EERE bit must be written to a logic one to trigger the EEPROM read. The EEPROM read access takes one instruction and the requested data is available immediately. When the EEPROM is read, the CPU is halted for four cycles before the next instruction is executed. The user should poll the EEPE bit before starting the read operation. If a write operation is in progress, it is neither possible to read the EEPROM nor to change the EEAR Register.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </EECR>
    </EEPROM>
    <JTAG>
      <LIST>[OCDR:MCUCR:MCUSR]</LIST>
      <LINK/>
      <RULES/>
      <ICON>io_com.bmp</ICON>
      <ID>00</ID>
      <TEXT>The AVR IEEE std. 1149.1 compliant JTAG interface can be used for Testing PCBs by using the JTAG Boundary-scan capability, Programming the non-volatile memories, Fuses and Lock bits and On-chip debugging. Its main features are: Boundary-scan Capabilities According to the IEEE std. 1149.1 (JTAG) Standard; Debugger Access to all Internal Peripheral Units, the internal and external RAM, the Internal Register File, the Program Counter and the EEPROM and Flash Memories; Extensive On-chip Debug Support for Break Conditions, Including AVR Break Instruction, Break on Change of Program Memory Flow, Single Step Break, Program Memory Break Points on Single Address or Address Range and Data Memory Break Points on Single Address or Address Range; Programming of Flash, EEPROM, Fuses, and Lock Bits through the JTAG Interface; On-chip Debugging Supported by AVR Studio.</TEXT>
      <OCDR>
        <NAME>OCDR</NAME>
        <DESCRIPTION>On-Chip Debug Register</DESCRIPTION>
        <TEXT>The OCDR Register provides a communication channel from the running program in the microcontroller to the debugger. The CPU can transfer a byte to the debugger by writing to this location. At the same time, an internal flag; I/O Debug Register Dirty  IDRD  is set to indicate to the debugger that the register has been written. When the CPU reads the OCDR Register the 7 LSB will be from the OCDR Register, while the MSB is the IDRD bit. The debugger clears the IDRD bit when it has read the information. In some AVR devices, this register is shared with a standard I/O location. In this case, the OCDR Register can only be accessed if the OCDEN Fuse is programmed, and the debugger enables access to the OCDR Register. In all other cases, the standard I/O location is accessed.</TEXT>
        <IO_ADDR>$31</IO_ADDR>
        <MEM_ADDR>$51</MEM_ADDR>
        <READ_INTRUSIVE/>
        <WRITE_INTRUSIVE/>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>OCDR7</NAME>
          <ALIAS>IDRD</ALIAS>
          <DESCRIPTION>On-Chip Debug Register Data</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCDR6</NAME>
          <DESCRIPTION>On-Chip Debug Register Data</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCDR5</NAME>
          <DESCRIPTION>On-Chip Debug Register Data</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCDR4</NAME>
          <DESCRIPTION>On-Chip Debug Register Data</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCDR3</NAME>
          <DESCRIPTION>On-Chip Debug Register Data</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCDR2</NAME>
          <DESCRIPTION>On-Chip Debug Register Data</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCDR1</NAME>
          <DESCRIPTION>On-Chip Debug Register Data</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCDR0</NAME>
          <DESCRIPTION>On-Chip Debug Register Data</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>OCDR_DATA_BITF</ENUM>
        </BIT0>
      </OCDR>
      <MCUCR>
        <NAME>MCUCR</NAME>
        <DESCRIPTION>MCU Control Register</DESCRIPTION>
        <TEXT>The MCU Control Register contains control bits for general Microcontroller Unit functions.</TEXT>
        <IO_ADDR>$35</IO_ADDR>
        <MEM_ADDR>$55</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>JTD</NAME>
          <DESCRIPTION>JTAG Interface Disable</DESCRIPTION>
          <TEXT>When this bit is zero, the JTAG interface is enabled if the JTAGEN Fuse is programmed. If this bit is one, the JTAG interface is disabled. In order to avoid unintentional disabling or enabling of the JTAG interface, a timed sequence must be followed when changing this bit: The application software must write this bit to the desired value twice within four cycles to change its value. Note that this bit must not be altered when using the On-chip Debug system.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
      </MCUCR>
      <MCUSR>
        <NAME>MCUSR</NAME>
        <DESCRIPTION>MCU Status Register</DESCRIPTION>
        <TEXT>The MCU Status Register provides information on which reset source caused an MCU reset.</TEXT>
        <IO_ADDR>$34</IO_ADDR>
        <MEM_ADDR>$54</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT4>
          <NAME>JTRF</NAME>
          <DESCRIPTION>JTAG Reset Flag</DESCRIPTION>
          <TEXT>This bit is set if a reset is being caused by a logic one in the JTAG Reset Register selected by the JTAG instruction AVR_RESET. This bit is reset by a Power-on Reset, or by writing a logic zero to the flag.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
      </MCUSR>
    </JTAG>
    <EXTERNAL_INTERRUPT>
      <LIST>[EICRA:EICRB:EIMSK:EIFR:PCICR:PCIFR:PCMSK2:PCMSK1:PCMSK0]</LIST>
      <LINK>[PCMSK2:PCMSK1:PCMSK0]</LINK>
      <ICON>io_ext.bmp</ICON>
      <ID/>
      <TEXT>The External Interrupts are triggered by the INT7:0 pin or any of the PCINT8:0 pins. Observe that, if enabled, the interrupts will trigger even if the INT7:0 or PCINT8:0 pins are configured as outputs. This feature provides a way of generating a software interrupt. The Pin change interrupt PCI1 will trigger if the enabled PCINT8 pin toggles PCI0 will trigger if any enabled PCINT7:0 pin toggles. PCMSK1 and PCMSK0 Registers control which pins contribute to the pin change interrupts. Pin change interrupts on PCINT8:0 are detected asynchronously. This implies that these interrupts can be used for waking the part also from sleep modes other than Idle mode. The External Interrupts can be triggered by a falling or rising edge or a low level. This is set up as indicated in the specification for the "External Interrupt Control Registers EICRA" (INT3:0) and EICRB (INT7:4). When the external interrupt is enabled and is configured as level triggered, the interrupt will trigger as long as the pin is held low. Note that recognition of falling or rising edge interrupts on INT7:4 requires the presence of an I/O clock. Low level interrupts and the edge interrupt on INT3:0 are detected asynchronously. This implies that these interrupts can be used for waking the part also from sleep modes other than Idle mode. The I/O clock is halted in all sleep modes except Idle mode. Note that if a level triggered interrupt is used for wake-up from Power-down, the required level must be held long enough for the MCU to complete the wake-up to trigger the level interrupt. If the level disappears before the end of the Start-up Time, the MCU will still wake up, but no interrupt will be generated. The start-up time is defined by the SUT and CKSEL Fuses as described in section "System Clock and Clock Options".</TEXT>
      <EICRA>
        <NAME>EICRA</NAME>
        <DESCRIPTION>External Interrupt Control Register A</DESCRIPTION>
        <TEXT>The External Interrupts 3 - 0 are activated by the external pins INT3:0 if the SREG I-flag and the corresponding interrupt mask in the EIMSK is set. The level and edges on the external pins that activate the interrupts are defined in the following tables. Edges on INT3:0 are registered asynchronously. Pulses on INT3:0 pins wider than the minimum pulse width of typical 50 ns will generate an interrupt. Shorter pulses are not guaranteed to generate an interrupt. If low level interrupt is selected, the low level must be held until the completion of the currently executing instruction to generate an interrupt. If enabled, a level triggered interrupt will generate an interrupt request as long as the pin is held low. When changing the ISCn bit, an interrupt can occur. Therefore, it is recommended to first disable INTn by clearing its Interrupt Enable bit in the EIMSK Register. Then, the ISCn bit can be changed. Finally, the INTn interrupt flag should be cleared by writing a logical one to its Interrupt Flag bit (INTFn) in the EIFR Register before the interrupt is re-enabled. When changing the ISCn1/ISCn0 bits, the interrupt must be disabled by clearing its Interrupt Enable bit in the EIMSK Register. Otherwise an interrupt can occur when the bits are changed.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$69</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>ISC31</NAME>
          <DESCRIPTION>External Interrupt 3 Sense Control Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ISC30</NAME>
          <DESCRIPTION>External Interrupt 3 Sense Control Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <ENUM>INTERRUPT_SENSE_CONTROL3</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ISC21</NAME>
          <DESCRIPTION>External Interrupt 2 Sense Control Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ISC20</NAME>
          <DESCRIPTION>External Interrupt 2 Sense Control Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <ENUM>INTERRUPT_SENSE_CONTROL3</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ISC11</NAME>
          <DESCRIPTION>External Interrupt 1 Sense Control Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ISC10</NAME>
          <DESCRIPTION>External Interrupt 1 Sense Control Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <ENUM>INTERRUPT_SENSE_CONTROL3</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ISC01</NAME>
          <DESCRIPTION>External Interrupt 0 Sense Control Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ISC00</NAME>
          <DESCRIPTION>External Interrupt 0 Sense Control Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <ENUM>INTERRUPT_SENSE_CONTROL3</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </EICRA>
      <EICRB>
        <NAME>EICRB</NAME>
        <DESCRIPTION>External Interrupt Control Register B</DESCRIPTION>
        <TEXT>The External Interrupts 7 - 4 are activated by the external pins INT7:4 if the SREG I-flag and the corresponding interrupt mask in the EIMSK is set. The level and edges on the external pins that activate the interrupts are defined in the following tables. Edges on INT7:4 are registered asynchronously. Pulses on INT7:4 pins wider than the minimum pulse width of typical 50 ns will generate an interrupt. Shorter pulses are not guaranteed to generate an interrupt. If low level interrupt is selected, the low level must be held until the completion of the currently executing instruction to generate an interrupt. If enabled, a level triggered interrupt will generate an interrupt request as long as the pin is held low. When changing the ISCn bit, an interrupt can occur. Therefore, it is recommended to first disable INTn by clearing its Interrupt Enable bit in the EIMSK Register. Then, the ISCn bit can be changed. Finally, the INTn interrupt flag should be cleared by writing a logical one to its Interrupt Flag bit (INTFn) in the EIFR Register before the interrupt is re-enabled. When changing the ISCn1/ISCn0 bits, the interrupt must be disabled by clearing its Interrupt Enable bit in the EIMSK Register. Otherwise an interrupt can occur when the bits are changed.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$6A</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>ISC71</NAME>
          <DESCRIPTION>External Interrupt 7 Sense Control Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ISC70</NAME>
          <DESCRIPTION>External Interrupt 7 Sense Control Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <ENUM>INTERRUPT_SENSE_CONTROL3</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ISC61</NAME>
          <DESCRIPTION>External Interrupt 6 Sense Control Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ISC60</NAME>
          <DESCRIPTION>External Interrupt 6 Sense Control Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <ENUM>INTERRUPT_SENSE_CONTROL3</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ISC51</NAME>
          <DESCRIPTION>External Interrupt 5 Sense Control Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ISC50</NAME>
          <DESCRIPTION>External Interrupt 5 Sense Control Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <ENUM>INTERRUPT_SENSE_CONTROL3</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ISC41</NAME>
          <DESCRIPTION>External Interrupt 4 Sense Control Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ISC40</NAME>
          <DESCRIPTION>External Interrupt 4 Sense Control Bit</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <ENUM>INTERRUPT_SENSE_CONTROL3</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </EICRB>
      <EIMSK>
        <NAME>EIMSK</NAME>
        <DESCRIPTION>External Interrupt Mask Register</DESCRIPTION>
        <TEXT>When an INT7:0 bit is written to one and the I-bit in the Status Register (SREG) is set (one), the corresponding external pin interrupt is enabled. The Interrupt Sense Control bits in the External Interrupt Control Registers EICRA and EICRB define whether the External Interrupt is activated on rising or falling edge or level sensed. Activity on any of these pins will trigger an interrupt request even if the pin is enabled as an output. This provides a way of generating a software interrupt.</TEXT>
        <IO_ADDR>$1D</IO_ADDR>
        <MEM_ADDR>$3D</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>INT7</NAME>
          <DESCRIPTION>External Interrupt Request Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>INT6</NAME>
          <DESCRIPTION>External Interrupt Request Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>INT5</NAME>
          <DESCRIPTION>External Interrupt Request Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>INT4</NAME>
          <DESCRIPTION>External Interrupt Request Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>INT3</NAME>
          <DESCRIPTION>External Interrupt Request Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>INT2</NAME>
          <DESCRIPTION>External Interrupt Request Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>INT1</NAME>
          <DESCRIPTION>External Interrupt Request Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>INT0</NAME>
          <DESCRIPTION>External Interrupt Request Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>INTERRUPT_REQ_ENABLE_BITF</ENUM>
        </BIT0>
      </EIMSK>
      <EIFR>
        <NAME>EIFR</NAME>
        <DESCRIPTION>External Interrupt Flag Register</DESCRIPTION>
        <TEXT>When an edge or logic change on the INT7:0 pin triggers an interrupt request, INTF7:0 becomes set (one). If the I-bit in SREG and the corresponding interrupt enable bit INT7:0 in EIMSK are set (one), the MCU will jump to the interrupt vector. The flag is cleared when the interrupt routine is executed. Alternatively, the flag can be cleared by writing a logical one to it. These flags are always cleared when INT7:0 are configured as level interrupt. Note that when entering sleep mode with the INT3:0 interrupts disabled, the input buffers on these pins will be disabled. This may cause a logic change in internal signals which will set the INTF3:0 flags. See "Digital Input Enable and Sleep Modes" for more information.</TEXT>
        <IO_ADDR>$1C</IO_ADDR>
        <MEM_ADDR>$3C</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>INTF7</NAME>
          <DESCRIPTION>External Interrupt Flag</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>INTF6</NAME>
          <DESCRIPTION>External Interrupt Flag</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>INTF5</NAME>
          <DESCRIPTION>External Interrupt Flag</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>INTF4</NAME>
          <DESCRIPTION>External Interrupt Flag</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>INTF3</NAME>
          <DESCRIPTION>External Interrupt Flag</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>INTF2</NAME>
          <DESCRIPTION>External Interrupt Flag</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>INTF1</NAME>
          <DESCRIPTION>External Interrupt Flag</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>INTF0</NAME>
          <DESCRIPTION>External Interrupt Flag</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>INTERRUPT_EXT_FLAG_BITF</ENUM>
        </BIT0>
      </EIFR>
      <PCMSK2>
        <NAME>PCMSK2</NAME>
        <DESCRIPTION>Pin Change Mask Register 2</DESCRIPTION>
        <TEXT>Note that the PCMSK2 register has no function in this device. The I/O ports associated to PCINT23:16 are not implemented. Normally each bit PCINT23:16 selects whether the pin change interrupt is enabled on the corresponding I/O pin. If PCINT23:16 is set and the PCIE2 bit in PCICR is set, the pin change interrupt is enabled on the corresponding I/O pin. If PCINT23:16 is cleared, the pin change interrupt on the corresponding I/O pin is disabled.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$6D</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>PCINT23</NAME>
          <DESCRIPTION>Pin Change Enable Mask</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PCINT22</NAME>
          <DESCRIPTION>Pin Change Enable Mask</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PCINT21</NAME>
          <DESCRIPTION>Pin Change Enable Mask</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PCINT20</NAME>
          <DESCRIPTION>Pin Change Enable Mask</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PCINT19</NAME>
          <DESCRIPTION>Pin Change Enable Mask</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PCINT18</NAME>
          <DESCRIPTION>Pin Change Enable Mask</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PCINT17</NAME>
          <DESCRIPTION>Pin Change Enable Mask</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PCINT16</NAME>
          <DESCRIPTION>Pin Change Enable Mask</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PCMSK2>
      <PCMSK1>
        <NAME>PCMSK1</NAME>
        <DESCRIPTION>Pin Change Mask Register 1</DESCRIPTION>
        <TEXT>Bit PCINT8 selects whether the pin change interrupt is enabled on the corresponding I/O pin. If PCINT8 is set and the PCIE1 bit in PCICR is set, the pin change interrupt is enabled on the corresponding I/O pin. If PCINT8 is cleared, the pin change interrupt on the corresponding I/O pin is disabled.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$6C</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>PCINT15</NAME>
          <DESCRIPTION>Pin Change Enable Mask</DESCRIPTION>
          <TEXT>Bits 15:9 of the PCMSK1 register have no function in this device. The I/O ports associated to PCINT15:9 are not implemented.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PCINT14</NAME>
          <DESCRIPTION>Pin Change Enable Mask</DESCRIPTION>
          <TEXT>Bits 15:9 of the PCMSK1 register have no function in this device. The I/O ports associated to PCINT15:9 are not implemented.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PCINT13</NAME>
          <DESCRIPTION>Pin Change Enable Mask</DESCRIPTION>
          <TEXT>Bits 15:9 of the PCMSK1 register have no function in this device. The I/O ports associated to PCINT15:9 are not implemented.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PCINT12</NAME>
          <DESCRIPTION>Pin Change Enable Mask</DESCRIPTION>
          <TEXT>Bits 15:9 of the PCMSK1 register have no function in this device. The I/O ports associated to PCINT15:9 are not implemented.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PCINT11</NAME>
          <DESCRIPTION>Pin Change Enable Mask</DESCRIPTION>
          <TEXT>Bits 15:9 of the PCMSK1 register have no function in this device. The I/O ports associated to PCINT15:9 are not implemented.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PCINT10</NAME>
          <DESCRIPTION>Pin Change Enable Mask</DESCRIPTION>
          <TEXT>Bits 15:9 of the PCMSK1 register have no function in this device. The I/O ports associated to PCINT15:9 are not implemented.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PCINT9</NAME>
          <DESCRIPTION>Pin Change Enable Mask</DESCRIPTION>
          <TEXT>Bits 15:9 of the PCMSK1 register have no function in this device. The I/O ports associated to PCINT15:9 are not implemented.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PCINT8</NAME>
          <DESCRIPTION>Pin Change Enable Mask 8</DESCRIPTION>
          <TEXT>If this bit is set to one the pin change interrupt on the corresponding I/O pin is enabled. If this bit is set to zero the pin change interrupt is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PCMSK1>
      <PCMSK0>
        <NAME>PCMSK0</NAME>
        <DESCRIPTION>Pin Change Mask Register 0</DESCRIPTION>
        <TEXT>Each bit PCINT7:0 selects whether the pin change interrupt is enabled on the corresponding I/O pin. If PCINT7:0 is set and the PCIE0 bit in PCICR is set, the pin change interrupt is enabled on the corresponding I/O pin. If PCINT7:0 is cleared, the pin change interrupt on the corresponding I/O pin is disabled.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$6B</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PCINT7</NAME>
          <DESCRIPTION>Pin Change Enable Mask</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PCINT6</NAME>
          <DESCRIPTION>Pin Change Enable Mask</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PCINT5</NAME>
          <DESCRIPTION>Pin Change Enable Mask</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PCINT4</NAME>
          <DESCRIPTION>Pin Change Enable Mask</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PCINT3</NAME>
          <DESCRIPTION>Pin Change Enable Mask</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PCINT2</NAME>
          <DESCRIPTION>Pin Change Enable Mask</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PCINT1</NAME>
          <DESCRIPTION>Pin Change Enable Mask</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PCINT0</NAME>
          <DESCRIPTION>Pin Change Enable Mask</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>INTERRUPT_PCMSK_BITF</ENUM>
        </BIT0>
      </PCMSK0>
      <PCIFR>
        <NAME>PCIFR</NAME>
        <DESCRIPTION>Pin Change Interrupt Flag Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$1B</IO_ADDR>
        <MEM_ADDR>$3B</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>Res4</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res3</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>Res2</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PCIF2</NAME>
          <DESCRIPTION>Pin Change Interrupt Flag 2</DESCRIPTION>
          <TEXT>When a logic change on any PCINT23:16 pin triggers an interrupt request, PCIF2 becomes set (one). If the I-bit in SREG and the PCIE2 bit in PCICR are set (one), the MCU will jump to the corresponding Interrupt Vector. The flag is cleared when the interrupt routine is executed. Alternatively, the flag can be cleared by writing a logical one to it. Note that the I/O ports corresponding to PCINT23:16 are not implemented. Therefore PCIF2 has no function in this device.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PCIF1</NAME>
          <DESCRIPTION>Pin Change Interrupt Flag 1</DESCRIPTION>
          <TEXT>When a logic change on any PCINT15:8 pin triggers an interrupt request, PCIF1 becomes set (one). If the I-bit in SREG and the PCIE1 bit in PCICR are set (one), the MCU will jump to the corresponding Interrupt Vector. The flag is cleared when the interrupt routine is executed.  Alternatively, the flag can be cleared by writing a logical one to it. Note that the I/O ports corresponding to PCINT15:9 are not implemented.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PCIF0</NAME>
          <DESCRIPTION>Pin Change Interrupt Flag 0</DESCRIPTION>
          <TEXT>When a logic change on any PCINT7:0 pin triggers an interrupt request, PCIF0 becomes set (one). If the I-bit in SREG and the PCIE0 bit in PCICR are set (one), the MCU will jump to the corresponding Interrupt Vector. The flag is cleared when the interrupt routine is executed.  Alternatively, the flag can be cleared by writing a logical one to it.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PCIFR>
      <PCICR>
        <NAME>PCICR</NAME>
        <DESCRIPTION>Pin Change Interrupt Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$68</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>Res4</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res3</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>Res2</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PCIE2</NAME>
          <DESCRIPTION>Pin Change Interrupt Enable 2</DESCRIPTION>
          <TEXT>When the PCIE2 bit is set (one) and the I-bit in the Status Register (SREG) is set (one), pin change interrupt 2 is enabled. Any change on any enabled PCINT23:16 pin will cause an interrupt. The corresponding interrupt of Pin Change Interrupt Request is executed from the PCI2 Interrupt Vector. PCINT23:16 pins are enabled individually by the PCMSK2 Register. Note that the I/O ports corresponding to PCINT23:16 are not implemented. Therefore PCIE2 has no function in this device.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PCIE1</NAME>
          <DESCRIPTION>Pin Change Interrupt Enable 1</DESCRIPTION>
          <TEXT>When the PCIE1 bit is set (one) and the I-bit in the Status Register (SREG) is set (one), pin change interrupt 1 is enabled. Any change on any enabled PCINT15:8 pin will cause an interrupt. The corresponding interrupt of Pin Change Interrupt Request is executed from the PCI1 Interrupt Vector. PCINT15:8 pins are enabled individually by the PCMSK1 Register. Note that the I/O ports corresponding to PCINT15:9 are not implemented.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PCIE0</NAME>
          <DESCRIPTION>Pin Change Interrupt Enable 0</DESCRIPTION>
          <TEXT>When the PCIE0 bit is set (one) and the I-bit in the Status Register (SREG) is set (one), pin change interrupt 0 is enabled. Any change on any enabled PCINT7:0 pin will cause an interrupt. The corresponding interrupt of Pin Change Interrupt Request is executed from the PCI0 Interrupt Vector. PCINT7:0 pins are enabled individually by the PCMSK0 Register.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PCICR>
    </EXTERNAL_INTERRUPT>
    <AD_CONVERTER>
      <LIST>[ADMUX:ADCSRA:ADCSRB:ADCSRC:ADCH:ADCL:DIDR0:DIDR2]</LIST>
      <LINK/>
      <RULES>((IF ADMUX.ADLAR = 1) LINK [ADCH(1:0):ADCL(7:0)]); (IF ADMUX.ADLAR = 0) LINK [ADCH(7:0):ADCL(7:6)]);</RULES>
      <ICON>io_analo.bmp</ICON>
      <ID/>
      <TEXT>AD converter feature list: 10-bit resolution. 2 LSB integral non-linearity. +/-4 LSB absolute accuracy. 3 - 240 us conversion time. Up to 330 kSPS at maximum resolution. 8 multiplexed single-ended input channels. 7 differential input channels. 2 differential input channels with an optional gain of 10x and 200x. Internal linear temperature sensor. Optional left adjustment for ADC result readout. 0 - AVDD ADC input voltage range. 0 - EVDD differential ADC input voltage range. Selectable 1.5 V, 1.6 V or AVDD ADC reference voltage. Free running or single conversion mode. Interrupt on AD conversion complete. Sleep mode noise canceller.</TEXT>
      <ADMUX>
        <NAME>ADMUX</NAME>
        <DESCRIPTION>The ADC Multiplexer Selection Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$7C</MEM_ADDR>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>REFS1</NAME>
          <DESCRIPTION>Reference Selection Bits</DESCRIPTION>
          <TEXT>These bits select the voltage reference for the ADC. Changes of these bits will only take effect until the first conversion start is requested by setting ADSC. After this the ADC has to be disabled and enabled again for new reference selections. The internal voltage reference options may not be used if an external reference voltage is being applied to the AREF pin.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>REFS0</NAME>
          <DESCRIPTION>Reference Selection Bits</DESCRIPTION>
          <TEXT>These bits select the voltage reference for the ADC. Changes of these bits will only take effect until the first conversion start is requested by setting ADSC. After this the ADC has to be disabled and enabled again for new reference selections. The internal voltage reference options may not be used if an external reference voltage is being applied to the AREF pin.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>ANALOG_ADC_V_REF9</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ADLAR</NAME>
          <DESCRIPTION>ADC Left Adjust Result</DESCRIPTION>
          <TEXT>The ADLAR bit affects the presentation of the ADC conversion result in the ADC Data Register. Write one to ADLAR to left adjust the result. Otherwise, the result is right adjusted. Changing the ADLAR bit will affect the ADC Data Register immediately, regardless of any ongoing conversions. For a complete description of this bit, see ADCL and ADCH register description.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>MUX4</NAME>
          <DESCRIPTION>Analog Channel and Gain Selection Bits</DESCRIPTION>
          <TEXT>The value of these bits selects which combination of analog inputs is connected to the ADC. If these bits are changed during a conversion, the change will not go in effect until this conversion is complete (ADIF in ADCSRA is set). Note that the MUX5 bit is located in the ADCSRB register. A write access to the MUX4:0 bits triggers the update of the internally buffered MUX5 bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>MUX3</NAME>
          <DESCRIPTION>Analog Channel and Gain Selection Bits</DESCRIPTION>
          <TEXT>The value of these bits selects which combination of analog inputs is connected to the ADC. If these bits are changed during a conversion, the change will not go in effect until this conversion is complete (ADIF in ADCSRA is set). Note that the MUX5 bit is located in the ADCSRB register. A write access to the MUX4:0 bits triggers the update of the internally buffered MUX5 bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>MUX2</NAME>
          <DESCRIPTION>Analog Channel and Gain Selection Bits</DESCRIPTION>
          <TEXT>The value of these bits selects which combination of analog inputs is connected to the ADC. If these bits are changed during a conversion, the change will not go in effect until this conversion is complete (ADIF in ADCSRA is set). Note that the MUX5 bit is located in the ADCSRB register. A write access to the MUX4:0 bits triggers the update of the internally buffered MUX5 bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>MUX1</NAME>
          <DESCRIPTION>Analog Channel and Gain Selection Bits</DESCRIPTION>
          <TEXT>The value of these bits selects which combination of analog inputs is connected to the ADC. If these bits are changed during a conversion, the change will not go in effect until this conversion is complete (ADIF in ADCSRA is set). Note that the MUX5 bit is located in the ADCSRB register. A write access to the MUX4:0 bits triggers the update of the internally buffered MUX5 bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>MUX0</NAME>
          <DESCRIPTION>Analog Channel and Gain Selection Bits</DESCRIPTION>
          <TEXT>The value of these bits selects which combination of analog inputs is connected to the ADC. If these bits are changed during a conversion, the change will not go in effect until this conversion is complete (ADIF in ADCSRA is set). Note that the MUX5 bit is located in the ADCSRB register. A write access to the MUX4:0 bits triggers the update of the internally buffered MUX5 bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ADMUX>
      <ADCH>
        <NAME>ADCH</NAME>
        <DESCRIPTION>ADC Data Register High Byte</DESCRIPTION>
        <TEXT>When an ADC conversion is complete, the result is found in this register. If differential channels are used, the result is presented in twos complement form. If the result is left adjusted and no more than 8-bit precision (7 bit + sign bit for differential input channels) is required, it is sufficient to read ADCH. Otherwise, ADCL must be read first, then ADCH. The ADLAR bit in ADMUX, and the MUXn bits in ADMUX affect the way the result is read from the registers. If ADLAR is set, the result is left adjusted. If ADLAR is cleared (default), the result is right adjusted.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$79</MEM_ADDR>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>ADCH7</NAME>
          <DESCRIPTION>ADC Data Register High Byte</DESCRIPTION>
          <TEXT>These bits represent the result from the conversion.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ADCH6</NAME>
          <DESCRIPTION>ADC Data Register High Byte</DESCRIPTION>
          <TEXT>These bits represent the result from the conversion.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ADCH5</NAME>
          <DESCRIPTION>ADC Data Register High Byte</DESCRIPTION>
          <TEXT>These bits represent the result from the conversion.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ADCH4</NAME>
          <DESCRIPTION>ADC Data Register High Byte</DESCRIPTION>
          <TEXT>These bits represent the result from the conversion.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ADCH3</NAME>
          <DESCRIPTION>ADC Data Register High Byte</DESCRIPTION>
          <TEXT>These bits represent the result from the conversion.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ADCH2</NAME>
          <DESCRIPTION>ADC Data Register High Byte</DESCRIPTION>
          <TEXT>These bits represent the result from the conversion.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ADCH1</NAME>
          <DESCRIPTION>ADC Data Register High Byte</DESCRIPTION>
          <TEXT>These bits represent the result from the conversion.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ADCH0</NAME>
          <DESCRIPTION>ADC Data Register High Byte</DESCRIPTION>
          <TEXT>These bits represent the result from the conversion.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ADCH>
      <ADCL>
        <NAME>ADCL</NAME>
        <DESCRIPTION>ADC Data Register Low Byte</DESCRIPTION>
        <TEXT>When an ADC conversion is complete, the result is found in this register. If differential channels are used, the result is presented in twos complement form. When ADCL is read, the ADC Data Register is not updated until ADCH is read. Consequently, if the result is left adjusted and no more than 8-bit precision (7 bit + sign bit for differential input channels) is required, it is sufficient to read ADCH. Otherwise, ADCL must be read first, then ADCH. The ADLAR bit in ADMUX, and the MUXn bits in ADMUX affect the way the result is read from the registers. If ADLAR is set, the result is left adjusted. If ADLAR is cleared (default), the result is right adjusted.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$78</MEM_ADDR>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>ADCL7</NAME>
          <DESCRIPTION>ADC Data Register Low Byte</DESCRIPTION>
          <TEXT>These bits represent the result from the conversion.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ADCL6</NAME>
          <DESCRIPTION>ADC Data Register Low Byte</DESCRIPTION>
          <TEXT>These bits represent the result from the conversion.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ADCL5</NAME>
          <DESCRIPTION>ADC Data Register Low Byte</DESCRIPTION>
          <TEXT>These bits represent the result from the conversion.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ADCL4</NAME>
          <DESCRIPTION>ADC Data Register Low Byte</DESCRIPTION>
          <TEXT>These bits represent the result from the conversion.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ADCL3</NAME>
          <DESCRIPTION>ADC Data Register Low Byte</DESCRIPTION>
          <TEXT>These bits represent the result from the conversion.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ADCL2</NAME>
          <DESCRIPTION>ADC Data Register Low Byte</DESCRIPTION>
          <TEXT>These bits represent the result from the conversion.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ADCL1</NAME>
          <DESCRIPTION>ADC Data Register Low Byte</DESCRIPTION>
          <TEXT>These bits represent the result from the conversion.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ADCL0</NAME>
          <DESCRIPTION>ADC Data Register Low Byte</DESCRIPTION>
          <TEXT>These bits represent the result from the conversion.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ADCL>
      <ADCSRA>
        <NAME>ADCSRA</NAME>
        <DESCRIPTION>The ADC Control and Status Register A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$7A</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>ADEN</NAME>
          <DESCRIPTION>ADC Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables the ADC. The AVDD supply voltage will also be enabled if not already available. By writing it to zero, the ADC is turned off. Turning the ADC off while a conversion is in progress will terminate this conversion.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ADSC</NAME>
          <DESCRIPTION>ADC Start Conversion</DESCRIPTION>
          <TEXT>In Single Conversion mode, write this bit to one to start each conversion. In Free Running mode, write this bit to one to start the first conversion. The first conversion after ADSC has been written after the ADC has been enabled, or if ADSC is written at the same time as the ADC is enabled, will include a start-up time to initialize the analog blocks of the ADC. The start-up time is defined by the ADSUT bits of register ADCSRC. ADSC will read as one as long as a conversion is in progress. When the conversion is complete, it returns to zero. Writing zero to this bit has no effect.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ADATE</NAME>
          <DESCRIPTION>ADC Auto Trigger Enable</DESCRIPTION>
          <TEXT>When this bit is written to one, Auto Triggering of the ADC is enabled. The ADC will start a conversion on a positive edge of the selected trigger signal. The trigger source is selected by setting the ADC Trigger Select bits, ADTS in ADCSRB.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ADIF</NAME>
          <DESCRIPTION>ADC Interrupt Flag</DESCRIPTION>
          <TEXT>This bit is set when an AD conversion completes and the Data Registers are updated. The ADC Conversion Complete Interrupt is executed if the ADIE bit and the I-bit in SREG are set. ADIF is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, ADIF is cleared by writing a logical one to the flag. Beware that if doing a Read-Modify- Write on ADCSRA, a pending interrupt can be disabled. This also applies if the SBI and CBI instructions are used.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ADIE</NAME>
          <DESCRIPTION>ADC Interrupt Enable</DESCRIPTION>
          <TEXT>When this bit is written to one and the I-bit in SREG is set, the ADC Conversion Complete Interrupt is activated.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ADPS2</NAME>
          <DESCRIPTION>ADC  Prescaler Select Bits</DESCRIPTION>
          <TEXT>These bits determine the division factor between the CPU frequency and the input clock to the ADC.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ADPS1</NAME>
          <DESCRIPTION>ADC  Prescaler Select Bits</DESCRIPTION>
          <TEXT>These bits determine the division factor between the CPU frequency and the input clock to the ADC.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ADPS0</NAME>
          <DESCRIPTION>ADC  Prescaler Select Bits</DESCRIPTION>
          <TEXT>These bits determine the division factor between the CPU frequency and the input clock to the ADC.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>ANALIG_ADC_PRESCALER</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ADCSRA>
      <ADCSRB>
        <NAME>ADCSRB</NAME>
        <DESCRIPTION>The ADC Control and Status Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$7B</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>AVDDOK</NAME>
          <DESCRIPTION>AVDD Supply Voltage OK</DESCRIPTION>
          <TEXT>The analog functions of the ADC are powered from the AVDD domain. AVDD is supplied from an internal voltage regulator. Setting the ADEN bit in register ADCSRA will power-up the AVDD domain if not already requested by another functional group of the device. The bit allows the user to monitor (poll) the status of the AVDD domain. A status of 1 indicates that AVDD has been powered-up.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ACME</NAME>
          <DESCRIPTION>Analog Comparator Multiplexer Enable</DESCRIPTION>
          <TEXT>When this bit is written logic one and the ADC is switched off (ADEN in ADCSRA is zero), the ADC multiplexer selects the negative input to the Analog Comparator. When this bit is written logic zero, AIN1 is applied to the negative input of the Analog Comparator.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>REFOK</NAME>
          <DESCRIPTION>Reference Voltage OK</DESCRIPTION>
          <TEXT>The status of the internal generated reference voltage can be monitored through this bit. Setting the ADEN bit in register ADCSRA will enable the reference voltage for the ADC according to the REFS bits in the ADMUX register. The reference voltage will be available after a start-up delay. A status of 1 of this bit indicates that the internal generated reference voltage is reaching nominal levels.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ACCH</NAME>
          <DESCRIPTION>Analog Channel Change</DESCRIPTION>
          <TEXT>This bit indicates that a new analog channel has been selected. The MUX bits in ADMUX and ADCSRB have changed. The analog blocks of the ADC will be reset to handle possible new voltage ranges. Such a reset phase is especially important for the gain amplifier. It could be temporarily disabled by a large step of its input common voltage leading to erroneous AD conversion results. The user can force a reset of the analog blocks by setting this bit to 1 independent from requesting a different channel.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>MUX5</NAME>
          <DESCRIPTION>Analog Channel and Gain Selection Bits</DESCRIPTION>
          <TEXT>This bit is used together with MUX4:0 in ADMUX to select which combination of the analog inputs are connected to the ADC. If this bit is changed during a conversion, the change will not go in effect until this conversion is complete.Note that the MUX5 bit is internally buffered and a write access to the MUX4:0 bits is required to trigger the update of the MUX5 bit. The MUX4:0 bits are located in the ADMUX register.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ADTS2</NAME>
          <DESCRIPTION>ADC Auto Trigger Source</DESCRIPTION>
          <TEXT>If ADATE in ADCSRA is written to one, the value of these bits selects which source will trigger an AD conversion. If ADATE is cleared, the ADTS2:0 settings will have no effect. A conversion will be triggered by the rising edge of the selected Interrupt Flag. Note that switching from a trigger source that is cleared to a trigger source that is set, will generate a positive edge on the trigger signal. If ADEN in ADCSRA is set, this will start a conversion. Switching to Free Running mode (ADTS[2:0]=0) will not cause a trigger event, even if the ADC Interrupt Flag is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ADTS1</NAME>
          <DESCRIPTION>ADC Auto Trigger Source</DESCRIPTION>
          <TEXT>If ADATE in ADCSRA is written to one, the value of these bits selects which source will trigger an AD conversion. If ADATE is cleared, the ADTS2:0 settings will have no effect. A conversion will be triggered by the rising edge of the selected Interrupt Flag. Note that switching from a trigger source that is cleared to a trigger source that is set, will generate a positive edge on the trigger signal. If ADEN in ADCSRA is set, this will start a conversion. Switching to Free Running mode (ADTS[2:0]=0) will not cause a trigger event, even if the ADC Interrupt Flag is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ADTS0</NAME>
          <DESCRIPTION>ADC Auto Trigger Source</DESCRIPTION>
          <TEXT>If ADATE in ADCSRA is written to one, the value of these bits selects which source will trigger an AD conversion. If ADATE is cleared, the ADTS2:0 settings will have no effect. A conversion will be triggered by the rising edge of the selected Interrupt Flag. Note that switching from a trigger source that is cleared to a trigger source that is set, will generate a positive edge on the trigger signal. If ADEN in ADCSRA is set, this will start a conversion. Switching to Free Running mode (ADTS[2:0]=0) will not cause a trigger event, even if the ADC Interrupt Flag is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>ANALIG_ADC_AUTO_TRIGGER</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ADCSRB>
      <ADCSRC>
        <NAME>ADCSRC</NAME>
        <DESCRIPTION>The ADC Control and Status Register C</DESCRIPTION>
        <TEXT>This register defines the track-and-hold time for sampling the analog input voltage of the ADC and it defines the start-up time for the analog blocks based on a number of ADC clock cycles. The ADC clock is generated from the system clock with the ADC prescaler. The bits ADPS2:0 of register ADCSRA set the prescaler ratio. Correct start-up and track-and-hold times are important for precise conversion results.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$77</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>ADTHT1</NAME>
          <DESCRIPTION>ADC Track-and-Hold Time</DESCRIPTION>
          <TEXT>These bits define the number of ADC clock cycles for the sampling time of the analog input voltage.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ADTHT0</NAME>
          <DESCRIPTION>ADC Track-and-Hold Time</DESCRIPTION>
          <TEXT>These bits define the number of ADC clock cycles for the sampling time of the analog input voltage.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>ANALOG_ADC_TRACK_AND_HOLD_TIME</ENUM>
          <INIT_VAL>1</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>This bit is reserved.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ADSUT4</NAME>
          <DESCRIPTION>ADC Start-up Time</DESCRIPTION>
          <TEXT>These bits define the number of ADC clock cycles for the start-up time of the analog blocks.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ADSUT3</NAME>
          <DESCRIPTION>ADC Start-up Time</DESCRIPTION>
          <TEXT>These bits define the number of ADC clock cycles for the start-up time of the analog blocks.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ADSUT2</NAME>
          <DESCRIPTION>ADC Start-up Time</DESCRIPTION>
          <TEXT>These bits define the number of ADC clock cycles for the start-up time of the analog blocks.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ADSUT1</NAME>
          <DESCRIPTION>ADC Start-up Time</DESCRIPTION>
          <TEXT>These bits define the number of ADC clock cycles for the start-up time of the analog blocks.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ADSUT0</NAME>
          <DESCRIPTION>ADC Start-up Time</DESCRIPTION>
          <TEXT>These bits define the number of ADC clock cycles for the start-up time of the analog blocks.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>ANALOG_ADC_STARTUP_TIME</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ADCSRC>
      <DIDR2>
        <NAME>DIDR2</NAME>
        <DESCRIPTION>Digital Input Disable Register 2</DESCRIPTION>
        <TEXT>Reserved for future use.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$7D</MEM_ADDR>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>ADC15D</NAME>
          <DESCRIPTION>Reserved Bits</DESCRIPTION>
          <TEXT>This bit is reserved for future use. For ensuring compatibility with future devices, this bit must be written to zero.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ADC14D</NAME>
          <DESCRIPTION>Reserved Bits</DESCRIPTION>
          <TEXT>This bit is reserved for future use. For ensuring compatibility with future devices, this bit must be written to zero.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ADC13D</NAME>
          <DESCRIPTION>Reserved Bits</DESCRIPTION>
          <TEXT>This bit is reserved for future use. For ensuring compatibility with future devices, this bit must be written to zero.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ADC12D</NAME>
          <DESCRIPTION>Reserved Bits</DESCRIPTION>
          <TEXT>This bit is reserved for future use. For ensuring compatibility with future devices, this bit must be written to zero.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ADC11D</NAME>
          <DESCRIPTION>Reserved Bits</DESCRIPTION>
          <TEXT>This bit is reserved for future use. For ensuring compatibility with future devices, this bit must be written to zero.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ADC10D</NAME>
          <DESCRIPTION>Reserved Bits</DESCRIPTION>
          <TEXT>This bit is reserved for future use. For ensuring compatibility with future devices, this bit must be written to zero.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ADC9D</NAME>
          <DESCRIPTION>Reserved Bits</DESCRIPTION>
          <TEXT>This bit is reserved for future use. For ensuring compatibility with future devices, this bit must be written to zero.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ADC8D</NAME>
          <DESCRIPTION>Reserved Bits</DESCRIPTION>
          <TEXT>This bit is reserved for future use. For ensuring compatibility with future devices, this bit must be written to zero.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </DIDR2>
      <DIDR0>
        <NAME>DIDR0</NAME>
        <DESCRIPTION>Digital Input Disable Register 0</DESCRIPTION>
        <TEXT>For analog input pins, the digital input buffer should be disabled at all times. An analog signal level close to AVDD/2 on an input pin can cause significant current even in active mode. Digital input buffers can be disabled by writing to this register.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$7E</MEM_ADDR>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>ADC7D</NAME>
          <DESCRIPTION>Disable ADC7:0 Digital Input</DESCRIPTION>
          <TEXT>When this bit is written logic one, the digital input buffer on the corresponding ADC pin is disabled. The corresponding PIN Register bit will always read as zero when this bit is set. When an analog signal is applied to the ADC7:0 pin and the digital input from this pin is not needed, this bit should be written logic one to reduce power consumption in the digital input buffer.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ADC6D</NAME>
          <DESCRIPTION>Disable ADC7:0 Digital Input</DESCRIPTION>
          <TEXT>When this bit is written logic one, the digital input buffer on the corresponding ADC pin is disabled. The corresponding PIN Register bit will always read as zero when this bit is set. When an analog signal is applied to the ADC7:0 pin and the digital input from this pin is not needed, this bit should be written logic one to reduce power consumption in the digital input buffer.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ADC5D</NAME>
          <DESCRIPTION>Disable ADC7:0 Digital Input</DESCRIPTION>
          <TEXT>When this bit is written logic one, the digital input buffer on the corresponding ADC pin is disabled. The corresponding PIN Register bit will always read as zero when this bit is set. When an analog signal is applied to the ADC7:0 pin and the digital input from this pin is not needed, this bit should be written logic one to reduce power consumption in the digital input buffer.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ADC4D</NAME>
          <DESCRIPTION>Disable ADC7:0 Digital Input</DESCRIPTION>
          <TEXT>When this bit is written logic one, the digital input buffer on the corresponding ADC pin is disabled. The corresponding PIN Register bit will always read as zero when this bit is set. When an analog signal is applied to the ADC7:0 pin and the digital input from this pin is not needed, this bit should be written logic one to reduce power consumption in the digital input buffer.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ADC3D</NAME>
          <DESCRIPTION>Disable ADC7:0 Digital Input</DESCRIPTION>
          <TEXT>When this bit is written logic one, the digital input buffer on the corresponding ADC pin is disabled. The corresponding PIN Register bit will always read as zero when this bit is set. When an analog signal is applied to the ADC7:0 pin and the digital input from this pin is not needed, this bit should be written logic one to reduce power consumption in the digital input buffer.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ADC2D</NAME>
          <DESCRIPTION>Disable ADC7:0 Digital Input</DESCRIPTION>
          <TEXT>When this bit is written logic one, the digital input buffer on the corresponding ADC pin is disabled. The corresponding PIN Register bit will always read as zero when this bit is set. When an analog signal is applied to the ADC7:0 pin and the digital input from this pin is not needed, this bit should be written logic one to reduce power consumption in the digital input buffer.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ADC1D</NAME>
          <DESCRIPTION>Disable ADC7:0 Digital Input</DESCRIPTION>
          <TEXT>When this bit is written logic one, the digital input buffer on the corresponding ADC pin is disabled. The corresponding PIN Register bit will always read as zero when this bit is set. When an analog signal is applied to the ADC7:0 pin and the digital input from this pin is not needed, this bit should be written logic one to reduce power consumption in the digital input buffer.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ADC0D</NAME>
          <DESCRIPTION>Disable ADC7:0 Digital Input</DESCRIPTION>
          <TEXT>When this bit is written logic one, the digital input buffer on the corresponding ADC pin is disabled. The corresponding PIN Register bit will always read as zero when this bit is set. When an analog signal is applied to the ADC7:0 pin and the digital input from this pin is not needed, this bit should be written logic one to reduce power consumption in the digital input buffer.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </DIDR0>
    </AD_CONVERTER>
    <BOOT_LOAD>
      <LIST>[SPMCSR]</LIST>
      <LINK/>
      <RULES/>
      <ICON>io_cpu.bmp</ICON>
      <ID>AVRSimIOSPM.SimIOSPM</ID>
      <TEXT>The Boot Loader Support provides a real Read While Write self-programming mechanism for downloading and uploading program code by the MCU itself. This feature allows flexible application software updates controlled by the MCU using a Flash-resident Boot Loader program. The Boot Loader program can use any available data interface and associated proto-col to read code and write (program) that code into the Flash memory, or read the code from the program memory. The program code within the Boot Loader section has the capability to write into the entire Flash, including the Boot Loader Memory. The Boot Loader can thus even modify itself, and it can also erase itself from the code if the feature is not needed anymore. The size of the Boot Loader Memory is configurable with fuses and the Boot Loader has two separate sets of Boot Lock Bits which can be set independently. This gives the user a unique flexibility to select different levels of protection.</TEXT>
      <SPMCSR>
        <NAME>SPMCSR</NAME>
        <DESCRIPTION>Store Program Memory Control Register</DESCRIPTION>
        <TEXT>The Store Program Memory Control Register contains the control bits needed to control the Boot Loader operations. Note: Only one SPM instruction should be active at any time.</TEXT>
        <IO_ADDR>$37</IO_ADDR>
        <MEM_ADDR>$57</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SPMIE</NAME>
          <DESCRIPTION>SPM Interrupt Enable</DESCRIPTION>
          <TEXT>When the SPMIE bit is written to one, and the I-bit in the Status Register is set (one), the SPM ready interrupt will be enabled. The SPM ready Interrupt will be executed as long as the SPMEN bit in the SPMCR register is cleared.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>RWWSB</NAME>
          <DESCRIPTION>Read While Write Section Busy</DESCRIPTION>
          <TEXT>When a self-programming (page erase or page write) operation to the RWW section is initiated, the RWWSB will be set (one) by hardware. When the RWWSB bit is set, the RWW section cannot be accessed. The RWWSB bit will be cleared if the RWWSRE bit is written to one after a self-programming operation is completed. Alternatively the RWWSB bit will automatically be cleared if a page load operation is initiated.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SIGRD</NAME>
          <DESCRIPTION>Signature Row Read</DESCRIPTION>
          <TEXT>If this bit is written to one at the same time as SPMEN, the next LPM instruction within three clock cycles will read a byte from the signature row into the destination register. A SPM instruction within four cycles after SIGRD and SPMEN are set, will have no effect. This operation is reserved for future use and should not be used.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>RWWSRE</NAME>
          <DESCRIPTION>Read While Write Section Read Enable</DESCRIPTION>
          <TEXT>When programming (page erase or page write) to the RWW section, the RWW section is blocked for reading (the RWWSB will be set by hardware). To re-enable the RWW section, the user software must wait until the programming is completed (SPMEN will be cleared). Then, if the RWWSRE bit is written to one at the same time as SPMEN, the next SPM instruction within four clock cycles re-enables the RWW section. The RWW section cannot be re-enabled while the Flash is busy with a page erase or a page write (SPMEN is set). If the RWWSRE bit is written while the Flash is being loaded, the Flash load operation will abort and the data loaded will be lost.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>BLBSET</NAME>
          <DESCRIPTION>Boot Lock Bit Set</DESCRIPTION>
          <TEXT>If this bit is written to one at the same time as SPMEN, the next SPM instruction within four clock cycles sets Boot Lock bits, according to the data in R0. The data in R1 and the address in the Z pointer are ignored. The BLBSET bit will automatically be cleared upon completion of the lock bit set, or if no SPM instruction is executed within four clock cycles. A LPM instruction within three cycles after BLBSET and SPMEN are set in the SPMCR register, will read either the Lock-bits or the Fuse bits (depending on Z0 in the Z pointer) into the destination register.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PGWRT</NAME>
          <DESCRIPTION>Page Write</DESCRIPTION>
          <TEXT>If this bit is written to one at the same time as SPMEN, the next SPM instruction within four clock cycles executes page write, with the data stored in the temporary buffer. The page address is taken from the high part of the Z pointer. The data in R1 and R0 are ignored. The PGWRT bit will auto-clear upon completion of a page write, or if no SPM instruction is executed within four clock cycles. The CPU is halted during the entire page write operation if the NRWW section is addressed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PGERS</NAME>
          <DESCRIPTION>Page Erase</DESCRIPTION>
          <TEXT>If this bit is written to one at the same time as SPMEN, the next SPM instruction within four clock cycles executes page erase. The page address is taken from the high part of the Z pointer. The data in R1 and R0 are ignored. The PGERS bit will auto-clear upon completion of a page erase, or if no SPM instruction is executed within four clock cycles. The CPU is halted during the entire page write operation if the NRWW section is addressed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SPMEN</NAME>
          <DESCRIPTION>Store Program Memory Enable</DESCRIPTION>
          <TEXT>This bit enables the SPM instruction for the next four clock cycles. If written to one together with either RWWSRE, BLB-SET, PGWRT or PGERS, the following SPM instruction will have a special meaning, see description above. If only SPMEN is written, the following SPM instruction will store the value in R1:R0 in the temporary page buffer addressed by the Z pointer. The LSB of the Z pointer is ignored. The SPMEN bit will auto-clear upon completion of an SPM instruction, or if no SPM instruction is executed within four clock cycles. During page erase and page write, the SPMEN bit remain high until the operation is completed. Writing any other combination than "10001", "01001", "00101", "00011" or "00001" in the lower five bits will have no effect.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SPMCSR>
    </BOOT_LOAD>
    <CPU>
      <LIST>[SREG:SPH:SPL:MCUCR:MCUSR:OSCCAL:CLKPR:SMCR:RAMPZ:GPIOR2:GPIOR1:GPIOR0:PRR2:PRR1:PRR0]</LIST>
      <LINK>[SPH:SPL]</LINK>
      <ICON>io_cpu.bmp</ICON>
      <ID/>
      <TEXT/>
      <SREG>
        <NAME>SREG</NAME>
        <DESCRIPTION>Status Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$3F</IO_ADDR>
        <MEM_ADDR>$5F</MEM_ADDR>
        <ICON>io_sreg.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>I</NAME>
          <DESCRIPTION>Global Interrupt Enable</DESCRIPTION>
          <TEXT>The global interrupt enable bit must be set (one) for the interrupts to be enabled. The individual interrupt enable control is then performed in separate control registers. If the global interrupt enable bit is cleared (zero), none of the interrupts are enabled independent of the individual interrupt enable settings. The I-bit is cleared by hardware after an interrupt has occurred, and is set by the RETI instruction to enable subsequent interrupts.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>T</NAME>
          <DESCRIPTION>Bit Copy Storage</DESCRIPTION>
          <TEXT>The bit copy instructions BLD (Bit LoaD) and BST (Bit STore) use the T bit as source and destination for the operated bit. A bit from a register in the register file can be copied into T by the BST instruction, and a bit in T can be copied into a bit in a register in the register file by the BLD instruction.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>H</NAME>
          <DESCRIPTION>Half Carry Flag</DESCRIPTION>
          <TEXT>The half carry flag H indicates a half carry in some arithmetic operations. See the Instruction Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>S</NAME>
          <DESCRIPTION>Sign Bit</DESCRIPTION>
          <TEXT>The S-bit is always an exclusive or between the negative flag N and the two's complement overflow flag V. See the Instruction Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>V</NAME>
          <DESCRIPTION>Two's Complement Overflow Flag</DESCRIPTION>
          <TEXT>The two's complement overflow flag V supports two's complement arithmetics. See the Instruction Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>N</NAME>
          <DESCRIPTION>Negative Flag</DESCRIPTION>
          <TEXT>The negative flag N indicates a negative result after the different arithmetic and logic operations. See the Instruction Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>Z</NAME>
          <DESCRIPTION>Zero Flag</DESCRIPTION>
          <TEXT>The zero flag Z indicates a zero result after the different arithmetic and logic operations. See the Instruction Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>C</NAME>
          <DESCRIPTION>Carry Flag</DESCRIPTION>
          <TEXT>The carry flag C indicates a carry in an arithmetic or logic operation. See the Instruction Set Description for detailed information. Note that the status register is not automatically stored when entering an interrupt routine and restored when returning from an interrupt routine. This must be handled by software.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SREG>
      <SPH>
        <NAME>SPH</NAME>
        <DESCRIPTION>Stack Pointer High</DESCRIPTION>
        <TEXT>The AVR Stack Pointer is implemented as two 8-bit registers SPL and SPH in the I/O space. The number of bits actually used is implementation dependent. Note that the data space in some implementations of the AVR architecture is so small that only SPL is needed. In this case, the SPH Register will not be present.</TEXT>
        <IO_ADDR>$3E</IO_ADDR>
        <MEM_ADDR>$5E</MEM_ADDR>
        <ICON>io_sph.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>SP15</NAME>
          <DESCRIPTION>Stack Pointer High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SP14</NAME>
          <DESCRIPTION>Stack Pointer High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SP13</NAME>
          <DESCRIPTION>Stack Pointer High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SP12</NAME>
          <DESCRIPTION>Stack Pointer High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SP11</NAME>
          <DESCRIPTION>Stack Pointer High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SP10</NAME>
          <DESCRIPTION>Stack Pointer High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SP9</NAME>
          <DESCRIPTION>Stack Pointer High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SP8</NAME>
          <DESCRIPTION>Stack Pointer High Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
          <ENUM>SP_HIGH_BITF</ENUM>
        </BIT0>
      </SPH>
      <SPL>
        <NAME>SPL</NAME>
        <DESCRIPTION>Stack Pointer Low</DESCRIPTION>
        <TEXT>The AVR Stack Pointer is implemented as two 8-bit registers SPL and SPH in the I/O space. The number of bits actually used is implementation dependent. Note that the data space in some implementations of the AVR architecture is so small that only SPL is needed. In this case, the SPH Register will not be present.</TEXT>
        <IO_ADDR>$3D</IO_ADDR>
        <MEM_ADDR>$5D</MEM_ADDR>
        <ICON>io_sph.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>SP7</NAME>
          <DESCRIPTION>Stack Pointer Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SP6</NAME>
          <DESCRIPTION>Stack Pointer Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SP5</NAME>
          <DESCRIPTION>Stack Pointer Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SP4</NAME>
          <DESCRIPTION>Stack Pointer Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SP3</NAME>
          <DESCRIPTION>Stack Pointer Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SP2</NAME>
          <DESCRIPTION>Stack Pointer Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SP1</NAME>
          <DESCRIPTION>Stack Pointer Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SP0</NAME>
          <DESCRIPTION>Stack Pointer Low Byte</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
          <ENUM>SP_LOW_BITF</ENUM>
        </BIT0>
      </SPL>
      <MCUCR>
        <NAME>MCUCR</NAME>
        <DESCRIPTION>MCU Control Register</DESCRIPTION>
        <TEXT>The MCU Control Register contains control bits for general Microcontroller Unit functions.</TEXT>
        <IO_ADDR>$35</IO_ADDR>
        <MEM_ADDR>$55</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>JTD</NAME>
          <DESCRIPTION>JTAG Interface Disable</DESCRIPTION>
          <TEXT>When this bit is zero, the JTAG interface is enabled if the JTAGEN Fuse is programmed. If this bit is one, the JTAG interface is disabled. In order to avoid unintentional disabling or enabling of the JTAG interface, a timed sequence must be followed when changing this bit: The application software must write this bit to the desired value twice within four cycles to change its value. Note that this bit must not be altered when using the On-chip Debug system.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PUD</NAME>
          <DESCRIPTION>Pull-up Disable</DESCRIPTION>
          <TEXT>When this bit is written to one, the I/O ports pull-up resistors are disabled even if the DDxn and PORTxn Registers are configured to enable the pull-up resistor ({DDxn, PORTxn} = 2'b01). See section "Ports as General Digital I/O" for more details about this feature.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>IVSEL</NAME>
          <DESCRIPTION>Interrupt Vector Select</DESCRIPTION>
          <TEXT>When the IVSEL bit is cleared (zero), the Interrupt Vectors are placed at the start of the Flash memory. When this bit is set (one), the Interrupt Vectors are moved to the beginning of the Boot Loader section of the Flash. The actual address of the start of the Boot Flash Section is determined by the BOOTSZ Fuses. Refer to the section "Memory Programming" for details. To avoid unintentional changes of Interrupt Vector tables, a special write procedure must be followed to change the IVSEL bit (see section "Moving Interrupts Between Application and Boot Section" for details): 1. Write the Interrupt Vector Change Enable (IVCE) bit to one; 2. Within four cycles, write the desired value to IVSEL while writing a zero to IVCE. Interrupts will be automatically disabled while this sequence is executed. Interrupts are disabled in the same cycle IVCE is set, and they remain disabled until after the instruction following the write to IVSEL. If IVSEL is not written, interrupts remain disabled for four cycles. The I-bit in the Status Register is unaffected by the automatic disabling. Note that if Interrupt Vectors are placed in the Boot Loader section and Boot Lock bit BLB02 is programmed, interrupts are disabled while executing from the Application section. If Interrupt Vectors are placed in the Application section and Boot Lock bit BLB12 is programed, interrupts are disabled while executing from the Boot Loader section.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>IVCE</NAME>
          <DESCRIPTION>Interrupt Vector Change Enable</DESCRIPTION>
          <TEXT>The IVCE bit must be written to logic one to enable change of the IVSEL bit. IVCE is cleared by hardware four cycles after it is written or when IVSEL is written. Setting the IVCE bit will disable interrupts as explained in the IVSEL description.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </MCUCR>
      <MCUSR>
        <NAME>MCUSR</NAME>
        <DESCRIPTION>MCU Status Register</DESCRIPTION>
        <TEXT>The MCU Status Register provides information on which reset source caused an MCU reset. To make use of the Reset Flags to identify a reset condition, the user should read and then Reset the MCUSR as early as possible in the program. If the register is cleared before another reset occurs, the source of the reset can be found by examining the Reset Flags. Note, after power on the bit EXTRF has to be ignored.</TEXT>
        <IO_ADDR>$34</IO_ADDR>
        <MEM_ADDR>$54</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>Res2</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>JTRF</NAME>
          <DESCRIPTION>JTAG Reset Flag</DESCRIPTION>
          <TEXT>This bit is set if a reset is being caused by a logic one in the JTAG Reset Register selected by the JTAG instruction AVR_RESET. This bit is reset by a Power-on Reset, or by writing a logic zero to the flag.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>WDRF</NAME>
          <DESCRIPTION>Watchdog Reset Flag</DESCRIPTION>
          <TEXT>This bit is set if a Watchdog Reset occurs. The bit is reset by a Power-on Reset, or by writing a logic zero to the flag.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>BORF</NAME>
          <DESCRIPTION>Brown-out Reset Flag</DESCRIPTION>
          <TEXT>This bit is set if a Brown-out Reset occurs. The bit is reset by a Power-on Reset, or by writing a logic zero to the flag.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>EXTRF</NAME>
          <DESCRIPTION>External Reset Flag</DESCRIPTION>
          <TEXT>This bit is set if an External Reset occurs. The bit is reset by a Power-on Reset, or by writing a logic zero to the flag.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PORF</NAME>
          <DESCRIPTION>Power-on Reset Flag</DESCRIPTION>
          <TEXT>This bit is set if a Power-on Reset occurs. The bit is reset only by writing a logic zero to the flag.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </MCUSR>
      <OSCCAL>
        <NAME>OSCCAL</NAME>
        <DESCRIPTION>Oscillator Calibration Value</DESCRIPTION>
        <TEXT>The Oscillator Calibration Register is used to trim the Calibrated Internal RC Oscillator to remove process variations from the oscillator frequency. A preprogrammed calibration value is automatically written to this register during chip reset, giving the Factory calibrated frequency. The application software can write this register to change the oscillator frequency. The oscillator can be calibrated to frequencies as specified in the section "Electrical Characteristics". Calibration outside that range is not guaranteed. Note that this oscillator is used to time EEPROM and Flash write accesses and these write times will be affected accordingly. The calibration to very high frequencies can cause EEPROM or Flash erase/write failures. The CAL7 bit determines the range of operation for the oscillator. Setting this bit to 0 gives the lowest frequency range, setting this bit to 1 gives the highest frequency range. The two frequency ranges are overlapping, in other words a setting of OSCCAL = 0x7F gives a higher frequency than OSCCAL = 0x80. The CAL6..0 bits are used to tune the frequency within the selected range. A setting of 0x00 gives the lowest frequency in that range, and a setting of 0x7F gives the highest frequency in the range.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$66</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>CAL7</NAME>
          <DESCRIPTION>Oscillator Calibration Tuning Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>CAL6</NAME>
          <DESCRIPTION>Oscillator Calibration Tuning Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>CAL5</NAME>
          <DESCRIPTION>Oscillator Calibration Tuning Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>CAL4</NAME>
          <DESCRIPTION>Oscillator Calibration Tuning Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>CAL3</NAME>
          <DESCRIPTION>Oscillator Calibration Tuning Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CAL2</NAME>
          <DESCRIPTION>Oscillator Calibration Tuning Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CAL1</NAME>
          <DESCRIPTION>Oscillator Calibration Tuning Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CAL0</NAME>
          <DESCRIPTION>Oscillator Calibration Tuning Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>OSCCAL_BITF</ENUM>
        </BIT0>
      </OSCCAL>
      <CLKPR>
        <NAME>CLKPR</NAME>
        <DESCRIPTION>Clock Prescale Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$61</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>CLKPCE</NAME>
          <DESCRIPTION>Clock Prescaler Change Enable</DESCRIPTION>
          <TEXT>The CLKPCE bit must be written to logic one to enable change of the CLKPS bits. The CLKPCE bit is only updated when the other bits in CLKPR are simultaneously written to zero. CLKPCE is cleared by hardware four cycles after it is written or when CLKPS bits are written. Rewriting the CLKPCE bit within this time-out period does neither extend the time-out period, nor clear the CLKPCE bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res2</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>CLKPS3</NAME>
          <DESCRIPTION>Clock Prescaler Select Bits</DESCRIPTION>
          <TEXT>These bits define the division factor between the selected clock source and the internal system clock. These bits can be written run-time to vary the clock frequency to suit the application requirements. As the divider divides the master clock input to the MCU, the speed of all synchronous peripherals is reduced when a division factor is used. The division factors are given in the following table. Note that the factor is different when using the internal 16MHz RC oscillator as the clock source. The CKDIV8 Fuse determines the initial value of the CLKPS bits. If CKDIV8 is not programmed, the CLKPS bits will be reset to 0000. If CKDIV8 is programmed, CLKPS bits are reset to 0011 giving a division factor of 8 at start up. This feature should be used if the selected clock source has a higher frequency than the maximum frequency of the device at the present operating conditions. Note that any value can be written to the CLKPS bits regardless of the CKDIV8 Fuse setting. The Application software must ensure that a sufficient division factor is chosen if the selected clock source has a higher frequency than the maximum frequency of the device at the present operating conditions. The device is shipped with the CKDIV8 Fuse programmed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CLKPS2</NAME>
          <DESCRIPTION>Clock Prescaler Select Bits</DESCRIPTION>
          <TEXT>These bits define the division factor between the selected clock source and the internal system clock. These bits can be written run-time to vary the clock frequency to suit the application requirements. As the divider divides the master clock input to the MCU, the speed of all synchronous peripherals is reduced when a division factor is used. The division factors are given in the following table. Note that the factor is different when using the internal 16MHz RC oscillator as the clock source. The CKDIV8 Fuse determines the initial value of the CLKPS bits. If CKDIV8 is not programmed, the CLKPS bits will be reset to 0000. If CKDIV8 is programmed, CLKPS bits are reset to 0011 giving a division factor of 8 at start up. This feature should be used if the selected clock source has a higher frequency than the maximum frequency of the device at the present operating conditions. Note that any value can be written to the CLKPS bits regardless of the CKDIV8 Fuse setting. The Application software must ensure that a sufficient division factor is chosen if the selected clock source has a higher frequency than the maximum frequency of the device at the present operating conditions. The device is shipped with the CKDIV8 Fuse programmed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CLKPS1</NAME>
          <DESCRIPTION>Clock Prescaler Select Bits</DESCRIPTION>
          <TEXT>These bits define the division factor between the selected clock source and the internal system clock. These bits can be written run-time to vary the clock frequency to suit the application requirements. As the divider divides the master clock input to the MCU, the speed of all synchronous peripherals is reduced when a division factor is used. The division factors are given in the following table. Note that the factor is different when using the internal 16MHz RC oscillator as the clock source. The CKDIV8 Fuse determines the initial value of the CLKPS bits. If CKDIV8 is not programmed, the CLKPS bits will be reset to 0000. If CKDIV8 is programmed, CLKPS bits are reset to 0011 giving a division factor of 8 at start up. This feature should be used if the selected clock source has a higher frequency than the maximum frequency of the device at the present operating conditions. Note that any value can be written to the CLKPS bits regardless of the CKDIV8 Fuse setting. The Application software must ensure that a sufficient division factor is chosen if the selected clock source has a higher frequency than the maximum frequency of the device at the present operating conditions. The device is shipped with the CKDIV8 Fuse programmed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CLKPS0</NAME>
          <DESCRIPTION>Clock Prescaler Select Bits</DESCRIPTION>
          <TEXT>These bits define the division factor between the selected clock source and the internal system clock. These bits can be written run-time to vary the clock frequency to suit the application requirements. As the divider divides the master clock input to the MCU, the speed of all synchronous peripherals is reduced when a division factor is used. The division factors are given in the following table. Note that the factor is different when using the internal 16MHz RC oscillator as the clock source. The CKDIV8 Fuse determines the initial value of the CLKPS bits. If CKDIV8 is not programmed, the CLKPS bits will be reset to 0000. If CKDIV8 is programmed, CLKPS bits are reset to 0011 giving a division factor of 8 at start up. This feature should be used if the selected clock source has a higher frequency than the maximum frequency of the device at the present operating conditions. Note that any value can be written to the CLKPS bits regardless of the CKDIV8 Fuse setting. The Application software must ensure that a sufficient division factor is chosen if the selected clock source has a higher frequency than the maximum frequency of the device at the present operating conditions. The device is shipped with the CKDIV8 Fuse programmed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>CPU_CLK_PRESCALE_4_BITS_SMALL_MEGARF</ENUM>
        </BIT0>
      </CLKPR>
      <SMCR>
        <NAME>SMCR</NAME>
        <DESCRIPTION>Sleep Mode Control Register</DESCRIPTION>
        <TEXT>The Sleep Mode Control Register contains control bits for power management.</TEXT>
        <IO_ADDR>$33</IO_ADDR>
        <MEM_ADDR>$53</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>Res3</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res2</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SM2</NAME>
          <DESCRIPTION>Sleep Mode Select bit 2</DESCRIPTION>
          <TEXT>These bits select between the five available sleep modes. Standby modes are only recommended for use with external crystals or resonators.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SM1</NAME>
          <DESCRIPTION>Sleep Mode Select bit 1</DESCRIPTION>
          <TEXT>These bits select between the five available sleep modes. Standby modes are only recommended for use with external crystals or resonators.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SM0</NAME>
          <DESCRIPTION>Sleep Mode Select bit 0</DESCRIPTION>
          <TEXT>These bits select between the five available sleep modes. Standby modes are only recommended for use with external crystals or resonators.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>CPU_SLEEP_MODE_3BITS</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SE</NAME>
          <DESCRIPTION>Sleep Enable</DESCRIPTION>
          <TEXT>The SE bit must be written to logic one to make the MCU enter the sleep mode when the SLEEP instruction is executed. To avoid the MCU entering the sleep mode unless it is the programmers purpose, it is recommended to write the Sleep Enable (SE) bit to one just before the execution of the SLEEP instruction and to clear it immediately after waking up.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SMCR>
      <RAMPZ>
        <NAME>RAMPZ</NAME>
        <DESCRIPTION>Extended Z-pointer Register for ELPM/SPM</DESCRIPTION>
        <TEXT>For ELPM/SPM instructions, the Z-pointer is a concatenation of RAMPZ, ZH, and ZL. Note that LPM is not affected by the RAMPZ setting.</TEXT>
        <IO_ADDR>$3B</IO_ADDR>
        <MEM_ADDR>$5B</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>Res5</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>For compatibility with future devices, be sure to write these bits to zero.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res4</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>For compatibility with future devices, be sure to write these bits to zero.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>Res3</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>For compatibility with future devices, be sure to write these bits to zero.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res2</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>For compatibility with future devices, be sure to write these bits to zero.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>For compatibility with future devices, be sure to write these bits to zero.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>For compatibility with future devices, be sure to write these bits to zero.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>RAMPZ1</NAME>
          <DESCRIPTION>Extended Z-Pointer Value</DESCRIPTION>
          <TEXT>These two bits represent the MSB's of the Z-Pointer.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>RAMPZ0</NAME>
          <DESCRIPTION>Extended Z-Pointer Value</DESCRIPTION>
          <TEXT>These two bits represent the MSB's of the Z-Pointer.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>RAMPZ_BITF</ENUM>
        </BIT0>
      </RAMPZ>
      <GPIOR2>
        <NAME>GPIOR2</NAME>
        <DESCRIPTION>General Purpose I/O Register 2</DESCRIPTION>
        <TEXT>The three General Purpose I/O Registers can be used for storing any information.</TEXT>
        <IO_ADDR>$2B</IO_ADDR>
        <MEM_ADDR>$4B</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>GPIOR27</NAME>
          <DESCRIPTION>General Purpose I/O Register 2 Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>GPIOR26</NAME>
          <DESCRIPTION>General Purpose I/O Register 2 Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>GPIOR25</NAME>
          <DESCRIPTION>General Purpose I/O Register 2 Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>GPIOR24</NAME>
          <DESCRIPTION>General Purpose I/O Register 2 Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>GPIOR23</NAME>
          <DESCRIPTION>General Purpose I/O Register 2 Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>GPIOR22</NAME>
          <DESCRIPTION>General Purpose I/O Register 2 Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>GPIOR21</NAME>
          <DESCRIPTION>General Purpose I/O Register 2 Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>GPIOR20</NAME>
          <DESCRIPTION>General Purpose I/O Register 2 Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </GPIOR2>
      <GPIOR1>
        <NAME>GPIOR1</NAME>
        <DESCRIPTION>General Purpose IO Register 1</DESCRIPTION>
        <TEXT>The three General Purpose I/O Registers can be used for storing any information.</TEXT>
        <IO_ADDR>$2A</IO_ADDR>
        <MEM_ADDR>$4A</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>GPIOR17</NAME>
          <DESCRIPTION>General Purpose I/O Register 1 Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>GPIOR16</NAME>
          <DESCRIPTION>General Purpose I/O Register 1 Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>GPIOR15</NAME>
          <DESCRIPTION>General Purpose I/O Register 1 Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>GPIOR14</NAME>
          <DESCRIPTION>General Purpose I/O Register 1 Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>GPIOR13</NAME>
          <DESCRIPTION>General Purpose I/O Register 1 Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>GPIOR12</NAME>
          <DESCRIPTION>General Purpose I/O Register 1 Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>GPIOR11</NAME>
          <DESCRIPTION>General Purpose I/O Register 1 Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>GPIOR10</NAME>
          <DESCRIPTION>General Purpose I/O Register 1 Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </GPIOR1>
      <GPIOR0>
        <NAME>GPIOR0</NAME>
        <DESCRIPTION>General Purpose IO Register 0</DESCRIPTION>
        <TEXT>The three General Purpose I/O Registers can be used for storing any information.</TEXT>
        <IO_ADDR>$1E</IO_ADDR>
        <MEM_ADDR>$3E</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>GPIOR07</NAME>
          <DESCRIPTION>General Purpose I/O Register 0 Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>GPIOR06</NAME>
          <DESCRIPTION>General Purpose I/O Register 0 Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>GPIOR05</NAME>
          <DESCRIPTION>General Purpose I/O Register 0 Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>GPIOR04</NAME>
          <DESCRIPTION>General Purpose I/O Register 0 Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>GPIOR03</NAME>
          <DESCRIPTION>General Purpose I/O Register 0 Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>GPIOR02</NAME>
          <DESCRIPTION>General Purpose I/O Register 0 Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>GPIOR01</NAME>
          <DESCRIPTION>General Purpose I/O Register 0 Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>GPIOR00</NAME>
          <DESCRIPTION>General Purpose I/O Register 0 Value</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </GPIOR0>
      <PRR2>
        <NAME>PRR2</NAME>
        <DESCRIPTION>Power Reduction Register 2</DESCRIPTION>
        <TEXT>The Power Reduction Register PRR2 allows to individually disable all four SRAM blocks. Setting any PRRAM3:0 bit to one will completely switch off (disconnect from the power supply) the corresponding SRAM block. This enables the application to disable unused SRAM memory to save power. Every SRAM block can be re-enabled by reseting the appropriate PRRAM3:0 bit.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$63</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>Res3</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res2</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PRRAM3</NAME>
          <DESCRIPTION>Power Reduction SRAM 3</DESCRIPTION>
          <TEXT>Setting this bit to one will disable the SRAM block 3. Setting this bit to zero will enable the SRAM block 3.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PRRAM2</NAME>
          <DESCRIPTION>Power Reduction SRAM 2</DESCRIPTION>
          <TEXT>Setting this bit to one will disable the SRAM block 2. Setting this bit to zero will enable the SRAM block 2.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PRRAM1</NAME>
          <DESCRIPTION>Power Reduction SRAM 1</DESCRIPTION>
          <TEXT>Setting this bit to one will disable the SRAM block 1. Setting this bit to zero will enable the SRAM block 1.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PRRAM0</NAME>
          <DESCRIPTION>Power Reduction SRAM 0</DESCRIPTION>
          <TEXT>Setting this bit to one will disable the SRAM block 0. Setting this bit to zero will enable the SRAM block 0.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PRR2>
      <PRR1>
        <NAME>PRR1</NAME>
        <DESCRIPTION>Power Reduction Register 1</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$65</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>Res</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PRTRX24</NAME>
          <DESCRIPTION>Power Reduction Transceiver</DESCRIPTION>
          <TEXT>Writing a logic one to this bit shuts down the transceiver (disconnect from the power supply). In power-down and power-save modes the power-chain will be disabled when this bit is one. Writing a logic zero to this bit will re-enable the transceiver.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PRTIM5</NAME>
          <DESCRIPTION>Power Reduction Timer/Counter5</DESCRIPTION>
          <TEXT>Writing a logic one to this bit shuts down the Timer/Counter5 module. When the Timer/Counter5 is enabled, operation will continue like before the shutdown.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PRTIM4</NAME>
          <DESCRIPTION>Power Reduction Timer/Counter4</DESCRIPTION>
          <TEXT>Writing a logic one to this bit shuts down the Timer/Counter4 module. When the Timer/Counter4 is enabled, operation will continue like before the shutdown.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PRTIM3</NAME>
          <DESCRIPTION>Power Reduction Timer/Counter3</DESCRIPTION>
          <TEXT>Writing a logic one to this bit shuts down the Timer/Counter3 module. When the Timer/Counter3 is enabled, operation will continue like before the shutdown.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PRUSART3</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>This bit is reserved for future use. It has currently no associated function.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PRUSART2</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>This bit is reserved for future use. It has currently no associated function.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PRUSART1</NAME>
          <DESCRIPTION>Power Reduction USART1</DESCRIPTION>
          <TEXT>Writing a logic one to this bit shuts down the USART1 by stopping the clock to the module. When waking up the USART1 again, the USART1 should be reinitialized to ensure proper operation.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PRR1>
      <PRR0>
        <NAME>PRR0</NAME>
        <DESCRIPTION>Power Reduction Register0</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$64</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>PRTWI</NAME>
          <DESCRIPTION>Power Reduction TWI</DESCRIPTION>
          <TEXT>Writing a logic one to this bit shuts down the TWI by stopping the clock to the module. When waking up the TWI again, the TWI should be re initialized to ensure proper operation.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PRTIM2</NAME>
          <DESCRIPTION>Power Reduction Timer/Counter2</DESCRIPTION>
          <TEXT>Writing a logic one to this bit shuts down the Timer/Counter2 module. When the Timer/Counter2 is enabled, operation will continue like before the shutdown.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PRTIM0</NAME>
          <DESCRIPTION>Power Reduction Timer/Counter0</DESCRIPTION>
          <TEXT>Writing a logic one to this bit shuts down the Timer/Counter0 module. When the Timer/Counter0 is enabled, operation will continue like before the shutdown.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PRPGA</NAME>
          <DESCRIPTION>Power Reduction PGA</DESCRIPTION>
          <TEXT>Writing a logic one to this bit reduced the power consumption of the programmable gain amplifier. The block is not turned off. Only the current levels in the amplifiers are reduced. Reducing the PGA current levels is only recommended for slow ADC clock frequencies. A new ADC conversion using the PGA should be delayed by a default start-up time after changing (setting or resetting) this bit.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PRTIM1</NAME>
          <DESCRIPTION>Power Reduction Timer/Counter1</DESCRIPTION>
          <TEXT>Writing a logic one to this bit shuts down the Timer/Counter1 module. When the Timer/Counter1 is enabled, operation will continue like before the shutdown.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PRSPI</NAME>
          <DESCRIPTION>Power Reduction Serial Peripheral Interface</DESCRIPTION>
          <TEXT>Writing a logic one to this bit shuts down the Serial Peripheral Interface by stopping the clock to the module. When waking up the SPI again, the SPI should be re initialized to ensure proper operation.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PRUSART0</NAME>
          <DESCRIPTION>Power Reduction USART</DESCRIPTION>
          <TEXT>Writing a logic one to this bit shuts down the USART0 by stopping the clock to the module. When waking up the USART0 again, the USART0 should be reinitialized to ensure proper operation.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PRADC</NAME>
          <DESCRIPTION>Power Reduction ADC</DESCRIPTION>
          <TEXT>Writing a logic one to this bit shuts down the ADC. The ADC must be disabled (reset ADEN bit in register ADCSRA) before shut down. The analog comparator cannot use the ADC input MUX when the ADC is shut down.</TEXT>
          <ACCESS>R/W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PRR0>
    </CPU>
    <FLASH>
      <LIST>[NEMCR:BGCR]</LIST>
      <LINK/>
      <ICON>io_flash.bmp</ICON>
      <ID/>
      <TEXT/>
      <NEMCR>
        <NAME>NEMCR</NAME>
        <DESCRIPTION>Flash Extended-Mode Control-Register</DESCRIPTION>
        <TEXT>The Flash Extended-Mode Control-Register handles the extended address-mode of the extra rows.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$75</MEM_ADDR>
        <ICON>io_flash.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT6>
          <NAME>ENEAM</NAME>
          <DESCRIPTION>Enable Extended Address Mode for Extra Rows</DESCRIPTION>
          <TEXT>When active high, the extended address mode of the extra rows is enabled. The address is decoded from bits AEAM1:0 of this register.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>AEAM1</NAME>
          <DESCRIPTION>Address for Extended Address Mode of Extra Rows</DESCRIPTION>
          <TEXT>These bits are only used when bit ENEAM of this register is set high. Then AEAM1:0 are used to decode the addresses of the extra rows. A value of 0 decodes the default factory row that is also accessible when the extended address mode is deactivated.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>AEAM0</NAME>
          <DESCRIPTION>Address for Extended Address Mode of Extra Rows</DESCRIPTION>
          <TEXT>These bits are only used when bit ENEAM of this register is set high. Then AEAM1:0 are used to decode the addresses of the extra rows. A value of 0 decodes the default factory row that is also accessible when the extended address mode is deactivated.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>NEMCR_ADDRESS_BITF</ENUM>
        </BIT4>
      </NEMCR>
      <BGCR>
        <NAME>BGCR</NAME>
        <DESCRIPTION>Reference Voltage Calibration Register</DESCRIPTION>
        <TEXT>This register contains the calibration values of the reference voltage of the ADC. The values are loaded from the fuse memory after power-up. They can be corrected by the application software e.g. to compensate for temperature changes. The internal 1.6V reference voltage is calibrated and has therefore the highest accuracy compared to the 1.5V or AVDD reference.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$67</MEM_ADDR>
        <ICON>io_flash.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>Res</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>BGCAL_FINE3</NAME>
          <DESCRIPTION>Fine Calibration Bits</DESCRIPTION>
          <TEXT>These bits allow the calibration of the AREF voltage with a resolution of 2mV.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>BGCAL_FINE2</NAME>
          <DESCRIPTION>Fine Calibration Bits</DESCRIPTION>
          <TEXT>These bits allow the calibration of the AREF voltage with a resolution of 2mV.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>BGCAL_FINE1</NAME>
          <DESCRIPTION>Fine Calibration Bits</DESCRIPTION>
          <TEXT>These bits allow the calibration of the AREF voltage with a resolution of 2mV.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>BGCAL_FINE0</NAME>
          <DESCRIPTION>Fine Calibration Bits</DESCRIPTION>
          <TEXT>These bits allow the calibration of the AREF voltage with a resolution of 2mV.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>BGCAL_FINE_BITF</ENUM>
        </BIT3>
        <BIT2>
          <NAME>BGCAL2</NAME>
          <DESCRIPTION>Coarse Calibration Bits</DESCRIPTION>
          <TEXT>These bits allow the calibration of the AREF voltage with a resolution of 10mV.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>BGCAL1</NAME>
          <DESCRIPTION>Coarse Calibration Bits</DESCRIPTION>
          <TEXT>These bits allow the calibration of the AREF voltage with a resolution of 10mV.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>BGCAL0</NAME>
          <DESCRIPTION>Coarse Calibration Bits</DESCRIPTION>
          <TEXT>These bits allow the calibration of the AREF voltage with a resolution of 10mV.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>BGCAL_BITF</ENUM>
        </BIT0>
      </BGCR>
    </FLASH>
    <PWRCTRL>
      <LIST>[TRXPR:DRTRAM0:DRTRAM1:DRTRAM2:DRTRAM3:LLDRL:LLDRH:LLCR:DPDS0:DPDS1:MCUCR]</LIST>
      <LINK/>
      <ICON>io_pwrctrl.bmp</ICON>
      <ID/>
      <TEXT/>
      <TRXPR>
        <NAME>TRXPR</NAME>
        <DESCRIPTION>Transceiver Pin Register</DESCRIPTION>
        <TEXT>The register TRXPR allows to control basic actions of the radio transceiver like reset or state transitions. The register bit functionality is inherited from the external pins of the stand-alone radio transceiver.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$139</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>Res3</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res2</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT1>
          <NAME>SLPTR</NAME>
          <DESCRIPTION>Multi-purpose Transceiver Control Bit</DESCRIPTION>
          <TEXT>The bit SLPTR is a multi-functional bit to control transceiver state transitions. Dependent on the radio transceiver state, a rising edge of bit SLPTR causes the following state transitions: TRX_OFF =&gt; SLEEP (level sensitive), PLL_ON =&gt; BUSY_TX. Whereas the falling edge of bit SLPTR causes the following state transition: SLEEP =&gt; TRX_OFF (level sensitive). When the radio transceiver is in TRX_OFF state the microcontroller forces the transceiver to SLEEP by setting SLPTR = H. The Transceiver awakes when the microcontroller releases the bit SLPTR. In states PLL_ON and TX_ARET_ON, bit SLPTR is used as trigger input to initiate a TX transaction. Here SLPTR is sensitive on rising edge only. After initiating a state change by a rising edge at Bit SLPTR in radio transceiver states TRX_OFF, RX_ON or RX_AACK_ON, the radio transceiver remains in the new state as long as the pin is logical high and returns to the preceding state with the falling edge.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TRXRST</NAME>
          <DESCRIPTION>Force Transceiver Reset</DESCRIPTION>
          <TEXT>The RESET state is used to set back the state machine and to reset all registers of the transceiver to their default values. A reset forces the radio transceiver into the TRX_OFF state and resets all transceiver register to their default values. A reset is initiated with bit TRXRST = H. The bit is cleared automatically During transceiver reset the microcontroller has to set the radio transceiver control bit SLPTR to the default value.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TRXPR>
      <DRTRAM0>
        <NAME>DRTRAM0</NAME>
        <DESCRIPTION>Data Retention Configuration Register of SRAM 0</DESCRIPTION>
        <TEXT>The DRTRAM0 register controls the behavior of SRAM block 0 in the power-states "power-save" and "power-down". To prevent any data loss the SRAM will not completely disconnected from the power supply. Instead the SRAM supply voltage can be reduced to a save level thus providing data retention and low leakage current.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$135</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>DRTSWOK</NAME>
          <DESCRIPTION>DRT Switch OK</DESCRIPTION>
          <TEXT>This bit indicates the status of the SRAM power-switch. A logical one indicates that the SRAM supply voltage is fully available and the memory may be accessed normally.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ENDRT</NAME>
          <DESCRIPTION>Enable SRAM Data Retention</DESCRIPTION>
          <TEXT>During the power-states "power-down" and "power-save" each SRAM block will either be switched off or provides data retention of its memory content. This bit must set to one if data retention mode should be used. Otherwise the SRAM is switched off (disconnected from the power supply) and all its data are lost.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
      </DRTRAM0>
      <DRTRAM1>
        <NAME>DRTRAM1</NAME>
        <DESCRIPTION>Data Retention Configuration Register of SRAM 1</DESCRIPTION>
        <TEXT>The DRTRAM1 register controls the behavior of SRAM block 1 in the power-states "power-save" and "power-down". To prevent any data loss the SRAM will not completely disconnected from the power supply. Instead the SRAM supply voltage can be reduced to a save level thus providing data retention and low leakage current.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$134</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>DRTSWOK</NAME>
          <DESCRIPTION>DRT Switch OK</DESCRIPTION>
          <TEXT>This bit indicates the status of the SRAM power-switch. A logical one indicates that the SRAM supply voltage is fully available and the memory may be accessed normally.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ENDRT</NAME>
          <DESCRIPTION>Enable SRAM Data Retention</DESCRIPTION>
          <TEXT>During the power-states "power-down" and "power-save" each SRAM block will either be switched off or provides data retention of its memory content. This bit must set to one if data retention mode should be used. Otherwise the SRAM is switched off (disconnected from the power supply) and all its data are lost.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
      </DRTRAM1>
      <DRTRAM2>
        <NAME>DRTRAM2</NAME>
        <DESCRIPTION>Data Retention Configuration Register of SRAM 2</DESCRIPTION>
        <TEXT>The DRTRAM2 register controls the behavior of SRAM block 2 in the power-states "power-save" and "power-down". To prevent any data loss the SRAM will not completely disconnected from the power supply. Instead the SRAM supply voltage can be reduced to a save level thus providing data retention and low leakage current.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$133</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT6>
          <NAME>Res</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>DRTSWOK</NAME>
          <DESCRIPTION>DRT Switch OK</DESCRIPTION>
          <TEXT>This bit indicates the status of the SRAM power-switch. A logical one indicates that the SRAM supply voltage is fully available and the memory may be accessed normally.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ENDRT</NAME>
          <DESCRIPTION>Enable SRAM Data Retention</DESCRIPTION>
          <TEXT>During the power-states "power-down" and "power-save" each SRAM block will either be switched off or provides data retention of its memory content. This bit must set to one if data retention mode should be used. Otherwise the SRAM is switched off (disconnected from the power supply) and all its data are lost.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
      </DRTRAM2>
      <DRTRAM3>
        <NAME>DRTRAM3</NAME>
        <DESCRIPTION>Data Retention Configuration Register of SRAM 3</DESCRIPTION>
        <TEXT>The DRTRAM3 register controls the behavior of SRAM block 3 in the power-states "power-save" and "power-down". To prevent any data loss the SRAM will not completely disconnected from the power supply. Instead the SRAM supply voltage can be reduced to a save level thus providing data retention and low leakage current.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$132</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>DRTSWOK</NAME>
          <DESCRIPTION>DRT Switch OK</DESCRIPTION>
          <TEXT>This bit indicates the status of the SRAM power-switch. A logical one indicates that the SRAM supply voltage is fully available and the memory may be accessed normally.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ENDRT</NAME>
          <DESCRIPTION>Enable SRAM Data Retention</DESCRIPTION>
          <TEXT>During the power-states "power-down" and "power-save" each SRAM block will either be switched off or provides data retention of its memory content. This bit must set to one if data retention mode should be used. Otherwise the SRAM is switched off (disconnected from the power supply) and all its data are lost.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
      </DRTRAM3>
      <LLDRL>
        <NAME>LLDRL</NAME>
        <DESCRIPTION>Low Leakage Voltage Regulator Data Register (Low-Byte)</DESCRIPTION>
        <TEXT>The low-byte of the calibration data can be accessed through this register. Write access is only enabled when the bit LLENCAL of the LLCR register is 0. Then the data bits LLDRL3:0 directly control the output voltage of the low-leakage voltage regulator. Higher numbers generate lower voltages. The contents of this register is meaningless when the bit LLSHORT of the LLCR register is 1. If the bit LLENCAL is 1 then the results of the automatic calibration are stored.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$130</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>Res3</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res2</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>LLDRL3</NAME>
          <DESCRIPTION>Low-Byte Data Register Bits</DESCRIPTION>
          <TEXT>Value of the low-byte calibration result</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>LLDRL2</NAME>
          <DESCRIPTION>Low-Byte Data Register Bits</DESCRIPTION>
          <TEXT>Value of the low-byte calibration result</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>LLDRL1</NAME>
          <DESCRIPTION>Low-Byte Data Register Bits</DESCRIPTION>
          <TEXT>Value of the low-byte calibration result</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>LLDRL0</NAME>
          <DESCRIPTION>Low-Byte Data Register Bits</DESCRIPTION>
          <TEXT>Value of the low-byte calibration result</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>LLDRL_VALUE_BITF</ENUM>
        </BIT0>
      </LLDRL>
      <LLDRH>
        <NAME>LLDRH</NAME>
        <DESCRIPTION>Low Leakage Voltage Regulator Data Register (High-Byte)</DESCRIPTION>
        <TEXT>The high-byte of the calibration data can be accessed through this register. Write access is only enabled when the bit LLENCAL of the LLCR register is 0. Then the data bits LLDRH4:0 directly control the output voltage of the low-leakage voltage regulator. Higher numbers generate lower voltages. If the bit LLENCAL is 1 then the results of the automatic calibration are stored.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$131</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>Res2</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT>These bits are reserved for future use.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>LLDRH4</NAME>
          <DESCRIPTION>High-Byte Data Register Bits</DESCRIPTION>
          <TEXT>Value of the high-byte calibration result</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>LLDRH3</NAME>
          <DESCRIPTION>High-Byte Data Register Bits</DESCRIPTION>
          <TEXT>Value of the high-byte calibration result</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>LLDRH2</NAME>
          <DESCRIPTION>High-Byte Data Register Bits</DESCRIPTION>
          <TEXT>Value of the high-byte calibration result</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>LLDRH1</NAME>
          <DESCRIPTION>High-Byte Data Register Bits</DESCRIPTION>
          <TEXT>Value of the high-byte calibration result</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>LLDRH0</NAME>
          <DESCRIPTION>High-Byte Data Register Bits</DESCRIPTION>
          <TEXT>Value of the high-byte calibration result</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>LLDRH_VALUE_BITF</ENUM>
        </BIT0>
      </LLDRH>
      <LLCR>
        <NAME>LLCR</NAME>
        <DESCRIPTION>Low Leakage Voltage Regulator Control Register</DESCRIPTION>
        <TEXT>This register allows to monitor and to control the calibration process of the low-leakage voltage regulator. The automatic calibration is the normal operation mode. However, certain circumstances may require to disable this automatic process for instance to save power-up time. The results of the automatic calibration can also be modified when required by the application for instance to get a higher or lower output voltage.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$12F</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved Bit</DESCRIPTION>
          <TEXT>This bit is reserved for future use. A read access always will return zero. A write access does not modify the content.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>LLDONE</NAME>
          <DESCRIPTION>Calibration Done</DESCRIPTION>
          <TEXT>This bit indicates the last state of the calibration algorithm. The data register contents is updated with new calibration data after the bit changed to 1. The bit will only be high for one 64kHz clock period, because a new calibration loop is started automatically.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>LLCOMP</NAME>
          <DESCRIPTION>Comparator Output</DESCRIPTION>
          <TEXT>This bit indicates the output state of the comparator of the low-leakage voltage regulator. In this way the calibration progress can be directly monitored for debug purposes. The state of the bit changes at most every 64kHz clock period.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>LLCAL</NAME>
          <DESCRIPTION>Calibration Active</DESCRIPTION>
          <TEXT>This bit indicates that the automatic calibration is in progress. The analog part of the calibration circuit is powered up if the bit is 1.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>LLTCO</NAME>
          <DESCRIPTION>Temperature Coefficient of Current Source</DESCRIPTION>
          <TEXT>This bit shows the status of the selection of the temperature coefficient. The state of the bit is updated in the course of the automatic calibration. A valid value is present after the LLDONE bit is 1 for the first time. Write access is only enabled when the automatic calibration is turned off (LLENCAL is 0). This bit should not be changed without further information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>LLSHORT</NAME>
          <DESCRIPTION>Short Lower Calibration Circuit</DESCRIPTION>
          <TEXT>This bit shows the status of the short switch for the lower calibration circuit. The state of the bit is updated in the course of the automatic calibration. A valid value is present after the LLDONE bit is 1 for the first time. If this bit is set to 1 register LLDRL has no function. Write access is only possible when the automatic calibration is turned off (LLENCAL is 0). This bit should not be changed without further information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>LLENCAL</NAME>
          <DESCRIPTION>Enable Automatic Calibration</DESCRIPTION>
          <TEXT>This bit enables the automatic calibration. The automatic calibration runs if the state of the bit is 1. Write access to the two data register and the bits LLSHORT and LLTCO is then denied. If the state of LLENCAL is 0 then the calibration algorithm is stopped and the output voltage of the low-leakage voltage regulator is defined by the values in the two data register LLDRL and LLDRH and by the bits LLSHORT and LLTCO.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT0>
      </LLCR>
      <DPDS0>
        <NAME>DPDS0</NAME>
        <DESCRIPTION>Port Driver Strength Register 0</DESCRIPTION>
        <TEXT>The output driver strength can be set individually for each digital I/O port. The following tables show output current levels for a typical supply voltage of DEVDD = 3.3V. Refer to section "Electrical Characteristics" for details.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$136</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>PFDRV1</NAME>
          <DESCRIPTION>Driver Strength Port F </DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PFDRV0</NAME>
          <DESCRIPTION>Driver Strength Port F </DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>PAD_IO_bitf</ENUM>
        </BIT6>
        <BIT5>
          <NAME>PEDRV1</NAME>
          <DESCRIPTION>Driver Strength Port E </DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PEDRV0</NAME>
          <DESCRIPTION>Driver Strength Port E </DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>PAD_IO_bitf</ENUM>
        </BIT4>
        <BIT3>
          <NAME>PDDRV1</NAME>
          <DESCRIPTION>Driver Strength Port D </DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PDDRV0</NAME>
          <DESCRIPTION>Driver Strength Port D </DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>PAD_IO_bitf</ENUM>
        </BIT2>
        <BIT1>
          <NAME>PBDRV1</NAME>
          <DESCRIPTION>Driver Strength Port B </DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PBDRV0</NAME>
          <DESCRIPTION>Driver Strength Port B </DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>PAD_IO_bitf</ENUM>
        </BIT0>
      </DPDS0>
      <DPDS1>
        <NAME>DPDS1</NAME>
        <DESCRIPTION>Port Driver Strength Register 1</DESCRIPTION>
        <TEXT>The output driver strength can be set individually for each digital I/O port. The following table shows output current levels for a typical supply voltage of DEVDD = 3.3V. Refer to section "Electrical Characteristics" for details.</TEXT>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$137</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>Res5</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>Res4</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>Res3</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>Res2</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>Res1</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>Res0</NAME>
          <DESCRIPTION>Reserved</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PGDRV1</NAME>
          <DESCRIPTION>Driver Strength Port G </DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PGDRV0</NAME>
          <DESCRIPTION>Driver Strength Port G </DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
          <ENUM>PAD_IO_bitf</ENUM>
        </BIT0>
      </DPDS1>
      <MCUCR>
        <NAME>MCUCR</NAME>
        <DESCRIPTION>MCU Control Register</DESCRIPTION>
        <TEXT>The MCU Control Register contains control bits of the general Microcontroller Unit functions.</TEXT>
        <IO_ADDR>$35</IO_ADDR>
        <MEM_ADDR>$55</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT4>
          <NAME>PUD</NAME>
          <DESCRIPTION>Pull-up Disable</DESCRIPTION>
          <TEXT>When this bit is written to one, the I/O ports pull-up resistors are disabled even if the DDxn and PORTxn Registers are configured to enable the pull-up resistor ({DDxn, PORTxn} = 2'b01). See section "Ports as General Digital I/O" for more details about this feature.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
      </MCUCR>
    </PWRCTRL>
    <USART0_SPI>
      <LIST>[UCSR0A:UCSR0B:UCSR0C]</LIST>
      <LINK/>
      <ICON>io_com.bmp</ICON>
      <ID/>
      <TEXT>The Universal Synchronous and Asynchronous Serial Receiver and Transmitter (USART) can be set to a master SPI compliant mode of operation. The Master SPI Mode (MSPIM) has the following features: Full Duplex, Three-wire Synchronous Data Transfer; Master Operation; Supports all four SPI Modes of Operation (Mode 0, 1, 2, and 3); LSB First or MSB First Data Transfer (Configurable Data Order); Queued Operation (Double Buffered); High Resolution Baud Rate Generator; High Speed Operation (fXCKmax = fCK/2); Flexible Interrupt Generation.</TEXT>
      <UCSR0A>
        <NAME>UCSR0A</NAME>
        <DESCRIPTION>USART0 MSPIM Control and Status Register A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$C0</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>RXC0</NAME>
          <DESCRIPTION>USART Receive Complete</DESCRIPTION>
          <TEXT>This flag bit is set when there are unread data in the receive buffer and cleared when the receive buffer is empty (i.e., does not contain any unread data). If the Receiver is disabled, the receive buffer will be flushed and consequently the RXC0 bit will become zero. The RXC0 Flag can be used to generate a Receive Complete interrupt (see description of the RXCIE0 bit).</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TXC0</NAME>
          <DESCRIPTION>USART Transmit Complete</DESCRIPTION>
          <TEXT>This flag bit is set when the entire frame in the Transmit Shift Register has been shifted out and there are no new data currently present in the transmit buffer (UDR0). The TXC0 Flag bit is automatically cleared when a transmit complete interrupt is executed, or it can be cleared by writing a one to its bit location. The TXC0 Flag can generate a Transmit Complete interrupt (see description of the TXCIE0 bit).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UDRE0</NAME>
          <DESCRIPTION>USART Data Register Empty</DESCRIPTION>
          <TEXT>The UDRE0 Flag indicates if the transmit buffer (UDR0) is ready to receive new data. If UDRE0 is one, the buffer is empty, and therefore ready to be written. The UDRE0 Flag can generate a Data Register Empty interrupt (see description of the UDRIE0 bit). UDRE0 is set after a reset to indicate that the Transmitter is ready.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
      </UCSR0A>
      <UCSR0B>
        <NAME>UCSR0B</NAME>
        <DESCRIPTION>USART0 MSPIM Control and Status Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$C1</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>RXCIE0</NAME>
          <DESCRIPTION>RX Complete Interrupt Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables interrupt on the RXC0 Flag. A USART Receive Complete interrupt will be generated only if the RXCIE0 bit is written to one, the Global Interrupt Flag in SREG is written to one and the RXC0 bit in UCSR0A is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TXCIE0</NAME>
          <DESCRIPTION>TX Complete Interrupt Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables interrupt on the TXC0 Flag. A USART Transmit Complete interrupt will be generated only if the TXCIE0 bit is written to one, the Global Interrupt Flag in SREG is written to one and the TXC0 bit in UCSR0A is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UDRIE0</NAME>
          <DESCRIPTION>USART Data Register Empty Interrupt Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables interrupt on the UDRE0 Flag. A Data Register Empty interrupt will be generated only if the UDRIE0 bit is written to one, the Global Interrupt Flag in SREG is written to one and the UDRE0 bit in UCSR0A is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>RXEN0</NAME>
          <DESCRIPTION>Receiver Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables the USART Receiver in MSPIM mode. The Receiver will override normal port operation for the RxD0 pin when enabled. Disabling the Receiver will flush the receive buffer. Only enabling the receiver in MSPI mode (i.e. setting RXEN0=1 and TXEN0=0) has no meaning since it is the transmitter that controls the transfer clock and since only master mode is supported.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TXEN0</NAME>
          <DESCRIPTION>Transmitter Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables the USART Transmitter. The Transmitter will override normal port operation for the TxD0 pin when enabled. The disabling of the Transmitter (writing TXEN0 to zero) will not become effective until ongoing and pending transmissions are completed, i.e., when the Transmit Shift Register and Transmit Buffer Register do not contain data to be transmitted. When disabled, the Transmitter will no longer override the TxD0 port.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
      </UCSR0B>
      <UCSR0C>
        <NAME>UCSR0C</NAME>
        <DESCRIPTION>USART0 MSPIM Control and Status Register C</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$C2</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT2>
          <NAME>UDORD0</NAME>
          <ALIAS>UCSZ01</ALIAS>
          <DESCRIPTION>Data Order</DESCRIPTION>
          <TEXT>When set to one the LSB of the data word is transmitted first. When set to zero the MSB of the data word is transmitted first. Refer to section "Frame Formats" for details.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>UCPHA0</NAME>
          <ALIAS>UCSZ00</ALIAS>
          <DESCRIPTION>Clock Phase</DESCRIPTION>
          <TEXT>The UCPHA0 bit setting determines if data is sampled on the leading (first) or tailing (last) edge of XCK0. Refer to the section "SPI Data Modes and Timing" for details.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>UCPOL0</NAME>
          <DESCRIPTION>Clock Polarity</DESCRIPTION>
          <TEXT>The UCPOL0 bit sets the polarity of the XCK0 clock. The combination of the UCPOL0 and UCPHA0 bit settings determine the timing of the data transfer. Refer to the section "SPI Data Modes and Timing" for details.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </UCSR0C>
    </USART0_SPI>
    <USART1_SPI>
      <LIST>[UCSR1A:UCSR1B:UCSR1C]</LIST>
      <LINK/>
      <ICON>io_com.bmp</ICON>
      <ID/>
      <TEXT>The Universal Synchronous and Asynchronous Serial Receiver and Transmitter (USART) can be set to a master SPI compliant mode of operation. The Master SPI Mode (MSPIM) has the following features: Full Duplex, Three-wire Synchronous Data Transfer; Master Operation; Supports all four SPI Modes of Operation (Mode 0, 1, 2, and 3); LSB First or MSB First Data Transfer (Configurable Data Order); Queued Operation (Double Buffered); High Resolution Baud Rate Generator; High Speed Operation (fXCKmax = fCK/2); Flexible Interrupt Generation.</TEXT>
      <UCSR1A>
        <NAME>UCSR1A</NAME>
        <DESCRIPTION>USART1 MSPIM Control and Status Register A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$C8</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>RXC1</NAME>
          <DESCRIPTION>USART Receive Complete</DESCRIPTION>
          <TEXT>This flag bit is set when there are unread data in the receive buffer and cleared when the receive buffer is empty (i.e., does not contain any unread data). If the Receiver is disabled, the receive buffer will be flushed and consequently the RXC1 bit will become zero. The RXC1 Flag can be used to generate a Receive Complete interrupt (see description of the RXCIE1 bit).</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TXC1</NAME>
          <DESCRIPTION>USART Transmit Complete</DESCRIPTION>
          <TEXT>This flag bit is set when the entire frame in the Transmit Shift Register has been shifted out and there are no new data currently present in the transmit buffer (UDR1). The TXC1 Flag bit is automatically cleared when a transmit complete interrupt is executed, or it can be cleared by writing a one to its bit location. The TXC1 Flag can generate a Transmit Complete interrupt (see description of the TXCIE1 bit).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UDRE1</NAME>
          <DESCRIPTION>USART Data Register Empty</DESCRIPTION>
          <TEXT>The UDRE1 Flag indicates if the transmit buffer (UDR1) is ready to receive new data. If UDRE1 is one, the buffer is empty, and therefore ready to be written. The UDRE1 Flag can generate a Data Register Empty interrupt (see description of the UDRIE1 bit). UDRE1 is set after a reset to indicate that the Transmitter is ready.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
      </UCSR1A>
      <UCSR1B>
        <NAME>UCSR1B</NAME>
        <DESCRIPTION>USART1 MSPIM Control and Status Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$C9</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>RXCIE1</NAME>
          <DESCRIPTION>RX Complete Interrupt Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables interrupt on the RXC1 Flag. A USART Receive Complete interrupt will be generated only if the RXCIE1 bit is written to one, the Global Interrupt Flag in SREG is written to one and the RXC1 bit in UCSR1A is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TXCIE1</NAME>
          <DESCRIPTION>TX Complete Interrupt Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables interrupt on the TXC1 Flag. A USART Transmit Complete interrupt will be generated only if the TXCIE1 bit is written to one, the Global Interrupt Flag in SREG is written to one and the TXC1 bit in UCSR1A is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>UDRIE1</NAME>
          <DESCRIPTION>USART Data Register Empty Interrupt Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables interrupt on the UDRE1 Flag. A Data Register Empty interrupt will be generated only if the UDRIE1 bit is written to one, the Global Interrupt Flag in SREG is written to one and the UDRE1 bit in UCSR1A is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>RXEN1</NAME>
          <DESCRIPTION>Receiver Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables the USART Receiver in MSPIM mode. The Receiver will override normal port operation for the RxD1 pin when enabled. Disabling the Receiver will flush the receive buffer. Only enabling the receiver in MSPI mode (i.e. setting RXEN1=1 and TXEN1=0) has no meaning since it is the transmitter that controls the transfer clock and since only master mode is supported.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TXEN1</NAME>
          <DESCRIPTION>Transmitter Enable</DESCRIPTION>
          <TEXT>Writing this bit to one enables the USART Transmitter. The Transmitter will override normal port operation for the TxD1 pin when enabled. The disabling of the Transmitter (writing TXEN1 to zero) will not become effective until ongoing and pending transmissions are completed, i.e., when the Transmit Shift Register and Transmit Buffer Register do not contain data to be transmitted. When disabled, the Transmitter will no longer override the TxD1 port.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
      </UCSR1B>
      <UCSR1C>
        <NAME>UCSR1C</NAME>
        <DESCRIPTION>USART1 MSPIM Control and Status Register C</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>NA</IO_ADDR>
        <MEM_ADDR>$CA</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT2>
          <NAME>UDORD1</NAME>
          <ALIAS>UCSZ11</ALIAS>
          <DESCRIPTION>Data Order</DESCRIPTION>
          <TEXT>When set to one the LSB of the data word is transmitted first. When set to zero the MSB of the data word is transmitted first. Refer to section "Frame Formats" for details.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>UCPHA1</NAME>
          <ALIAS>UCSZ10</ALIAS>
          <DESCRIPTION>Clock Phase</DESCRIPTION>
          <TEXT>The UCPHA1 bit setting determines if data is sampled on the leading (first) or tailing (last) edge of XCK1. Refer to the section "SPI Data Modes and Timing" for details.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>UCPOL1</NAME>
          <DESCRIPTION>Clock Polarity</DESCRIPTION>
          <TEXT>The UCPOL1 bit sets the polarity of the XCK1 clock. The combination of the UCPOL1 and UCPHA1 bit settings determine the timing of the data transfer. Refer to the section "SPI Data Modes and Timing" for details.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </UCSR1C>
    </USART1_SPI>
  </IO_MODULE>
  <ICE_SETTINGS>
    <MODULE_LIST>[ICE50:SIMULATOR:JTAGICEmkII:STK500_2:AVRISPmkII:AVRDragon:STK600:AVRONE]</MODULE_LIST>
    <ICE50>
      <MMU_ACCESS>
        <MemTypeSram8Bit>0x05</MemTypeSram8Bit>
        <MemTypeSram16Bit>0x0F</MemTypeSram16Bit>
        <MemTypeSramShdw8Bit>0x0F</MemTypeSramShdw8Bit>
        <MemTypeSramShdw16Bit>0x0F</MemTypeSramShdw16Bit>
        <MemTypeEeprom>0x05</MemTypeEeprom>
        <MemTypeProgram>0x05</MemTypeProgram>
        <MemTypePrgEventBreak>0x05</MemTypePrgEventBreak>
        <MemTypePrgEventTrigOut>0x05</MemTypePrgEventTrigOut>
        <MemTypePrgEventTraceCtrl>0x05</MemTypePrgEventTraceCtrl>
        <MemTypePrgEventComplex>0x05</MemTypePrgEventComplex>
        <MemTypeSramEventLow>0x05</MemTypeSramEventLow>
        <MemTypeSramEventHigh>0x05</MemTypeSramEventHigh>
        <MemTypeEepromEvent>0x05</MemTypeEepromEvent>
        <MemTypeRegisterEvent>0x0F</MemTypeRegisterEvent>
        <MemTypeIoEvent>0x0F</MemTypeIoEvent>
        <MemTypePreTrace>0x0F</MemTypePreTrace>
        <MemTypeTrace>0x15</MemTypeTrace>
        <MemTypeCoreShdw>0x14</MemTypeCoreShdw>
        <MemTypeCoreMem>0x14</MemTypeCoreMem>
      </MMU_ACCESS>
      <MMU_NOXRAM>
        <MemTypeSram8Bit>0x000021FF</MemTypeSram8Bit>
        <MemTypeSram16Bit>0x00000000</MemTypeSram16Bit>
        <MemTypeSramShdw8Bit>0x00000000</MemTypeSramShdw8Bit>
        <MemTypeSramShdw16Bit>0x00000000</MemTypeSramShdw16Bit>
        <MemTypeEeprom>0x00000FFF</MemTypeEeprom>
        <MemTypeProgram>0x0001FFFF</MemTypeProgram>
        <MemTypePrgEventBreak>0x0000FFFF</MemTypePrgEventBreak>
        <MemTypePrgEventTrigOut>0x0000FFFF</MemTypePrgEventTrigOut>
        <MemTypePrgEventTraceCtrl>0x0000FFFF</MemTypePrgEventTraceCtrl>
        <MemTypePrgEventComplex>0x0000FFFF</MemTypePrgEventComplex>
        <MemTypeSramEventLow>0x000021FF</MemTypeSramEventLow>
        <MemTypeSramEventHigh>0x0000FFFF</MemTypeSramEventHigh>
        <MemTypeEepromEvent>0x00000FFF</MemTypeEepromEvent>
        <MemTypeRegisterEvent>0x00000000</MemTypeRegisterEvent>
        <MemTypeIoEvent>0x00000000</MemTypeIoEvent>
        <MemTypePreTrace>0x00000000</MemTypePreTrace>
        <MemTypeTrace>0x0023FFFF</MemTypeTrace>
        <MemTypeCoreShdw>0x00000FFF</MemTypeCoreShdw>
        <MemTypeCoreMem>0x000001FF</MemTypeCoreMem>
      </MMU_NOXRAM>
      <MMU_EMULATED>
        <MemTypeSram8Bit>0x0000FFFF</MemTypeSram8Bit>
        <MemTypeSram16Bit>0x00000000</MemTypeSram16Bit>
        <MemTypeSramShdw8Bit>0x00000000</MemTypeSramShdw8Bit>
        <MemTypeSramShdw16Bit>0x00000000</MemTypeSramShdw16Bit>
        <MemTypeEeprom>0x00000FFF</MemTypeEeprom>
        <MemTypeProgram>0x0001FFFF</MemTypeProgram>
        <MemTypePrgEventBreak>0x0000FFFF</MemTypePrgEventBreak>
        <MemTypePrgEventTrigOut>0x0000FFFF</MemTypePrgEventTrigOut>
        <MemTypePrgEventTraceCtrl>0x0000FFFF</MemTypePrgEventTraceCtrl>
        <MemTypePrgEventComplex>0x0000FFFF</MemTypePrgEventComplex>
        <MemTypeSramEventLow>0x0000FFFF</MemTypeSramEventLow>
        <MemTypeSramEventHigh>0x0000FFFF</MemTypeSramEventHigh>
        <MemTypeEepromEvent>0x00000FFF</MemTypeEepromEvent>
        <MemTypeRegisterEvent>0x00000000</MemTypeRegisterEvent>
        <MemTypeIoEvent>0x00000000</MemTypeIoEvent>
        <MemTypePreTrace>0x00000000</MemTypePreTrace>
        <MemTypeTrace>0x0023FFFF</MemTypeTrace>
        <MemTypeCoreShdw>0x00000FFF</MemTypeCoreShdw>
        <MemTypeCoreMem>0x000001FF</MemTypeCoreMem>
      </MMU_EMULATED>
      <MMU_XRAMIF>
        <MemTypeSram8Bit>0x000021FF</MemTypeSram8Bit>
        <MemTypeSram16Bit>0x00000000</MemTypeSram16Bit>
        <MemTypeSramShdw8Bit>0x00000000</MemTypeSramShdw8Bit>
        <MemTypeSramShdw16Bit>0x00000000</MemTypeSramShdw16Bit>
        <MemTypeEeprom>0x00000FFF</MemTypeEeprom>
        <MemTypeProgram>0x0001FFFF</MemTypeProgram>
        <MemTypePrgEventBreak>0x0000FFFF</MemTypePrgEventBreak>
        <MemTypePrgEventTrigOut>0x0000FFFF</MemTypePrgEventTrigOut>
        <MemTypePrgEventTraceCtrl>0x0000FFFF</MemTypePrgEventTraceCtrl>
        <MemTypePrgEventComplex>0x0000FFFF</MemTypePrgEventComplex>
        <MemTypeSramEventLow>0x0000FFFF</MemTypeSramEventLow>
        <MemTypeSramEventHigh>0x0000FFFF</MemTypeSramEventHigh>
        <MemTypeEepromEvent>0x00000FFF</MemTypeEepromEvent>
        <MemTypeRegisterEvent>0x00000000</MemTypeRegisterEvent>
        <MemTypeIoEvent>0x00000000</MemTypeIoEvent>
        <MemTypePreTrace>0x00000000</MemTypePreTrace>
        <MemTypeTrace>0x0023FFFF</MemTypeTrace>
        <MemTypeCoreShdw>0x00000FFF</MemTypeCoreShdw>
        <MemTypeCoreMem>0x0000FFFF</MemTypeCoreMem>
      </MMU_XRAMIF>
      <DEFAULT_SETTINGS>
        <HighFuse>0x99</HighFuse>
        <ExtendedFuse>0xff</ExtendedFuse>
        <LowFuse>0x62</LowFuse>
        <Lockbit>0xff</Lockbit>
        <ADDROSC>0x66</ADDROSC>
        <VALOSC>0xC7</VALOSC>
        <BINFILE>AT86RF235.bin</BINFILE>
        <PARAM_MMU_DMEM_PARTION>0x02</PARAM_MMU_DMEM_PARTION>
        <PARAM_MMU_MEMCFG>0x00</PARAM_MMU_MEMCFG>
        <FREQUENCY>1000000</FREQUENCY>
        <MAXFREQUENCY>40000000</MAXFREQUENCY>
        <MINFREQUENCY>7</MINFREQUENCY>
        <CLOCK>2    ; INTOSC = 1, INTRC=2;EXTCLK=4</CLOCK>
        <TIMEROSC>1    ;NOTUSE = 1, EXTERNAL = 4, INTERNAL = 2 </TIMEROSC>
        <XTAL2SOURCING>1 </XTAL2SOURCING>
        <PARAM_AVR_RMR>0</PARAM_AVR_RMR>
        <PARAM_POD_VREFSELCONFIG>0x01</PARAM_POD_VREFSELCONFIG>
        <PARAM_POD_ADMUXCONFIG>0x00</PARAM_POD_ADMUXCONFIG>
        <PARAM_OSC_WD_FREQ>0x80</PARAM_OSC_WD_FREQ>
        <XRAMENABLE>0x00</XRAMENABLE>
        <XRAMOTHER>0x01</XRAMOTHER>
        <DIVCLOCK>8</DIVCLOCK>
      </DEFAULT_SETTINGS>
      <SETTINGS>
        <BOOTSIZE>
          <OPT1>
            <LFMASK>0x00000600</LFMASK>
            <LFBITS>0x00000600</LFBITS>
            <TEXT>Boot Size 512 Words, 4 pages,  $FE00-$FFFF, Boot reset $FE00</TEXT>
          </OPT1>
          <OPT2>
            <LFMASK>0x00000600</LFMASK>
            <LFBITS>0x00000400</LFBITS>
            <TEXT>Boot Size 1024 Words, 8 pages,  $FC00-$FFFF, Boot reset $FC00</TEXT>
          </OPT2>
          <OPT3>
            <LFMASK>0x00000600</LFMASK>
            <LFBITS>0x00000200</LFBITS>
            <TEXT>Boot Size 2048 Words, 16 pages, $F800-$FFFF, Boot reset $F800</TEXT>
          </OPT3>
          <OPT4>
            <LFMASK>0x00000600</LFMASK>
            <LFBITS>0x00000000</LFBITS>
            <TEXT>Boot Size 4096 Words, 32 pages, $F000-$FFFF, Boot reset $F000</TEXT>
          </OPT4>
        </BOOTSIZE>
        <CLOCK>
          <STARTUP>
            <INTOSC>
              <OPT1>
                <LFMASK>0x00000031</LFMASK>
                <LFBITS>0x00000000</LFBITS>
                <TEXT>258 CK, 4.1 ms </TEXT>
              </OPT1>
              <OPT2>
                <LFMASK>0x00000031</LFMASK>
                <LFBITS>0x00000010</LFBITS>
                <TEXT>258 CK, 65 ms</TEXT>
              </OPT2>
              <OPT3>
                <LFMASK>0x00000031</LFMASK>
                <LFBITS>0x00000020</LFBITS>
                <TEXT>1K CK</TEXT>
              </OPT3>
              <OPT4>
                <LFMASK>0x00000031</LFMASK>
                <LFBITS>0x00000030</LFBITS>
                <TEXT>1K CK, 4.1 ms</TEXT>
              </OPT4>
              <OPT5>
                <LFMASK>0x00000031</LFMASK>
                <LFBITS>0x00000001</LFBITS>
                <TEXT>1K CK, 65 ms</TEXT>
              </OPT5>
              <OPT6>
                <LFMASK>0x00000031</LFMASK>
                <LFBITS>0x00000011</LFBITS>
                <TEXT>16K CK</TEXT>
              </OPT6>
              <OPT7>
                <LFMASK>0x00000031</LFMASK>
                <LFBITS>0x00000021</LFBITS>
                <TEXT>16K CK, 4.1 ms</TEXT>
              </OPT7>
              <OPT8>
                <LFMASK>0x00000031</LFMASK>
                <LFBITS>0x00000031</LFBITS>
                <TEXT>16K CK, 65 ms</TEXT>
              </OPT8>
            </INTOSC>
            <INTRC>
              <OPT1>
                <LFMASK>0x00000030</LFMASK>
                <LFBITS>0x00000000</LFBITS>
                <TEXT>6 CK,14 CK</TEXT>
              </OPT1>
              <OPT2>
                <LFMASK>0x00000030</LFMASK>
                <LFBITS>0x00000010</LFBITS>
                <TEXT>6 CK, 14 CK + 4.1ms</TEXT>
              </OPT2>
              <OPT3>
                <LFMASK>0x00000030</LFMASK>
                <LFBITS>0x00000020</LFBITS>
                <TEXT>6 CK, 65 ms</TEXT>
              </OPT3>
            </INTRC>
            <EXTCLK>
              <OPT1>
                <LFMASK>0x00000030</LFMASK>
                <LFBITS>0x00000000</LFBITS>
                <TEXT>6 CK, 14 CK</TEXT>
              </OPT1>
              <OPT2>
                <LFMASK>0x00000030</LFMASK>
                <LFBITS>0x00000010</LFBITS>
                <TEXT>6 CK, 14 CK + 4.1ms</TEXT>
              </OPT2>
              <OPT3>
                <LFMASK>0x00000030</LFMASK>
                <LFBITS>0x00000020</LFBITS>
                <TEXT>6 CK, 14 CK + 65 ms</TEXT>
              </OPT3>
            </EXTCLK>
          </STARTUP>
          <CLOCK>
            <INTOSC>
              <LFMASK>0x0000000e</LFMASK>
              <LFBITS>0x0000000e</LFBITS>
            </INTOSC>
            <INTRC>
              <OPT1>
                <LFMASK>0x0000000f</LFMASK>
                <LFBITS>0x00000002</LFBITS>
                <TEXT>8.0</TEXT>
              </OPT1>
            </INTRC>
            <EXTCLK>
              <LFMASK>0x0000000f</LFMASK>
              <LFBITS>0x00000000</LFBITS>
            </EXTCLK>
          </CLOCK>
        </CLOCK>
        <BOOTRESET>
          <OPT1>
            <LFMASK>0x00000100</LFMASK>
            <LFBITS>0x00000100</LFBITS>
            <TEXT>Application reset, address $0</TEXT>
          </OPT1>
          <OPT2>
            <LFMASK>0x00000100</LFMASK>
            <LFBITS>0x00000000</LFBITS>
            <TEXT>Boot loader reset</TEXT>
          </OPT2>
        </BOOTRESET>
        <BOOTLOCK0>
          <OPT1>
            <LFMASK>0x0c000000</LFMASK>
            <LFBITS>0x0c000000</LFBITS>
            <TEXT>No restrictions for SPM or (E)LPM</TEXT>
          </OPT1>
          <OPT2>
            <LFMASK>0x0c000000</LFMASK>
            <LFBITS>0x08000000</LFBITS>
            <TEXT>No write to the Application section</TEXT>
          </OPT2>
          <OPT3>
            <LFMASK>0x0c000000</LFMASK>
            <LFBITS>0x00000000</LFBITS>
            <TEXT>No write to Application section,  No read from the Application section</TEXT>
          </OPT3>
          <OPT4>
            <LFMASK>0x0c000000</LFMASK>
            <LFBITS>0x04000000</LFBITS>
            <TEXT>No read from the Application section</TEXT>
          </OPT4>
        </BOOTLOCK0>
        <BOOTLOCK1>
          <OPT1>
            <LFMASK>0x30000000</LFMASK>
            <LFBITS>0x30000000</LFBITS>
            <TEXT>No restrictions for SPM or (E)LPM</TEXT>
          </OPT1>
          <OPT2>
            <LFMASK>0x30000000</LFMASK>
            <LFBITS>0x20000000</LFBITS>
            <TEXT>No write to the Boot Loader section</TEXT>
          </OPT2>
          <OPT3>
            <LFMASK>0x30000000</LFMASK>
            <LFBITS>0x00000000</LFBITS>
            <TEXT>No write to Boot Loader section, No read from the Boot Loader section</TEXT>
          </OPT3>
          <OPT4>
            <LFMASK>0x30000000</LFMASK>
            <LFBITS>0x10000000</LFBITS>
            <TEXT>No read from the Boot Loader section</TEXT>
          </OPT4>
        </BOOTLOCK1>
        <WATCHDOG>
          <TRUE>
            <LFMASK>0x00001000</LFMASK>
            <LFBITS>0x00000000</LFBITS>
            <TEXT>Watchdog always ON</TEXT>
          </TRUE>
          <FALSE>
            <LFMASK>0x00001000</LFMASK>
            <LFBITS>0x00001000</LFBITS>
            <TEXT>Watchdog disabled</TEXT>
          </FALSE>
        </WATCHDOG>
        <CLKDIV>
          <VALUE>8</VALUE>
          <TRUE>
            <LFMASK>0x00000080</LFMASK>
            <LFBITS>0x00000000</LFBITS>
            <TEXT>CKDIV8 Fuse</TEXT>
          </TRUE>
          <FALSE>
            <LFMASK>0x00000080</LFMASK>
            <LFBITS>0x00000080</LFBITS>
            <TEXT>CKDIV8 Fuse</TEXT>
          </FALSE>
        </CLKDIV>
        <CKOUT>
          <TRUE>
            <LFMASK>0x00000040</LFMASK>
            <LFBITS>0x00000000</LFBITS>
            <TEXT>CKOUT Fuse</TEXT>
          </TRUE>
          <FALSE>
            <LFMASK>0x00000040</LFMASK>
            <LFBITS>0x00000040</LFBITS>
            <TEXT>CKOUT Fuse</TEXT>
          </FALSE>
        </CKOUT>
        <BOD>
          <OPT1>
            <LFMASK>0x00070000</LFMASK>
            <LFBITS>0x00070000</LFBITS>
            <TEXT>BOD disabled</TEXT>
          </OPT1>
          <OPT2>
            <LFMASK>0x00070000</LFMASK>
            <LFBITS>0x00060000</LFBITS>
            <TEXT>BOD enabled, 1.8 V</TEXT>
          </OPT2>
          <OPT3>
            <LFMASK>0x00070000</LFMASK>
            <LFBITS>0x00050000</LFBITS>
            <TEXT>BOD enabled, 2.7 V</TEXT>
          </OPT3>
          <OPT4>
            <LFMASK>0x00070000</LFMASK>
            <LFBITS>0x00040000</LFBITS>
            <TEXT>BOD enabled, 4.0 V</TEXT>
          </OPT4>
        </BOD>
      </SETTINGS>
    </ICE50>
    <SIMULATOR>
      <CoreID>AVRSimCoreV2.SimCoreV2</CoreID>
      <MemoryID>AVRSimMemory8bit.SimMemory8bit</MemoryID>
      <InterruptID>AVRSimInterrupt.SimInterrupt</InterruptID>
      <EEINTERRUPT>0x3c</EEINTERRUPT>
      <EEAR_EXTRA_BIT>0</EEAR_EXTRA_BIT>
      <NmbIOModules>30</NmbIOModules>
      <PORTA>
        <ID>AVRSimIOPort.SimIOPort</ID>
        <TOGGLE_PIN>Y</TOGGLE_PIN>
      </PORTA>
      <PORTB>
        <ID>AVRSimIOPort.SimIOPort</ID>
        <TOGGLE_PIN>Y</TOGGLE_PIN>
      </PORTB>
      <PORTC>
        <ID>AVRSimIOPort.SimIOPort</ID>
        <TOGGLE_PIN>Y</TOGGLE_PIN>
      </PORTC>
      <PORTD>
        <ID>AVRSimIOPort.SimIOPort</ID>
        <TOGGLE_PIN>Y</TOGGLE_PIN>
      </PORTD>
      <PORTE>
        <ID>AVRSimIOPort.SimIOPort</ID>
        <TOGGLE_PIN>Y</TOGGLE_PIN>
      </PORTE>
      <PORTF>
        <ID>AVRSimIOPort.SimIOPort</ID>
        <TOGGLE_PIN>Y</TOGGLE_PIN>
      </PORTF>
      <PORTG>
        <ID>AVRSimIOPort.SimIOPort</ID>
        <TOGGLE_PIN>Y</TOGGLE_PIN>
      </PORTG>
      <PININT0>
        <ID>AVRSimIOPinChangeInterrupt.SimIOPinChangeInterrupt</ID>
        <IntVector>0x12</IntVector>
        <EnableIOAdr>0x48</EnableIOAdr>
        <EnableMask>0x01</EnableMask>
        <FlagIOAdr>0x1B</FlagIOAdr>
        <FlagMask>0x01</FlagMask>
        <PCMaskIOAdr>0x4b</PCMaskIOAdr>
        <ExtPinIOAdr>0x03</ExtPinIOAdr>
        <ExtPinMask>0xff</ExtPinMask>
      </PININT0>
      <PININT1>
        <ID>AVRSimIOPinChangeInterrupt.SimIOPinChangeInterrupt</ID>
        <IntVector>0x14</IntVector>
        <EnableIOAdr>0x48</EnableIOAdr>
        <EnableMask>0x02</EnableMask>
        <FlagIOAdr>0x1B</FlagIOAdr>
        <FlagMask>0x02</FlagMask>
        <ExtPinIOAdr>0xe3</ExtPinIOAdr>
        <ExtPinMask>0xff</ExtPinMask>
        <PCMaskIOAdr>0x4c</PCMaskIOAdr>
      </PININT1>
      <PININT2>
        <ID>AVRSimIOPinChangeInterrupt.SimIOPinChangeInterrupt</ID>
        <IntVector>0x16</IntVector>
        <EnableIOAdr>0x48</EnableIOAdr>
        <EnableMask>0x04</EnableMask>
        <FlagIOAdr>0x1B</FlagIOAdr>
        <FlagMask>0x04</FlagMask>
        <ExtPinIOAdr>0xe6</ExtPinIOAdr>
        <ExtPinMask>0xff</ExtPinMask>
        <PCMaskIOAdr>0x4d</PCMaskIOAdr>
      </PININT2>
      <EXTINT0>
        <ID>AVRSimIOExtInterrupt.SimIOExtInterrupt</ID>
        <IntVector>0x02</IntVector>
        <EnableIOAdr>0x1d</EnableIOAdr>
        <EnableMask>0x01</EnableMask>
        <FlagIOAdr>0x1c</FlagIOAdr>
        <FlagMask>0x01</FlagMask>
        <ExtPinIOAdr>0x09</ExtPinIOAdr>
        <ExtPinMask>0x01</ExtPinMask>
        <SenseIOAdr>0x49</SenseIOAdr>
        <SenseMask>0x03</SenseMask>
      </EXTINT0>
      <EXTINT1>
        <ID>AVRSimIOExtInterrupt.SimIOExtInterrupt</ID>
        <IntVector>0x04</IntVector>
        <EnableIOAdr>0x1d</EnableIOAdr>
        <EnableMask>0x02</EnableMask>
        <FlagIOAdr>0x1c</FlagIOAdr>
        <FlagMask>0x02</FlagMask>
        <ExtPinIOAdr>0x09</ExtPinIOAdr>
        <ExtPinMask>0x02</ExtPinMask>
        <SenseIOAdr>0x49</SenseIOAdr>
        <SenseMask>0x0c</SenseMask>
      </EXTINT1>
      <EXTINT2>
        <ID>AVRSimIOExtInterrupt.SimIOExtInterrupt</ID>
        <IntVector>0x06</IntVector>
        <EnableIOAdr>0x1d</EnableIOAdr>
        <EnableMask>0x04</EnableMask>
        <FlagIOAdr>0x1c</FlagIOAdr>
        <FlagMask>0x04</FlagMask>
        <ExtPinIOAdr>0x09</ExtPinIOAdr>
        <ExtPinMask>0x04</ExtPinMask>
        <SenseIOAdr>0x49</SenseIOAdr>
        <SenseMask>0x30</SenseMask>
      </EXTINT2>
      <EXTINT3>
        <ID>AVRSimIOExtInterrupt.SimIOExtInterrupt</ID>
        <IntVector>0x08</IntVector>
        <EnableIOAdr>0x1d</EnableIOAdr>
        <EnableMask>0x08</EnableMask>
        <FlagIOAdr>0x1c</FlagIOAdr>
        <FlagMask>0x08</FlagMask>
        <ExtPinIOAdr>0x09</ExtPinIOAdr>
        <ExtPinMask>0x08</ExtPinMask>
        <SenseIOAdr>0x49</SenseIOAdr>
        <SenseMask>0xc0</SenseMask>
      </EXTINT3>
      <EXTINT4>
        <ID>AVRSimIOExtInterrupt.SimIOExtInterrupt</ID>
        <IntVector>0x0a</IntVector>
        <EnableIOAdr>0x1d</EnableIOAdr>
        <EnableMask>0x10</EnableMask>
        <FlagIOAdr>0x1c</FlagIOAdr>
        <FlagMask>0x10</FlagMask>
        <ExtPinIOAdr>0x0c</ExtPinIOAdr>
        <ExtPinMask>0x10</ExtPinMask>
        <SenseIOAdr>0x4a</SenseIOAdr>
        <SenseMask>0x03</SenseMask>
      </EXTINT4>
      <EXTINT5>
        <ID>AVRSimIOExtInterrupt.SimIOExtInterrupt</ID>
        <IntVector>0x0c</IntVector>
        <EnableIOAdr>0x1d</EnableIOAdr>
        <EnableMask>0x20</EnableMask>
        <FlagIOAdr>0x1c</FlagIOAdr>
        <FlagMask>0x20</FlagMask>
        <ExtPinIOAdr>0x0c</ExtPinIOAdr>
        <ExtPinMask>0x20</ExtPinMask>
        <SenseIOAdr>0x4a</SenseIOAdr>
        <SenseMask>0x0c</SenseMask>
      </EXTINT5>
      <EXTINT6>
        <ID>AVRSimIOExtInterrupt.SimIOExtInterrupt</ID>
        <IntVector>0x0e</IntVector>
        <EnableIOAdr>0x1d</EnableIOAdr>
        <EnableMask>0x40</EnableMask>
        <FlagIOAdr>0x1c</FlagIOAdr>
        <FlagMask>0x40</FlagMask>
        <ExtPinIOAdr>0x0c</ExtPinIOAdr>
        <ExtPinMask>0x40</ExtPinMask>
        <SenseIOAdr>0x4a</SenseIOAdr>
        <SenseMask>0x30</SenseMask>
      </EXTINT6>
      <EXTINT7>
        <ID>AVRSimIOExtInterrupt.SimIOExtInterrupt</ID>
        <IntVector>0x10</IntVector>
        <EnableIOAdr>0x1d</EnableIOAdr>
        <EnableMask>0x80</EnableMask>
        <FlagIOAdr>0x1c</FlagIOAdr>
        <FlagMask>0x80</FlagMask>
        <ExtPinIOAdr>0x0c</ExtPinIOAdr>
        <ExtPinMask>0x80</ExtPinMask>
        <SenseIOAdr>0x4a</SenseIOAdr>
        <SenseMask>0xc0</SenseMask>
      </EXTINT7>
      <TIMER0>
        <ID>AvrSimIOtim8pwmsync2.tim8pwmsync2</ID>
        <CompAVector>0x2A</CompAVector>
        <CompBVector>0x2C</CompBVector>
        <OvfVector>0x2E</OvfVector>
        <OCnAport>PORTB</OCnAport>
        <OCnAbit>7</OCnAbit>
        <OCnBport>PORTG</OCnBport>
        <OCnBbit>5</OCnBbit>
      </TIMER0>
      <TIMER1>
        <ID>AvrMasterTimer.MasterTimer</ID>
        <IcpVector>0x20</IcpVector>
        <CompAVector>0x22</CompAVector>
        <CompBVector>0x24</CompBVector>
        <CompCVector>0x26</CompCVector>
        <OvfVector>0x28</OvfVector>
        <CountPinAdr>0x09</CountPinAdr>
        <CountPinMask>0x40</CountPinMask>
        <IcpPinAdr>0x09</IcpPinAdr>
        <IcpPinMask>0x10</IcpPinMask>
        <OutputAAdr>0x05</OutputAAdr>
        <OutputAMask>0x20</OutputAMask>
        <OutputBAdr>0x05</OutputBAdr>
        <OutputBMask>0x40</OutputBMask>
        <OutputCAdr>0x05</OutputCAdr>
        <OutputCMask>0x80</OutputCMask>
        <OCFA>TIFR1/OCF1A</OCFA>
        <OCFB>TIFR1/OCF1B</OCFB>
        <OCFC>TIFR1/OCF1C</OCFC>
        <Prescaler>1:8:64:256:1024</Prescaler>
        <PSRregister>0x23</PSRregister>
        <PSRbitmask>0x01</PSRbitmask>
      </TIMER1>
      <TIMER2>
        <ID>AvrMasterTimer.MasterTimer</ID>
        <CompAVector>0x1a</CompAVector>
        <CompBVector>0x1c</CompBVector>
        <OvfVector>0x1e</OvfVector>
        <OCnAport>PORTB</OCnAport>
        <OCnAbit>4</OCnAbit>
        <Prescaler>1:8:64:256:1024</Prescaler>
      </TIMER2>
      <TIMER3>
        <ID>AvrMasterTimer.MasterTimer</ID>
        <IcpVector>0x3E</IcpVector>
        <CompAVector>0x40</CompAVector>
        <CompBVector>0x42</CompBVector>
        <CompCVector>0x44</CompCVector>
        <OvfVector>0x46</OvfVector>
        <CountPinAdr>0x0C</CountPinAdr>
        <CountPinMask>0x40</CountPinMask>
        <IcpPinAdr>0x0C</IcpPinAdr>
        <IcpPinMask>0x80</IcpPinMask>
        <OutputAAdr>0x0e</OutputAAdr>
        <OutputAMask>0x08</OutputAMask>
        <OutputBAdr>0x0e</OutputBAdr>
        <OutputBMask>0x10</OutputBMask>
        <OutputCAdr>0x0e</OutputCAdr>
        <OutputCMask>0x20</OutputCMask>
        <OCFA>TIFR3/OCF3A</OCFA>
        <OCFB>TIFR3/OCF3B</OCFB>
        <OCFC>TIFR3/OCF3C</OCFC>
        <Prescaler>1:8:64:256:1024</Prescaler>
        <PSRregister>0x23</PSRregister>
        <PSRbitmask>0x01</PSRbitmask>
      </TIMER3>
      <TIMER4>
        <ID>AvrMasterTimer.MasterTimer</ID>
        <CompAVector>0x54</CompAVector>
        <CompBVector>0x56</CompBVector>
        <CompCVector>0x58</CompCVector>
        <OvfVector>0x5a</OvfVector>
        <OCFA>TIFR4/OCF4A</OCFA>
        <OCFB>TIFR4/OCF4B</OCFB>
        <OCFC>TIFR4/OCF4C</OCFC>
        <Prescaler>1:8:64:256:1024</Prescaler>
        <PSRregister>0x23</PSRregister>
        <PSRbitmask>0x01</PSRbitmask>
      </TIMER4>
      <TIMER5>
        <ID>AvrMasterTimer.MasterTimer</ID>
        <CompAVector>0x5e</CompAVector>
        <CompBVector>0x60</CompBVector>
        <CompCVector>0x62</CompCVector>
        <OvfVector>0x64</OvfVector>
        <OCFA>TIFR5/OCF5A</OCFA>
        <OCFB>TIFR5/OCF5B</OCFB>
        <OCFC>TIFR5/OCF5C</OCFC>
        <Prescaler>1:8:64:256:1024</Prescaler>
        <PSRregister>0x23</PSRregister>
        <PSRbitmask>0x01</PSRbitmask>
      </TIMER5>
      <SPM>
        <ID>AVRSimIOSPM.SimIOSPM</ID>
        <IntVector>0x50</IntVector>
      </SPM>
      <SPI>
        <ID>AVRSimIOSpi.SimIOSpi</ID>
        <IntVector>0x30</IntVector>
        <SCKAddress>0x03</SCKAddress>
        <SCKMask>0x02</SCKMask>
        <MISOAddress>0x03</MISOAddress>
        <MISOMask>0x08</MISOMask>
        <MOSIAddress>0x03</MOSIAddress>
        <MOSIMask>0x04</MOSIMask>
        <SSAddress>0x03</SSAddress>
        <DIRAddress>0x04</DIRAddress>
        <SSMask>0x01</SSMask>
      </SPI>
      <USART0>
        <ID>AVRSimIOUsart.SimIOUsart</ID>
        <RXVector>0x32</RXVector>
        <TXVector>0x36</TXVector>
        <UDREVector>0x34</UDREVector>
        <TXPinAddress>0x0c</TXPinAddress>
        <TXPinMask>0x02</TXPinMask>
        <RXPinAddress>0x0c</RXPinAddress>
        <RXPinMask>0x01</RXPinMask>
      </USART0>
      <USART1>
        <ID>AVRSimIOUsart.SimIOUsart</ID>
        <RXVector>0x48</RXVector>
        <TXVector>0x4C</TXVector>
        <UDREVector>0x4A</UDREVector>
        <TXPinAddress>0x09</TXPinAddress>
        <TXPinMask>0x08</TXPinMask>
        <RXPinAddress>0x09</RXPinAddress>
        <RXPinMask>0x04</RXPinMask>
      </USART1>
      <ANALOGCOMP>
        <ID>AVRSimAC.SimIOAC</ID>
        <IntVector>0x38</IntVector>
      </ANALOGCOMP>
      <ADC>
        <ID>AVRSimADC.SimADC</ID>
        <IntVector>0x3A</IntVector>
      </ADC>
      <TWI>
        <ID>AvrSimTWI.SimTWI</ID>
        <IntVector>0x4E</IntVector>
      </TWI>
      <WATCHDOG>
        <ID>AvrMasterTimer.MasterTimer</ID>
        <Version>0</Version>
        <PrescaleArray>16384:32768:65536:131072:262144:524288:1048576:2097152</PrescaleArray>
      </WATCHDOG>
      <DEFAULT_SETTINGS>
        <HighFuse>0xFF</HighFuse>
        <ExtendedFuse>0xff</ExtendedFuse>
        <LowFuse>0xFF</LowFuse>
        <Lockbit>0xFF</Lockbit>
      </DEFAULT_SETTINGS>
    </SIMULATOR>
    <JTAGICEmkII>
      <ID>0x0A70103F</ID>
      <Interface>JTAG</Interface>
<!--Bit 0 in byte 0 is I/O location, bit 7 in byte 7 is I/O location 63-->
      <ucRead>0xFF,0xFF,0xFF,0xF9,0xFF,0x3D,0xB9,0xF8</ucRead>
      <ucWrite>0xFF,0xFF,0x1F,0xE0,0xFF,0x1D,0xA9,0xF8</ucWrite>
      <ucReadShadow>0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00</ucReadShadow>
      <ucWriteShadow>0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00</ucWriteShadow>
<!--Bit 0 in byte 0 is extended I/O location, bit 7 in last byte is extended I/O location 0x1FF-->
      <ucExtRead>0xFB,0xFF,0xBF,0xFF,0xF7,0x3F,0xF7,0x3F,0xF7,0x3F,0x5F,0x3F,0x77,0x77,0x03,0xF0,0xFF,0xFF,0xFF,0x01,0x00,0x00,0x00,0x00,0xF7,0xBF,0xFF,0xFA,0xFE,0xFF,0xA7,0xFF,0xFF,0xFF,0xEF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF</ucExtRead>
      <ucExtWrite>0xFB,0xFF,0xBF,0xFF,0xB7,0x3F,0xB7,0x3F,0xB7,0x3F,0x5F,0x3F,0x77,0x77,0x03,0xB0,0xFF,0xE1,0xFF,0x01,0x00,0x00,0x00,0x00,0xB7,0xBF,0xFF,0xDA,0x3C,0xFF,0xA7,0x0F,0xFF,0xFF,0xE8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF</ucExtWrite>
      <ucExtReadShadow>0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00</ucExtReadShadow>
      <ucExtWriteShadow>0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00</ucExtWriteShadow>
<!--Register locations etc.-->
      <ucIDRAddress>0x31</ucIDRAddress>
      <ucSPMCAddress>0x57</ucSPMCAddress>
      <ulFlashPageSize>0x0100</ulFlashPageSize>
      <ulEepromPageSize>0x0008</ulEepromPageSize>
      <ulBootAddress>0xFE00</ulBootAddress>
      <ucUpperExtIOLoc>0x01FF</ucUpperExtIOLoc>
      <ulRegStart>0x0000,32</ulRegStart>
      <ulIoStart>0x0020,64</ulIoStart>
<!--Other stuff-->
      <DWENmaskExt>0x00</DWENmaskExt>
      <DWENmaskHigh>0x00</DWENmaskHigh>
      <DWENmaskLow>0x00</DWENmaskLow>
      <ucEepromInst>0x00</ucEepromInst>
      <ucFlashInst>0x00</ucFlashInst>
      <DWdatareg>0x00</DWdatareg>
      <DWbasePC>0x00</DWbasePC>
      <PCMaskExtended>0</PCMaskExtended>
      <PCMaskHigh>0</PCMaskHigh>
      <Osccalshared>0x00</Osccalshared>
      <ucAllowFullPageBitstream>0x00</ucAllowFullPageBitstream>
      <uiStartSmallestBootLoaderSection>0x00</uiStartSmallestBootLoaderSection>
      <ucUseJTAGID>0x01</ucUseJTAGID>
      <EECRAddress>0x3F</EECRAddress>
      <EnablePageProgramming>1</EnablePageProgramming>
      <CacheType>0</CacheType>
      <ResetType>0</ResetType>
      <bUseProgIfc>1</bUseProgIfc>
    </JTAGICEmkII>
    <STK500_2>
      <IspEnterProgMode>
        <timeout>200</timeout>
        <stabDelay>100</stabDelay>
        <cmdexeDelay>25</cmdexeDelay>
        <synchLoops>32</synchLoops>
        <byteDelay>0</byteDelay>
        <pollIndex>3</pollIndex>
        <pollValue>0x53</pollValue>
      </IspEnterProgMode>
      <IspLeaveProgMode>
        <preDelay>1</preDelay>
        <postDelay>1</postDelay>
      </IspLeaveProgMode>
      <IspChipErase>
        <eraseDelay>55</eraseDelay>
        <pollMethod>1</pollMethod>
      </IspChipErase>
      <IspProgramFlash>
        <mode>0x41</mode>
        <blockSize>256</blockSize>
        <delay>50</delay>
        <cmd1>0x40</cmd1>
        <cmd2>0x4C</cmd2>
        <cmd3>0x00</cmd3>
        <pollVal1>0x00</pollVal1>
        <pollVal2>0x00</pollVal2>
      </IspProgramFlash>
      <IspProgramEeprom>
        <mode>0x41</mode>
        <blockSize>8</blockSize>
        <delay>50</delay>
        <cmd1>0xC1</cmd1>
        <cmd2>0xC2</cmd2>
        <cmd3>0x00</cmd3>
        <pollVal1>0x00</pollVal1>
        <pollVal2>0x00</pollVal2>
      </IspProgramEeprom>
      <IspReadFlash>
        <blockSize>256</blockSize>
      </IspReadFlash>
      <IspReadEeprom>
        <blockSize>256</blockSize>
      </IspReadEeprom>
      <IspReadFuse>
        <pollIndex>4</pollIndex>
      </IspReadFuse>
      <IspReadLock>
        <pollIndex>4</pollIndex>
      </IspReadLock>
      <IspReadSign>
        <pollIndex>4</pollIndex>
      </IspReadSign>
      <IspReadOsccal>
        <pollIndex>4</pollIndex>
      </IspReadOsccal>
      <PPControlStack>0x0E 0x1E 0x0F 0x1F 0x2E 0x3E 0x2F 0x3F 0x4E 0x5E 0x4F 0x5F 0x6E 0x7E 0x6F 0x7F 0x66 0x76 0x67 0x77 0x6A 0x7A 0x6B 0x7B 0xBE 0xFD 0x00 0x01 0x00 0x00 0x00 0x00</PPControlStack>
      <PpEnterProgMode>
        <stabDelay>100</stabDelay>
        <progModeDelay>0</progModeDelay>
        <latchCycles>5</latchCycles>
        <toggleVtg>1</toggleVtg>
        <powerOffDelay>15</powerOffDelay>
        <resetDelayMs>1</resetDelayMs>
        <resetDelayUs>0</resetDelayUs>
      </PpEnterProgMode>
      <PpLeaveProgMode>
        <stabDelay>15</stabDelay>
        <resetDelay>15</resetDelay>
      </PpLeaveProgMode>
      <PpChipErase>
        <pulseWidth>0</pulseWidth>
        <pollTimeout>10</pollTimeout>
      </PpChipErase>
      <PpProgramFlash>
        <pollTimeout>5</pollTimeout>
        <mode>0x01</mode>
        <blockSize>256</blockSize>
      </PpProgramFlash>
      <PpReadFlash>
        <blockSize>256</blockSize>
      </PpReadFlash>
      <PpProgramEeprom>
        <pollTimeout>5</pollTimeout>
        <mode>0x07</mode>
        <blockSize>256</blockSize>
      </PpProgramEeprom>
      <PpReadEeprom>
        <blockSize>256</blockSize>
      </PpReadEeprom>
      <PpProgramFuse>
        <pulseWidth>0</pulseWidth>
        <pollTimeout>5</pollTimeout>
      </PpProgramFuse>
      <PpProgramLock>
        <pulseWidth>0</pulseWidth>
        <pollTimeout>5</pollTimeout>
      </PpProgramLock>
    </STK500_2>
    <AVRISPmkII/>
    <AVRDragon/>
    <STK600>
      <IspEnterProgMode>
        <timeout>200</timeout>
        <stabDelay>100</stabDelay>
        <cmdexeDelay>25</cmdexeDelay>
        <synchLoops>32</synchLoops>
        <byteDelay>0</byteDelay>
        <pollIndex>3</pollIndex>
        <pollValue>0x53</pollValue>
      </IspEnterProgMode>
      <IspLeaveProgMode>
        <preDelay>1</preDelay>
        <postDelay>1</postDelay>
      </IspLeaveProgMode>
      <IspChipErase>
        <eraseDelay>55</eraseDelay>
        <pollMethod>1</pollMethod>
      </IspChipErase>
      <IspProgramFlash>
        <mode>0x41</mode>
        <blockSize>256</blockSize>
        <delay>50</delay>
        <cmd1>0x40</cmd1>
        <cmd2>0x4C</cmd2>
        <cmd3>0x00</cmd3>
        <pollVal1>0x00</pollVal1>
        <pollVal2>0x00</pollVal2>
      </IspProgramFlash>
      <IspProgramEeprom>
        <mode>0x41</mode>
        <blockSize>8</blockSize>
        <delay>50</delay>
        <cmd1>0xC1</cmd1>
        <cmd2>0xC2</cmd2>
        <cmd3>0x00</cmd3>
        <pollVal1>0x00</pollVal1>
        <pollVal2>0x00</pollVal2>
      </IspProgramEeprom>
      <IspReadFlash>
        <blockSize>256</blockSize>
      </IspReadFlash>
      <IspReadEeprom>
        <blockSize>256</blockSize>
      </IspReadEeprom>
      <IspReadFuse>
        <pollIndex>4</pollIndex>
      </IspReadFuse>
      <IspReadLock>
        <pollIndex>4</pollIndex>
      </IspReadLock>
      <IspReadSign>
        <pollIndex>4</pollIndex>
      </IspReadSign>
      <IspReadOsccal>
        <pollIndex>4</pollIndex>
      </IspReadOsccal>
      <PPControlStack>0x0E 0x1E 0x0F 0x1F 0x2E 0x3E 0x2F 0x3F 0x4E 0x5E 0x4F 0x5F 0x6E 0x7E 0x6F 0x7F 0x66 0x76 0x67 0x77 0x6A 0x7A 0x6B 0x7B 0xBE 0xFD 0x00 0x01 0x00 0x00 0x00 0x00</PPControlStack>
      <PpEnterProgMode>
        <stabDelay>100</stabDelay>
        <progModeDelay>0</progModeDelay>
        <latchCycles>6</latchCycles>
        <toggleVtg>0</toggleVtg>
        <powerOffDelay>0</powerOffDelay>
        <resetDelayMs>0</resetDelayMs>
        <resetDelayUs>0</resetDelayUs>
      </PpEnterProgMode>
      <PpLeaveProgMode>
        <stabDelay>15</stabDelay>
        <resetDelay>15</resetDelay>
      </PpLeaveProgMode>
      <PpChipErase>
        <pulseWidth>0</pulseWidth>
        <pollTimeout>10</pollTimeout>
      </PpChipErase>
      <PpProgramFlash>
        <pollTimeout>5</pollTimeout>
        <mode>0x01</mode>
        <blockSize>256</blockSize>
      </PpProgramFlash>
      <PpReadFlash>
        <blockSize>256</blockSize>
      </PpReadFlash>
      <PpProgramEeprom>
        <pollTimeout>5</pollTimeout>
        <mode>0x07</mode>
        <blockSize>256</blockSize>
      </PpProgramEeprom>
      <PpReadEeprom>
        <blockSize>256</blockSize>
      </PpReadEeprom>
      <PpProgramFuse>
        <pulseWidth>0</pulseWidth>
        <pollTimeout>5</pollTimeout>
      </PpProgramFuse>
      <PpProgramLock>
        <pulseWidth>0</pulseWidth>
        <pollTimeout>5</pollTimeout>
      </PpProgramLock>
    </STK600>
    <AVRONE>
      <ID>0x0A70103F</ID>
      <Interface>JTAG</Interface>
    </AVRONE>
  </ICE_SETTINGS>
  <V2>
    <templates>
      <module class="FUSE">
        <registers name="FUSE" memspace="FUSE">
          <reg size="1" name="EXTENDED" offset="0x02">
            <bitfield name="BODLEVEL" mask="0x07" text="Brown-out Detector trigger level" icon="" enum="ENUM_BODLEVEL"/>
          </reg>
          <reg size="1" name="HIGH" offset="0x01">
            <bitfield name="OCDEN" mask="0x80" text="On-Chip Debug Enabled" icon=""/>
            <bitfield name="JTAGEN" mask="0x40" text="JTAG Interface Enabled" icon=""/>
            <bitfield name="SPIEN" mask="0x20" text="Serial program downloading (SPI) enabled" icon=""/>
            <bitfield name="WDTON" mask="0x10" text="Watchdog timer always on" icon=""/>
            <bitfield name="EESAVE" mask="0x08" text="Preserve EEPROM through the Chip Erase cycle" icon=""/>
            <bitfield name="BOOTSZ" mask="0x06" text="Select Boot Size" icon="" enum="ENUM_BOOTSZ"/>
            <bitfield name="BOOTRST" mask="0x01" text="Boot Reset vector Enabled" icon=""/>
          </reg>
          <reg size="1" name="LOW" offset="0x00">
            <bitfield name="CKDIV8" mask="0x80" text="Divide clock by 8 internally" icon=""/>
            <bitfield name="CKOUT" mask="0x40" text="Clock output on PORTE7" icon=""/>
            <bitfield name="CKSEL_SUT" mask="0x3F" text="Select Clock Source : Start-up time" icon="" enum="ENUM_SUT_CKSEL"/>
          </reg>
        </registers>
        <enumerator name="ENUM_SUT_CKSEL">
          <enum val="0x00" text="Ext. Clock; Start-up time: 6 CK + 0 ms" constname="EXTCLK_6CK_0MS"/>
          <enum val="0x10" text="Ext. Clock; Start-up time: 6 CK + 4.1 ms" constname="EXTCLK_6CK_4MS1"/>
          <enum val="0x20" text="Ext. Clock; Start-up time: 6 CK + 65 ms" constname="EXTCLK_6CK_65MS"/>
          <enum val="0x02" text="Int. RC Osc.; Start-up time: 6 CK + 0 ms" constname="INTRCOSC_6CK_0MS"/>
          <enum val="0x12" text="Int. RC Osc.; Start-up time: 6 CK + 4.1 ms" constname="INTRCOSC_6CK_4MS1"/>
          <enum val="0x22" text="Int. RC Osc.; Start-up time: 6 CK + 65 ms" constname="INTRCOSC_6CK_65MS"/>
          <enum val="0x03" text="Int. 128kHz RC Osc.; Start-up time: 6 CK + 0 ms" constname="INTRCOSC_128KHZ_6CK_0MS"/>
          <enum val="0x13" text="Int. 128kHz RC Osc.; Start-up time: 6 CK + 4.1 ms" constname="INTRCOSC_128KHZ_6CK_4MS1"/>
          <enum val="0x23" text="Int. 128kHz RC Osc.; Start-up time: 6 CK + 65 ms" constname="INTRCOSC_128KHZ_6CK_65MS"/>
          <enum val="0x06" text="Tranceiver Oscillator; Start-up time: 258 CK + 4.1 ms" constname="TOSC_258CK_4MS1"/>
          <enum val="0x16" text="Tranceiver Oscillator; Start-up time: 258 CK + 65 ms" constname="TOSC_258CK_65MS"/>
          <enum val="0x26" text="Tranceiver Oscillator; Start-up time: 1K CK + 0 ms" constname="TOSC_1KCK_0MS"/>
          <enum val="0x36" text="Tranceiver Oscillator; Start-up time: 1K CK + 4.1 ms" constname="TOSC_1KCK_4MS1"/>
          <enum val="0x07" text="Tranceiver Oscillator; Start-up time: 1K CK + 65 ms" constname="TOSC_1KCK_65MS"/>
          <enum val="0x17" text="Tranceiver Oscillator; Start-up time: 16K CK + 0 ms" constname="TOSC_16KCK_0MS"/>
          <enum val="0x27" text="Tranceiver Oscillator; Start-up time: 16K CK + 4.1 ms" constname="TOSC_16KCK_4MS1"/>
          <enum val="0x37" text="Tranceiver Oscillator; Start-up time: 16K CK + 65 ms" constname="TOSC_16KCK_65MS"/>
          <enum val="0x08" text="Tranceiver Oscillator; Start-up time: 258 CK + 4.1 ms" constname="TOSC_258CK_4MS1"/>
          <enum val="0x18" text="Tranceiver Oscillator; Start-up time: 258 CK + 65 ms" constname="TOSC_258CK_65MS"/>
          <enum val="0x28" text="Tranceiver Oscillator; Start-up time: 1K CK + 0 ms" constname="TOSC_1KCK_0MS"/>
          <enum val="0x38" text="Tranceiver Oscillator; Start-up time: 1K CK + 4.1 ms" constname="TOSC_1KCK_4MS1"/>
          <enum val="0x09" text="Tranceiver Oscillator; Start-up time: 1K CK + 65 ms" constname="TOSC_1KCK_65MS"/>
          <enum val="0x19" text="Tranceiver Oscillator; Start-up time: 16K CK + 0 ms" constname="TOSC_16KCK_0MS"/>
          <enum val="0x29" text="Tranceiver Oscillator; Start-up time: 16K CK + 4.1 ms" constname="TOSC_16KCK_4MS1"/>
          <enum val="0x39" text="Tranceiver Oscillator; Start-up time: 16K CK + 65 ms" constname="TOSC_16KCK_65MS"/>
          <enum val="0x0A" text="Tranceiver Oscillator; Start-up time: 258 CK + 4.1 ms" constname="TOSC_258CK_4MS1"/>
          <enum val="0x1A" text="Tranceiver Oscillator; Start-up time: 258 CK + 65 ms" constname="TOSC_258CK_65MS"/>
          <enum val="0x2A" text="Tranceiver Oscillator; Start-up time: 1K CK + 0 ms" constname="TOSC_1KCK_0MS"/>
          <enum val="0x3A" text="Tranceiver Oscillator; Start-up time: 1K CK + 4.1 ms" constname="TOSC_1KCK_4MS1"/>
          <enum val="0x0B" text="Tranceiver Oscillator; Start-up time: 1K CK + 65 ms" constname="TOSC_1KCK_65MS"/>
          <enum val="0x1B" text="Tranceiver Oscillator; Start-up time: 16K CK + 0 ms" constname="TOSC_16KCK_0MS"/>
          <enum val="0x2B" text="Tranceiver Oscillator; Start-up time: 16K CK + 4.1 ms" constname="TOSC_16KCK_4MS1"/>
          <enum val="0x3B" text="Tranceiver Oscillator; Start-up time: 16K CK + 65 ms" constname="TOSC_16KCK_65MS"/>
          <enum val="0x0C" text="Tranceiver Oscillator; Start-up time: 258 CK + 4.1 ms" constname="TOSC_258CK_4MS1"/>
          <enum val="0x1C" text="Tranceiver Oscillator; Start-up time: 258 CK + 65 ms" constname="TOSC_258CK_65MS"/>
          <enum val="0x2C" text="Tranceiver Oscillator; Start-up time: 1K CK + 0 ms" constname="TOSC_1KCK_0MS"/>
          <enum val="0x3C" text="Tranceiver Oscillator; Start-up time: 1K CK + 4.1 ms" constname="TOSC_1KCK_4MS1"/>
          <enum val="0x0D" text="Tranceiver Oscillator; Start-up time: 1K CK + 65 ms" constname="TOSC_1KCK_65MS"/>
          <enum val="0x1D" text="Tranceiver Oscillator; Start-up time: 16K CK + 0 ms" constname="TOSC_16KCK_0MS"/>
          <enum val="0x2D" text="Tranceiver Oscillator; Start-up time: 16K CK + 4.1 ms" constname="TOSC_16KCK_4MS1"/>
          <enum val="0x3D" text="Tranceiver Oscillator; Start-up time: 16K CK + 65 ms" constname="TOSC_16KCK_65MS"/>
          <enum val="0x0E" text="Tranceiver Oscillator; Start-up time: 258 CK + 4.1 ms" constname="TOSC_258CK_4MS1"/>
          <enum val="0x1E" text="Tranceiver Oscillator; Start-up time: 258 CK + 65 ms" constname="TOSC_258CK_65MS"/>
          <enum val="0x2E" text="Tranceiver Oscillator; Start-up time: 1K CK + 0 ms" constname="TOSC_1KCK_0MS"/>
          <enum val="0x3E" text="Tranceiver Oscillator; Start-up time: 1K CK + 4.1 ms" constname="TOSC_1KCK_4MS1"/>
          <enum val="0x0F" text="Tranceiver Oscillator; Start-up time: 1K CK + 65 ms" constname="TOSC_1KCK_65MS"/>
          <enum val="0x1F" text="Tranceiver Oscillator; Start-up time: 16K CK + 0 ms" constname="TOSC_16KCK_0MS"/>
          <enum val="0x2F" text="Tranceiver Oscillator; Start-up time: 16K CK + 4.1 ms" constname="TOSC_16KCK_4MS1"/>
          <enum val="0x3F" text="Tranceiver Oscillator; Start-up time: 16K CK + 65 ms" constname="TOSC_16KCK_65MS"/>
        </enumerator>
        <enumerator name="ENUM_BOOTSZ">
          <enum val="0x03" text="Boot Flash size=512 words start address=$FE00" constname="512W_FE00"/>
          <enum val="0x02" text="Boot Flash size=1024 words start address=$FC00" constname="1024W_FC00"/>
          <enum val="0x01" text="Boot Flash size=2048 words start address=$F800" constname="2048W_F800"/>
          <enum val="0x00" text="Boot Flash size=4096 words start address=$F000" constname="4096W_F000"/>
        </enumerator>
        <enumerator name="ENUM_BODLEVEL">
          <enum val="0x07" text="Brown-out detection disabled" constname="DISABLED"/>
          <enum val="0x06" text="Brown-out detection at VCC=1.8 V" constname="1V8"/>
          <enum val="0x05" text="Brown-out detection at VCC=1.9 V" constname="1V9"/>
          <enum val="0x04" text="Brown-out detection at VCC=2.0 V" constname="2V0"/>
          <enum val="0x03" text="Brown-out detection at VCC=2.1 V" constname="2V1"/>
          <enum val="0x02" text="Brown-out detection at VCC=2.2 V" constname="2V2"/>
          <enum val="0x01" text="Brown-out detection at VCC=2.3 V" constname="2V3"/>
          <enum val="0x00" text="Brown-out detection at VCC=2.4 V" constname="2V4"/>
        </enumerator>
      </module>
      <module class="LOCKBIT">
        <registers name="LOCKBIT" memspace="LOCKBIT">
          <reg size="1" name="LOCKBIT" offset="0x00">
            <bitfield name="LB" mask="0x03" text="Memory Lock" icon="" enum="ENUM_LB"/>
            <bitfield name="BLB0" mask="0x0C" text="Boot Loader Protection Mode" icon="" enum="ENUM_BLB"/>
            <bitfield name="BLB1" mask="0x30" text="Boot Loader Protection Mode" icon="" enum="ENUM_BLB2"/>
          </reg>
        </registers>
        <enumerator name="ENUM_LB">
          <enum val="0x00" text="Further programming and verification disabled" constname="PROG_VER_DISABLED"/>
          <enum val="0x02" text="Further programming disabled" constname="PROG_DISABLED"/>
          <enum val="0x03" text="No memory lock features enabled" constname="NO_LOCK"/>
        </enumerator>
        <enumerator name="ENUM_BLB">
          <enum val="0x00" text="LPM and SPM prohibited in Application Section" constname="LPM_SPM_DISABLE"/>
          <enum val="0x01" text="LPM prohibited in Application Section" constname="LPM_DISABLE"/>
          <enum val="0x02" text="SPM prohibited in Application Section" constname="SPM_DISABLE"/>
          <enum val="0x03" text="No lock on SPM and LPM in Application Section" constname="NO_LOCK"/>
        </enumerator>
        <enumerator name="ENUM_BLB2">
          <enum val="0x00" text="LPM and SPM prohibited in Boot Section" constname="LPM_SPM_DISABLE"/>
          <enum val="0x01" text="LPM prohibited in Boot Section" constname="LPM_DISABLE"/>
          <enum val="0x02" text="SPM prohibited in Boot Section" constname="SPM_DISABLE"/>
          <enum val="0x03" text="No lock on SPM and LPM in Boot Section" constname="NO_LOCK"/>
        </enumerator>
      </module>
      <module class="ANALOG_COMPARATOR" text="">
        <registers name="ANALOG_COMPARATOR" memspace="DATAMEM" text="" icon="io_analo.bmp">
          <reg size="1" name="ADCSRB" offset="0x7B" text="ADC Control and Status Register B" icon="io_flag.bmp">
            <bitfield name="ACME" mask="0x40" text="Analog Comparator Multiplexer Enable" icon=""/>
          </reg>
          <reg size="1" name="ACSR" offset="0x50" text="Analog Comparator Control And Status Register" icon="io_analo.bmp">
            <bitfield name="ACD" mask="0x80" text="Analog Comparator Disable" icon=""/>
            <bitfield name="ACBG" mask="0x40" text="Analog Comparator Bandgap Select" icon=""/>
            <bitfield name="ACO" mask="0x20" text="Analog Compare Output" icon=""/>
            <bitfield name="ACI" mask="0x10" text="Analog Comparator Interrupt Flag" icon=""/>
            <bitfield name="ACIE" mask="0x08" text="Analog Comparator Interrupt Enable" icon=""/>
            <bitfield name="ACIC" mask="0x04" text="Analog Comparator Input Capture Enable" icon=""/>
            <bitfield name="ACIS" mask="0x03" text="Analog Comparator Interrupt Mode Select" icon="" enum="ANALOG_COMP_INTERRUPT"/>
          </reg>
          <reg size="1" name="DIDR1" offset="0x7F" text="Digital Input Disable Register 1" icon="io_analo.bmp">
            <bitfield name="AIN1D" mask="0x02" text="AIN1 Digital Input Disable" icon=""/>
            <bitfield name="AIN0D" mask="0x01" text="AIN0 Digital Input Disable" icon=""/>
          </reg>
        </registers>
        <enumerator name="ANALOG_COMP_INTERRUPT">
          <enum val="0x00" text="Interrupt on Toggle"/>
          <enum val="0x01" text="Reserved"/>
          <enum val="0x02" text="Interrupt on Falling Edge"/>
          <enum val="0x03" text="Interrupt on Rising Edge"/>
        </enumerator>
      </module>
      <module class="USART0" text="">
        <registers name="USART0" memspace="DATAMEM" text="" icon="io_com.bmp">
          <reg size="1" name="UDR0" offset="0xC6" text="USART0 I/O Data Register" icon="io_com.bmp" mask="0xFF"/>
          <reg size="1" name="UCSR0A" offset="0xC0" text="USART0 Control and Status Register A" icon="io_flag.bmp">
            <bitfield name="RXC0" mask="0x80" text="USART Receive Complete" icon=""/>
            <bitfield name="TXC0" mask="0x40" text="USART Transmit Complete" icon=""/>
            <bitfield name="UDRE0" mask="0x20" text="USART Data Register Empty" icon=""/>
            <bitfield name="FE0" mask="0x10" text="Frame Error" icon=""/>
            <bitfield name="DOR0" mask="0x08" text="Data OverRun" icon=""/>
            <bitfield name="UPE0" mask="0x04" text="USART Parity Error" icon=""/>
            <bitfield name="U2X0" mask="0x02" text="Double the USART Transmission Speed" icon=""/>
            <bitfield name="MPCM0" mask="0x01" text="Multi-processor Communication Mode" icon=""/>
          </reg>
          <reg size="1" name="UCSR0B" offset="0xC1" text="USART0 Control and Status Register B" icon="io_flag.bmp">
            <bitfield name="RXCIE0" mask="0x80" text="RX Complete Interrupt Enable" icon=""/>
            <bitfield name="TXCIE0" mask="0x40" text="TX Complete Interrupt Enable" icon=""/>
            <bitfield name="UDRIE0" mask="0x20" text="USART Data Register Empty Interrupt Enable" icon=""/>
            <bitfield name="RXEN0" mask="0x10" text="Receiver Enable" icon=""/>
            <bitfield name="TXEN0" mask="0x08" text="Transmitter Enable" icon=""/>
            <bitfield name="UCSZ02" mask="0x04" text="Character Size" icon=""/>
            <bitfield name="RXB80" mask="0x02" text="Receive Data Bit 8" icon=""/>
            <bitfield name="TXB80" mask="0x01" text="Transmit Data Bit 8" icon=""/>
          </reg>
          <reg size="1" name="UCSR0C" offset="0xC2" text="USART0 Control and Status Register C" icon="io_flag.bmp">
            <bitfield name="UMSEL0" mask="0xC0" text="USART Mode Select" icon="" enum="COMM_USART_MODE_2BIT_MEGARF"/>
            <bitfield name="UPM0" mask="0x30" text="Parity Mode" icon="" enum="COMM_UPM_PARITY_MODE"/>
            <bitfield name="USBS0" mask="0x08" text="Stop Bit Select" icon="" enum="COMM_STOP_BIT_SEL"/>
            <bitfield name="UCSZ0" mask="0x06" text="Character Size" icon="" enum="USART_CHAR_SIZE_BITF"/>
            <bitfield name="UCPOL0" mask="0x01" text="Clock Polarity" icon="" enum="USART_CLK_POLARITY_BITF"/>
          </reg>
          <reg size="2" name="UBRR0" offset="0xC4" text="USART0 Baud Rate Register  Bytes" icon="io_com.bmp" mask="0xFFFF"/>
        </registers>
        <enumerator name="COMM_USART_MODE_2BIT_MEGARF">
          <enum val="0x00" text="Asynchronous USART"/>
          <enum val="0x01" text="Synchronous USART"/>
          <enum val="0x02" text="Reserved"/>
          <enum val="0x03" text="Master SPI (MSPIM)"/>
        </enumerator>
        <enumerator name="COMM_UPM_PARITY_MODE">
          <enum val="0x00" text="Disabled"/>
          <enum val="0x01" text="Reserved"/>
          <enum val="0x02" text="Enabled, Even Parity"/>
          <enum val="0x03" text="Enabled, Odd Parity"/>
        </enumerator>
        <enumerator name="COMM_STOP_BIT_SEL">
          <enum val="0x00" text="1-bit"/>
          <enum val="0x01" text="2-bit"/>
        </enumerator>
        <enumerator name="USART_CHAR_SIZE_BITF">
          <enum val="0" text="5-bit"/>
          <enum val="1" text="6-bit"/>
          <enum val="2" text="7-bit"/>
          <enum val="3" text="8-bit"/>
          <enum val="4" text="Reserved"/>
          <enum val="5" text="Reserved"/>
          <enum val="6" text="Reserved"/>
          <enum val="7" text="9-bit"/>
        </enumerator>
        <enumerator name="USART_CLK_POLARITY_BITF">
          <enum val="0" text="Rising XCKn Edge (Transmitted Data Changed), Falling XCKn Edge (Received Data Sampled)"/>
          <enum val="1" text="Falling XCKn Edge (Transmitted Data Changed), Rising XCKn Edge (Received Data Sampled)"/>
        </enumerator>
      </module>
      <module class="USART1" text="">
        <registers name="USART1" memspace="DATAMEM" text="" icon="io_com.bmp">
          <reg size="1" name="UDR1" offset="0xCE" text="USART1 I/O Data Register" icon="io_com.bmp" mask="0xFF"/>
          <reg size="1" name="UCSR1A" offset="0xC8" text="USART1 Control and Status Register A" icon="io_flag.bmp">
            <bitfield name="RXC1" mask="0x80" text="USART Receive Complete" icon=""/>
            <bitfield name="TXC1" mask="0x40" text="USART Transmit Complete" icon=""/>
            <bitfield name="UDRE1" mask="0x20" text="USART Data Register Empty" icon=""/>
            <bitfield name="FE1" mask="0x10" text="Frame Error" icon=""/>
            <bitfield name="DOR1" mask="0x08" text="Data OverRun" icon=""/>
            <bitfield name="UPE1" mask="0x04" text="USART Parity Error" icon=""/>
            <bitfield name="U2X1" mask="0x02" text="Double the USART Transmission Speed" icon=""/>
            <bitfield name="MPCM1" mask="0x01" text="Multi-processor Communication Mode" icon=""/>
          </reg>
          <reg size="1" name="UCSR1B" offset="0xC9" text="USART1 Control and Status Register B" icon="io_flag.bmp">
            <bitfield name="RXCIE1" mask="0x80" text="RX Complete Interrupt Enable" icon=""/>
            <bitfield name="TXCIE1" mask="0x40" text="TX Complete Interrupt Enable" icon=""/>
            <bitfield name="UDRIE1" mask="0x20" text="USART Data Register Empty Interrupt Enable" icon=""/>
            <bitfield name="RXEN1" mask="0x10" text="Receiver Enable" icon=""/>
            <bitfield name="TXEN1" mask="0x08" text="Transmitter Enable" icon=""/>
            <bitfield name="UCSZ12" mask="0x04" text="Character Size" icon=""/>
            <bitfield name="RXB81" mask="0x02" text="Receive Data Bit 8" icon=""/>
            <bitfield name="TXB81" mask="0x01" text="Transmit Data Bit 8" icon=""/>
          </reg>
          <reg size="1" name="UCSR1C" offset="0xCA" text="USART1 Control and Status Register C" icon="io_flag.bmp">
            <bitfield name="UMSEL1" mask="0xC0" text="USART Mode Select" icon="" enum="COMM_USART_MODE_2BIT_MEGARF"/>
            <bitfield name="UPM1" mask="0x30" text="Parity Mode" icon="" enum="COMM_UPM_PARITY_MODE"/>
            <bitfield name="USBS1" mask="0x08" text="Stop Bit Select" icon="" enum="COMM_STOP_BIT_SEL"/>
            <bitfield name="UCSZ1" mask="0x06" text="Character Size" icon="" enum="USART_CHAR_SIZE_BITF"/>
            <bitfield name="UCPOL1" mask="0x01" text="Clock Polarity" icon="" enum="USART_CLK_POLARITY_BITF"/>
          </reg>
          <reg size="2" name="UBRR1" offset="0xCC" text="USART1 Baud Rate Register  Bytes" icon="io_com.bmp" mask="0xFFFF"/>
        </registers>
        <enumerator name="COMM_USART_MODE_2BIT_MEGARF">
          <enum val="0x00" text="Asynchronous USART"/>
          <enum val="0x01" text="Synchronous USART"/>
          <enum val="0x02" text="Reserved"/>
          <enum val="0x03" text="Master SPI (MSPIM)"/>
        </enumerator>
        <enumerator name="COMM_UPM_PARITY_MODE">
          <enum val="0x00" text="Disabled"/>
          <enum val="0x01" text="Reserved"/>
          <enum val="0x02" text="Enabled, Even Parity"/>
          <enum val="0x03" text="Enabled, Odd Parity"/>
        </enumerator>
        <enumerator name="COMM_STOP_BIT_SEL">
          <enum val="0x00" text="1-bit"/>
          <enum val="0x01" text="2-bit"/>
        </enumerator>
        <enumerator name="USART_CHAR_SIZE_BITF">
          <enum val="0" text="5-bit"/>
          <enum val="1" text="6-bit"/>
          <enum val="2" text="7-bit"/>
          <enum val="3" text="8-bit"/>
          <enum val="4" text="Reserved"/>
          <enum val="5" text="Reserved"/>
          <enum val="6" text="Reserved"/>
          <enum val="7" text="9-bit"/>
        </enumerator>
        <enumerator name="USART_CLK_POLARITY_BITF">
          <enum val="0" text="Rising XCKn Edge (Transmitted Data Changed), Falling XCKn Edge (Received Data Sampled)"/>
          <enum val="1" text="Falling XCKn Edge (Transmitted Data Changed), Rising XCKn Edge (Received Data Sampled)"/>
        </enumerator>
      </module>
      <module class="TWI" text="">
        <registers name="TWI" memspace="DATAMEM" text="" icon="io_com.bmp">
          <reg size="1" name="TWAMR" offset="0xBD" text="TWI (Slave) Address Mask Register" icon="io_com.bmp">
            <bitfield name="TWAM" mask="0xFE" text="TWI Address Mask" icon=""/>
            <bitfield name="Res" mask="0x01" text="Reserved Bit" icon=""/>
          </reg>
          <reg size="1" name="TWBR" offset="0xB8" text="TWI Bit Rate Register" icon="io_com.bmp" mask="0xFF"/>
          <reg size="1" name="TWCR" offset="0xBC" text="TWI Control Register" icon="io_flag.bmp">
            <bitfield name="TWINT" mask="0x80" text="TWI Interrupt Flag" icon=""/>
            <bitfield name="TWEA" mask="0x40" text="TWI Enable Acknowledge Bit" icon=""/>
            <bitfield name="TWSTA" mask="0x20" text="TWI START Condition Bit" icon=""/>
            <bitfield name="TWSTO" mask="0x10" text="TWI STOP Condition Bit" icon=""/>
            <bitfield name="TWWC" mask="0x08" text="TWI Write Collision Flag" icon=""/>
            <bitfield name="TWEN" mask="0x04" text="TWI Enable Bit" icon=""/>
            <bitfield name="Res" mask="0x02" text="Reserved Bit" icon=""/>
            <bitfield name="TWIE" mask="0x01" text="TWI Interrupt Enable" icon=""/>
          </reg>
          <reg size="1" name="TWSR" offset="0xB9" text="TWI Status Register" icon="io_flag.bmp">
            <bitfield name="TWS" mask="0xF8" text="TWI Status" icon="" enum="TWI_STATUS_BITF" lsb="3"/>
            <bitfield name="Res" mask="0x04" text="Reserved Bit" icon=""/>
            <bitfield name="TWPS" mask="0x03" text="TWI Prescaler Bits" icon="" enum="COMM_TWI_PRESACLE"/>
          </reg>
          <reg size="1" name="TWDR" offset="0xBB" text="TWI Data Register" icon="io_com.bmp" mask="0xFF"/>
          <reg size="1" name="TWAR" offset="0xBA" text="TWI (Slave) Address Register" icon="io_com.bmp">
            <bitfield name="TWA" mask="0xFE" text="TWI (Slave) Address" icon=""/>
            <bitfield name="TWGCE" mask="0x01" text="TWI General Call Recognition Enable Bit" icon=""/>
          </reg>
        </registers>
        <enumerator name="TWI_STATUS_BITF">
          <enum val="0x00" text="Bus error due to illegal START or STOP condition."/>
          <enum val="0x08" text="A START condition has been transmitted."/>
          <enum val="0x10" text="A repeated START condition has been transmitted."/>
          <enum val="0x18" text="SLA+W has been transmitted; ACK has been received."/>
          <enum val="0x20" text="SLA+W has been transmitted; NOT ACK has been received."/>
          <enum val="0x28" text="Data byte has been transmitted; ACK has been received."/>
          <enum val="0x30" text="Data byte has been transmitted; NOT ACK has been received."/>
          <enum val="0x38" text="Arbitration lost in SLA+W or data bytes (Transmitter); Arbitration lost in SLA+R or NOT ACK bit (Receiver)."/>
          <enum val="0x40" text="SLA+R has been transmitted; ACK has been received."/>
          <enum val="0x48" text="SLA+R has been transmitted; NOT ACK has been received."/>
          <enum val="0x50" text="Data byte has been received; ACK has been returned."/>
          <enum val="0x58" text="Data byte has been received; NOT ACK has been returned."/>
          <enum val="0x60" text="Own SLA+W has been received; ACK has been returned."/>
          <enum val="0x68" text="Arbitration lost in SLA+R/W as Master; own SLA+W has been received; ACK has been returned."/>
          <enum val="0x70" text="General call address has been received; ACK has been returned."/>
          <enum val="0x78" text="Arbitration lost in SLA+R/W as Master; general call address has been received; ACK has been returned."/>
          <enum val="0x80" text="Previously addressed with own SLA+W; data has been received; ACK has been returned."/>
          <enum val="0x88" text="Previously addressed with own SLA+W; data has been received; NOT ACK has been returned."/>
          <enum val="0x90" text="Previously addressed with general call; data has been received; ACK has been returned."/>
          <enum val="0x98" text="Previously addressed with general call; data has been received; NOT ACK has been returned."/>
          <enum val="0xA0" text="A STOP condition or repeated START condition has been received while still addressed as Slave."/>
          <enum val="0xA8" text="Own SLA+R has been received; ACK has been returned."/>
          <enum val="0xB0" text="Arbitration lost in SLA+R/W as Master; own SLA+R has been received; ACK has been returned."/>
          <enum val="0xB8" text="Data byte in TWDR has been transmitted; ACK has been received."/>
          <enum val="0xC0" text="Data byte in TWDR has been transmitted; NO ACK has been received."/>
          <enum val="0xC8" text="Last data byte in TWDR has been transmitted (TWEA = 0); ACK has been received."/>
          <enum val="0xF8" text="No relevant state information available; TWINT = 0."/>
        </enumerator>
        <enumerator name="COMM_TWI_PRESACLE">
          <enum val="0x00" text="1"/>
          <enum val="0x01" text="4"/>
          <enum val="0x02" text="16"/>
          <enum val="0x03" text="64"/>
        </enumerator>
      </module>
      <module class="SPI" text="">
        <registers name="SPI" memspace="DATAMEM" text="" icon="io_com.bmp">
          <reg size="1" name="SPCR" offset="0x4C" text="SPI Control Register" icon="io_flag.bmp">
            <bitfield name="SPIE" mask="0x80" text="SPI Interrupt Enable" icon=""/>
            <bitfield name="SPE" mask="0x40" text="SPI Enable" icon=""/>
            <bitfield name="DORD" mask="0x20" text="Data Order" icon=""/>
            <bitfield name="MSTR" mask="0x10" text="Master/Slave Select" icon=""/>
            <bitfield name="CPOL" mask="0x08" text="Clock polarity" icon="" enum="SPI_CPOL_BITF"/>
            <bitfield name="CPHA" mask="0x04" text="Clock Phase" icon="" enum="SPI_CPHA_BITF"/>
            <bitfield name="SPR" mask="0x03" text="SPI Clock Rate Select 1 and 0" icon="" enum="COMM_SCK_RATE_SPI2X"/>
          </reg>
          <reg size="1" name="SPSR" offset="0x4D" text="SPI Status Register" icon="io_flag.bmp">
            <bitfield name="SPIF" mask="0x80" text="SPI Interrupt Flag" icon=""/>
            <bitfield name="WCOL" mask="0x40" text="Write Collision Flag" icon=""/>
            <bitfield name="Res" mask="0x3E" text="Reserved" icon=""/>
            <bitfield name="SPI2X" mask="0x01" text="Double SPI Speed Bit" icon=""/>
          </reg>
          <reg size="1" name="SPDR" offset="0x4E" text="SPI Data Register" icon="io_com.bmp" mask="0xFF"/>
        </registers>
        <enumerator name="SPI_CPOL_BITF">
          <enum val="0" text="Rising (Leading Edge), Falling (Trailing Edge)"/>
          <enum val="1" text="Falling (Leading Egde), Rising (Trailing Edge)"/>
        </enumerator>
        <enumerator name="SPI_CPHA_BITF">
          <enum val="0" text="Sample (Leading Edge), Setup (Trailing Edge)"/>
          <enum val="1" text="Setup (Leading Edge), Sample (Trailing Edge)"/>
        </enumerator>
        <enumerator name="COMM_SCK_RATE_SPI2X">
          <enum val="0x00" text="fosc/4 / fosc/2 (SPI2X=0/1)"/>
          <enum val="0x01" text="fosc/16 / fosc/8 (SPI2X=0/1)"/>
          <enum val="0x02" text="fosc/64 / fosc/32 (SPI2X=0/1)"/>
          <enum val="0x03" text="fosc/128 / fosc/64 (SPI2X=0/1)"/>
        </enumerator>
      </module>
      <module class="PORTA" text="">
        <registers name="PORTA" memspace="DATAMEM" text="" icon="io_port.bmp">
          <reg size="1" name="PORTA" offset="0x22" text="Port A Data Register" icon="io_port.bmp" mask="0xFF"/>
          <reg size="1" name="DDRA" offset="0x21" text="Port A Data Direction Register" icon="io_flag.bmp" mask="0xFF"/>
          <reg size="1" name="PINA" offset="0x20" text="Port A Input Pins Address" icon="io_port.bmp" mask="0xFF"/>
        </registers>
      </module>
      <module class="PORTB" text="">
        <registers name="PORTB" memspace="DATAMEM" text="" icon="io_port.bmp">
          <reg size="1" name="PORTB" offset="0x25" text="Port B Data Register" icon="io_port.bmp" mask="0xFF"/>
          <reg size="1" name="DDRB" offset="0x24" text="Port B Data Direction Register" icon="io_flag.bmp" mask="0xFF"/>
          <reg size="1" name="PINB" offset="0x23" text="Port B Input Pins Address" icon="io_port.bmp" mask="0xFF"/>
        </registers>
      </module>
      <module class="PORTC" text="">
        <registers name="PORTC" memspace="DATAMEM" text="" icon="io_port.bmp">
          <reg size="1" name="PORTC" offset="0x28" text="Port C Data Register" icon="io_port.bmp" mask="0xFF"/>
          <reg size="1" name="DDRC" offset="0x27" text="Port C Data Direction Register" icon="io_flag.bmp" mask="0xFF"/>
          <reg size="1" name="PINC" offset="0x26" text="Port C Input Pins Address" icon="io_port.bmp" mask="0xFF"/>
        </registers>
      </module>
      <module class="PORTD" text="">
        <registers name="PORTD" memspace="DATAMEM" text="" icon="io_port.bmp">
          <reg size="1" name="PORTD" offset="0x2B" text="Port D Data Register" icon="io_port.bmp" mask="0xFF"/>
          <reg size="1" name="DDRD" offset="0x2A" text="Port D Data Direction Register" icon="io_flag.bmp" mask="0xFF"/>
          <reg size="1" name="PIND" offset="0x29" text="Port D Input Pins Address" icon="io_port.bmp" mask="0xFF"/>
        </registers>
      </module>
      <module class="PORTE" text="">
        <registers name="PORTE" memspace="DATAMEM" text="" icon="io_port.bmp">
          <reg size="1" name="PORTE" offset="0x2E" text="Port E Data Register" icon="io_port.bmp" mask="0xFF"/>
          <reg size="1" name="DDRE" offset="0x2D" text="Port E Data Direction Register" icon="io_flag.bmp" mask="0xFF"/>
          <reg size="1" name="PINE" offset="0x2C" text="Port E Input Pins Address" icon="io_port.bmp" mask="0xFF"/>
        </registers>
      </module>
      <module class="PORTF" text="">
        <registers name="PORTF" memspace="DATAMEM" text="" icon="io_port.bmp">
          <reg size="1" name="PORTF" offset="0x31" text="Port F Data Register" icon="io_port.bmp" mask="0xFF"/>
          <reg size="1" name="DDRF" offset="0x30" text="Port F Data Direction Register" icon="io_flag.bmp" mask="0xFF"/>
          <reg size="1" name="PINF" offset="0x2F" text="Port F Input Pins Address" icon="io_port.bmp" mask="0xFF"/>
        </registers>
      </module>
      <module class="PORTG" text="">
        <registers name="PORTG" memspace="DATAMEM" text="" icon="io_port.bmp">
          <reg size="1" name="PORTG" offset="0x34" text="Port G Data Register" icon="io_port.bmp" mask="0xFF"/>
          <reg size="1" name="DDRG" offset="0x33" text="Port G Data Direction Register" icon="io_flag.bmp" mask="0xFF"/>
          <reg size="1" name="PING" offset="0x32" text="Port G Input Pins Address" icon="io_port.bmp" mask="0xFF"/>
        </registers>
      </module>
      <module class="TIMER_COUNTER_0" text="">
        <registers name="TIMER_COUNTER_0" memspace="DATAMEM" text="" icon="io_timer.bmp">
          <reg size="1" name="OCR0B" offset="0x48" text="Timer/Counter0 Output Compare Register B" icon="io_timer.bmp" mask="0xFF"/>
          <reg size="1" name="OCR0A" offset="0x47" text="Timer/Counter0 Output Compare Register" icon="io_timer.bmp" mask="0xFF"/>
          <reg size="1" name="TCNT0" offset="0x46" text="Timer/Counter0 Register" icon="io_timer.bmp" mask="0xFF"/>
          <reg size="1" name="TCCR0B" offset="0x45" text="Timer/Counter0 Control Register B" icon="io_flag.bmp">
            <bitfield name="FOC0A" mask="0x80" text="Force Output Compare A" icon=""/>
            <bitfield name="FOC0B" mask="0x40" text="Force Output Compare B" icon=""/>
            <bitfield name="Res" mask="0x30" text="Reserved Bit" icon=""/>
            <bitfield name="WGM02" mask="0x08" text="" icon=""/>
            <bitfield name="CS0" mask="0x07" text="Clock Select" icon="" enum="TC0_CLK_SEL_3BIT_EXT"/>
          </reg>
          <reg size="1" name="TCCR0A" offset="0x44" text="Timer/Counter0 Control Register A" icon="io_flag.bmp">
            <bitfield name="COM0A" mask="0xC0" text="Compare Match Output A Mode" icon="" enum="TC0_COM0A_BITF"/>
            <bitfield name="COM0B" mask="0x30" text="Compare Match Output B Mode" icon="" enum="TC0_COM0B_BITF"/>
            <bitfield name="Res" mask="0x0C" text="Reserved Bit" icon=""/>
            <bitfield name="WGM0" mask="0x03" text="Waveform Generation Mode" icon="" enum="TC0_WGM_BITF"/>
          </reg>
          <reg size="1" name="TIMSK0" offset="0x6E" text="Timer/Counter0 Interrupt Mask Register" icon="io_flag.bmp">
            <bitfield name="Res" mask="0xF8" text="Reserved" icon=""/>
            <bitfield name="OCIE0B" mask="0x04" text="Timer/Counter0 Output Compare Match B Interrupt Enable" icon=""/>
            <bitfield name="OCIE0A" mask="0x02" text="Timer/Counter0 Output Compare Match A Interrupt Enable" icon=""/>
            <bitfield name="TOIE0" mask="0x01" text="Timer/Counter0 Overflow Interrupt Enable" icon=""/>
          </reg>
          <reg size="1" name="TIFR0" offset="0x35" text="Timer/Counter0 Interrupt Flag Register" icon="io_flag.bmp">
            <bitfield name="Res" mask="0xF8" text="Reserved" icon=""/>
            <bitfield name="OCF0B" mask="0x04" text="Timer/Counter0 Output Compare B Match Flag" icon=""/>
            <bitfield name="OCF0A" mask="0x02" text="Timer/Counter0 Output Compare A Match Flag" icon=""/>
            <bitfield name="TOV0" mask="0x01" text="Timer/Counter0 Overflow Flag" icon=""/>
          </reg>
          <reg size="1" name="GTCCR" offset="0x43" text="General Timer/Counter Control Register" icon="io_flag.bmp">
            <bitfield name="TSM" mask="0x80" text="Timer/Counter Synchronization Mode" icon=""/>
            <bitfield name="Res" mask="0x7C" text="Reserved" icon=""/>
            <bitfield name="PSRASY" mask="0x02" text="Prescaler Reset Timer/Counter2" icon=""/>
            <bitfield name="PSRSYNC" mask="0x01" text="Prescaler Reset for Synchronous Timer/Counters" icon=""/>
          </reg>
        </registers>
        <enumerator name="TC0_CLK_SEL_3BIT_EXT">
          <enum val="0x00" text="No clock source (Timer/Counter0 stopped)"/>
          <enum val="0x01" text="clk_IO/1 (no prescaling)"/>
          <enum val="0x02" text="clk_IO/8 (from prescaler)"/>
          <enum val="0x03" text="clk_IO/64 (from prescaler)"/>
          <enum val="0x04" text="clk_IO/256 (from prescaler)"/>
          <enum val="0x05" text="clk_IO/1024 (from prescaler)"/>
          <enum val="0x06" text="External clock source on T0 pin, clock on falling edge"/>
          <enum val="0x07" text="External clock source on T0 pin, clock on rising edge"/>
        </enumerator>
        <enumerator name="TC0_COM0A_BITF">
          <enum val="0" text="Normal port operation, OC0A disconnected"/>
          <enum val="1" text="Toggle OC0A on Compare Match"/>
          <enum val="2" text="Clear OC0A on Compare Match"/>
          <enum val="3" text="Set OC0A on Compare Match"/>
        </enumerator>
        <enumerator name="TC0_COM0B_BITF">
          <enum val="0" text="Normal port operation, OC0B disconnected"/>
          <enum val="1" text="Toggle OC0B on Compare Match"/>
          <enum val="2" text="Clear OC0B on Compare Match"/>
          <enum val="3" text="Set OC0B on Compare Match"/>
        </enumerator>
        <enumerator name="TC0_WGM_BITF">
          <enum val="0x0" text="Normal mode of operation"/>
          <enum val="0x1" text="PWM, phase correct, TOP=0xFF"/>
          <enum val="0x2" text="CTC, TOP = OCRA"/>
          <enum val="0x3" text="Fast PWM, TOP=0xFF"/>
          <enum val="0x4" text="Reserved"/>
          <enum val="0x5" text="PWM, Phase correct, TOP = OCRA"/>
          <enum val="0x6" text="Reserved"/>
          <enum val="0x7" text="Fast PWM, TOP=OCRA"/>
        </enumerator>
      </module>
      <module class="TIMER_COUNTER_2" text="">
        <registers name="TIMER_COUNTER_2" memspace="DATAMEM" text="" icon="io_timer.bmp">
          <reg size="1" name="TIMSK2" offset="0x70" text="Timer/Counter Interrupt Mask register" icon="io_flag.bmp">
            <bitfield name="Res" mask="0xF8" text="Reserved Bit" icon=""/>
            <bitfield name="OCIE2B" mask="0x04" text="Timer/Counter2 Output Compare Match B Interrupt Enable" icon=""/>
            <bitfield name="OCIE2A" mask="0x02" text="Timer/Counter2 Output Compare Match A Interrupt Enable" icon=""/>
            <bitfield name="TOIE2" mask="0x01" text="Timer/Counter2 Overflow Interrupt Enable" icon=""/>
          </reg>
          <reg size="1" name="TIFR2" offset="0x37" text="Timer/Counter Interrupt Flag Register" icon="io_flag.bmp">
            <bitfield name="Res" mask="0xF8" text="Reserved Bit" icon=""/>
            <bitfield name="OCF2B" mask="0x04" text="Output Compare Flag 2 B" icon=""/>
            <bitfield name="OCF2A" mask="0x02" text="Output Compare Flag 2 A" icon=""/>
            <bitfield name="TOV2" mask="0x01" text="Timer/Counter2 Overflow Flag" icon=""/>
          </reg>
          <reg size="1" name="TCCR2A" offset="0xB0" text="Timer/Counter2 Control Register A" icon="io_flag.bmp">
            <bitfield name="COM2A" mask="0xC0" text="Compare Match Output A Mode" icon="" enum="TC2_COM2A_BITF"/>
            <bitfield name="COM2B" mask="0x30" text="Compare Match Output B Mode" icon="" enum="TC2_COM2B_BITF"/>
            <bitfield name="Res" mask="0x0C" text="Reserved" icon=""/>
            <bitfield name="WGM2" mask="0x03" text="Waveform Generation Mode" icon="" enum="TC0_WGM_BITF"/>
          </reg>
          <reg size="1" name="TCCR2B" offset="0xB1" text="Timer/Counter2 Control Register B" icon="io_flag.bmp">
            <bitfield name="FOC2A" mask="0x80" text="Force Output Compare A" icon=""/>
            <bitfield name="FOC2B" mask="0x40" text="Force Output Compare B" icon=""/>
            <bitfield name="Res" mask="0x30" text="Reserved" icon=""/>
            <bitfield name="WGM22" mask="0x08" text="Waveform Generation Mode" icon=""/>
            <bitfield name="CS2" mask="0x07" text="Clock Select" icon="" enum="TC2_CLK_SEL_3BIT"/>
          </reg>
          <reg size="1" name="TCNT2" offset="0xB2" text="Timer/Counter2" icon="io_timer.bmp" mask="0xFF"/>
          <reg size="1" name="OCR2B" offset="0xB4" text="Timer/Counter2 Output Compare Register B" icon="io_timer.bmp" mask="0xFF"/>
          <reg size="1" name="OCR2A" offset="0xB3" text="Timer/Counter2 Output Compare Register A" icon="io_timer.bmp" mask="0xFF"/>
          <reg size="1" name="ASSR" offset="0xB6" text="Asynchronous Status Register" icon="io_flag.bmp">
            <bitfield name="EXCLKAMR" mask="0x80" text="Enable External Clock Input for AMR" icon=""/>
            <bitfield name="EXCLK" mask="0x40" text="Enable External Clock Input" icon=""/>
            <bitfield name="AS2" mask="0x20" text="Timer/Counter2 Asynchronous Mode" icon=""/>
            <bitfield name="TCN2UB" mask="0x10" text="Timer/Counter2 Update Busy" icon=""/>
            <bitfield name="OCR2AUB" mask="0x08" text="Timer/Counter2 Output Compare Register A Update Busy" icon=""/>
            <bitfield name="OCR2BUB" mask="0x04" text="Timer/Counter2 Output Compare Register B Update Busy" icon=""/>
            <bitfield name="TCR2AUB" mask="0x02" text="Timer/Counter2 Control Register A Update Busy" icon=""/>
            <bitfield name="TCR2BUB" mask="0x01" text="Timer/Counter2 Control Register B Update Busy" icon=""/>
          </reg>
          <reg size="1" name="GTCCR" offset="0x43" text="General Timer Counter Control register" icon="io_flag.bmp">
            <bitfield name="TSM" mask="0x80" text="Timer/Counter Synchronization Mode" icon=""/>
            <bitfield name="PSRASY" mask="0x02" text="Prescaler Reset Timer/Counter2" icon=""/>
          </reg>
        </registers>
        <enumerator name="TC2_COM2A_BITF">
          <enum val="0" text="Normal port operation, OC2A disconnected"/>
          <enum val="1" text="Toggle OC2A on Compare Match"/>
          <enum val="2" text="Clear OC2A on Compare Match"/>
          <enum val="3" text="Set OC2A on Compare Match"/>
        </enumerator>
        <enumerator name="TC2_COM2B_BITF">
          <enum val="0" text="Normal port operation, OC2B disconnected"/>
          <enum val="1" text="Toggle OC2B on Compare Match"/>
          <enum val="2" text="Clear OC2B on Compare Match"/>
          <enum val="3" text="Set OC2B on Compare Match"/>
        </enumerator>
        <enumerator name="TC0_WGM_BITF">
          <enum val="0x0" text="Normal mode of operation"/>
          <enum val="0x1" text="PWM, phase correct, TOP=0xFF"/>
          <enum val="0x2" text="CTC, TOP = OCRA"/>
          <enum val="0x3" text="Fast PWM, TOP=0xFF"/>
          <enum val="0x4" text="Reserved"/>
          <enum val="0x5" text="PWM, Phase correct, TOP = OCRA"/>
          <enum val="0x6" text="Reserved"/>
          <enum val="0x7" text="Fast PWM, TOP=OCRA"/>
        </enumerator>
        <enumerator name="TC2_CLK_SEL_3BIT">
          <enum val="0x00" text="No clock source (Timer/Counter2 stopped)"/>
          <enum val="0x01" text="clk_T2S/1 (no prescaling)"/>
          <enum val="0x02" text="clk_T2S/8 (from prescaler)"/>
          <enum val="0x03" text="clk_T2S/32 (from prescaler)"/>
          <enum val="0x04" text="clk_T2S/64 (from prescaler)"/>
          <enum val="0x05" text="clk_T2S/128 (from prescaler)"/>
          <enum val="0x06" text="clk_T2S/256 (from prescaler)"/>
          <enum val="0x07" text="clk_T2S/1024 (from prescaler)"/>
        </enumerator>
      </module>
      <module class="WATCHDOG" text="">
        <registers name="WATCHDOG" memspace="DATAMEM" text="" icon="io_watch.bmp">
          <reg size="1" name="WDTCSR" offset="0x60" text="Watchdog Timer Control Register" icon="io_flag.bmp">
            <bitfield name="WDIF" mask="0x80" text="Watchdog Timeout Interrupt Flag" icon=""/>
            <bitfield name="WDIE" mask="0x40" text="Watchdog Timeout Interrupt Enable" icon=""/>
            <bitfield name="WDP" mask="0x27" text="Watchdog Timer Prescaler Bits" icon="" enum="WDOG_TIMER_PRESCALE_4BITS"/>
            <bitfield name="WDCE" mask="0x10" text="Watchdog Change Enable" icon=""/>
            <bitfield name="WDE" mask="0x08" text="Watch Dog Enable" icon=""/>
          </reg>
        </registers>
        <enumerator name="WDOG_TIMER_PRESCALE_4BITS">
          <enum val="0x00" text="Oscillator Cycles 2K"/>
          <enum val="0x01" text="Oscillator Cycles 4K"/>
          <enum val="0x02" text="Oscillator Cycles 8K"/>
          <enum val="0x03" text="Oscillator Cycles 16K"/>
          <enum val="0x04" text="Oscillator Cycles 32K"/>
          <enum val="0x05" text="Oscillator Cycles 64K"/>
          <enum val="0x06" text="Oscillator Cycles 128K"/>
          <enum val="0x07" text="Oscillator Cycles 256K"/>
          <enum val="0x08" text="Oscillator Cycles 512K"/>
          <enum val="0x09" text="Oscillator Cycles 1024K"/>
        </enumerator>
      </module>
      <module class="TIMER_COUNTER_5" text="">
        <registers name="TIMER_COUNTER_5" memspace="DATAMEM" text="" icon="io_timer.bmp">
          <reg size="1" name="TCCR5A" offset="0x120" text="Timer/Counter5 Control Register A" icon="io_flag.bmp">
            <bitfield name="COM5A" mask="0xC0" text="Compare Output Mode for Channel A" icon="" enum="TC4_COMNX_BITF"/>
            <bitfield name="COM5B" mask="0x30" text="Compare Output Mode for Channel B" icon="" enum="TC4_COMNX_BITF"/>
            <bitfield name="COM5C" mask="0x0C" text="Compare Output Mode for Channel C" icon="" enum="TC4_COMNX_BITF"/>
            <bitfield name="WGM5" mask="0x03" text="Waveform Generation Mode" icon="" enum="TC1_WGMX_BITF"/>
          </reg>
          <reg size="1" name="TCCR5B" offset="0x121" text="Timer/Counter5 Control Register B" icon="io_flag.bmp">
            <bitfield name="ICNC5" mask="0x80" text="Input Capture 5 Noise Canceller" icon=""/>
            <bitfield name="ICES5" mask="0x40" text="Input Capture 5 Edge Select" icon=""/>
            <bitfield name="Res" mask="0x20" text="Reserved Bit" icon=""/>
            <bitfield name="WGM5" mask="0x18" text="Waveform Generation Mode" icon="" enum="TC1_WGMX_BITF" lsb="2"/>
            <bitfield name="CS5" mask="0x07" text="Clock Select" icon="" enum="CLK_SEL_3BIT_NOEXT_MEGARF"/>
          </reg>
          <reg size="1" name="TCCR5C" offset="0x122" text="Timer/Counter5 Control Register C" icon="io_flag.bmp">
            <bitfield name="FOC5A" mask="0x80" text="Force Output Compare for Channel A" icon=""/>
            <bitfield name="FOC5B" mask="0x40" text="Force Output Compare for Channel B" icon=""/>
            <bitfield name="FOC5C" mask="0x20" text="Force Output Compare for Channel C" icon=""/>
            <bitfield name="Res" mask="0x1F" text="Reserved" icon=""/>
          </reg>
          <reg size="2" name="TCNT5" offset="0x124" text="Timer/Counter5  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="2" name="OCR5A" offset="0x128" text="Timer/Counter5 Output Compare Register A  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="2" name="OCR5B" offset="0x12A" text="Timer/Counter5 Output Compare Register B  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="2" name="OCR5C" offset="0x12C" text="Timer/Counter5 Output Compare Register C  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="2" name="ICR5" offset="0x126" text="Timer/Counter5 Input Capture Register  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="1" name="TIMSK5" offset="0x73" text="Timer/Counter5 Interrupt Mask Register" icon="io_flag.bmp">
            <bitfield name="Res" mask="0xC0" text="Reserved Bit" icon=""/>
            <bitfield name="ICIE5" mask="0x20" text="Timer/Counter5 Input Capture Interrupt Enable" icon=""/>
            <bitfield name="Res" mask="0x10" text="Reserved Bit" icon=""/>
            <bitfield name="OCIE5C" mask="0x08" text="Timer/Counter5 Output Compare C Match Interrupt Enable" icon=""/>
            <bitfield name="OCIE5B" mask="0x04" text="Timer/Counter5 Output Compare B Match Interrupt Enable" icon=""/>
            <bitfield name="OCIE5A" mask="0x02" text="Timer/Counter5 Output Compare A Match Interrupt Enable" icon=""/>
            <bitfield name="TOIE5" mask="0x01" text="Timer/Counter5 Overflow Interrupt Enable" icon=""/>
          </reg>
          <reg size="1" name="TIFR5" offset="0x3A" text="Timer/Counter5 Interrupt Flag Register" icon="io_flag.bmp">
            <bitfield name="Res" mask="0xC0" text="Reserved Bit" icon=""/>
            <bitfield name="ICF5" mask="0x20" text="Timer/Counter5 Input Capture Flag" icon=""/>
            <bitfield name="Res" mask="0x10" text="Reserved Bit" icon=""/>
            <bitfield name="OCF5C" mask="0x08" text="Timer/Counter5 Output Compare C Match Flag" icon=""/>
            <bitfield name="OCF5B" mask="0x04" text="Timer/Counter5 Output Compare B Match Flag" icon=""/>
            <bitfield name="OCF5A" mask="0x02" text="Timer/Counter5 Output Compare A Match Flag" icon=""/>
            <bitfield name="TOV5" mask="0x01" text="Timer/Counter5 Overflow Flag" icon=""/>
          </reg>
        </registers>
        <enumerator name="TC4_COMNX_BITF">
          <enum val="0" text="Normal operation"/>
          <enum val="1" text="Reserved"/>
          <enum val="2" text="Reserved"/>
          <enum val="3" text="Reserved"/>
        </enumerator>
        <enumerator name="TC1_WGMX_BITF">
          <enum val="0x0" text="Normal mode of operation"/>
          <enum val="0x1" text="PWM, phase correct, 8-bit"/>
          <enum val="0x2" text="PWM, phase correct, 9-bit"/>
          <enum val="0x3" text="PWM, phase correct, 10-bit"/>
          <enum val="0x4" text="CTC, TOP = OCRnA"/>
          <enum val="0x5" text="Fast PWM, 8-bit"/>
          <enum val="0x6" text="Fast PWM, 9-bit"/>
          <enum val="0x7" text="Fast PWM, 10-bit"/>
          <enum val="0x8" text="PWM, Phase and frequency correct, TOP = ICRn"/>
          <enum val="0x9" text="PWM, Phase and frequency correct, TOP = OCRnA"/>
          <enum val="0xA" text="PWM, Phase correct, TOP = ICRn"/>
          <enum val="0xB" text="PWM, Phase correct, TOP = OCRnA"/>
          <enum val="0xC" text="CTC, TOP = OCRnA"/>
          <enum val="0xD" text="Reserved"/>
          <enum val="0xE" text="Fast PWM, TOP = ICRn"/>
          <enum val="0xF" text="Fast PWM, TOP = OCRnA"/>
        </enumerator>
        <enumerator name="CLK_SEL_3BIT_NOEXT_MEGARF">
          <enum val="0x00" text="No clock source (Timer/Counter stopped)"/>
          <enum val="0x01" text="clk_IO/1 (no prescaling)"/>
          <enum val="0x02" text="clk_IO/8 (from prescaler)"/>
          <enum val="0x03" text="clk_IO/64 (from prescaler)"/>
          <enum val="0x04" text="clk_IO/256 (from prescaler)"/>
          <enum val="0x05" text="clk_IO/1024 (from prescaler)"/>
          <enum val="0x06" text="Reserved"/>
          <enum val="0x07" text="Reserved"/>
        </enumerator>
      </module>
      <module class="TIMER_COUNTER_4" text="">
        <registers name="TIMER_COUNTER_4" memspace="DATAMEM" text="" icon="io_timer.bmp">
          <reg size="1" name="TCCR4A" offset="0xA0" text="Timer/Counter4 Control Register A" icon="io_flag.bmp">
            <bitfield name="COM4A" mask="0xC0" text="Compare Output Mode for Channel A" icon="" enum="TC4_COMNX_BITF"/>
            <bitfield name="COM4B" mask="0x30" text="Compare Output Mode for Channel B" icon="" enum="TC4_COMNX_BITF"/>
            <bitfield name="COM4C" mask="0x0C" text="Compare Output Mode for Channel C" icon="" enum="TC4_COMNX_BITF"/>
            <bitfield name="WGM4" mask="0x03" text="Waveform Generation Mode" icon="" enum="TC1_WGMX_BITF"/>
          </reg>
          <reg size="1" name="TCCR4B" offset="0xA1" text="Timer/Counter4 Control Register B" icon="io_flag.bmp">
            <bitfield name="ICNC4" mask="0x80" text="Input Capture 4 Noise Canceller" icon=""/>
            <bitfield name="ICES4" mask="0x40" text="Input Capture 4 Edge Select" icon=""/>
            <bitfield name="Res" mask="0x20" text="Reserved Bit" icon=""/>
            <bitfield name="WGM4" mask="0x18" text="Waveform Generation Mode" icon="" enum="TC1_WGMX_BITF" lsb="2"/>
            <bitfield name="CS4" mask="0x07" text="Clock Select" icon="" enum="CLK_SEL_3BIT_NOEXT_MEGARF"/>
          </reg>
          <reg size="1" name="TCCR4C" offset="0xA2" text="Timer/Counter4 Control Register C" icon="io_flag.bmp">
            <bitfield name="FOC4A" mask="0x80" text="Force Output Compare for Channel A" icon=""/>
            <bitfield name="FOC4B" mask="0x40" text="Force Output Compare for Channel B" icon=""/>
            <bitfield name="FOC4C" mask="0x20" text="Force Output Compare for Channel C" icon=""/>
            <bitfield name="Res" mask="0x1F" text="Reserved" icon=""/>
          </reg>
          <reg size="2" name="TCNT4" offset="0xA4" text="Timer/Counter4  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="2" name="OCR4A" offset="0xA8" text="Timer/Counter4 Output Compare Register A  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="2" name="OCR4B" offset="0xAA" text="Timer/Counter4 Output Compare Register B  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="2" name="OCR4C" offset="0xAC" text="Timer/Counter4 Output Compare Register C  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="2" name="ICR4" offset="0xA6" text="Timer/Counter4 Input Capture Register  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="1" name="TIMSK4" offset="0x72" text="Timer/Counter4 Interrupt Mask Register" icon="io_flag.bmp">
            <bitfield name="Res" mask="0xC0" text="Reserved Bit" icon=""/>
            <bitfield name="ICIE4" mask="0x20" text="Timer/Counter4 Input Capture Interrupt Enable" icon=""/>
            <bitfield name="Res" mask="0x10" text="Reserved Bit" icon=""/>
            <bitfield name="OCIE4C" mask="0x08" text="Timer/Counter4 Output Compare C Match Interrupt Enable" icon=""/>
            <bitfield name="OCIE4B" mask="0x04" text="Timer/Counter4 Output Compare B Match Interrupt Enable" icon=""/>
            <bitfield name="OCIE4A" mask="0x02" text="Timer/Counter4 Output Compare A Match Interrupt Enable" icon=""/>
            <bitfield name="TOIE4" mask="0x01" text="Timer/Counter4 Overflow Interrupt Enable" icon=""/>
          </reg>
          <reg size="1" name="TIFR4" offset="0x39" text="Timer/Counter4 Interrupt Flag Register" icon="io_flag.bmp">
            <bitfield name="Res" mask="0xC0" text="Reserved Bit" icon=""/>
            <bitfield name="ICF4" mask="0x20" text="Timer/Counter4 Input Capture Flag" icon=""/>
            <bitfield name="Res" mask="0x10" text="Reserved Bit" icon=""/>
            <bitfield name="OCF4C" mask="0x08" text="Timer/Counter4 Output Compare C Match Flag" icon=""/>
            <bitfield name="OCF4B" mask="0x04" text="Timer/Counter4 Output Compare B Match Flag" icon=""/>
            <bitfield name="OCF4A" mask="0x02" text="Timer/Counter4 Output Compare A Match Flag" icon=""/>
            <bitfield name="TOV4" mask="0x01" text="Timer/Counter4 Overflow Flag" icon=""/>
          </reg>
        </registers>
        <enumerator name="TC4_COMNX_BITF">
          <enum val="0" text="Normal operation"/>
          <enum val="1" text="Reserved"/>
          <enum val="2" text="Reserved"/>
          <enum val="3" text="Reserved"/>
        </enumerator>
        <enumerator name="TC1_WGMX_BITF">
          <enum val="0x0" text="Normal mode of operation"/>
          <enum val="0x1" text="PWM, phase correct, 8-bit"/>
          <enum val="0x2" text="PWM, phase correct, 9-bit"/>
          <enum val="0x3" text="PWM, phase correct, 10-bit"/>
          <enum val="0x4" text="CTC, TOP = OCRnA"/>
          <enum val="0x5" text="Fast PWM, 8-bit"/>
          <enum val="0x6" text="Fast PWM, 9-bit"/>
          <enum val="0x7" text="Fast PWM, 10-bit"/>
          <enum val="0x8" text="PWM, Phase and frequency correct, TOP = ICRn"/>
          <enum val="0x9" text="PWM, Phase and frequency correct, TOP = OCRnA"/>
          <enum val="0xA" text="PWM, Phase correct, TOP = ICRn"/>
          <enum val="0xB" text="PWM, Phase correct, TOP = OCRnA"/>
          <enum val="0xC" text="CTC, TOP = OCRnA"/>
          <enum val="0xD" text="Reserved"/>
          <enum val="0xE" text="Fast PWM, TOP = ICRn"/>
          <enum val="0xF" text="Fast PWM, TOP = OCRnA"/>
        </enumerator>
        <enumerator name="CLK_SEL_3BIT_NOEXT_MEGARF">
          <enum val="0x00" text="No clock source (Timer/Counter stopped)"/>
          <enum val="0x01" text="clk_IO/1 (no prescaling)"/>
          <enum val="0x02" text="clk_IO/8 (from prescaler)"/>
          <enum val="0x03" text="clk_IO/64 (from prescaler)"/>
          <enum val="0x04" text="clk_IO/256 (from prescaler)"/>
          <enum val="0x05" text="clk_IO/1024 (from prescaler)"/>
          <enum val="0x06" text="Reserved"/>
          <enum val="0x07" text="Reserved"/>
        </enumerator>
      </module>
      <module class="TIMER_COUNTER_3" text="">
        <registers name="TIMER_COUNTER_3" memspace="DATAMEM" text="" icon="io_timer.bmp">
          <reg size="1" name="TCCR3A" offset="0x90" text="Timer/Counter3 Control Register A" icon="io_flag.bmp">
            <bitfield name="COM3A" mask="0xC0" text="Compare Output Mode for Channel A" icon="" enum="TC1_COMNX_BITF"/>
            <bitfield name="COM3B" mask="0x30" text="Compare Output Mode for Channel B" icon="" enum="TC1_COMNX_BITF"/>
            <bitfield name="COM3C" mask="0x0C" text="Compare Output Mode for Channel C" icon="" enum="TC1_COMNX_BITF"/>
            <bitfield name="WGM3" mask="0x03" text="Waveform Generation Mode" icon="" enum="TC1_WGMX_BITF"/>
          </reg>
          <reg size="1" name="TCCR3B" offset="0x91" text="Timer/Counter3 Control Register B" icon="io_flag.bmp">
            <bitfield name="ICNC3" mask="0x80" text="Input Capture 3 Noise Canceller" icon=""/>
            <bitfield name="ICES3" mask="0x40" text="Input Capture 3 Edge Select" icon=""/>
            <bitfield name="Res" mask="0x20" text="Reserved Bit" icon=""/>
            <bitfield name="WGM3" mask="0x18" text="Waveform Generation Mode" icon="" enum="TC1_WGMX_BITF" lsb="2"/>
            <bitfield name="CS3" mask="0x07" text="Clock Select" icon="" enum="CLK_SEL_3BIT_EXT_MEGARF"/>
          </reg>
          <reg size="1" name="TCCR3C" offset="0x92" text="Timer/Counter3 Control Register C" icon="io_flag.bmp">
            <bitfield name="FOC3A" mask="0x80" text="Force Output Compare for Channel A" icon=""/>
            <bitfield name="FOC3B" mask="0x40" text="Force Output Compare for Channel B" icon=""/>
            <bitfield name="FOC3C" mask="0x20" text="Force Output Compare for Channel C" icon=""/>
            <bitfield name="Res" mask="0x1F" text="Reserved" icon=""/>
          </reg>
          <reg size="2" name="TCNT3" offset="0x94" text="Timer/Counter3  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="2" name="OCR3A" offset="0x98" text="Timer/Counter3 Output Compare Register A  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="2" name="OCR3B" offset="0x9A" text="Timer/Counter3 Output Compare Register B  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="2" name="OCR3C" offset="0x9C" text="Timer/Counter3 Output Compare Register C  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="2" name="ICR3" offset="0x96" text="Timer/Counter3 Input Capture Register  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="1" name="TIMSK3" offset="0x71" text="Timer/Counter3 Interrupt Mask Register" icon="io_flag.bmp">
            <bitfield name="Res" mask="0xC0" text="Reserved Bit" icon=""/>
            <bitfield name="ICIE3" mask="0x20" text="Timer/Counter3 Input Capture Interrupt Enable" icon=""/>
            <bitfield name="Res" mask="0x10" text="Reserved Bit" icon=""/>
            <bitfield name="OCIE3C" mask="0x08" text="Timer/Counter3 Output Compare C Match Interrupt Enable" icon=""/>
            <bitfield name="OCIE3B" mask="0x04" text="Timer/Counter3 Output Compare B Match Interrupt Enable" icon=""/>
            <bitfield name="OCIE3A" mask="0x02" text="Timer/Counter3 Output Compare A Match Interrupt Enable" icon=""/>
            <bitfield name="TOIE3" mask="0x01" text="Timer/Counter3 Overflow Interrupt Enable" icon=""/>
          </reg>
          <reg size="1" name="TIFR3" offset="0x38" text="Timer/Counter3 Interrupt Flag Register" icon="io_flag.bmp">
            <bitfield name="Res" mask="0xC0" text="Reserved Bit" icon=""/>
            <bitfield name="ICF3" mask="0x20" text="Timer/Counter3 Input Capture Flag" icon=""/>
            <bitfield name="Res" mask="0x10" text="Reserved Bit" icon=""/>
            <bitfield name="OCF3C" mask="0x08" text="Timer/Counter3 Output Compare C Match Flag" icon=""/>
            <bitfield name="OCF3B" mask="0x04" text="Timer/Counter3 Output Compare B Match Flag" icon=""/>
            <bitfield name="OCF3A" mask="0x02" text="Timer/Counter3 Output Compare A Match Flag" icon=""/>
            <bitfield name="TOV3" mask="0x01" text="Timer/Counter3 Overflow Flag" icon=""/>
          </reg>
        </registers>
        <enumerator name="TC1_COMNX_BITF">
          <enum val="0" text="Normal port operation, OCnA/OCnB/OCnC disconnected."/>
          <enum val="1" text="Toggle OCnA/OCnB/OCnC on Compare Match."/>
          <enum val="2" text="Clear OCnA/OCnB/OCnC on Compare Match (set output to low level)."/>
          <enum val="3" text="Set OCnA/OCnB/OCnC on Compare Match (set output to high level)."/>
        </enumerator>
        <enumerator name="TC1_WGMX_BITF">
          <enum val="0x0" text="Normal mode of operation"/>
          <enum val="0x1" text="PWM, phase correct, 8-bit"/>
          <enum val="0x2" text="PWM, phase correct, 9-bit"/>
          <enum val="0x3" text="PWM, phase correct, 10-bit"/>
          <enum val="0x4" text="CTC, TOP = OCRnA"/>
          <enum val="0x5" text="Fast PWM, 8-bit"/>
          <enum val="0x6" text="Fast PWM, 9-bit"/>
          <enum val="0x7" text="Fast PWM, 10-bit"/>
          <enum val="0x8" text="PWM, Phase and frequency correct, TOP = ICRn"/>
          <enum val="0x9" text="PWM, Phase and frequency correct, TOP = OCRnA"/>
          <enum val="0xA" text="PWM, Phase correct, TOP = ICRn"/>
          <enum val="0xB" text="PWM, Phase correct, TOP = OCRnA"/>
          <enum val="0xC" text="CTC, TOP = OCRnA"/>
          <enum val="0xD" text="Reserved"/>
          <enum val="0xE" text="Fast PWM, TOP = ICRn"/>
          <enum val="0xF" text="Fast PWM, TOP = OCRnA"/>
        </enumerator>
        <enumerator name="CLK_SEL_3BIT_EXT_MEGARF">
          <enum val="0x00" text="No clock source (Timer/Counter stopped)"/>
          <enum val="0x01" text="clk_IO/1 (no prescaling)"/>
          <enum val="0x02" text="clk_IO/8 (from prescaler)"/>
          <enum val="0x03" text="clk_IO/64 (from prescaler)"/>
          <enum val="0x04" text="clk_IO/256 (from prescaler)"/>
          <enum val="0x05" text="clk_IO/1024 (from prescaler)"/>
          <enum val="0x06" text="External clock source on Tn pin, clock on falling edge"/>
          <enum val="0x07" text="External clock source on Tn pin, clock on rising edge"/>
        </enumerator>
      </module>
      <module class="TIMER_COUNTER_1" text="">
        <registers name="TIMER_COUNTER_1" memspace="DATAMEM" text="" icon="io_timer.bmp">
          <reg size="1" name="TCCR1A" offset="0x80" text="Timer/Counter1 Control Register A" icon="io_flag.bmp">
            <bitfield name="COM1A" mask="0xC0" text="Compare Output Mode for Channel A" icon="" enum="TC1_COMNX_BITF"/>
            <bitfield name="COM1B" mask="0x30" text="Compare Output Mode for Channel B" icon="" enum="TC1_COMNX_BITF"/>
            <bitfield name="COM1C" mask="0x0C" text="Compare Output Mode for Channel C" icon="" enum="TC1_COMNX_BITF"/>
            <bitfield name="WGM1" mask="0x03" text="Waveform Generation Mode" icon="" enum="TC1_WGMX_BITF"/>
          </reg>
          <reg size="1" name="TCCR1B" offset="0x81" text="Timer/Counter1 Control Register B" icon="io_flag.bmp">
            <bitfield name="ICNC1" mask="0x80" text="Input Capture 1 Noise Canceller" icon=""/>
            <bitfield name="ICES1" mask="0x40" text="Input Capture 1 Edge Select" icon=""/>
            <bitfield name="Res" mask="0x20" text="Reserved Bit" icon=""/>
            <bitfield name="WGM1" mask="0x18" text="Waveform Generation Mode" icon="" enum="TC1_WGMX_BITF" lsb="2"/>
            <bitfield name="CS1" mask="0x07" text="Clock Select" icon="" enum="CLK_SEL_3BIT_EXT_MEGARF"/>
          </reg>
          <reg size="1" name="TCCR1C" offset="0x82" text="Timer/Counter1 Control Register C" icon="io_flag.bmp">
            <bitfield name="FOC1A" mask="0x80" text="Force Output Compare for Channel A" icon=""/>
            <bitfield name="FOC1B" mask="0x40" text="Force Output Compare for Channel B" icon=""/>
            <bitfield name="FOC1C" mask="0x20" text="Force Output Compare for Channel C" icon=""/>
            <bitfield name="Res" mask="0x1F" text="Reserved" icon=""/>
          </reg>
          <reg size="2" name="TCNT1" offset="0x84" text="Timer/Counter1  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="2" name="OCR1A" offset="0x88" text="Timer/Counter1 Output Compare Register A  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="2" name="OCR1B" offset="0x8A" text="Timer/Counter1 Output Compare Register B  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="2" name="OCR1C" offset="0x8C" text="Timer/Counter1 Output Compare Register C  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="2" name="ICR1" offset="0x86" text="Timer/Counter1 Input Capture Register  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="1" name="TIMSK1" offset="0x6F" text="Timer/Counter1 Interrupt Mask Register" icon="io_flag.bmp">
            <bitfield name="Res" mask="0xC0" text="Reserved Bit" icon=""/>
            <bitfield name="ICIE1" mask="0x20" text="Timer/Counter1 Input Capture Interrupt Enable" icon=""/>
            <bitfield name="Res" mask="0x10" text="Reserved Bit" icon=""/>
            <bitfield name="OCIE1C" mask="0x08" text="Timer/Counter1 Output Compare C Match Interrupt Enable" icon=""/>
            <bitfield name="OCIE1B" mask="0x04" text="Timer/Counter1 Output Compare B Match Interrupt Enable" icon=""/>
            <bitfield name="OCIE1A" mask="0x02" text="Timer/Counter1 Output Compare A Match Interrupt Enable" icon=""/>
            <bitfield name="TOIE1" mask="0x01" text="Timer/Counter1 Overflow Interrupt Enable" icon=""/>
          </reg>
          <reg size="1" name="TIFR1" offset="0x36" text="Timer/Counter1 Interrupt Flag Register" icon="io_flag.bmp">
            <bitfield name="Res" mask="0xC0" text="Reserved Bit" icon=""/>
            <bitfield name="ICF1" mask="0x20" text="Timer/Counter1 Input Capture Flag" icon=""/>
            <bitfield name="Res" mask="0x10" text="Reserved Bit" icon=""/>
            <bitfield name="OCF1C" mask="0x08" text="Timer/Counter1 Output Compare C Match Flag" icon=""/>
            <bitfield name="OCF1B" mask="0x04" text="Timer/Counter1 Output Compare B Match Flag" icon=""/>
            <bitfield name="OCF1A" mask="0x02" text="Timer/Counter1 Output Compare A Match Flag" icon=""/>
            <bitfield name="TOV1" mask="0x01" text="Timer/Counter1 Overflow Flag" icon=""/>
          </reg>
        </registers>
        <enumerator name="TC1_COMNX_BITF">
          <enum val="0" text="Normal port operation, OCnA/OCnB/OCnC disconnected."/>
          <enum val="1" text="Toggle OCnA/OCnB/OCnC on Compare Match."/>
          <enum val="2" text="Clear OCnA/OCnB/OCnC on Compare Match (set output to low level)."/>
          <enum val="3" text="Set OCnA/OCnB/OCnC on Compare Match (set output to high level)."/>
        </enumerator>
        <enumerator name="TC1_WGMX_BITF">
          <enum val="0x0" text="Normal mode of operation"/>
          <enum val="0x1" text="PWM, phase correct, 8-bit"/>
          <enum val="0x2" text="PWM, phase correct, 9-bit"/>
          <enum val="0x3" text="PWM, phase correct, 10-bit"/>
          <enum val="0x4" text="CTC, TOP = OCRnA"/>
          <enum val="0x5" text="Fast PWM, 8-bit"/>
          <enum val="0x6" text="Fast PWM, 9-bit"/>
          <enum val="0x7" text="Fast PWM, 10-bit"/>
          <enum val="0x8" text="PWM, Phase and frequency correct, TOP = ICRn"/>
          <enum val="0x9" text="PWM, Phase and frequency correct, TOP = OCRnA"/>
          <enum val="0xA" text="PWM, Phase correct, TOP = ICRn"/>
          <enum val="0xB" text="PWM, Phase correct, TOP = OCRnA"/>
          <enum val="0xC" text="CTC, TOP = OCRnA"/>
          <enum val="0xD" text="Reserved"/>
          <enum val="0xE" text="Fast PWM, TOP = ICRn"/>
          <enum val="0xF" text="Fast PWM, TOP = OCRnA"/>
        </enumerator>
        <enumerator name="CLK_SEL_3BIT_EXT_MEGARF">
          <enum val="0x00" text="No clock source (Timer/Counter stopped)"/>
          <enum val="0x01" text="clk_IO/1 (no prescaling)"/>
          <enum val="0x02" text="clk_IO/8 (from prescaler)"/>
          <enum val="0x03" text="clk_IO/64 (from prescaler)"/>
          <enum val="0x04" text="clk_IO/256 (from prescaler)"/>
          <enum val="0x05" text="clk_IO/1024 (from prescaler)"/>
          <enum val="0x06" text="External clock source on Tn pin, clock on falling edge"/>
          <enum val="0x07" text="External clock source on Tn pin, clock on rising edge"/>
        </enumerator>
      </module>
      <module class="TRX24" text="">
        <registers name="TRX24" memspace="DATAMEM" text="" icon="io_trx24.bmp">
          <reg size="1" name="AES_CTRL" offset="0x13C" text="AES Control Register" icon="io_flag.bmp">
            <bitfield name="AES_REQUEST" mask="0x80" text="Request AES Operation." icon=""/>
            <bitfield name="Res" mask="0x40" text="Reserved Bit" icon=""/>
            <bitfield name="AES_MODE" mask="0x20" text="Set AES Operation Mode" icon="" enum="AES_MODE_BITF"/>
            <bitfield name="Res" mask="0x10" text="Reserved Bit" icon=""/>
            <bitfield name="AES_DIR" mask="0x08" text="Set AES Operation Direction" icon="" enum="AES_DIRECTION_BITF"/>
            <bitfield name="AES_IM" mask="0x04" text="AES Interrupt Enable" icon=""/>
            <bitfield name="Res" mask="0x03" text="Reserved Bit" icon=""/>
          </reg>
          <reg size="1" name="AES_STATUS" offset="0x13D" text="AES Status Register" icon="io_flag.bmp">
            <bitfield name="AES_ER" mask="0x80" text="AES Operation Finished with Error" icon=""/>
            <bitfield name="Res" mask="0x7E" text="Reserved" icon=""/>
            <bitfield name="AES_DONE" mask="0x01" text="AES Operation Finished with Success" icon=""/>
          </reg>
          <reg size="1" name="AES_STATE" offset="0x13E" text="AES Plain and Cipher Text Buffer Register" icon="io_flag.bmp">
            <bitfield name="AES_STATE" mask="0xFF" text="AES Plain and Cipher Text Buffer" icon=""/>
          </reg>
          <reg size="1" name="AES_KEY" offset="0x13F" text="AES Encryption and Decryption Key Buffer Register" icon="io_flag.bmp">
            <bitfield name="AES_KEY" mask="0xFF" text="AES Encryption/Decryption Key Buffer" icon=""/>
          </reg>
          <reg size="1" name="TRX_STATUS" offset="0x141" text="Transceiver Status Register" icon="io_flag.bmp">
            <bitfield name="CCA_DONE" mask="0x80" text="CCA Algorithm Status" icon="" enum="CCA_DONE_bitf"/>
            <bitfield name="CCA_STATUS" mask="0x40" text="CCA Status Result" icon="" enum="CCA_STATUS_bitf"/>
            <bitfield name="TST_STATUS" mask="0x20" text="Test mode status" icon="" enum="TST_STATUS_bitf"/>
            <bitfield name="TRX_STATUS" mask="0x1F" text="Transceiver Main Status" icon="" enum="TRX_STATUS_bitf"/>
          </reg>
          <reg size="1" name="TRX_STATE" offset="0x142" text="Transceiver State Control Register" icon="io_flag.bmp">
            <bitfield name="TRAC_STATUS" mask="0xE0" text="Transaction Status" icon="" enum="TRAC_STATUS_bitf"/>
            <bitfield name="TRX_CMD" mask="0x1F" text="State Control Command" icon="" enum="TRX_CMD_bitf"/>
          </reg>
          <reg size="1" name="TRX_CTRL_0" offset="0x143" text="Reserved" icon="io_flag.bmp">
            <bitfield name="Res" mask="0xFF" text="Reserved" icon=""/>
          </reg>
          <reg size="1" name="TRX_CTRL_1" offset="0x144" text="Transceiver Control Register 1" icon="io_flag.bmp">
            <bitfield name="PA_EXT_EN" mask="0x80" text="External PA support enable" icon=""/>
            <bitfield name="IRQ_2_EXT_EN" mask="0x40" text="Connect Frame Start IRQ to TC1" icon=""/>
            <bitfield name="TX_AUTO_CRC_ON" mask="0x20" text="Enable Automatic CRC Calculation" icon=""/>
            <bitfield name="Res" mask="0x1F" text="Reserved" icon=""/>
          </reg>
          <reg size="1" name="PHY_TX_PWR" offset="0x145" text="Transceiver Transmit Power Control Register" icon="io_flag.bmp">
            <bitfield name="PA_BUF_LT" mask="0xC0" text="Power Amplifier Buffer Lead Time" icon="" enum="PA_BUF_LT_bitf"/>
            <bitfield name="PA_LT" mask="0x30" text="Power Amplifier Lead Time" icon="" enum="PA_LT_bitf"/>
            <bitfield name="TX_PWR" mask="0x0F" text="Transmit Power Setting" icon="" enum="TX_PWR_bitf"/>
          </reg>
          <reg size="1" name="PHY_RSSI" offset="0x146" text="Receiver Signal Strength Indicator Register" icon="io_flag.bmp">
            <bitfield name="RX_CRC_VALID" mask="0x80" text="Received Frame CRC Status" icon="" enum="RX_CRC_VALID_bitf"/>
            <bitfield name="RND_VALUE" mask="0x60" text="Random Value" icon=""/>
            <bitfield name="RSSI" mask="0x1F" text="Receiver Signal Strength Indicator" icon="" enum="RSSI_VALUE_BITF"/>
          </reg>
          <reg size="1" name="PHY_ED_LEVEL" offset="0x147" text="Transceiver Energy Detection Level Register" icon="io_flag.bmp">
            <bitfield name="ED_LEVEL" mask="0xFF" text="Energy Detection Level" icon="" enum="ED_LEVEL_BITF"/>
          </reg>
          <reg size="1" name="PHY_CC_CCA" offset="0x148" text="Transceiver Clear Channel Assessment (CCA) Control Register" icon="io_flag.bmp">
            <bitfield name="CCA_REQUEST" mask="0x80" text="Manual CCA Measurement Request" icon=""/>
            <bitfield name="CCA_MODE" mask="0x60" text="Select CCA Measurement Mode" icon="" enum="CCA_MODE_bitf"/>
            <bitfield name="CHANNEL" mask="0x1F" text="RX/TX Channel Selection" icon="" enum="CHANNEL_bitf"/>
          </reg>
          <reg size="1" name="CCA_THRES" offset="0x149" text="Transceiver CCA Threshold Setting Register" icon="io_flag.bmp">
            <bitfield name="CCA_CS_THRES" mask="0xF0" text="CS Threshold Level for CCA Measurement" icon=""/>
            <bitfield name="CCA_ED_THRES" mask="0x0F" text="ED Threshold Level for CCA Measurement" icon=""/>
          </reg>
          <reg size="1" name="RX_CTRL" offset="0x14A" text="Transceiver Receive Control Register" icon="io_flag.bmp">
            <bitfield name="PDT_THRES" mask="0x0F" text="Receiver Sensitivity Control" icon="" enum="PDT_THRES_bitf"/>
          </reg>
          <reg size="1" name="SFD_VALUE" offset="0x14B" text="Start of Frame Delimiter Value Register" icon="io_flag.bmp">
            <bitfield name="SFD_VALUE" mask="0xFF" text="Start of Frame Delimiter Value" icon="" enum="SFD_VALUE_BITF"/>
          </reg>
          <reg size="1" name="TRX_CTRL_2" offset="0x14C" text="Transceiver Control Register 2" icon="io_flag.bmp">
            <bitfield name="RX_SAFE_MODE" mask="0x80" text="RX Safe Mode" icon=""/>
            <bitfield name="Res" mask="0x7C" text="Reserved" icon=""/>
            <bitfield name="OQPSK_DATA_RATE" mask="0x03" text="Data Rate Selection" icon="" enum="OQPSK_DATA_RATE_bitf"/>
          </reg>
          <reg size="1" name="ANT_DIV" offset="0x14D" text="Antenna Diversity Control Register" icon="io_flag.bmp">
            <bitfield name="ANT_SEL" mask="0x80" text="Antenna Diversity Antenna Status" icon="" enum="ANT_SEL_bitf"/>
            <bitfield name="Res" mask="0x70" text="Reserved" icon=""/>
            <bitfield name="ANT_DIV_EN" mask="0x08" text="Enable Antenna Diversity" icon="" enum="ANT_DIV_EN_bitf"/>
            <bitfield name="ANT_EXT_SW_EN" mask="0x04" text="Enable External Antenna Switch Control" icon="" enum="ANT_EXT_SW_EN_bitf"/>
            <bitfield name="ANT_CTRL" mask="0x03" text="Static Antenna Diversity Switch Control" icon="" enum="ANT_CTRL_bitf"/>
          </reg>
          <reg size="1" name="IRQ_MASK" offset="0x14E" text="Transceiver Interrupt Enable Register" icon="io_flag.bmp">
            <bitfield name="AWAKE_EN" mask="0x80" text="Awake Interrupt Enable" icon=""/>
            <bitfield name="TX_END_EN" mask="0x40" text="TX_END Interrupt Enable" icon=""/>
            <bitfield name="AMI_EN" mask="0x20" text="Address Match Interrupt Enable" icon=""/>
            <bitfield name="CCA_ED_DONE_EN" mask="0x10" text="End of ED Measurement Interrupt Enable" icon=""/>
            <bitfield name="RX_END_EN" mask="0x08" text="RX_END Interrupt Enable" icon=""/>
            <bitfield name="RX_START_EN" mask="0x04" text="RX_START Interrupt Enable" icon=""/>
            <bitfield name="PLL_UNLOCK_EN" mask="0x02" text="PLL Unlock Interrupt Enable" icon=""/>
            <bitfield name="PLL_LOCK_EN" mask="0x01" text="PLL Lock Interrupt Enable" icon=""/>
          </reg>
          <reg size="1" name="IRQ_STATUS" offset="0x14F" text="Transceiver Interrupt Status Register" icon="io_flag.bmp">
            <bitfield name="AWAKE" mask="0x80" text="Awake Interrupt Status" icon=""/>
            <bitfield name="TX_END" mask="0x40" text="TX_END Interrupt Status" icon=""/>
            <bitfield name="AMI" mask="0x20" text="Address Match Interrupt Status" icon=""/>
            <bitfield name="CCA_ED_DONE" mask="0x10" text="End of ED Measurement Interrupt Status" icon=""/>
            <bitfield name="RX_END" mask="0x08" text="RX_END Interrupt Status" icon=""/>
            <bitfield name="RX_START" mask="0x04" text="RX_START Interrupt Status" icon=""/>
            <bitfield name="PLL_UNLOCK" mask="0x02" text="PLL Unlock Interrupt Status" icon=""/>
            <bitfield name="PLL_LOCK" mask="0x01" text="PLL Lock Interrupt Status" icon=""/>
          </reg>
          <reg size="1" name="VREG_CTRL" offset="0x150" text="Voltage Regulator Control and Status Register" icon="io_flag.bmp">
            <bitfield name="AVREG_EXT" mask="0x80" text="Use External AVDD Regulator" icon="" enum="AVREG_EXT_BITF"/>
            <bitfield name="AVDD_OK" mask="0x40" text="AVDD Supply Voltage Valid" icon="" enum="AVDD_OK_BITF"/>
            <bitfield name="DVREG_EXT" mask="0x08" text="Use External DVDD Regulator" icon="" enum="DVREG_EXT_BITF"/>
            <bitfield name="DVDD_OK" mask="0x04" text="DVDD Supply Voltage Valid" icon="" enum="DVDD_OK_BITF"/>
          </reg>
          <reg size="1" name="BATMON" offset="0x151" text="Battery Monitor Control and Status Register" icon="io_flag.bmp">
            <bitfield name="BAT_LOW" mask="0x80" text="Battery Monitor Interrupt Status" icon=""/>
            <bitfield name="BAT_LOW_EN" mask="0x40" text="Battery Monitor Interrupt Enable" icon=""/>
            <bitfield name="BATMON_OK" mask="0x20" text="Battery Monitor Status" icon="" enum="BATMON_OK_bitf"/>
            <bitfield name="BATMON_HR" mask="0x10" text="Battery Monitor Voltage Range" icon="" enum="BATMON_HR_bitf"/>
            <bitfield name="BATMON_VTH" mask="0x0F" text="Battery Monitor Threshold Voltage" icon="" enum="BATMON_VTH_bitf"/>
          </reg>
          <reg size="1" name="XOSC_CTRL" offset="0x152" text="Crystal Oscillator Control Register" icon="io_flag.bmp">
            <bitfield name="XTAL_MODE" mask="0xF0" text="Crystal Oscillator Operating Mode" icon="" enum="XTAL_MODE_BITF"/>
            <bitfield name="XTAL_TRIM" mask="0x0F" text="Crystal Oscillator Load Capacitance Trimming" icon="" enum="XTAL_TRIM_bitf"/>
          </reg>
          <reg size="1" name="RX_SYN" offset="0x155" text="Transceiver Receiver Sensitivity Control Register" icon="io_flag.bmp">
            <bitfield name="RX_PDT_DIS" mask="0x80" text="Prevent Frame Reception" icon=""/>
            <bitfield name="Res" mask="0x70" text="Reserved" icon=""/>
            <bitfield name="RX_PDT_LEVEL" mask="0x0F" text="Reduce Receiver Sensitivity" icon="" enum="RX_PDT_LEVEL_BITF"/>
          </reg>
          <reg size="1" name="XAH_CTRL_1" offset="0x157" text="Transceiver Acknowledgment Frame Control Register 1" icon="io_flag.bmp">
            <bitfield name="Res" mask="0xC0" text="Reserved Bit" icon=""/>
            <bitfield name="AACK_FLTR_RES_FT" mask="0x20" text="Filter Reserved Frames" icon=""/>
            <bitfield name="AACK_UPLD_RES_FT" mask="0x10" text="Process Reserved Frames" icon=""/>
            <bitfield name="Res" mask="0x08" text="Reserved Bit" icon=""/>
            <bitfield name="AACK_ACK_TIME" mask="0x04" text="Reduce Acknowledgment Time" icon="" enum="AACK_ACK_TIME_bitf"/>
            <bitfield name="AACK_PROM_MODE" mask="0x02" text="Enable Promiscuous Mode" icon=""/>
            <bitfield name="Res" mask="0x01" text="Reserved Bit" icon=""/>
          </reg>
          <reg size="1" name="FTN_CTRL" offset="0x158" text="Transceiver Filter Tuning Control Register" icon="io_flag.bmp">
            <bitfield name="FTN_START" mask="0x80" text="Start Calibration Loop of Filter Tuning Network" icon=""/>
          </reg>
          <reg size="1" name="PLL_CF" offset="0x15A" text="Transceiver Center Frequency Calibration Control Register" icon="io_flag.bmp">
            <bitfield name="PLL_CF_START" mask="0x80" text="Start Center Frequency Calibration" icon=""/>
          </reg>
          <reg size="1" name="PLL_DCU" offset="0x15B" text="Transceiver Delay Cell Calibration Control Register" icon="io_flag.bmp">
            <bitfield name="PLL_DCU_START" mask="0x80" text="Start Delay Cell Calibration" icon=""/>
          </reg>
          <reg size="1" name="PART_NUM" offset="0x15C" text="Device Identification Register (Part Number)" icon="io_flag.bmp">
            <bitfield name="PART_NUM" mask="0xFF" text="Part Number" icon="" enum="PART_NUM_bitf"/>
          </reg>
          <reg size="1" name="VERSION_NUM" offset="0x15D" text="Device Identification Register (Version Number)" icon="io_flag.bmp">
            <bitfield name="VERSION_NUM" mask="0xFF" text="Version Number" icon="" enum="VERSION_NUM_BITF"/>
          </reg>
          <reg size="1" name="MAN_ID_0" offset="0x15E" text="Device Identification Register (Manufacture ID Low Byte)" icon="io_flag.bmp">
            <bitfield name="MAN_ID_07" mask="0x80" text="Manufacturer ID (Low Byte)" icon=""/>
            <bitfield name="MAN_ID_06" mask="0x40" text="Manufacturer ID (Low Byte)" icon=""/>
            <bitfield name="MAN_ID_05" mask="0x20" text="Manufacturer ID (Low Byte)" icon=""/>
            <bitfield name="MAN_ID_04" mask="0x10" text="Manufacturer ID (Low Byte)" icon=""/>
            <bitfield name="MAN_ID_03" mask="0x08" text="Manufacturer ID (Low Byte)" icon=""/>
            <bitfield name="MAN_ID_02" mask="0x04" text="Manufacturer ID (Low Byte)" icon=""/>
            <bitfield name="MAN_ID_01" mask="0x02" text="Manufacturer ID (Low Byte)" icon=""/>
            <bitfield name="MAN_ID_00" mask="0x01" text="Manufacturer ID (Low Byte)" icon="" enum="MAN_ID_0_BITF"/>
          </reg>
          <reg size="1" name="MAN_ID_1" offset="0x15F" text="Device Identification Register (Manufacture ID High Byte)" icon="io_flag.bmp">
            <bitfield name="MAN_ID_" mask="0xFF" text="Manufacturer ID (High Byte)" icon="" enum="MAN_ID_1_BITF" lsb="10"/>
          </reg>
          <reg size="1" name="SHORT_ADDR_0" offset="0x160" text="Transceiver MAC Short Address Register (Low Byte)" icon="io_flag.bmp">
            <bitfield name="SHORT_ADDR_07" mask="0x80" text="MAC Short Address" icon=""/>
            <bitfield name="SHORT_ADDR_06" mask="0x40" text="MAC Short Address" icon=""/>
            <bitfield name="SHORT_ADDR_05" mask="0x20" text="MAC Short Address" icon=""/>
            <bitfield name="SHORT_ADDR_04" mask="0x10" text="MAC Short Address" icon=""/>
            <bitfield name="SHORT_ADDR_03" mask="0x08" text="MAC Short Address" icon=""/>
            <bitfield name="SHORT_ADDR_02" mask="0x04" text="MAC Short Address" icon=""/>
            <bitfield name="SHORT_ADDR_01" mask="0x02" text="MAC Short Address" icon=""/>
            <bitfield name="SHORT_ADDR_00" mask="0x01" text="MAC Short Address" icon=""/>
          </reg>
          <reg size="1" name="SHORT_ADDR_1" offset="0x161" text="Transceiver MAC Short Address Register (High Byte)" icon="io_flag.bmp">
            <bitfield name="SHORT_ADDR_" mask="0xFF" text="MAC Short Address" icon="" lsb="10"/>
          </reg>
          <reg size="1" name="PAN_ID_0" offset="0x162" text="Transceiver Personal Area Network ID Register (Low Byte)" icon="io_flag.bmp">
            <bitfield name="PAN_ID_07" mask="0x80" text="MAC Personal Area Network ID" icon=""/>
            <bitfield name="PAN_ID_06" mask="0x40" text="MAC Personal Area Network ID" icon=""/>
            <bitfield name="PAN_ID_05" mask="0x20" text="MAC Personal Area Network ID" icon=""/>
            <bitfield name="PAN_ID_04" mask="0x10" text="MAC Personal Area Network ID" icon=""/>
            <bitfield name="PAN_ID_03" mask="0x08" text="MAC Personal Area Network ID" icon=""/>
            <bitfield name="PAN_ID_02" mask="0x04" text="MAC Personal Area Network ID" icon=""/>
            <bitfield name="PAN_ID_01" mask="0x02" text="MAC Personal Area Network ID" icon=""/>
            <bitfield name="PAN_ID_00" mask="0x01" text="MAC Personal Area Network ID" icon=""/>
          </reg>
          <reg size="1" name="PAN_ID_1" offset="0x163" text="Transceiver Personal Area Network ID Register (High Byte)" icon="io_flag.bmp">
            <bitfield name="PAN_ID_" mask="0xFF" text="MAC Personal Area Network ID" icon="" lsb="10"/>
          </reg>
          <reg size="1" name="IEEE_ADDR_0" offset="0x164" text="Transceiver MAC IEEE Address Register 0" icon="io_flag.bmp">
            <bitfield name="IEEE_ADDR_07" mask="0x80" text="MAC IEEE Address" icon=""/>
            <bitfield name="IEEE_ADDR_06" mask="0x40" text="MAC IEEE Address" icon=""/>
            <bitfield name="IEEE_ADDR_05" mask="0x20" text="MAC IEEE Address" icon=""/>
            <bitfield name="IEEE_ADDR_04" mask="0x10" text="MAC IEEE Address" icon=""/>
            <bitfield name="IEEE_ADDR_03" mask="0x08" text="MAC IEEE Address" icon=""/>
            <bitfield name="IEEE_ADDR_02" mask="0x04" text="MAC IEEE Address" icon=""/>
            <bitfield name="IEEE_ADDR_01" mask="0x02" text="MAC IEEE Address" icon=""/>
            <bitfield name="IEEE_ADDR_00" mask="0x01" text="MAC IEEE Address" icon=""/>
          </reg>
          <reg size="1" name="IEEE_ADDR_1" offset="0x165" text="Transceiver MAC IEEE Address Register 1" icon="io_flag.bmp">
            <bitfield name="IEEE_ADDR_" mask="0xFF" text="MAC IEEE Address" icon="" lsb="10"/>
          </reg>
          <reg size="1" name="IEEE_ADDR_2" offset="0x166" text="Transceiver MAC IEEE Address Register 2" icon="io_flag.bmp">
            <bitfield name="IEEE_ADDR_" mask="0xFF" text="MAC IEEE Address" icon="" lsb="20"/>
          </reg>
          <reg size="1" name="IEEE_ADDR_3" offset="0x167" text="Transceiver MAC IEEE Address Register 3" icon="io_flag.bmp">
            <bitfield name="IEEE_ADDR_" mask="0xFF" text="MAC IEEE Address" icon="" lsb="30"/>
          </reg>
          <reg size="1" name="IEEE_ADDR_4" offset="0x168" text="Transceiver MAC IEEE Address Register 4" icon="io_flag.bmp">
            <bitfield name="IEEE_ADDR_" mask="0xFF" text="MAC IEEE Address" icon="" lsb="40"/>
          </reg>
          <reg size="1" name="IEEE_ADDR_5" offset="0x169" text="Transceiver MAC IEEE Address Register 5" icon="io_flag.bmp">
            <bitfield name="IEEE_ADDR_" mask="0xFF" text="MAC IEEE Address" icon="" lsb="50"/>
          </reg>
          <reg size="1" name="IEEE_ADDR_6" offset="0x16A" text="Transceiver MAC IEEE Address Register 6" icon="io_flag.bmp">
            <bitfield name="IEEE_ADDR_" mask="0xFF" text="MAC IEEE Address" icon="" lsb="60"/>
          </reg>
          <reg size="1" name="IEEE_ADDR_7" offset="0x16B" text="Transceiver MAC IEEE Address Register 7" icon="io_flag.bmp">
            <bitfield name="IEEE_ADDR_" mask="0xFF" text="MAC IEEE Address" icon="" lsb="70"/>
          </reg>
          <reg size="1" name="XAH_CTRL_0" offset="0x16C" text="Transceiver Extended Operating Mode Control Register" icon="io_flag.bmp">
            <bitfield name="MAX_FRAME_RETRIES" mask="0xF0" text="Maximum Number of Frame Re-transmission Attempts" icon="" enum="MAX_FRAME_RETRIES_bitf"/>
            <bitfield name="MAX_CSMA_RETRIES" mask="0x0E" text="Maximum Number of CSMA-CA Procedure Repetition Attempts" icon="" enum="MAX_CSMA_RETRIES_bitf"/>
            <bitfield name="SLOTTED_OPERATION" mask="0x01" text="Set Slotted Acknowledgment" icon="" enum="SLOTTED_OPERATION_BITF"/>
          </reg>
          <reg size="1" name="CSMA_SEED_0" offset="0x16D" text="Transceiver CSMA-CA Random Number Generator Seed Register" icon="io_flag.bmp">
            <bitfield name="CSMA_SEED_07" mask="0x80" text="Seed Value for CSMA Random Number Generator" icon=""/>
            <bitfield name="CSMA_SEED_06" mask="0x40" text="Seed Value for CSMA Random Number Generator" icon=""/>
            <bitfield name="CSMA_SEED_05" mask="0x20" text="Seed Value for CSMA Random Number Generator" icon=""/>
            <bitfield name="CSMA_SEED_04" mask="0x10" text="Seed Value for CSMA Random Number Generator" icon=""/>
            <bitfield name="CSMA_SEED_03" mask="0x08" text="Seed Value for CSMA Random Number Generator" icon=""/>
            <bitfield name="CSMA_SEED_02" mask="0x04" text="Seed Value for CSMA Random Number Generator" icon=""/>
            <bitfield name="CSMA_SEED_01" mask="0x02" text="Seed Value for CSMA Random Number Generator" icon=""/>
            <bitfield name="CSMA_SEED_00" mask="0x01" text="Seed Value for CSMA Random Number Generator" icon=""/>
          </reg>
          <reg size="1" name="CSMA_SEED_1" offset="0x16E" text="Transceiver Acknowledgment Frame Control Register 2" icon="io_flag.bmp">
            <bitfield name="AACK_FVN_MODE" mask="0xC0" text="Acknowledgment Frame Filter Mode" icon="" enum="AACK_FVN_MODE_bitf"/>
            <bitfield name="AACK_SET_PD" mask="0x20" text="Set Frame Pending Sub-field" icon=""/>
            <bitfield name="AACK_DIS_ACK" mask="0x10" text="Disable Acknowledgment Frame Transmission" icon=""/>
            <bitfield name="AACK_I_AM_COORD" mask="0x08" text="Set Personal Area Network Coordinator" icon=""/>
            <bitfield name="CSMA_SEED_1" mask="0x07" text="Seed Value for CSMA Random Number Generator" icon=""/>
          </reg>
          <reg size="1" name="CSMA_BE" offset="0x16F" text="Transceiver CSMA-CA Back-off Exponent Control Register" icon="io_flag.bmp">
            <bitfield name="MAX_BE" mask="0xF0" text="Maximum Back-off Exponent" icon="" enum="MAX_BE_bitf"/>
            <bitfield name="MIN_BE" mask="0x0F" text="Minimum Back-off Exponent" icon="" enum="MIN_BE_bitf"/>
          </reg>
          <reg size="1" name="TST_CTRL_DIGI" offset="0x176" text="Transceiver Digital Test Control Register" icon="io_flag.bmp">
            <bitfield name="TST_CTRL_DIG" mask="0x0F" text="Digital Test Controller Register" icon="" enum="TST_CTRL_DIG_BITF"/>
          </reg>
          <reg size="1" name="TST_RX_LENGTH" offset="0x17B" text="Transceiver Received Frame Length Register" icon="io_flag.bmp">
            <bitfield name="RX_LENGTH" mask="0xFF" text="Received Frame Length" icon=""/>
          </reg>
          <reg size="1" name="TRXFBST" offset="0x180" text="Start of frame buffer" icon="io_flag.bmp" mask="0xFF"/>
          <reg size="1" name="TRXFBEND" offset="0x1FF" text="End of frame buffer" icon="io_flag.bmp" mask="0xFF"/>
        </registers>
        <enumerator name="AES_MODE_BITF">
          <enum val="0" text="AES Mode is ECB (Electronic Code Book)." constname="AES_MODE_ECB"/>
          <enum val="1" text="AES Mode is CBC (Cipher Block Chaining)." constname="AES_MODE_CBC"/>
        </enumerator>
        <enumerator name="AES_DIRECTION_BITF">
          <enum val="0" text="AES operation is encryption." constname="AES_DIR_ENC"/>
          <enum val="1" text="AES operation is decryption." constname="AES_DIR_DEC"/>
        </enumerator>
        <enumerator name="CCA_DONE_bitf">
          <enum val="0" text="CCA calculation not finished" constname="CCA_NOT_FIN"/>
          <enum val="1" text="CCA calculation finished" constname="CCA_FIN"/>
        </enumerator>
        <enumerator name="CCA_STATUS_bitf">
          <enum val="0" text="Channel indicated as busy." constname="CCA_BUSY"/>
          <enum val="1" text="Channel indicated as idle." constname="CCA_IDLE"/>
        </enumerator>
        <enumerator name="TST_STATUS_bitf">
          <enum val="0" text="Test mode is disabled." constname="TST_DISABLED"/>
          <enum val="1" text="Test mode is active." constname="TST_ENABLED"/>
        </enumerator>
        <enumerator name="TRX_STATUS_bitf">
          <enum val="0x00" text="P_ON" constname="P_ON"/>
          <enum val="0x01" text="BUSY_RX" constname="BUSY_RX"/>
          <enum val="0x02" text="BUSY_TX" constname="BUSY_TX"/>
          <enum val="0x06" text="RX_ON" constname="RX_ON"/>
          <enum val="0x08" text="TRX_OFF" constname="TRX_OFF"/>
          <enum val="0x09" text="PLL_ON" constname="PLL_ON"/>
          <enum val="0x0F" text="SLEEP" constname="SLEEP"/>
          <enum val="0x11" text="BUSY_RX_AACK" constname="BUSY_RX_AACK"/>
          <enum val="0x12" text="BUSY_TX_ARET" constname="BUSY_TX_ARET"/>
          <enum val="0x16" text="RX_AACK_ON" constname="RX_AACK_ON"/>
          <enum val="0x19" text="TX_ARET_ON" constname="TX_ARET_ON"/>
          <enum val="0x1F" text="STATE_TRANSITION_IN_PROGRESS" constname="STATE_TRANSITION_IN_PROGRESS"/>
        </enumerator>
        <enumerator name="TRAC_STATUS_bitf">
          <enum val="0" text="SUCCESS (RX_AACK, TX_ARET)" constname="TRAC_SUCCESS"/>
          <enum val="1" text="SUCCESS_DATA_PENDING (TX_ARET)" constname="TRAC_SUCCESS_DATA_PENDING"/>
          <enum val="2" text="SUCCESS_WAIT_FOR_ACK (RX_AACK)" constname="TRAC_SUCCESS_WAIT_FOR_ACK"/>
          <enum val="3" text="CHANNEL_ACCESS_FAILURE (TX_ARET)" constname="TRAC_CHANNEL_ACCESS_FAILURE"/>
          <enum val="5" text="NO_ACK (TX_ARET)" constname="TRAC_NO_ACK"/>
          <enum val="7" text="INVALID (RX_AACK, TX_ARET)" constname="TRAC_INVALID"/>
        </enumerator>
        <enumerator name="TRX_CMD_bitf">
          <enum val="0x00" text="NOP" constname="CMD_NOP"/>
          <enum val="0x02" text="TX_START" constname="CMD_TX_START"/>
          <enum val="0x03" text="FORCE_TRX_OFF" constname="CMD_FORCE_TRX_OFF"/>
          <enum val="0x04" text="FORCE_PLL_ON" constname="CMD_FORCE_PLL_ON"/>
          <enum val="0x06" text="RX_ON" constname="CMD_RX_ON"/>
          <enum val="0x08" text="TRX_OFF" constname="CMD_TRX_OFF"/>
          <enum val="0x09" text="PLL_ON (TX_ON)" constname="CMD_PLL_ON"/>
          <enum val="0x16" text="RX_AACK_ON" constname="CMD_RX_AACK_ON"/>
          <enum val="0x19" text="TX_ARET_ON" constname="CMD_TX_ARET_ON"/>
        </enumerator>
        <enumerator name="PA_BUF_LT_bitf">
          <enum val="0" text="0 &#xB5;s" constname="PA_BUF_LT_0US"/>
          <enum val="1" text="2 &#xB5;s" constname="PA_BUF_LT_2US"/>
          <enum val="2" text="4 &#xB5;s" constname="PA_BUF_LT_4US"/>
          <enum val="3" text="6 &#xB5;s" constname="PA_BUF_LT_6US"/>
        </enumerator>
        <enumerator name="PA_LT_bitf">
          <enum val="0" text="2 &#xB5;s" constname="PA_LT_2US"/>
          <enum val="1" text="4 &#xB5;s" constname="PA_LT_4US"/>
          <enum val="2" text="6 &#xB5;s" constname="PA_LT_6US"/>
          <enum val="3" text="8 &#xB5;s" constname="PA_LT_8US"/>
        </enumerator>
        <enumerator name="TX_PWR_bitf">
          <enum val="0" text="3.5 dBm"/>
          <enum val="1" text="3.3 dBm"/>
          <enum val="2" text="2.8 dBm"/>
          <enum val="3" text="2.3 dBm"/>
          <enum val="4" text="1.8 dBm"/>
          <enum val="5" text="1.2 dBm"/>
          <enum val="6" text="0.5 dBm"/>
          <enum val="7" text="-0.5 dBm"/>
          <enum val="8" text="-1.5 dBm"/>
          <enum val="9" text="-2.5 dBm"/>
          <enum val="10" text="-3.5 dBm"/>
          <enum val="11" text="-4.5 dBm"/>
          <enum val="12" text="-6.5 dBm"/>
          <enum val="13" text="-8.5 dBm"/>
          <enum val="14" text="-11.5 dBm"/>
          <enum val="15" text="-16.5 dBm"/>
        </enumerator>
        <enumerator name="RX_CRC_VALID_bitf">
          <enum val="0" text="CRC (FCS) not valid" constname="CRC_INVALID"/>
          <enum val="1" text="CRC (FCS) valid" constname="CRC_VALID"/>
        </enumerator>
        <enumerator name="RSSI_VALUE_BITF">
          <enum val="0" text="Minimum RSSI value: P(RF) &lt; -90 dBm" constname="RSSI_MIN"/>
          <enum val="1" text="P(RF) = RSSI_BASE_VAL+3 &#xB7; (RSSI-1) [dBm]" constname="RSSI_MIN_PLUS_3dB"/>
          <enum val="2" text="..."/>
          <enum val="28" text="Maximum RSSI value: P(RF) &#x2265; -10 dBm" constname="RSSI_MAX"/>
        </enumerator>
        <enumerator name="ED_LEVEL_BITF">
          <enum val="0x00" text="Minimum result of last ED measurement" constname="ED_MIN"/>
          <enum val="0x01" text="P(RF) = RSSI_BASE_VAL+ED [dBm]" constname="ED_MIN_PLUS_1dB"/>
          <enum val="0x02" text="..."/>
          <enum val="0x54" text="Maximum result of last ED measurement" constname="ED_MAX"/>
          <enum val="0xFF" text="Reset value" constname="ED_RESET"/>
        </enumerator>
        <enumerator name="CCA_MODE_bitf">
          <enum val="0" text="Mode 3a, Carrier sense OR energy above threshold" constname="CCA_CS_OR_ED"/>
          <enum val="1" text="Mode 1, Energy above threshold" constname="CCA_ED"/>
          <enum val="2" text="Mode 2, Carrier sense only" constname="CCA_CS"/>
          <enum val="3" text="Mode 3b, Carrier sense AND energy above threshold" constname="CCA_CS_AND_ED"/>
        </enumerator>
        <enumerator name="CHANNEL_bitf">
          <enum val="11" text="2405 MHz" constname="F_2405MHZ"/>
          <enum val="12" text="2410 MHz" constname="F_2410MHZ"/>
          <enum val="13" text="2415 MHz" constname="F_2415MHZ"/>
          <enum val="14" text="2420 MHz" constname="F_2420MHZ"/>
          <enum val="15" text="2425 MHz" constname="F_2425MHZ"/>
          <enum val="16" text="2430 MHz" constname="F_2430MHZ"/>
          <enum val="17" text="2435 MHz" constname="F_2435MHZ"/>
          <enum val="18" text="2440 MHz" constname="F_2440MHZ"/>
          <enum val="19" text="2445 MHz" constname="F_2445MHZ"/>
          <enum val="20" text="2450 MHz" constname="F_2450MHZ"/>
          <enum val="21" text="2455 MHz" constname="F_2455MHZ"/>
          <enum val="22" text="2460 MHz" constname="F_2460MHZ"/>
          <enum val="23" text="2465 MHz" constname="F_2465MHZ"/>
          <enum val="24" text="2470 MHz" constname="F_2470MHZ"/>
          <enum val="25" text="2475 MHz" constname="F_2475MHZ"/>
          <enum val="26" text="2480 MHz" constname="F_2480MHZ"/>
        </enumerator>
        <enumerator name="PDT_THRES_bitf">
          <enum val="0x7" text="Reset value, to be used if Antenna Diversity algorithm is disabled" constname="PDT_THRES_ANT_DIV_OFF"/>
          <enum val="0x3" text="Recommended correlator threshold for Antenna Diversity operation" constname="PDT_THRES_ANT_DIV_ON"/>
        </enumerator>
        <enumerator name="SFD_VALUE_BITF">
          <enum val="0xA7" text="IEEE 802.15.4 compliant value of the SFD" constname="IEEE_SFD"/>
        </enumerator>
        <enumerator name="OQPSK_DATA_RATE_bitf">
          <enum val="0" text="250 kb/s (IEEE 802.15.4 compliant)" constname="RATE_250KB"/>
          <enum val="1" text="500 kb/s" constname="RATE_500KB"/>
          <enum val="2" text="1000 kb/s" constname="RATE_1000KB"/>
          <enum val="3" text="2000 kb/s" constname="RATE_2000KB"/>
        </enumerator>
        <enumerator name="ANT_SEL_bitf">
          <enum val="0" text="Antenna 0" constname="ANTENNA_0"/>
          <enum val="1" text="Antenna 1" constname="ANTENNA_1"/>
        </enumerator>
        <enumerator name="ANT_DIV_EN_bitf">
          <enum val="0" text="Antenna Diversity algorithm disabled"/>
          <enum val="1" text="Antenna Diversity algorithm enabled"/>
        </enumerator>
        <enumerator name="ANT_EXT_SW_EN_bitf">
          <enum val="0" text="Antenna Diversity RF switch control disabled" constname="ANT_DIV_EXT_SW_DIS"/>
          <enum val="1" text="Antenna Diversity RF switch control enabled" constname="ANT_DIV_EXT_SW_EN"/>
        </enumerator>
        <enumerator name="ANT_CTRL_bitf">
          <enum val="0" text="Reserved"/>
          <enum val="1" text="Antenna 1: DIG1=H, DIG2=L" constname="ANT_1"/>
          <enum val="2" text="Antenna 0: DIG1=L, DIG2=H" constname="ANT_0"/>
          <enum val="3" text="Default value for ANT_EXT_SW_EN=0; Mandatory setting for applications not using Antenna Diversity" constname="ANT_RESET"/>
        </enumerator>
        <enumerator name="AVREG_EXT_BITF">
          <enum val="0" text="Internal AVDD voltage regulator for the analog section is enabled." constname="AVDD_INT"/>
          <enum val="1" text="Internal AVDD voltage regulator is disabled; use external regulated 1.8V supply voltage for the analog section." constname="AVDD_EXT"/>
        </enumerator>
        <enumerator name="AVDD_OK_BITF">
          <enum val="0" text="Analog voltage regulator disabled or supply voltage not stable"/>
          <enum val="1" text="Analog supply voltage has settled"/>
        </enumerator>
        <enumerator name="DVREG_EXT_BITF">
          <enum val="0" text="Internal DVDD voltage regulator for the digital section is enabled." constname="DVDD_INT"/>
          <enum val="1" text="Internal DVDD voltage regulator is disabled; use external regulated 1.8V supply voltage for the digital section." constname="DVDD_EXT"/>
        </enumerator>
        <enumerator name="DVDD_OK_BITF">
          <enum val="0" text="Digital voltage regulator disabled or supply voltage not stable"/>
          <enum val="1" text="Digital supply voltage has settled"/>
        </enumerator>
        <enumerator name="BATMON_OK_bitf">
          <enum val="0" text="The battery voltage is below the threshold."/>
          <enum val="1" text="The battery voltage is above the threshold."/>
        </enumerator>
        <enumerator name="BATMON_HR_bitf">
          <enum val="0" text="Enables the low range, see BATMON_VTH" constname="BATMON_HR_DIS"/>
          <enum val="1" text="Enables the high range, see BATMON_VTH" constname="BATMON_HR_EN"/>
        </enumerator>
        <enumerator name="BATMON_VTH_bitf">
          <enum val="0x0" text="2.550V / 1.70V (BATMON_HR=1/0)"/>
          <enum val="0x1" text="2.625V / 1.75V (BATMON_HR=1/0)"/>
          <enum val="0x2" text="2.700V / 1.80V (BATMON_HR=1/0)"/>
          <enum val="0x3" text="2.775V / 1.85V (BATMON_HR=1/0)"/>
          <enum val="0x4" text="2.850V / 1.90V (BATMON_HR=1/0)"/>
          <enum val="0x5" text="2.925V / 1.95V (BATMON_HR=1/0)"/>
          <enum val="0x6" text="3.000V / 2.00V (BATMON_HR=1/0)"/>
          <enum val="0x7" text="3.075V / 2.05V (BATMON_HR=1/0)"/>
          <enum val="0x8" text="3.150V / 2.10V (BATMON_HR=1/0)"/>
          <enum val="0x9" text="3.225V / 2.15V (BATMON_HR=1/0)"/>
          <enum val="0xA" text="3.300V / 2.20V (BATMON_HR=1/0)"/>
          <enum val="0xB" text="3.375V / 2.25V (BATMON_HR=1/0)"/>
          <enum val="0xC" text="3.450V / 2.30V (BATMON_HR=1/0)"/>
          <enum val="0xD" text="3.525V / 2.35V (BATMON_HR=1/0)"/>
          <enum val="0xE" text="3.600V / 2.40V (BATMON_HR=1/0)"/>
          <enum val="0xF" text="3.675V / 2.45V (BATMON_HR=1/0)"/>
        </enumerator>
        <enumerator name="XTAL_MODE_BITF">
          <enum val="0x4" text="Internal crystal oscillator disabled; use external reference frequency."/>
          <enum val="0xF" text="Internal crystal oscillator enabled; amplitude regulation of oscillation enabled."/>
        </enumerator>
        <enumerator name="XTAL_TRIM_bitf">
          <enum val="0x0" text="0.0 pF, trimming capacitors disconnected" constname="XTAL_TRIM_MIN"/>
          <enum val="0x1" text="0.3 pF, trimming capacitor switched on"/>
          <enum val="0x2" text="..."/>
          <enum val="0xF" text="4.5 pF, trimming capacitor switched on" constname="XTAL_TRIM_MAX"/>
        </enumerator>
        <enumerator name="RX_PDT_LEVEL_BITF">
          <enum val="0x0" text="RX_THRES &#x2264; RSSI_BASE_VAL (Reset value); RSSI value not considered" constname="RX_PDT_LEVEL_MIN"/>
          <enum val="0x1" text="RX_THRES &gt; RSSI_BASE_VAL + 0 &#xB7; 3; RSSI &gt; -90 dBm"/>
          <enum val="0x2" text="..."/>
          <enum val="0xE" text="RX_THRES &gt; RSSI_BASE_VAL + 13 &#xB7; 3; RSSI &gt; -51 dBm"/>
          <enum val="0xF" text="RX_THRES &gt; RSSI_BASE_VAL + 14 &#xB7; 3; RSSI &gt; -48 dBm" constname="RX_PDT_LEVEL_MAX"/>
        </enumerator>
        <enumerator name="AACK_ACK_TIME_bitf">
          <enum val="0" text="12 symbols acknowledgment time" constname="AACK_ACK_TIME_12_SYM"/>
          <enum val="1" text=" 2 symbols acknowledgment time" constname="AACK_ACK_TIME_2_SYM"/>
        </enumerator>
        <enumerator name="PART_NUM_bitf">
          <enum val="0x83" text="ATmega128RFA1 part number" constname="P_ATmega128RFA1"/>
          <enum val="0x93" text="RFA2 family" constname="P_RFA2"/>
          <enum val="0x94" text="RFR2 family" constname="P_RFR2"/>
        </enumerator>
        <enumerator name="VERSION_NUM_BITF">
          <enum val="2" text="Revision AB" constname="REV_AB"/>
          <enum val="3" text="Revision C" constname="REV_C"/>
          <enum val="4" text="Revision D" constname="REV_D"/>
        </enumerator>
        <enumerator name="MAN_ID_0_BITF">
          <enum val="0x1f" text="Atmel JEDEC manufacturer ID, bits [7:0] of 32 bit manufacturer ID: 00 00 00 1F" constname="ATMEL_BYTE_0"/>
        </enumerator>
        <enumerator name="MAN_ID_1_BITF">
          <enum val="0x00" text="Atmel JEDEC manufacturer ID, bits [15:8] of 32 bit manufacturer ID: 00 00 00 1F" constname="ATMEL_BYTE_1"/>
        </enumerator>
        <enumerator name="MAX_FRAME_RETRIES_bitf">
          <enum val="0x0" text="Retransmission of frame is not attempted."/>
          <enum val="0x1" text="Retransmission of frame is attempted once."/>
          <enum val="0x2" text="..."/>
          <enum val="0xF" text="Retransmission of frame is attempted 15 times."/>
        </enumerator>
        <enumerator name="MAX_CSMA_RETRIES_bitf">
          <enum val="0x0" text="No repetition of CSMA-CA procedure"/>
          <enum val="0x1" text="One repetition of CSMA-CA procedure"/>
          <enum val="0x2" text="..."/>
          <enum val="0x5" text="Five repetitions (highest IEEE 802.15.4 compliant value)"/>
          <enum val="0x6" text="Reserved"/>
          <enum val="0x7" text="Immediate frame re-transmission without performing CSMA-CA"/>
        </enumerator>
        <enumerator name="SLOTTED_OPERATION_BITF">
          <enum val="0" text="The radio transceiver operates in unslotted mode. An acknowledgment frame is automatically sent if requested." constname="SLOTTED_OP_DIS"/>
          <enum val="1" text="The transmission of an acknowledgment frame has to be controlled by the microcontroller." constname="SLOTTED_OP_EN"/>
        </enumerator>
        <enumerator name="AACK_FVN_MODE_bitf">
          <enum val="0" text="Acknowledge frames with version number 0"/>
          <enum val="1" text="Acknowledge frames with version number 0 or 1"/>
          <enum val="2" text="Acknowledge frames with version number 0 or 1 or 2"/>
          <enum val="3" text="Acknowledge frames independent of frame version number"/>
        </enumerator>
        <enumerator name="MAX_BE_bitf">
          <enum val="1" text="This value is not valid for the maximum back-off exponent."/>
          <enum val="2" text="This value is not valid for the maximum back-off exponent."/>
          <enum val="3" text="Minimum, IEEE compliant value for the maximum back-off exponent."/>
          <enum val="4" text="..."/>
          <enum val="8" text="Maximum, IEEE compliant value for the maximum back-off exponent."/>
        </enumerator>
        <enumerator name="MIN_BE_bitf">
          <enum val="0" text="Minimum value of minimum back-off exponent."/>
          <enum val="1" text="..."/>
          <enum val="8" text="Maximum value of minimum back-off exponent. MIN_BE must be smaller or equal to MAX_BE."/>
        </enumerator>
        <enumerator name="TST_CTRL_DIG_BITF">
          <enum val="0" text="NORMAL (no test is active)"/>
          <enum val="15" text="TST_CONT_TX (continuous transmit)"/>
        </enumerator>
      </module>
      <module class="SYMCNT" text="">
        <registers name="SYMCNT" memspace="DATAMEM" text="" icon="io_symcnt.bmp">
          <reg size="1" name="SCOCR1HH" offset="0xF8" text="Symbol Counter Output Compare Register 1 HH-Byte" icon="io_flag.bmp">
            <bitfield name="SCOCR1HH" mask="0xFF" text="Symbol Counter Output Compare Register 1 HH-Byte" icon=""/>
          </reg>
          <reg size="1" name="SCOCR1HL" offset="0xF7" text="Symbol Counter Output Compare Register 1 HL-Byte" icon="io_flag.bmp">
            <bitfield name="SCOCR1HL" mask="0xFF" text="Symbol Counter Output Compare Register 1 HL-Byte" icon=""/>
          </reg>
          <reg size="1" name="SCOCR1LH" offset="0xF6" text="Symbol Counter Output Compare Register 1 LH-Byte" icon="io_flag.bmp">
            <bitfield name="SCOCR1LH" mask="0xFF" text="Symbol Counter Output Compare Register 1 LH-Byte" icon=""/>
          </reg>
          <reg size="1" name="SCOCR1LL" offset="0xF5" text="Symbol Counter Output Compare Register 1 LL-Byte" icon="io_flag.bmp">
            <bitfield name="SCOCR1LL" mask="0xFF" text="Symbol Counter Output Compare Register 1 LL-Byte" icon=""/>
          </reg>
          <reg size="1" name="SCOCR2HH" offset="0xF4" text="Symbol Counter Output Compare Register 2 HH-Byte" icon="io_flag.bmp">
            <bitfield name="SCOCR2HH" mask="0xFF" text="Symbol Counter Output Compare Register 2 HH-Byte" icon=""/>
          </reg>
          <reg size="1" name="SCOCR2HL" offset="0xF3" text="Symbol Counter Output Compare Register 2 HL-Byte" icon="io_flag.bmp">
            <bitfield name="SCOCR2HL" mask="0xFF" text="Symbol Counter Output Compare Register 2 HL-Byte" icon=""/>
          </reg>
          <reg size="1" name="SCOCR2LH" offset="0xF2" text="Symbol Counter Output Compare Register 2 LH-Byte" icon="io_flag.bmp">
            <bitfield name="SCOCR2LH" mask="0xFF" text="Symbol Counter Output Compare Register 2 LH-Byte" icon=""/>
          </reg>
          <reg size="1" name="SCOCR2LL" offset="0xF1" text="Symbol Counter Output Compare Register 2 LL-Byte" icon="io_flag.bmp">
            <bitfield name="SCOCR2LL" mask="0xFF" text="Symbol Counter Output Compare Register 2 LL-Byte" icon=""/>
          </reg>
          <reg size="1" name="SCOCR3HH" offset="0xF0" text="Symbol Counter Output Compare Register 3 HH-Byte" icon="io_flag.bmp">
            <bitfield name="SCOCR3HH" mask="0xFF" text="Symbol Counter Output Compare Register 3 HH-Byte" icon=""/>
          </reg>
          <reg size="1" name="SCOCR3HL" offset="0xEF" text="Symbol Counter Output Compare Register 3 HL-Byte" icon="io_flag.bmp">
            <bitfield name="SCOCR3HL" mask="0xFF" text="Symbol Counter Output Compare Register 3 HL-Byte" icon=""/>
          </reg>
          <reg size="1" name="SCOCR3LH" offset="0xEE" text="Symbol Counter Output Compare Register 3 LH-Byte" icon="io_flag.bmp">
            <bitfield name="SCOCR3LH" mask="0xFF" text="Symbol Counter Output Compare Register 3 LH-Byte" icon=""/>
          </reg>
          <reg size="1" name="SCOCR3LL" offset="0xED" text="Symbol Counter Output Compare Register 3 LL-Byte" icon="io_flag.bmp">
            <bitfield name="SCOCR3LL" mask="0xFF" text="Symbol Counter Output Compare Register 3 LL-Byte" icon=""/>
          </reg>
          <reg size="1" name="SCTSRHH" offset="0xEC" text="Symbol Counter Frame Timestamp Register HH-Byte" icon="io_flag.bmp">
            <bitfield name="SCTSRHH" mask="0xFF" text="Symbol Counter Frame Timestamp Register HH-Byte" icon=""/>
          </reg>
          <reg size="1" name="SCTSRHL" offset="0xEB" text="Symbol Counter Frame Timestamp Register HL-Byte" icon="io_flag.bmp">
            <bitfield name="SCTSRHL" mask="0xFF" text="Symbol Counter Frame Timestamp Register HL-Byte" icon=""/>
          </reg>
          <reg size="1" name="SCTSRLH" offset="0xEA" text="Symbol Counter Frame Timestamp Register LH-Byte" icon="io_flag.bmp">
            <bitfield name="SCTSRLH" mask="0xFF" text="Symbol Counter Frame Timestamp Register LH-Byte" icon=""/>
          </reg>
          <reg size="1" name="SCTSRLL" offset="0xE9" text="Symbol Counter Frame Timestamp Register LL-Byte" icon="io_flag.bmp">
            <bitfield name="SCTSRLL" mask="0xFF" text="Symbol Counter Frame Timestamp Register LL-Byte" icon=""/>
          </reg>
          <reg size="1" name="SCBTSRHH" offset="0xE8" text="Symbol Counter Beacon Timestamp Register HH-Byte" icon="io_flag.bmp">
            <bitfield name="SCBTSRHH" mask="0xFF" text="Symbol Counter Beacon Timestamp Register HH-Byte" icon=""/>
          </reg>
          <reg size="1" name="SCBTSRHL" offset="0xE7" text="Symbol Counter Beacon Timestamp Register HL-Byte" icon="io_flag.bmp">
            <bitfield name="SCBTSRHL" mask="0xFF" text="Symbol Counter Beacon Timestamp Register HL-Byte" icon=""/>
          </reg>
          <reg size="1" name="SCBTSRLH" offset="0xE6" text="Symbol Counter Beacon Timestamp Register LH-Byte" icon="io_flag.bmp">
            <bitfield name="SCBTSRLH" mask="0xFF" text="Symbol Counter Beacon Timestamp Register LH-Byte" icon=""/>
          </reg>
          <reg size="1" name="SCBTSRLL" offset="0xE5" text="Symbol Counter Beacon Timestamp Register LL-Byte" icon="io_flag.bmp">
            <bitfield name="SCBTSRLL" mask="0xFF" text="Symbol Counter Beacon Timestamp Register LL-Byte" icon=""/>
          </reg>
          <reg size="1" name="SCCNTHH" offset="0xE4" text="Symbol Counter Register HH-Byte" icon="io_flag.bmp">
            <bitfield name="SCCNTHH" mask="0xFF" text="Symbol Counter Register HH-Byte" icon=""/>
          </reg>
          <reg size="1" name="SCCNTHL" offset="0xE3" text="Symbol Counter Register HL-Byte" icon="io_flag.bmp">
            <bitfield name="SCCNTHL" mask="0xFF" text="Symbol Counter Register HL-Byte" icon=""/>
          </reg>
          <reg size="1" name="SCCNTLH" offset="0xE2" text="Symbol Counter Register LH-Byte" icon="io_flag.bmp">
            <bitfield name="SCCNTLH" mask="0xFF" text="Symbol Counter Register LH-Byte" icon=""/>
          </reg>
          <reg size="1" name="SCCNTLL" offset="0xE1" text="Symbol Counter Register LL-Byte" icon="io_flag.bmp">
            <bitfield name="SCCNTLL" mask="0xFF" text="Symbol Counter Register LL-Byte" icon=""/>
          </reg>
          <reg size="1" name="SCIRQS" offset="0xE0" text="Symbol Counter Interrupt Status Register" icon="io_flag.bmp">
            <bitfield name="Res" mask="0xE0" text="Reserved Bit" icon=""/>
            <bitfield name="IRQSBO" mask="0x10" text="Backoff Slot Counter IRQ" icon=""/>
            <bitfield name="IRQSOF" mask="0x08" text="Symbol Counter Overflow IRQ" icon=""/>
            <bitfield name="IRQSCP" mask="0x07" text="Compare Unit 3 Compare Match IRQ" icon="" lsb="1"/>
          </reg>
          <reg size="1" name="SCIRQM" offset="0xDF" text="Symbol Counter Interrupt Mask Register" icon="io_flag.bmp">
            <bitfield name="Res" mask="0xE0" text="Reserved Bit" icon=""/>
            <bitfield name="IRQMBO" mask="0x10" text="Backoff Slot Counter IRQ enable" icon=""/>
            <bitfield name="IRQMOF" mask="0x08" text="Symbol Counter Overflow IRQ enable" icon=""/>
            <bitfield name="IRQMCP" mask="0x07" text="Symbol Counter Compare Match 3 IRQ enable" icon="" lsb="1"/>
          </reg>
          <reg size="1" name="SCSR" offset="0xDE" text="Symbol Counter Status Register" icon="io_flag.bmp">
            <bitfield name="Res" mask="0xFE" text="Reserved Bit" icon=""/>
            <bitfield name="SCBSY" mask="0x01" text="Symbol Counter busy" icon=""/>
          </reg>
          <reg size="1" name="SCCR1" offset="0xDD" text="Symbol Counter Control Register 1" icon="io_flag.bmp">
            <bitfield name="Res" mask="0xFE" text="Reserved Bit" icon=""/>
            <bitfield name="SCENBO" mask="0x01" text="Backoff Slot Counter enable" icon=""/>
          </reg>
          <reg size="1" name="SCCR0" offset="0xDC" text="Symbol Counter Control Register 0" icon="io_flag.bmp">
            <bitfield name="SCRES" mask="0x80" text="Symbol Counter Synchronization" icon=""/>
            <bitfield name="SCMBTS" mask="0x40" text="Manual Beacon Timestamp" icon=""/>
            <bitfield name="SCEN" mask="0x20" text="Symbol Counter enable" icon=""/>
            <bitfield name="SCCKSEL" mask="0x10" text="Symbol Counter Clock Source select" icon=""/>
            <bitfield name="SCTSE" mask="0x08" text="Symbol Counter Automatic Timestamping enable" icon=""/>
            <bitfield name="SCCMP" mask="0x07" text="Symbol Counter Compare Unit 3 Mode select" icon="" lsb="1"/>
          </reg>
        </registers>
      </module>
      <module class="EEPROM" text="">
        <registers name="EEPROM" memspace="DATAMEM" text="" icon="io_cpu.bmp">
          <reg size="2" name="EEAR" offset="0x41" text="EEPROM Address Register  Bytes" icon="io_cpu.bmp" mask="0xFFFF"/>
          <reg size="1" name="EEDR" offset="0x40" text="EEPROM Data Register" icon="io_cpu.bmp" mask="0xFF"/>
          <reg size="1" name="EECR" offset="0x3F" text="EEPROM Control Register" icon="io_flag.bmp">
            <bitfield name="Res" mask="0xC0" text="Reserved" icon=""/>
            <bitfield name="EEPM" mask="0x30" text="EEPROM Programming Mode" icon="" enum="EEP_MODE2"/>
            <bitfield name="EERIE" mask="0x08" text="EEPROM Ready Interrupt Enable" icon=""/>
            <bitfield name="EEMPE" mask="0x04" text="EEPROM Master Write Enable" icon=""/>
            <bitfield name="EEPE" mask="0x02" text="EEPROM Programming Enable" icon=""/>
            <bitfield name="EERE" mask="0x01" text="EEPROM Read Enable" icon=""/>
          </reg>
        </registers>
        <enumerator name="EEP_MODE2">
          <enum val="0x00" text="Erase and Write in one operation (Atomic Operation)"/>
          <enum val="0x01" text="Erase only"/>
          <enum val="0x02" text="Write only"/>
          <enum val="0x03" text="Reserved for future use"/>
        </enumerator>
      </module>
      <module class="JTAG" text="">
        <registers name="JTAG" memspace="DATAMEM" text="" icon="io_com.bmp">
          <reg size="1" name="OCDR" offset="0x51" text="On-Chip Debug Register" icon="io_com.bmp">
            <bitfield name="OCDR" mask="0xFF" text="On-Chip Debug Register Data" icon="" enum="OCDR_DATA_BITF"/>
          </reg>
          <reg size="1" name="MCUCR" offset="0x55" text="MCU Control Register" icon="io_flag.bmp">
            <bitfield name="JTD" mask="0x80" text="JTAG Interface Disable" icon=""/>
          </reg>
          <reg size="1" name="MCUSR" offset="0x54" text="MCU Status Register" icon="io_flag.bmp">
            <bitfield name="JTRF" mask="0x10" text="JTAG Reset Flag" icon=""/>
          </reg>
        </registers>
        <enumerator name="OCDR_DATA_BITF">
          <enum val="0" text="Refer to the debugger documentation for further information on how to use this register."/>
        </enumerator>
      </module>
      <module class="EXTERNAL_INTERRUPT" text="">
        <registers name="EXTERNAL_INTERRUPT" memspace="DATAMEM" text="" icon="io_ext.bmp">
          <reg size="1" name="EICRA" offset="0x69" text="External Interrupt Control Register A" icon="io_flag.bmp">
            <bitfield name="ISC3" mask="0xC0" text="External Interrupt 3 Sense Control Bit" icon="" enum="INTERRUPT_SENSE_CONTROL3"/>
            <bitfield name="ISC2" mask="0x30" text="External Interrupt 2 Sense Control Bit" icon="" enum="INTERRUPT_SENSE_CONTROL3"/>
            <bitfield name="ISC1" mask="0x0C" text="External Interrupt 1 Sense Control Bit" icon="" enum="INTERRUPT_SENSE_CONTROL3"/>
            <bitfield name="ISC0" mask="0x03" text="External Interrupt 0 Sense Control Bit" icon="" enum="INTERRUPT_SENSE_CONTROL3"/>
          </reg>
          <reg size="1" name="EICRB" offset="0x6A" text="External Interrupt Control Register B" icon="io_flag.bmp">
            <bitfield name="ISC7" mask="0xC0" text="External Interrupt 7 Sense Control Bit" icon="" enum="INTERRUPT_SENSE_CONTROL3"/>
            <bitfield name="ISC6" mask="0x30" text="External Interrupt 6 Sense Control Bit" icon="" enum="INTERRUPT_SENSE_CONTROL3"/>
            <bitfield name="ISC5" mask="0x0C" text="External Interrupt 5 Sense Control Bit" icon="" enum="INTERRUPT_SENSE_CONTROL3"/>
            <bitfield name="ISC4" mask="0x03" text="External Interrupt 4 Sense Control Bit" icon="" enum="INTERRUPT_SENSE_CONTROL3"/>
          </reg>
          <reg size="1" name="EIMSK" offset="0x3D" text="External Interrupt Mask Register" icon="io_flag.bmp">
            <bitfield name="INT" mask="0xFF" text="External Interrupt Request Enable" icon="" enum="INTERRUPT_REQ_ENABLE_BITF"/>
          </reg>
          <reg size="1" name="EIFR" offset="0x3C" text="External Interrupt Flag Register" icon="io_flag.bmp">
            <bitfield name="INTF" mask="0xFF" text="External Interrupt Flag" icon="" enum="INTERRUPT_EXT_FLAG_BITF"/>
          </reg>
          <reg size="1" name="PCMSK2" offset="0x6D" text="Pin Change Mask Register 2" icon="io_flag.bmp">
            <bitfield name="PCINT" mask="0xFF" text="Pin Change Enable Mask" icon="" lsb="16"/>
          </reg>
          <reg size="1" name="PCMSK1" offset="0x6C" text="Pin Change Mask Register 1" icon="io_flag.bmp">
            <bitfield name="PCINT" mask="0xFF" text="Pin Change Enable Mask" icon="" lsb="8"/>
          </reg>
          <reg size="1" name="PCMSK0" offset="0x6B" text="Pin Change Mask Register 0" icon="io_flag.bmp" mask="0xFF"/>
          <reg size="1" name="PCIFR" offset="0x3B" text="Pin Change Interrupt Flag Register" icon="io_flag.bmp">
            <bitfield name="Res" mask="0xF8" text="Reserved Bit" icon=""/>
            <bitfield name="PCIF" mask="0x07" text="Pin Change Interrupt Flags" icon=""/>
          </reg>
          <reg size="1" name="PCICR" offset="0x68" text="Pin Change Interrupt Control Register" icon="io_flag.bmp">
            <bitfield name="Res" mask="0xF8" text="Reserved Bit" icon=""/>
            <bitfield name="PCIE" mask="0x07" text="Pin Change Interrupt Enables" icon=""/>
          </reg>
        </registers>
        <enumerator name="INTERRUPT_SENSE_CONTROL3">
          <enum val="0x00" text="The low level of INTn generates an interrupt request."/>
          <enum val="0x01" text="Any edge of INTn generates asynchronously an interrupt request."/>
          <enum val="0x02" text="The falling edge of INTn generates asynchronously an interrupt request."/>
          <enum val="0x03" text="The rising edge of INTn generates asynchronously an interrupt request."/>
        </enumerator>
        <enumerator name="INTERRUPT_REQ_ENABLE_BITF">
          <enum val="0x00" text="All external pin interrupts are disabled."/>
          <enum val="0xff" text="All external pin interrupts are enabled."/>
        </enumerator>
        <enumerator name="INTERRUPT_EXT_FLAG_BITF">
          <enum val="0x00" text="No edge or logic change on INT7:0 occurred."/>
          <enum val="0x01" text="A edge or logic change on INT0 occurred and triggered an interrupt request."/>
          <enum val="0x02" text="..."/>
          <enum val="0x80" text="A edge or logic change on INT7 occurred and triggered an interrupt request."/>
        </enumerator>
      </module>
      <module class="AD_CONVERTER" text="">
        <registers name="AD_CONVERTER" memspace="DATAMEM" text="" icon="io_analo.bmp">
          <reg size="1" name="ADMUX" offset="0x7C" text="The ADC Multiplexer Selection Register" icon="io_analo.bmp">
            <bitfield name="REFS" mask="0xC0" text="Reference Selection Bits" icon="" enum="ANALOG_ADC_V_REF9"/>
            <bitfield name="ADLAR" mask="0x20" text="ADC Left Adjust Result" icon=""/>
            <bitfield name="MUX" mask="0x1F" text="Analog Channel and Gain Selection Bits" icon=""/>
          </reg>
          <reg size="2" name="ADC" offset="0x78" text="ADC Data Register  Bytes" icon="io_analo.bmp" mask="0xFFFF"/>
          <reg size="1" name="ADCSRA" offset="0x7A" text="The ADC Control and Status Register A" icon="io_flag.bmp">
            <bitfield name="ADEN" mask="0x80" text="ADC Enable" icon=""/>
            <bitfield name="ADSC" mask="0x40" text="ADC Start Conversion" icon=""/>
            <bitfield name="ADATE" mask="0x20" text="ADC Auto Trigger Enable" icon=""/>
            <bitfield name="ADIF" mask="0x10" text="ADC Interrupt Flag" icon=""/>
            <bitfield name="ADIE" mask="0x08" text="ADC Interrupt Enable" icon=""/>
            <bitfield name="ADPS" mask="0x07" text="ADC  Prescaler Select Bits" icon="" enum="ANALIG_ADC_PRESCALER"/>
          </reg>
          <reg size="1" name="ADCSRB" offset="0x7B" text="The ADC Control and Status Register B" icon="io_flag.bmp">
            <bitfield name="AVDDOK" mask="0x80" text="AVDD Supply Voltage OK" icon=""/>
            <bitfield name="ACME" mask="0x40" text="Analog Comparator Multiplexer Enable" icon=""/>
            <bitfield name="REFOK" mask="0x20" text="Reference Voltage OK" icon=""/>
            <bitfield name="ACCH" mask="0x10" text="Analog Channel Change" icon=""/>
            <bitfield name="MUX5" mask="0x08" text="Analog Channel and Gain Selection Bits" icon=""/>
            <bitfield name="ADTS" mask="0x07" text="ADC Auto Trigger Source" icon="" enum="ANALIG_ADC_AUTO_TRIGGER"/>
          </reg>
          <reg size="1" name="ADCSRC" offset="0x77" text="The ADC Control and Status Register C" icon="io_flag.bmp">
            <bitfield name="ADTHT" mask="0xC0" text="ADC Track-and-Hold Time" icon="" enum="ANALOG_ADC_TRACK_AND_HOLD_TIME"/>
            <bitfield name="Res0" mask="0x20" text="Reserved" icon=""/>
            <bitfield name="ADSUT" mask="0x1F" text="ADC Start-up Time" icon="" enum="ANALOG_ADC_STARTUP_TIME"/>
          </reg>
          <reg size="1" name="DIDR2" offset="0x7D" text="Digital Input Disable Register 2" icon="io_analo.bmp">
            <bitfield name="ADC15D" mask="0x80" text="Reserved Bits" icon=""/>
            <bitfield name="ADC14D" mask="0x40" text="Reserved Bits" icon=""/>
            <bitfield name="ADC13D" mask="0x20" text="Reserved Bits" icon=""/>
            <bitfield name="ADC12D" mask="0x10" text="Reserved Bits" icon=""/>
            <bitfield name="ADC11D" mask="0x08" text="Reserved Bits" icon=""/>
            <bitfield name="ADC10D" mask="0x04" text="Reserved Bits" icon=""/>
            <bitfield name="ADC9D" mask="0x02" text="Reserved Bits" icon=""/>
            <bitfield name="ADC8D" mask="0x01" text="Reserved Bits" icon=""/>
          </reg>
          <reg size="1" name="DIDR0" offset="0x7E" text="Digital Input Disable Register 0" icon="io_analo.bmp">
            <bitfield name="ADC7D" mask="0x80" text="Disable ADC7:0 Digital Input" icon=""/>
            <bitfield name="ADC6D" mask="0x40" text="Disable ADC7:0 Digital Input" icon=""/>
            <bitfield name="ADC5D" mask="0x20" text="Disable ADC7:0 Digital Input" icon=""/>
            <bitfield name="ADC4D" mask="0x10" text="Disable ADC7:0 Digital Input" icon=""/>
            <bitfield name="ADC3D" mask="0x08" text="Disable ADC7:0 Digital Input" icon=""/>
            <bitfield name="ADC2D" mask="0x04" text="Disable ADC7:0 Digital Input" icon=""/>
            <bitfield name="ADC1D" mask="0x02" text="Disable ADC7:0 Digital Input" icon=""/>
            <bitfield name="ADC0D" mask="0x01" text="Disable ADC7:0 Digital Input" icon=""/>
          </reg>
        </registers>
        <enumerator name="ANALOG_ADC_V_REF9">
          <enum val="0x00" text="AREF, Internal reference voltage generation turned off"/>
          <enum val="0x01" text="AVDD with external capacitor at AREF pin"/>
          <enum val="0x02" text="Internal 1.5V Voltage Reference (no external capacitor at AREF pin)"/>
          <enum val="0x03" text="Internal 1.6V Voltage Reference (no external capacitor at AREF pin)"/>
        </enumerator>
        <enumerator name="ANALIG_ADC_PRESCALER">
          <enum val="0x00" text="2"/>
          <enum val="0x01" text="2"/>
          <enum val="0x02" text="4"/>
          <enum val="0x03" text="8"/>
          <enum val="0x04" text="16"/>
          <enum val="0x05" text="32"/>
          <enum val="0x06" text="64"/>
          <enum val="0x07" text="128"/>
        </enumerator>
        <enumerator name="ANALIG_ADC_AUTO_TRIGGER">
          <enum val="0x00" text="Free Running mode"/>
          <enum val="0x01" text="Analog Comparator"/>
          <enum val="0x02" text="External Interrupt Request 0"/>
          <enum val="0x03" text="Timer/Counter0 Compare Match A"/>
          <enum val="0x04" text="Timer/Counter0 Overflow"/>
          <enum val="0x05" text="Timer/Counter1 Compare Match B"/>
          <enum val="0x06" text="Timer/Counter1 Overflow"/>
          <enum val="0x07" text="Timer/Counter1 Capture Event"/>
        </enumerator>
        <enumerator name="ANALOG_ADC_TRACK_AND_HOLD_TIME">
          <enum val="0x00" text="Single ended: 1, differential 3 ADC clock cycles"/>
          <enum val="0x01" text="Single ended: 2, differential 5 ADC clock cycles"/>
          <enum val="0x02" text="Single ended: 3, differential 7 ADC clock cycles"/>
          <enum val="0x03" text="Single ended: 4, differential 9 ADC clock cycles"/>
        </enumerator>
        <enumerator name="ANALOG_ADC_STARTUP_TIME">
          <enum val="0x00" text="3 ADC clock cycles"/>
          <enum val="0x01" text="7 ADC clock cycles"/>
          <enum val="0x02" text="11 ADC clock cycles"/>
          <enum val="0x03" text="15 ADC clock cycles"/>
          <enum val="0x04" text="..."/>
          <enum val="0x3E" text="251 ADC clock cycles"/>
          <enum val="0x3F" text="255 ADC clock cycles"/>
        </enumerator>
      </module>
      <module class="BOOT_LOAD" text="">
        <registers name="BOOT_LOAD" memspace="DATAMEM" text="" icon="io_cpu.bmp">
          <reg size="1" name="SPMCSR" offset="0x57" text="Store Program Memory Control Register" icon="io_flag.bmp">
            <bitfield name="SPMIE" mask="0x80" text="SPM Interrupt Enable" icon=""/>
            <bitfield name="RWWSB" mask="0x40" text="Read While Write Section Busy" icon=""/>
            <bitfield name="SIGRD" mask="0x20" text="Signature Row Read" icon=""/>
            <bitfield name="RWWSRE" mask="0x10" text="Read While Write Section Read Enable" icon=""/>
            <bitfield name="BLBSET" mask="0x08" text="Boot Lock Bit Set" icon=""/>
            <bitfield name="PGWRT" mask="0x04" text="Page Write" icon=""/>
            <bitfield name="PGERS" mask="0x02" text="Page Erase" icon=""/>
            <bitfield name="SPMEN" mask="0x01" text="Store Program Memory Enable" icon=""/>
          </reg>
        </registers>
      </module>
      <module class="CPU" text="">
        <registers name="CPU" memspace="DATAMEM" text="" icon="io_cpu.bmp">
          <reg size="1" name="SREG" offset="0x5F" text="Status Register" icon="io_sreg.bmp">
            <bitfield name="I" mask="0x80" text="Global Interrupt Enable" icon=""/>
            <bitfield name="T" mask="0x40" text="Bit Copy Storage" icon=""/>
            <bitfield name="H" mask="0x20" text="Half Carry Flag" icon=""/>
            <bitfield name="S" mask="0x10" text="Sign Bit" icon=""/>
            <bitfield name="V" mask="0x08" text="Two's Complement Overflow Flag" icon=""/>
            <bitfield name="N" mask="0x04" text="Negative Flag" icon=""/>
            <bitfield name="Z" mask="0x02" text="Zero Flag" icon=""/>
            <bitfield name="C" mask="0x01" text="Carry Flag" icon=""/>
          </reg>
          <reg size="2" name="SP" offset="0x5D" text="Stack Pointer " icon="io_sph.bmp" mask="0xFFFF"/>
          <reg size="1" name="MCUCR" offset="0x55" text="MCU Control Register" icon="io_flag.bmp">
            <bitfield name="JTD" mask="0x80" text="JTAG Interface Disable" icon=""/>
            <bitfield name="Res" mask="0x60" text="Reserved" icon=""/>
            <bitfield name="PUD" mask="0x10" text="Pull-up Disable" icon=""/>
            <bitfield name="Res" mask="0x0C" text="Reserved" icon=""/>
            <bitfield name="IVSEL" mask="0x02" text="Interrupt Vector Select" icon=""/>
            <bitfield name="IVCE" mask="0x01" text="Interrupt Vector Change Enable" icon=""/>
          </reg>
          <reg size="1" name="MCUSR" offset="0x54" text="MCU Status Register" icon="io_flag.bmp">
            <bitfield name="Res" mask="0xE0" text="Reserved" icon=""/>
            <bitfield name="JTRF" mask="0x10" text="JTAG Reset Flag" icon=""/>
            <bitfield name="WDRF" mask="0x08" text="Watchdog Reset Flag" icon=""/>
            <bitfield name="BORF" mask="0x04" text="Brown-out Reset Flag" icon=""/>
            <bitfield name="EXTRF" mask="0x02" text="External Reset Flag" icon=""/>
            <bitfield name="PORF" mask="0x01" text="Power-on Reset Flag" icon=""/>
          </reg>
          <reg size="1" name="OSCCAL" offset="0x66" text="Oscillator Calibration Value" icon="io_cpu.bmp">
            <bitfield name="CAL" mask="0xFF" text="Oscillator Calibration Tuning Value" icon="" enum="OSCCAL_BITF"/>
          </reg>
          <reg size="1" name="CLKPR" offset="0x61" text="Clock Prescale Register" icon="io_cpu.bmp">
            <bitfield name="CLKPCE" mask="0x80" text="Clock Prescaler Change Enable" icon=""/>
            <bitfield name="Res" mask="0x70" text="Reserved" icon=""/>
            <bitfield name="CLKPS" mask="0x0F" text="Clock Prescaler Select Bits" icon="" enum="CPU_CLK_PRESCALE_4_BITS_SMALL_MEGARF"/>
          </reg>
          <reg size="1" name="SMCR" offset="0x53" text="Sleep Mode Control Register" icon="io_cpu.bmp">
            <bitfield name="Res" mask="0xF0" text="Reserved" icon=""/>
            <bitfield name="SM" mask="0x0E" text="Sleep Mode Select bits" icon="" enum="CPU_SLEEP_MODE_3BITS"/>
            <bitfield name="SE" mask="0x01" text="Sleep Enable" icon=""/>
          </reg>
          <reg size="1" name="RAMPZ" offset="0x5B" text="Extended Z-pointer Register for ELPM/SPM" icon="io_cpu.bmp">
            <bitfield name="Res" mask="0xFC" text="Reserved" icon=""/>
            <bitfield name="RAMPZ" mask="0x03" text="Extended Z-Pointer Value" icon="" enum="RAMPZ_BITF"/>
          </reg>
          <reg size="1" name="GPIOR2" offset="0x4B" text="General Purpose I/O Register 2" icon="io_cpu.bmp">
            <bitfield name="GPIOR" mask="0xFF" text="General Purpose I/O Register 2 Value" icon="" lsb="20"/>
          </reg>
          <reg size="1" name="GPIOR1" offset="0x4A" text="General Purpose IO Register 1" icon="io_cpu.bmp">
            <bitfield name="GPIOR" mask="0xFF" text="General Purpose I/O Register 1 Value" icon="" lsb="10"/>
          </reg>
          <reg size="1" name="GPIOR0" offset="0x3E" text="General Purpose IO Register 0" icon="io_cpu.bmp">
            <bitfield name="GPIOR07" mask="0x80" text="General Purpose I/O Register 0 Value" icon=""/>
            <bitfield name="GPIOR06" mask="0x40" text="General Purpose I/O Register 0 Value" icon=""/>
            <bitfield name="GPIOR05" mask="0x20" text="General Purpose I/O Register 0 Value" icon=""/>
            <bitfield name="GPIOR04" mask="0x10" text="General Purpose I/O Register 0 Value" icon=""/>
            <bitfield name="GPIOR03" mask="0x08" text="General Purpose I/O Register 0 Value" icon=""/>
            <bitfield name="GPIOR02" mask="0x04" text="General Purpose I/O Register 0 Value" icon=""/>
            <bitfield name="GPIOR01" mask="0x02" text="General Purpose I/O Register 0 Value" icon=""/>
            <bitfield name="GPIOR00" mask="0x01" text="General Purpose I/O Register 0 Value" icon=""/>
          </reg>
          <reg size="1" name="PRR2" offset="0x63" text="Power Reduction Register 2" icon="io_cpu.bmp">
            <bitfield name="Res" mask="0xF0" text="Reserved Bit" icon=""/>
            <bitfield name="PRRAM" mask="0x0F" text="Power Reduction SRAMs" icon=""/>
          </reg>
          <reg size="1" name="PRR1" offset="0x65" text="Power Reduction Register 1" icon="io_cpu.bmp">
            <bitfield name="Res" mask="0x80" text="Reserved Bit" icon=""/>
            <bitfield name="PRTRX24" mask="0x40" text="Power Reduction Transceiver" icon=""/>
            <bitfield name="PRTIM5" mask="0x20" text="Power Reduction Timer/Counter5" icon=""/>
            <bitfield name="PRTIM4" mask="0x10" text="Power Reduction Timer/Counter4" icon=""/>
            <bitfield name="PRTIM3" mask="0x08" text="Power Reduction Timer/Counter3" icon=""/>
            <bitfield name="PRUSART" mask="0x07" text="Reserved" icon="" lsb="1"/>
          </reg>
          <reg size="1" name="PRR0" offset="0x64" text="Power Reduction Register0" icon="io_cpu.bmp">
            <bitfield name="PRTWI" mask="0x80" text="Power Reduction TWI" icon=""/>
            <bitfield name="PRTIM2" mask="0x40" text="Power Reduction Timer/Counter2" icon=""/>
            <bitfield name="PRTIM0" mask="0x20" text="Power Reduction Timer/Counter0" icon=""/>
            <bitfield name="PRPGA" mask="0x10" text="Power Reduction PGA" icon=""/>
            <bitfield name="PRTIM1" mask="0x08" text="Power Reduction Timer/Counter1" icon=""/>
            <bitfield name="PRSPI" mask="0x04" text="Power Reduction Serial Peripheral Interface" icon=""/>
            <bitfield name="PRUSART0" mask="0x02" text="Power Reduction USART" icon=""/>
            <bitfield name="PRADC" mask="0x01" text="Power Reduction ADC" icon=""/>
          </reg>
        </registers>
        <enumerator name="OSCCAL_BITF">
          <enum val="0x00" text="Calibration value for lowest oscillator frequency"/>
          <enum val="0x7f" text="End value of low frequency range calibration"/>
          <enum val="0x80" text="Start value of high frequency range calibration"/>
          <enum val="0xff" text="Calibration value for highest oscillator frequency"/>
        </enumerator>
        <enumerator name="CPU_CLK_PRESCALE_4_BITS_SMALL_MEGARF">
          <enum val="0x0" text="Division factor 1   / RC-Oscillator   2"/>
          <enum val="0x1" text="Division factor 2   / RC-Oscillator   4"/>
          <enum val="0x2" text="Division factor 4   / RC-Oscillator   8"/>
          <enum val="0x3" text="Division factor 8   / RC-Oscillator  16"/>
          <enum val="0x4" text="Division factor 16  / RC-Oscillator  32"/>
          <enum val="0x5" text="Division factor 32  / RC-Oscillator  64"/>
          <enum val="0x6" text="Division factor 64  / RC-Oscillator 128"/>
          <enum val="0x7" text="Division factor 128 / RC-Oscillator 256"/>
          <enum val="0x8" text="Division factor 256 / RC-Oscillator 512"/>
          <enum val="0x9" text="Reserved"/>
          <enum val="0xA" text="Reserved"/>
          <enum val="0xB" text="Reserved"/>
          <enum val="0xC" text="Reserved"/>
          <enum val="0xD" text="Reserved"/>
          <enum val="0xE" text="Reserved"/>
          <enum val="0xF" text="Division factor 1 only permitted for RC-Oscillator. Flash and EEPROM programming is not allowed."/>
        </enumerator>
        <enumerator name="CPU_SLEEP_MODE_3BITS">
          <enum val="0x00" text="Idle"/>
          <enum val="0x01" text="ADC Noise Reduction (If Available)"/>
          <enum val="0x02" text="Power Down"/>
          <enum val="0x03" text="Power Save"/>
          <enum val="0x04" text="Reserved"/>
          <enum val="0x05" text="Reserved"/>
          <enum val="0x06" text="Standby"/>
          <enum val="0x07" text="Extended Standby"/>
        </enumerator>
        <enumerator name="RAMPZ_BITF">
          <enum val="0" text="Default value of Z-pointer MSB's."/>
        </enumerator>
      </module>
      <module class="FLASH" text="">
        <registers name="FLASH" memspace="DATAMEM" text="" icon="io_flash.bmp">
          <reg size="1" name="NEMCR" offset="0x75" text="Flash Extended-Mode Control-Register" icon="io_flash.bmp">
            <bitfield name="ENEAM" mask="0x40" text="Enable Extended Address Mode for Extra Rows" icon=""/>
            <bitfield name="AEAM" mask="0x30" text="Address for Extended Address Mode of Extra Rows" icon="" enum="NEMCR_ADDRESS_BITF"/>
          </reg>
          <reg size="1" name="BGCR" offset="0x67" text="Reference Voltage Calibration Register" icon="io_flash.bmp">
            <bitfield name="Res" mask="0x80" text="Reserved Bit" icon=""/>
            <bitfield name="BGCAL_FINE" mask="0x78" text="Fine Calibration Bits" icon="" enum="BGCAL_FINE_BITF"/>
            <bitfield name="BGCAL" mask="0x07" text="Coarse Calibration Bits" icon="" enum="BGCAL_BITF"/>
          </reg>
        </registers>
        <enumerator name="NEMCR_ADDRESS_BITF">
          <enum val="0" text="Factory Row"/>
          <enum val="1" text="User Row 1"/>
          <enum val="2" text="User Row 2"/>
          <enum val="3" text="User Row 3"/>
        </enumerator>
        <enumerator name="BGCAL_FINE_BITF">
          <enum val="0" text="Center value"/>
          <enum val="1" text="Voltage step up"/>
          <enum val="8" text="Voltage step down"/>
          <enum val="7" text="Setting for highest voltage"/>
          <enum val="15" text="Setting for lowest voltage"/>
        </enumerator>
        <enumerator name="BGCAL_BITF">
          <enum val="4" text="Center value"/>
          <enum val="3" text="Voltage step up"/>
          <enum val="5" text="Voltage step down"/>
          <enum val="0" text="Setting for highest voltage"/>
          <enum val="7" text="Setting for lowest voltage"/>
        </enumerator>
      </module>
      <module class="PWRCTRL" text="">
        <registers name="PWRCTRL" memspace="DATAMEM" text="" icon="io_pwrctrl.bmp">
          <reg size="1" name="TRXPR" offset="0x139" text="Transceiver Pin Register" icon="io_flag.bmp">
            <bitfield name="Res" mask="0xF0" text="Reserved" icon=""/>
            <bitfield name="SLPTR" mask="0x02" text="Multi-purpose Transceiver Control Bit" icon=""/>
            <bitfield name="TRXRST" mask="0x01" text="Force Transceiver Reset" icon=""/>
          </reg>
          <reg size="1" name="DRTRAM0" offset="0x135" text="Data Retention Configuration Register of SRAM 0" icon="io_flag.bmp">
            <bitfield name="Res" mask="0xC0" text="Reserved" icon=""/>
            <bitfield name="DRTSWOK" mask="0x20" text="DRT Switch OK" icon=""/>
            <bitfield name="ENDRT" mask="0x10" text="Enable SRAM Data Retention" icon=""/>
          </reg>
          <reg size="1" name="DRTRAM1" offset="0x134" text="Data Retention Configuration Register of SRAM 1" icon="io_flag.bmp">
            <bitfield name="Res" mask="0xC0" text="Reserved" icon=""/>
            <bitfield name="DRTSWOK" mask="0x20" text="DRT Switch OK" icon=""/>
            <bitfield name="ENDRT" mask="0x10" text="Enable SRAM Data Retention" icon=""/>
          </reg>
          <reg size="1" name="DRTRAM2" offset="0x133" text="Data Retention Configuration Register of SRAM 2" icon="io_flag.bmp">
            <bitfield name="Res" mask="0x40" text="Reserved Bit" icon=""/>
            <bitfield name="DRTSWOK" mask="0x20" text="DRT Switch OK" icon=""/>
            <bitfield name="ENDRT" mask="0x10" text="Enable SRAM Data Retention" icon=""/>
          </reg>
          <reg size="1" name="DRTRAM3" offset="0x132" text="Data Retention Configuration Register of SRAM 3" icon="io_flag.bmp">
            <bitfield name="Res" mask="0xC0" text="Reserved" icon=""/>
            <bitfield name="DRTSWOK" mask="0x20" text="DRT Switch OK" icon=""/>
            <bitfield name="ENDRT" mask="0x10" text="Enable SRAM Data Retention" icon=""/>
          </reg>
          <reg size="1" name="LLDRL" offset="0x130" text="Low Leakage Voltage Regulator Data Register (Low-Byte)" icon="io_flag.bmp">
            <bitfield name="Res" mask="0xF0" text="Reserved" icon=""/>
            <bitfield name="LLDRL" mask="0x0F" text="Low-Byte Data Register Bits" icon="" enum="LLDRL_VALUE_BITF"/>
          </reg>
          <reg size="1" name="LLDRH" offset="0x131" text="Low Leakage Voltage Regulator Data Register (High-Byte)" icon="io_flag.bmp">
            <bitfield name="Res" mask="0xE0" text="Reserved" icon=""/>
            <bitfield name="LLDRH" mask="0x1F" text="High-Byte Data Register Bits" icon="" enum="LLDRH_VALUE_BITF"/>
          </reg>
          <reg size="1" name="LLCR" offset="0x12F" text="Low Leakage Voltage Regulator Control Register" icon="io_flag.bmp">
            <bitfield name="Res" mask="0xC0" text="Reserved Bit" icon=""/>
            <bitfield name="LLDONE" mask="0x20" text="Calibration Done" icon=""/>
            <bitfield name="LLCOMP" mask="0x10" text="Comparator Output" icon=""/>
            <bitfield name="LLCAL" mask="0x08" text="Calibration Active" icon=""/>
            <bitfield name="LLTCO" mask="0x04" text="Temperature Coefficient of Current Source" icon=""/>
            <bitfield name="LLSHORT" mask="0x02" text="Short Lower Calibration Circuit" icon=""/>
            <bitfield name="LLENCAL" mask="0x01" text="Enable Automatic Calibration" icon=""/>
          </reg>
          <reg size="1" name="DPDS0" offset="0x136" text="Port Driver Strength Register 0" icon="io_flag.bmp">
            <bitfield name="PFDRV" mask="0xC0" text="Driver Strength Port F" icon="" enum="PAD_IO_bitf"/>
            <bitfield name="PEDRV" mask="0x30" text="Driver Strength Port E" icon="" enum="PAD_IO_bitf"/>
            <bitfield name="PDDRV" mask="0x0C" text="Driver Strength Port D" icon="" enum="PAD_IO_bitf"/>
            <bitfield name="PBDRV" mask="0x03" text="Driver Strength Port B" icon="" enum="PAD_IO_bitf"/>
          </reg>
          <reg size="1" name="DPDS1" offset="0x137" text="Port Driver Strength Register 1" icon="io_flag.bmp">
            <bitfield name="Res" mask="0xFC" text="Reserved" icon=""/>
            <bitfield name="PGDRV" mask="0x03" text="Driver Strength Port G" icon="" enum="PAD_IO_bitf"/>
          </reg>
          <reg size="1" name="MCUCR" offset="0x55" text="MCU Control Register" icon="io_flag.bmp">
            <bitfield name="PUD" mask="0x10" text="Pull-up Disable" icon=""/>
          </reg>
        </registers>
        <enumerator name="LLDRL_VALUE_BITF">
          <enum val="0x00" text="Calibration limit for fast process corner/high output voltage"/>
          <enum val="0x08" text="Calibration limit for slow process corner/low output voltage"/>
        </enumerator>
        <enumerator name="LLDRH_VALUE_BITF">
          <enum val="0x00" text="Calibration limit for fast process corner/high output voltage"/>
          <enum val="0x10" text="Calibration limit for slow process corner/low output voltage"/>
        </enumerator>
        <enumerator name="PAD_IO_bitf">
          <enum val="0" text="2 mA" constname="PAD_IO_2MA"/>
          <enum val="1" text="4 mA" constname="PAD_IO_4MA"/>
          <enum val="2" text="6 mA" constname="PAD_IO_6MA"/>
          <enum val="3" text="8 mA" constname="PAD_IO_8MA"/>
        </enumerator>
      </module>
      <module class="USART0_SPI" text="">
        <registers name="USART0_SPI" memspace="DATAMEM" text="" icon="io_com.bmp">
          <reg size="1" name="UCSR0A" offset="0xC0" text="USART0 MSPIM Control and Status Register A" icon="io_flag.bmp">
            <bitfield name="RXC0" mask="0x80" text="USART Receive Complete" icon=""/>
            <bitfield name="TXC0" mask="0x40" text="USART Transmit Complete" icon=""/>
            <bitfield name="UDRE0" mask="0x20" text="USART Data Register Empty" icon=""/>
          </reg>
          <reg size="1" name="UCSR0B" offset="0xC1" text="USART0 MSPIM Control and Status Register B" icon="io_flag.bmp">
            <bitfield name="RXCIE0" mask="0x80" text="RX Complete Interrupt Enable" icon=""/>
            <bitfield name="TXCIE0" mask="0x40" text="TX Complete Interrupt Enable" icon=""/>
            <bitfield name="UDRIE0" mask="0x20" text="USART Data Register Empty Interrupt Enable" icon=""/>
            <bitfield name="RXEN0" mask="0x10" text="Receiver Enable" icon=""/>
            <bitfield name="TXEN0" mask="0x08" text="Transmitter Enable" icon=""/>
          </reg>
          <reg size="1" name="UCSR0C" offset="0xC2" text="USART0 MSPIM Control and Status Register C" icon="io_flag.bmp">
            <bitfield name="UDORD0" mask="0x04" text="Data Order" icon=""/>
            <bitfield name="UCPHA0" mask="0x02" text="Clock Phase" icon=""/>
            <bitfield name="UCPOL0" mask="0x01" text="Clock Polarity" icon=""/>
          </reg>
        </registers>
      </module>
      <module class="USART1_SPI" text="">
        <registers name="USART1_SPI" memspace="DATAMEM" text="" icon="io_com.bmp">
          <reg size="1" name="UCSR1A" offset="0xC8" text="USART1 MSPIM Control and Status Register A" icon="io_flag.bmp">
            <bitfield name="RXC1" mask="0x80" text="USART Receive Complete" icon=""/>
            <bitfield name="TXC1" mask="0x40" text="USART Transmit Complete" icon=""/>
            <bitfield name="UDRE1" mask="0x20" text="USART Data Register Empty" icon=""/>
          </reg>
          <reg size="1" name="UCSR1B" offset="0xC9" text="USART1 MSPIM Control and Status Register B" icon="io_flag.bmp">
            <bitfield name="RXCIE1" mask="0x80" text="RX Complete Interrupt Enable" icon=""/>
            <bitfield name="TXCIE1" mask="0x40" text="TX Complete Interrupt Enable" icon=""/>
            <bitfield name="UDRIE1" mask="0x20" text="USART Data Register Empty Interrupt Enable" icon=""/>
            <bitfield name="RXEN1" mask="0x10" text="Receiver Enable" icon=""/>
            <bitfield name="TXEN1" mask="0x08" text="Transmitter Enable" icon=""/>
          </reg>
          <reg size="1" name="UCSR1C" offset="0xCA" text="USART1 MSPIM Control and Status Register C" icon="io_flag.bmp">
            <bitfield name="UDORD1" mask="0x04" text="Data Order" icon=""/>
            <bitfield name="UCPHA1" mask="0x02" text="Clock Phase" icon=""/>
            <bitfield name="UCPOL1" mask="0x01" text="Clock Polarity" icon=""/>
          </reg>
        </registers>
      </module>
    </templates>
    <modules>
      <module implements="ANALOG_COMPARATOR" name="ANALOG_COMPARATOR">
        <registers implements="ANALOG_COMPARATOR" name="ANALOG_COMPARATOR" offset="0x00" text=""/>
      </module>
      <module implements="USART0" name="USART0">
        <registers implements="USART0" name="USART0" offset="0x00" text=""/>
      </module>
      <module implements="USART1" name="USART1">
        <registers implements="USART1" name="USART1" offset="0x00" text=""/>
      </module>
      <module implements="TWI" name="TWI">
        <registers implements="TWI" name="TWI" offset="0x00" text=""/>
      </module>
      <module implements="SPI" name="SPI">
        <registers implements="SPI" name="SPI" offset="0x00" text=""/>
      </module>
      <module implements="PORTA" name="PORTA">
        <registers implements="PORTA" name="PORTA" offset="0x00" text=""/>
      </module>
      <module implements="PORTB" name="PORTB">
        <registers implements="PORTB" name="PORTB" offset="0x00" text=""/>
      </module>
      <module implements="PORTC" name="PORTC">
        <registers implements="PORTC" name="PORTC" offset="0x00" text=""/>
      </module>
      <module implements="PORTD" name="PORTD">
        <registers implements="PORTD" name="PORTD" offset="0x00" text=""/>
      </module>
      <module implements="PORTE" name="PORTE">
        <registers implements="PORTE" name="PORTE" offset="0x00" text=""/>
      </module>
      <module implements="PORTF" name="PORTF">
        <registers implements="PORTF" name="PORTF" offset="0x00" text=""/>
      </module>
      <module implements="PORTG" name="PORTG">
        <registers implements="PORTG" name="PORTG" offset="0x00" text=""/>
      </module>
      <module implements="TIMER_COUNTER_0" name="TIMER_COUNTER_0">
        <registers implements="TIMER_COUNTER_0" name="TIMER_COUNTER_0" offset="0x00" text=""/>
      </module>
      <module implements="TIMER_COUNTER_2" name="TIMER_COUNTER_2">
        <registers implements="TIMER_COUNTER_2" name="TIMER_COUNTER_2" offset="0x00" text=""/>
      </module>
      <module implements="WATCHDOG" name="WATCHDOG">
        <registers implements="WATCHDOG" name="WATCHDOG" offset="0x00" text=""/>
      </module>
      <module implements="TIMER_COUNTER_5" name="TIMER_COUNTER_5">
        <registers implements="TIMER_COUNTER_5" name="TIMER_COUNTER_5" offset="0x00" text=""/>
      </module>
      <module implements="TIMER_COUNTER_4" name="TIMER_COUNTER_4">
        <registers implements="TIMER_COUNTER_4" name="TIMER_COUNTER_4" offset="0x00" text=""/>
      </module>
      <module implements="TIMER_COUNTER_3" name="TIMER_COUNTER_3">
        <registers implements="TIMER_COUNTER_3" name="TIMER_COUNTER_3" offset="0x00" text=""/>
      </module>
      <module implements="TIMER_COUNTER_1" name="TIMER_COUNTER_1">
        <registers implements="TIMER_COUNTER_1" name="TIMER_COUNTER_1" offset="0x00" text=""/>
      </module>
      <module implements="TRX24" name="TRX24">
        <registers implements="TRX24" name="TRX24" offset="0x00" text=""/>
      </module>
      <module implements="SYMCNT" name="SYMCNT">
        <registers implements="SYMCNT" name="SYMCNT" offset="0x00" text=""/>
      </module>
      <module implements="EEPROM" name="EEPROM">
        <registers implements="EEPROM" name="EEPROM" offset="0x00" text=""/>
      </module>
      <module implements="JTAG" name="JTAG">
        <registers implements="JTAG" name="JTAG" offset="0x00" text=""/>
      </module>
      <module implements="EXTERNAL_INTERRUPT" name="EXTERNAL_INTERRUPT">
        <registers implements="EXTERNAL_INTERRUPT" name="EXTERNAL_INTERRUPT" offset="0x00" text=""/>
      </module>
      <module implements="AD_CONVERTER" name="AD_CONVERTER">
        <registers implements="AD_CONVERTER" name="AD_CONVERTER" offset="0x00" text=""/>
      </module>
      <module implements="BOOT_LOAD" name="BOOT_LOAD">
        <registers implements="BOOT_LOAD" name="BOOT_LOAD" offset="0x00" text=""/>
      </module>
      <module implements="CPU" name="CPU">
        <registers implements="CPU" name="CPU" offset="0x00" text=""/>
      </module>
      <module implements="FLASH" name="FLASH">
        <registers implements="FLASH" name="FLASH" offset="0x00" text=""/>
      </module>
      <module implements="PWRCTRL" name="PWRCTRL">
        <registers implements="PWRCTRL" name="PWRCTRL" offset="0x00" text=""/>
      </module>
      <module implements="USART0_SPI" name="USART0_SPI">
        <registers implements="USART0_SPI" name="USART0_SPI" offset="0x00" text=""/>
      </module>
      <module implements="USART1_SPI" name="USART1_SPI">
        <registers implements="USART1_SPI" name="USART1_SPI" offset="0x00" text=""/>
      </module>
    </modules>
    <fuses>
      <fuse implements="FUSE" name="FUSE">
        <registers implements="FUSE" name="FUSE"/>
      </fuse>
    </fuses>
    <lockbits>
      <lockbit implements="LOCKBIT" name="LOCKBIT">
        <registers implements="LOCKBIT" name="LOCKBIT"/>
      </lockbit>
    </lockbits>
  </V2>
</AVRPART>

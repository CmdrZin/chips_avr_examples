<?xml version="1.0"?>
<AVRPART>
  <MODULE_LIST>[CORE:LOCKBIT:ADMIN:FUSE:INTERRUPT_VECTOR:MEMORY:PACKAGE:PROGRAMMING:IO_MODULE:ICE_SETTINGS]</MODULE_LIST>
  <CORE>
    <CORE_VERSION>AVR8L_0</CORE_VERSION>
    <ID/>
    <INSTRUCTION_SET>AVR8L</INSTRUCTION_SET>
    <NEW_INSTRUCTIONS>[]</NEW_INSTRUCTIONS>
    <INSTRUCTIONS_NOT_SUPPORTED>[]</INSTRUCTIONS_NOT_SUPPORTED>
    <RAMP_REGISTERS>[]</RAMP_REGISTERS>
    <GP_REG_FILE>
      <NMB_REG>16</NMB_REG>
      <START_ADDR>$10</START_ADDR>
      <X_REG_HIGH>27</X_REG_HIGH>
      <X_REG_LOW>26</X_REG_LOW>
      <Y_REG_HIGH>29</Y_REG_HIGH>
      <Y_REG_LOW>28</Y_REG_LOW>
      <Z_REG_HIGH>31</Z_REG_HIGH>
      <Z_REG_LOW>30</Z_REG_LOW>
    </GP_REG_FILE>
  </CORE>
  <LOCKBIT>
    <ICON/>
    <ID/>
    <TEXT>[LB1 = 1 :  LB2 = 1] No memory lock features enabled. [LB1 = 0 :  LB2 = 1] Further programming of Flash and EEPROM is enabled. [LB1 = 0 :  LB2 = 0] Same as previous, but verify is also disabled</TEXT>
    <NMB_TEXT>3</NMB_TEXT>
    <NMB_LOCK_BITS>2</NMB_LOCK_BITS>
    <TEXT1>
      <MASK>0x03</MASK>
      <VALUE>0x03</VALUE>
      <TEXT>Mode 1: No memory lock features enabled</TEXT>
    </TEXT1>
    <TEXT2>
      <MASK>0x03</MASK>
      <VALUE>0x02</VALUE>
      <TEXT>Mode 2: Further programming disabled</TEXT>
    </TEXT2>
    <TEXT3>
      <MASK>0x03</MASK>
      <VALUE>0x00</VALUE>
      <TEXT>Mode 3: Further programming and verification disabled</TEXT>
    </TEXT3>
    <LOCKBIT0>
      <NAME>LB1</NAME>
      <TEXT>Lockbit</TEXT>
    </LOCKBIT0>
    <LOCKBIT1>
      <NAME>LB2</NAME>
      <TEXT>Lockbit</TEXT>
    </LOCKBIT1>
  </LOCKBIT>
  <ADMIN>
    <PART_NAME>ATtiny20</PART_NAME>
    <SPEED>12MHZ</SPEED>
    <BUILD>1</BUILD>
    <RELEASE_STATUS>RELEASED</RELEASE_STATUS>
    <SIGNATURE>
      <ADDR000>$1E</ADDR000>
      <ADDR001>$91</ADDR001>
      <ADDR002>$0F</ADDR002>
    </SIGNATURE>
  </ADMIN>
  <FUSE>
    <LIST>[BYTE0]</LIST>
    <ICON/>
    <ID/>
    <TEXT/>
    <BYTE0>
      <NMB_FUSE_BITS>6</NMB_FUSE_BITS>
      <FUSE6>
        <NAME>BODLEVEL2</NAME>
        <TEXT>Brown-out Detector trigger level</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE6>
      <FUSE5>
        <NAME>BODLEVEL1</NAME>
        <TEXT>Brown-out Detector trigger level</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE5>
      <FUSE4>
        <NAME>BODLEVEL0</NAME>
        <TEXT>Brown-out Detector trigger level</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE4>
      <FUSE2>
        <NAME>CKOUT</NAME>
        <TEXT>Output external clock</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE2>
      <FUSE2>
        <NAME>CKOUT</NAME>
        <TEXT>Output external clock</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE2>
      <FUSE1>
        <NAME>WDTON</NAME>
        <TEXT>Watch dog timer always on</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE1>
      <FUSE0>
        <NAME>RSTDISBL</NAME>
        <TEXT>Disable external reset</TEXT>
        <DEFAULT>1</DEFAULT>
      </FUSE0>
      <NMB_TEXT>7</NMB_TEXT>
      <TEXT1>
        <MASK>0x70</MASK>
        <VALUE>0x07</VALUE>
        <TEXT>Brown-out detection disabled; [BODLEVEL=111]</TEXT>
      </TEXT1>
      <TEXT2>
        <MASK>0x70</MASK>
        <VALUE>0x06</VALUE>
        <TEXT>Brown-out detection level at VCC=1.8 V; [BODLEVEL=110]</TEXT>
      </TEXT2>
      <TEXT3>
        <MASK>0x70</MASK>
        <VALUE>0x05</VALUE>
        <TEXT>Brown-out detection level at VCC=2.7 V; [BODLEVEL=101]</TEXT>
      </TEXT3>
      <TEXT4>
        <MASK>0x70</MASK>
        <VALUE>0x04</VALUE>
        <TEXT>Brown-out detection level at VCC=4.3 V; [BODLEVEL=100]</TEXT>
      </TEXT4>
      <TEXT5>
        <MASK>0x04</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Output external clock</TEXT>
      </TEXT5>
      <TEXT6>
        <MASK>0x02</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Watch dog timer always on</TEXT>
      </TEXT6>
      <TEXT7>
        <MASK>0x01</MASK>
        <VALUE>0x00</VALUE>
        <TEXT>Disable external reset</TEXT>
      </TEXT7>
    </BYTE0>
  </FUSE>
  <INTERRUPT_VECTOR>
    <NMB_VECTORS>17</NMB_VECTORS>
    <VECTOR1>
      <PROGRAM_ADDRESS>$000</PROGRAM_ADDRESS>
      <SOURCE>RESET</SOURCE>
      <DEFINITION>External Reset, Power-on Reset and Watchdog Reset</DEFINITION>
    </VECTOR1>
    <VECTOR2>
      <PROGRAM_ADDRESS>$001</PROGRAM_ADDRESS>
      <SOURCE>INT0</SOURCE>
      <DEFINITION>External Interrupt Request 0</DEFINITION>
    </VECTOR2>
    <VECTOR3>
      <PROGRAM_ADDRESS>$002</PROGRAM_ADDRESS>
      <SOURCE>PCINT0</SOURCE>
      <DEFINITION>Pin Change Interrupt Request 0</DEFINITION>
    </VECTOR3>
    <VECTOR4>
      <PROGRAM_ADDRESS>$003</PROGRAM_ADDRESS>
      <SOURCE>PCINT1</SOURCE>
      <DEFINITION>Pin Change Interrupt Request 1</DEFINITION>
    </VECTOR4>
    <VECTOR5>
      <PROGRAM_ADDRESS>$004</PROGRAM_ADDRESS>
      <SOURCE>WDT</SOURCE>
      <DEFINITION>Watchdog Time-out</DEFINITION>
    </VECTOR5>
    <VECTOR6>
      <PROGRAM_ADDRESS>$005</PROGRAM_ADDRESS>
      <SOURCE>TIM1_CAPT</SOURCE>
      <DEFINITION>Timer/Counter1 Input Capture</DEFINITION>
    </VECTOR6>
    <VECTOR7>
      <PROGRAM_ADDRESS>$006</PROGRAM_ADDRESS>
      <SOURCE>TIM1_COMPA</SOURCE>
      <DEFINITION> Timer/Counter1 Compare Match A</DEFINITION>
    </VECTOR7>
    <VECTOR8>
      <PROGRAM_ADDRESS>$007</PROGRAM_ADDRESS>
      <SOURCE>TIM1_COMPB</SOURCE>
      <DEFINITION> Timer/Counter1 Compare Match B</DEFINITION>
    </VECTOR8>
    <VECTOR9>
      <PROGRAM_ADDRESS>$008</PROGRAM_ADDRESS>
      <SOURCE>TIM1_OVF</SOURCE>
      <DEFINITION>Timer/Counter1 Overflow</DEFINITION>
    </VECTOR9>
    <VECTOR10>
      <PROGRAM_ADDRESS>$009</PROGRAM_ADDRESS>
      <SOURCE>TIM0_COMPA</SOURCE>
      <DEFINITION>Timer/Counter0 Compare Match A</DEFINITION>
    </VECTOR10>
    <VECTOR11>
      <PROGRAM_ADDRESS>$00A</PROGRAM_ADDRESS>
      <SOURCE>TIM0_COMPB</SOURCE>
      <DEFINITION>Timer/Counter0 Compare Match B</DEFINITION>
    </VECTOR11>
    <VECTOR12>
      <PROGRAM_ADDRESS>$00B</PROGRAM_ADDRESS>
      <SOURCE>TIM0_OVF</SOURCE>
      <DEFINITION>Timer/Counter0 Overflow</DEFINITION>
    </VECTOR12>
    <VECTOR13>
      <PROGRAM_ADDRESS>$00C</PROGRAM_ADDRESS>
      <SOURCE>ANA_COMP</SOURCE>
      <DEFINITION>Analog Comparator</DEFINITION>
    </VECTOR13>
    <VECTOR14>
      <PROGRAM_ADDRESS>$00D</PROGRAM_ADDRESS>
      <SOURCE>ADC ADC</SOURCE>
      <DEFINITION>Conversion Complete</DEFINITION>
    </VECTOR14>
    <VECTOR15>
      <PROGRAM_ADDRESS>$00E</PROGRAM_ADDRESS>
      <SOURCE>TWI_SLAVE</SOURCE>
      <DEFINITION>Two-Wire Interface</DEFINITION>
    </VECTOR15>
    <VECTOR16>
      <PROGRAM_ADDRESS>$00F</PROGRAM_ADDRESS>
      <SOURCE>SPI</SOURCE>
      <DEFINITION>Serial Peripheral Interface</DEFINITION>
    </VECTOR16>
    <VECTOR17>
      <PROGRAM_ADDRESS>$010</PROGRAM_ADDRESS>
      <SOURCE>QTRIP</SOURCE>
      <DEFINITION>Touch Sensing</DEFINITION>
    </VECTOR17>
  </INTERRUPT_VECTOR>
  <MEMORY>
    <ID>AVRSimMemory8bit.SimMemory8bit</ID>
    <PROG_FLASH>2048</PROG_FLASH>
    <EEPROM>0</EEPROM>
    <INT_SRAM>
      <SIZE>128</SIZE>
      <START_ADDR>$40</START_ADDR>
    </INT_SRAM>
    <EXT_SRAM>
      <SIZE>0</SIZE>
      <START_ADDR>NA</START_ADDR>
    </EXT_SRAM>
    <IO_MEMORY>
      <IO_START_ADDR>$00</IO_START_ADDR>
      <IO_STOP_ADDR>$3F</IO_STOP_ADDR>
      <EXT_IO_START_ADDR>NA</EXT_IO_START_ADDR>
      <EXT_IO_STOP_ADDR>NA</EXT_IO_STOP_ADDR>
      <MEM_START_ADDR>$00</MEM_START_ADDR>
      <MEM_STOP_ADDR>$3F</MEM_STOP_ADDR>
      <SREG>
        <IO_ADDR>$3F</IO_ADDR>
        <MEM_ADDR>$3F</MEM_ADDR>
        <C_MASK>0x01</C_MASK>
        <Z_MASK>0x02</Z_MASK>
        <N_MASK>0x04</N_MASK>
        <V_MASK>0x08</V_MASK>
        <S_MASK>0x10</S_MASK>
        <H_MASK>0x20</H_MASK>
        <T_MASK>0x40</T_MASK>
        <I_MASK>0x80</I_MASK>
      </SREG>
      <SPH>
        <IO_ADDR>$3E</IO_ADDR>
        <MEM_ADDR>$3E</MEM_ADDR>
        <SP8_MASK>0x01</SP8_MASK>
        <SP9_MASK>0x02</SP9_MASK>
        <SP10_MASK>0x04</SP10_MASK>
        <SP11_MASK>0x08</SP11_MASK>
        <SP12_MASK>0x10</SP12_MASK>
        <SP13_MASK>0x20</SP13_MASK>
        <SP14_MASK>0x40</SP14_MASK>
        <SP15_MASK>0x80</SP15_MASK>
      </SPH>
      <SPL>
        <IO_ADDR>$3D</IO_ADDR>
        <MEM_ADDR>$3D</MEM_ADDR>
        <INIT>$5F</INIT>
        <SP0_MASK>0x01</SP0_MASK>
        <SP1_MASK>0x02</SP1_MASK>
        <SP2_MASK>0x04</SP2_MASK>
        <SP3_MASK>0x08</SP3_MASK>
        <SP4_MASK>0x10</SP4_MASK>
        <SP5_MASK>0x20</SP5_MASK>
        <SP6_MASK>0x40</SP6_MASK>
        <SP7_MASK>0x80</SP7_MASK>
      </SPL>
      <CCP>
        <IO_ADDR>$3C</IO_ADDR>
        <MEM_ADDR>$3C</MEM_ADDR>
        <CCP0_MASK>0x01</CCP0_MASK>
        <CCP1_MASK>0x02</CCP1_MASK>
        <CCP2_MASK>0x04</CCP2_MASK>
        <CCP3_MASK>0x08</CCP3_MASK>
        <CCP4_MASK>0x10</CCP4_MASK>
        <CCP5_MASK>0x20</CCP5_MASK>
        <CCP6_MASK>0x40</CCP6_MASK>
        <CCP7_MASK>0x80</CCP7_MASK>
      </CCP>
      <RSTFLR>
        <IO_ADDR>$3B</IO_ADDR>
        <MEM_ADDR>$3B</MEM_ADDR>
        <PORF_MASK>0x01</PORF_MASK>
        <EXTRF_MASK>0x02</EXTRF_MASK>
        <WDRF_MASK>0x08</WDRF_MASK>
      </RSTFLR>
      <MCUCR>
        <IO_ADDR>$3A</IO_ADDR>
        <MEM_ADDR>$3A</MEM_ADDR>
        <SE_MASK>0x01</SE_MASK>
        <SM0_MASK>0x02</SM0_MASK>
        <SM1_MASK>0x04</SM1_MASK>
        <SM2_MASK>0x08</SM2_MASK>
        <BODS_MASK>0x10</BODS_MASK>
        <ISC00_MASK>0x40</ISC00_MASK>
        <ISC01_MASK>0x80</ISC01_MASK>
      </MCUCR>
      <OSCCAL>
        <IO_ADDR>$39</IO_ADDR>
        <MEM_ADDR>$39</MEM_ADDR>
        <CAL0_MASK>0x01</CAL0_MASK>
        <CAL1_MASK>0x02</CAL1_MASK>
        <CAL2_MASK>0x04</CAL2_MASK>
        <CAL3_MASK>0x08</CAL3_MASK>
        <CAL4_MASK>0x10</CAL4_MASK>
        <CAL5_MASK>0x20</CAL5_MASK>
        <CAL6_MASK>0x40</CAL6_MASK>
        <CAL7_MASK>0x80</CAL7_MASK>
      </OSCCAL>
      <CLKMSR>
        <IO_ADDR>$37</IO_ADDR>
        <MEM_ADDR>$37</MEM_ADDR>
        <CLKMS0_MASK>0x01</CLKMS0_MASK>
        <CLKMS1_MASK>0x02</CLKMS1_MASK>
      </CLKMSR>
      <CLKPSR>
        <IO_ADDR>$36</IO_ADDR>
        <MEM_ADDR>$36</MEM_ADDR>
        <CLKPS0_MASK>0x01</CLKPS0_MASK>
        <CLKPS1_MASK>0x02</CLKPS1_MASK>
        <CLKPS2_MASK>0x04</CLKPS2_MASK>
        <CLKPS3_MASK>0x08</CLKPS3_MASK>
      </CLKPSR>
      <PRR>
        <IO_ADDR>$35</IO_ADDR>
        <MEM_ADDR>$35</MEM_ADDR>
        <PRADC_MASK>0x01</PRADC_MASK>
        <PRTIM0_MASK>0x02</PRTIM0_MASK>
        <PRTIM1_MASK>0x04</PRTIM1_MASK>
        <PRSPI_MASK>0x08</PRSPI_MASK>
        <PRTWI_MASK>0x10</PRTWI_MASK>
      </PRR>
      <QTCSR>
        <IO_ADDR>$34</IO_ADDR>
        <MEM_ADDR>$34</MEM_ADDR>
      </QTCSR>
      <NVMCMD>
        <IO_ADDR>$33</IO_ADDR>
        <MEM_ADDR>$33</MEM_ADDR>
        <NVMCMD0_MASK>0x01</NVMCMD0_MASK>
        <NVMCMD1_MASK>0x02</NVMCMD1_MASK>
        <NVMCMD2_MASK>0x04</NVMCMD2_MASK>
        <NVMCMD3_MASK>0x08</NVMCMD3_MASK>
        <NVMCMD4_MASK>0x10</NVMCMD4_MASK>
        <NVMCMD5_MASK>0x20</NVMCMD5_MASK>
      </NVMCMD>
      <NVMCSR>
        <IO_ADDR>$32</IO_ADDR>
        <MEM_ADDR>$32</MEM_ADDR>
        <NVMBSY_MASK>0x80</NVMBSY_MASK>
      </NVMCSR>
      <WDTCSR>
        <IO_ADDR>$31</IO_ADDR>
        <MEM_ADDR>$31</MEM_ADDR>
        <WDP0_MASK>0x01</WDP0_MASK>
        <WDP1_MASK>0x02</WDP1_MASK>
        <WDP2_MASK>0x04</WDP2_MASK>
        <WDE_MASK>0x08</WDE_MASK>
        <WDP3_MASK>0x20</WDP3_MASK>
        <WDIE_MASK>0x40</WDIE_MASK>
        <WDIF_MASK>0x80</WDIF_MASK>
      </WDTCSR>
      <SPCR>
        <IO_ADDR>$30</IO_ADDR>
        <MEM_ADDR>$30</MEM_ADDR>
        <SPR0_MASK>0x01</SPR0_MASK>
        <SPR1_MASK>0x02</SPR1_MASK>
        <CPHA_MASK>0x04</CPHA_MASK>
        <CPOL_MASK>0x08</CPOL_MASK>
        <MSTR_MASK>0x10</MSTR_MASK>
        <DORD_MASK>0x20</DORD_MASK>
        <SPE_MASK>0x40</SPE_MASK>
        <SPIE_MASK>0x80</SPIE_MASK>
      </SPCR>
      <SPSR>
        <IO_ADDR>$2F</IO_ADDR>
        <MEM_ADDR>$2F</MEM_ADDR>
        <SPI2X_MASK>0x01</SPI2X_MASK>
        <WCOL_MASK>0x40</WCOL_MASK>
        <SPIF_MASK>0x80</SPIF_MASK>
      </SPSR>
      <SPDR>
        <IO_ADDR>$2E</IO_ADDR>
        <MEM_ADDR>$2E</MEM_ADDR>
        <SPDR0_MASK>0x01</SPDR0_MASK>
        <SPDR1_MASK>0x02</SPDR1_MASK>
        <SPDR2_MASK>0x04</SPDR2_MASK>
        <SPDR3_MASK>0x08</SPDR3_MASK>
        <SPDR4_MASK>0x10</SPDR4_MASK>
        <SPDR5_MASK>0x20</SPDR5_MASK>
        <SPDR6_MASK>0x40</SPDR6_MASK>
        <SPDR7_MASK>0x80</SPDR7_MASK>
      </SPDR>
      <TWSCRA>
        <IO_ADDR>$2D</IO_ADDR>
        <MEM_ADDR>$2D</MEM_ADDR>
        <TWSME_MASK>0x01</TWSME_MASK>
        <TWPME_MASK>0x02</TWPME_MASK>
        <TWSIE_MASK>0x04</TWSIE_MASK>
        <TWEN_MASK>0x08</TWEN_MASK>
        <TWASIE_MASK>0x10</TWASIE_MASK>
        <TWDIE_MASK>0x20</TWDIE_MASK>
        <TWSHE_MASK>0x80</TWSHE_MASK>
      </TWSCRA>
      <TWSCRB>
        <IO_ADDR>$2C</IO_ADDR>
        <MEM_ADDR>$2C</MEM_ADDR>
        <TWCMD0_MASK>0x01</TWCMD0_MASK>
        <TWCMD1_MASK>0x02</TWCMD1_MASK>
        <TWAA_MASK>0x04</TWAA_MASK>
      </TWSCRB>
      <TWSSRA>
        <IO_ADDR>$2B</IO_ADDR>
        <MEM_ADDR>$2B</MEM_ADDR>
        <TWAS_MASK>0x01</TWAS_MASK>
        <TWDIR_MASK>0x02</TWDIR_MASK>
        <TWBE_MASK>0x04</TWBE_MASK>
        <TWC_MASK>0x08</TWC_MASK>
        <TWRA_MASK>0x10</TWRA_MASK>
        <TWCH_MASK>0x20</TWCH_MASK>
        <TWASIF_MASK>0x40</TWASIF_MASK>
        <TWDIF_MASK>0x80</TWDIF_MASK>
      </TWSSRA>
      <TWSA>
        <IO_ADDR>$2A</IO_ADDR>
        <MEM_ADDR>$2A</MEM_ADDR>
        <TWSA0_MASK>0x01</TWSA0_MASK>
        <TWSA1_MASK>0x02</TWSA1_MASK>
        <TWSA2_MASK>0x04</TWSA2_MASK>
        <TWSA3_MASK>0x08</TWSA3_MASK>
        <TWSA4_MASK>0x10</TWSA4_MASK>
        <TWSA5_MASK>0x20</TWSA5_MASK>
        <TWSA6_MASK>0x40</TWSA6_MASK>
        <TWSA7_MASK>0x80</TWSA7_MASK>
      </TWSA>
      <TWSAM>
        <IO_ADDR>$29</IO_ADDR>
        <MEM_ADDR>$29</MEM_ADDR>
        <TWAE_MASK>0x01</TWAE_MASK>
        <TWSAM1_MASK>0x02</TWSAM1_MASK>
        <TWSAM2_MASK>0x04</TWSAM2_MASK>
        <TWSAM3_MASK>0x08</TWSAM3_MASK>
        <TWSAM4_MASK>0x10</TWSAM4_MASK>
        <TWSAM5_MASK>0x20</TWSAM5_MASK>
        <TWSAM6_MASK>0x40</TWSAM6_MASK>
        <TWSAM7_MASK>0x80</TWSAM7_MASK>
      </TWSAM>
      <TWSD>
        <IO_ADDR>$28</IO_ADDR>
        <MEM_ADDR>$28</MEM_ADDR>
        <TWSD0_MASK>0x01</TWSD0_MASK>
        <TWSD1_MASK>0x02</TWSD1_MASK>
        <TWSD2_MASK>0x04</TWSD2_MASK>
        <TWSD3_MASK>0x08</TWSD3_MASK>
        <TWSD4_MASK>0x10</TWSD4_MASK>
        <TWSD5_MASK>0x20</TWSD5_MASK>
        <TWSD6_MASK>0x40</TWSD6_MASK>
        <TWSD7_MASK>0x80</TWSD7_MASK>
      </TWSD>
      <GTCCR>
        <IO_ADDR>$27</IO_ADDR>
        <MEM_ADDR>$27</MEM_ADDR>
        <PSR_MASK>0x01</PSR_MASK>
        <TSM_MASK>0x80</TSM_MASK>
      </GTCCR>
      <TIMSK>
        <IO_ADDR>$26</IO_ADDR>
        <MEM_ADDR>$26</MEM_ADDR>
        <TOIE0_MASK>0x01</TOIE0_MASK>
        <OCIE0A_MASK>0x02</OCIE0A_MASK>
        <OCIE0B_MASK>0x04</OCIE0B_MASK>
        <TOIE1_MASK>0x08</TOIE1_MASK>
        <OCIE1A_MASK>0x10</OCIE1A_MASK>
        <OCIE1B_MASK>0x20</OCIE1B_MASK>
        <ICIE1_MASK>0x80</ICIE1_MASK>
      </TIMSK>
      <TIFR>
        <IO_ADDR>$25</IO_ADDR>
        <MEM_ADDR>$25</MEM_ADDR>
        <TOV0_MASK>0x01</TOV0_MASK>
        <OCF0A_MASK>0x02</OCF0A_MASK>
        <OCF0B_MASK>0x04</OCF0B_MASK>
        <TOV1_MASK>0x08</TOV1_MASK>
        <OCF1A_MASK>0x10</OCF1A_MASK>
        <OCF1B_MASK>0x20</OCF1B_MASK>
        <ICF1_MASK>0x80</ICF1_MASK>
      </TIFR>
      <TCCR1A>
        <IO_ADDR>$24</IO_ADDR>
        <MEM_ADDR>$24</MEM_ADDR>
        <WGM10_MASK>0x01</WGM10_MASK>
        <WGM11_MASK>0x02</WGM11_MASK>
        <COM1B0_MASK>0x10</COM1B0_MASK>
        <COM1B1_MASK>0x20</COM1B1_MASK>
        <COM1A0_MASK>0x40</COM1A0_MASK>
        <COM1A1_MASK>0x80</COM1A1_MASK>
      </TCCR1A>
      <TCCR1B>
        <IO_ADDR>$23</IO_ADDR>
        <MEM_ADDR>$23</MEM_ADDR>
        <CS10_MASK>0x01</CS10_MASK>
        <CS11_MASK>0x02</CS11_MASK>
        <CS12_MASK>0x04</CS12_MASK>
        <WGM12_MASK>0x08</WGM12_MASK>
        <WGM13_MASK>0x10</WGM13_MASK>
        <ICES1_MASK>0x40</ICES1_MASK>
        <ICNC1_MASK>0x80</ICNC1_MASK>
      </TCCR1B>
      <TCCR1C>
        <IO_ADDR>$22</IO_ADDR>
        <MEM_ADDR>$22</MEM_ADDR>
        <FOC1B_MASK>0x40</FOC1B_MASK>
        <FOC1A_MASK>0x80</FOC1A_MASK>
      </TCCR1C>
      <TCNT1H>
        <IO_ADDR>$21</IO_ADDR>
        <MEM_ADDR>$21</MEM_ADDR>
        <TCNT1_8_MASK>0x01</TCNT1_8_MASK>
        <TCNT1_9_MASK>0x02</TCNT1_9_MASK>
        <TCNT1_10_MASK>0x04</TCNT1_10_MASK>
        <TCNT1_11_MASK>0x08</TCNT1_11_MASK>
        <TCNT1_12_MASK>0x10</TCNT1_12_MASK>
        <TCNT1_13_MASK>0x20</TCNT1_13_MASK>
        <TCNT1_14_MASK>0x40</TCNT1_14_MASK>
        <TCNT1_15_MASK>0x80</TCNT1_15_MASK>
      </TCNT1H>
      <TCNT1L>
        <IO_ADDR>$20</IO_ADDR>
        <MEM_ADDR>$20</MEM_ADDR>
        <TCNT1_0_MASK>0x01</TCNT1_0_MASK>
        <TCNT1_1_MASK>0x02</TCNT1_1_MASK>
        <TCNT1_2_MASK>0x04</TCNT1_2_MASK>
        <TCNT1_3_MASK>0x08</TCNT1_3_MASK>
        <TCNT1_4_MASK>0x10</TCNT1_4_MASK>
        <TCNT1_5_MASK>0x20</TCNT1_5_MASK>
        <TCNT1_6_MASK>0x40</TCNT1_6_MASK>
        <TCNT1_7_MASK>0x80</TCNT1_7_MASK>
      </TCNT1L>
      <OCR1AH>
        <IO_ADDR>$1F</IO_ADDR>
        <MEM_ADDR>$1F</MEM_ADDR>
        <OCR1A8_MASK>0x01</OCR1A8_MASK>
        <OCR1A9_MASK>0x02</OCR1A9_MASK>
        <OCR1A10_MASK>0x04</OCR1A10_MASK>
        <OCR1A11_MASK>0x08</OCR1A11_MASK>
        <OCR1A12_MASK>0x10</OCR1A12_MASK>
        <OCR1A13_MASK>0x20</OCR1A13_MASK>
        <OCR1A14_MASK>0x40</OCR1A14_MASK>
        <OCR1A15_MASK>0x80</OCR1A15_MASK>
      </OCR1AH>
      <OCR1AL>
        <IO_ADDR>$1E</IO_ADDR>
        <MEM_ADDR>$1E</MEM_ADDR>
        <OCR1A0_MASK>0x01</OCR1A0_MASK>
        <OCR1A1_MASK>0x02</OCR1A1_MASK>
        <OCR1A2_MASK>0x04</OCR1A2_MASK>
        <OCR1A3_MASK>0x08</OCR1A3_MASK>
        <OCR1A4_MASK>0x10</OCR1A4_MASK>
        <OCR1A5_MASK>0x20</OCR1A5_MASK>
        <OCR1A6_MASK>0x40</OCR1A6_MASK>
        <OCR1A7_MASK>0x80</OCR1A7_MASK>
      </OCR1AL>
      <OCR1BH>
        <IO_ADDR>$1D</IO_ADDR>
        <MEM_ADDR>$1D</MEM_ADDR>
        <OCR1B8_MASK>0x01</OCR1B8_MASK>
        <OCR1B9_MASK>0x02</OCR1B9_MASK>
        <OCR1B10_MASK>0x04</OCR1B10_MASK>
        <OCR1B11_MASK>0x08</OCR1B11_MASK>
        <OCR1B12_MASK>0x10</OCR1B12_MASK>
        <OCR1B13_MASK>0x20</OCR1B13_MASK>
        <OCR1B14_MASK>0x40</OCR1B14_MASK>
        <OCR1B15_MASK>0x80</OCR1B15_MASK>
      </OCR1BH>
      <OCR1BL>
        <IO_ADDR>$1C</IO_ADDR>
        <MEM_ADDR>$1C</MEM_ADDR>
        <OCR1B0_MASK>0x01</OCR1B0_MASK>
        <OCR1B1_MASK>0x02</OCR1B1_MASK>
        <OCR1B2_MASK>0x04</OCR1B2_MASK>
        <OCR1B3_MASK>0x08</OCR1B3_MASK>
        <OCR1B4_MASK>0x10</OCR1B4_MASK>
        <OCR1B5_MASK>0x20</OCR1B5_MASK>
        <OCR1B6_MASK>0x40</OCR1B6_MASK>
        <OCR1B7_MASK>0x80</OCR1B7_MASK>
      </OCR1BL>
      <ICR1H>
        <IO_ADDR>$1B</IO_ADDR>
        <MEM_ADDR>$1B</MEM_ADDR>
        <ICR1_8_MASK>0x01</ICR1_8_MASK>
        <ICR1_9_MASK>0x02</ICR1_9_MASK>
        <ICR1_10_MASK>0x04</ICR1_10_MASK>
        <ICR1_11_MASK>0x08</ICR1_11_MASK>
        <ICR1_12_MASK>0x10</ICR1_12_MASK>
        <ICR1_13_MASK>0x20</ICR1_13_MASK>
        <ICR1_14_MASK>0x40</ICR1_14_MASK>
        <ICR1_15_MASK>0x80</ICR1_15_MASK>
      </ICR1H>
      <ICR1L>
        <IO_ADDR>$1A</IO_ADDR>
        <MEM_ADDR>$1A</MEM_ADDR>
        <ICR1_0_MASK>0x01</ICR1_0_MASK>
        <ICR1_1_MASK>0x02</ICR1_1_MASK>
        <ICR1_2_MASK>0x04</ICR1_2_MASK>
        <ICR1_3_MASK>0x08</ICR1_3_MASK>
        <ICR1_4_MASK>0x10</ICR1_4_MASK>
        <ICR1_5_MASK>0x20</ICR1_5_MASK>
        <ICR1_6_MASK>0x40</ICR1_6_MASK>
        <ICR1_7_MASK>0x80</ICR1_7_MASK>
      </ICR1L>
      <TCCR0A>
        <IO_ADDR>$19</IO_ADDR>
        <MEM_ADDR>$19</MEM_ADDR>
        <WGM00_MASK>0x01</WGM00_MASK>
        <WGM01_MASK>0x02</WGM01_MASK>
        <COM0B0_MASK>0x10</COM0B0_MASK>
        <COM0B1_MASK>0x20</COM0B1_MASK>
        <COM0A0_MASK>0x40</COM0A0_MASK>
        <COM0A1_MASK>0x80</COM0A1_MASK>
      </TCCR0A>
      <TCCR0B>
        <IO_ADDR>$18</IO_ADDR>
        <MEM_ADDR>$18</MEM_ADDR>
        <CS00_MASK>0x01</CS00_MASK>
        <CS01_MASK>0x02</CS01_MASK>
        <CS02_MASK>0x04</CS02_MASK>
        <WGM02_MASK>0x08</WGM02_MASK>
        <FOC0B_MASK>0x40</FOC0B_MASK>
        <FOC0A_MASK>0x80</FOC0A_MASK>
      </TCCR0B>
      <TCNT0>
        <IO_ADDR>$17</IO_ADDR>
        <MEM_ADDR>$17</MEM_ADDR>
        <TCNT0_0_MASK>0x01</TCNT0_0_MASK>
        <TCNT0_1_MASK>0x02</TCNT0_1_MASK>
        <TCNT0_2_MASK>0x04</TCNT0_2_MASK>
        <TCNT0_3_MASK>0x08</TCNT0_3_MASK>
        <TCNT0_4_MASK>0x10</TCNT0_4_MASK>
        <TCNT0_5_MASK>0x20</TCNT0_5_MASK>
        <TCNT0_6_MASK>0x40</TCNT0_6_MASK>
        <TCNT0_7_MASK>0x80</TCNT0_7_MASK>
      </TCNT0>
      <OCR0A>
        <IO_ADDR>$16</IO_ADDR>
        <MEM_ADDR>$16</MEM_ADDR>
        <OCR0_0_MASK>0x01</OCR0_0_MASK>
        <OCR0_1_MASK>0x02</OCR0_1_MASK>
        <OCR0_2_MASK>0x04</OCR0_2_MASK>
        <OCR0_3_MASK>0x08</OCR0_3_MASK>
        <OCR0_4_MASK>0x10</OCR0_4_MASK>
        <OCR0_5_MASK>0x20</OCR0_5_MASK>
        <OCR0_6_MASK>0x40</OCR0_6_MASK>
        <OCR0_7_MASK>0x80</OCR0_7_MASK>
      </OCR0A>
      <OCR0B>
        <IO_ADDR>$15</IO_ADDR>
        <MEM_ADDR>$15</MEM_ADDR>
        <OCR0B_0_MASK>0x01</OCR0B_0_MASK>
        <OCR0B_1_MASK>0x02</OCR0B_1_MASK>
        <OCR0B_2_MASK>0x04</OCR0B_2_MASK>
        <OCR0B_3_MASK>0x08</OCR0B_3_MASK>
        <OCR0B_4_MASK>0x10</OCR0B_4_MASK>
        <OCR0B_5_MASK>0x20</OCR0B_5_MASK>
        <OCR0B_6_MASK>0x40</OCR0B_6_MASK>
        <OCR0B_7_MASK>0x80</OCR0B_7_MASK>
      </OCR0B>
      <ACSRA>
        <IO_ADDR>$14</IO_ADDR>
        <MEM_ADDR>$14</MEM_ADDR>
        <ACIS0_MASK>0x01</ACIS0_MASK>
        <ACIS1_MASK>0x02</ACIS1_MASK>
        <ACIC_MASK>0x04</ACIC_MASK>
        <ACIE_MASK>0x08</ACIE_MASK>
        <ACI_MASK>0x10</ACI_MASK>
        <ACO_MASK>0x20</ACO_MASK>
        <ACBG_MASK>0x40</ACBG_MASK>
        <ACD_MASK>0x80</ACD_MASK>
      </ACSRA>
      <ACSRB>
        <IO_ADDR>$13</IO_ADDR>
        <MEM_ADDR>$13</MEM_ADDR>
        <ACME_MASK>0x04</ACME_MASK>
        <HLEV_MASK>0x40</HLEV_MASK>
        <HSEL_MASK>0x80</HSEL_MASK>
      </ACSRB>
      <ADCSRA>
        <IO_ADDR>$12</IO_ADDR>
        <MEM_ADDR>$12</MEM_ADDR>
        <ADPS0_MASK>0x01</ADPS0_MASK>
        <ADPS1_MASK>0x02</ADPS1_MASK>
        <ADPS2_MASK>0x04</ADPS2_MASK>
        <ADIE_MASK>0x08</ADIE_MASK>
        <ADIF_MASK>0x10</ADIF_MASK>
        <ADATE_MASK>0x20</ADATE_MASK>
        <ADSC_MASK>0x40</ADSC_MASK>
        <ADEN_MASK>0x80</ADEN_MASK>
      </ADCSRA>
      <ADCSRB>
        <IO_ADDR>$11</IO_ADDR>
        <MEM_ADDR>$11</MEM_ADDR>
        <ADTS0_MASK>0x01</ADTS0_MASK>
        <ADTS1_MASK>0x02</ADTS1_MASK>
        <ADTS2_MASK>0x04</ADTS2_MASK>
        <ADLAR_MASK>0x08</ADLAR_MASK>
      </ADCSRB>
      <ADMUX>
        <IO_ADDR>$10</IO_ADDR>
        <MEM_ADDR>$10</MEM_ADDR>
        <MUX0_MASK>0x01</MUX0_MASK>
        <MUX1_MASK>0x02</MUX1_MASK>
        <MUX2_MASK>0x04</MUX2_MASK>
        <MUX3_MASK>0x08</MUX3_MASK>
        <REFS_MASK>0x40</REFS_MASK>
      </ADMUX>
      <ADCH>
        <IO_ADDR>$0F</IO_ADDR>
        <MEM_ADDR>$0F</MEM_ADDR>
        <ADCH0_MASK>0x01</ADCH0_MASK>
        <ADCH1_MASK>0x02</ADCH1_MASK>
        <ADCH2_MASK>0x04</ADCH2_MASK>
        <ADCH3_MASK>0x08</ADCH3_MASK>
        <ADCH4_MASK>0x10</ADCH4_MASK>
        <ADCH5_MASK>0x20</ADCH5_MASK>
        <ADCH6_MASK>0x40</ADCH6_MASK>
        <ADCH7_MASK>0x80</ADCH7_MASK>
      </ADCH>
      <ADCL>
        <IO_ADDR>$0E</IO_ADDR>
        <MEM_ADDR>$0E</MEM_ADDR>
        <ADCL0_MASK>0x01</ADCL0_MASK>
        <ADCL1_MASK>0x02</ADCL1_MASK>
        <ADCL2_MASK>0x04</ADCL2_MASK>
        <ADCL3_MASK>0x08</ADCL3_MASK>
        <ADCL4_MASK>0x10</ADCL4_MASK>
        <ADCL5_MASK>0x20</ADCL5_MASK>
        <ADCL6_MASK>0x40</ADCL6_MASK>
        <ADCL7_MASK>0x80</ADCL7_MASK>
      </ADCL>
      <DIDR0>
        <IO_ADDR>$0D</IO_ADDR>
        <MEM_ADDR>$0D</MEM_ADDR>
        <ADC0D_MASK>0x01</ADC0D_MASK>
        <ADC1D_MASK>0x02</ADC1D_MASK>
        <ADC2D_MASK>0x04</ADC2D_MASK>
        <ADC3D_MASK>0x08</ADC3D_MASK>
        <ADC4D_MASK>0x10</ADC4D_MASK>
        <ADC5D_MASK>0x20</ADC5D_MASK>
        <ADC6D_MASK>0x40</ADC6D_MASK>
        <ADC7D_MASK>0x80</ADC7D_MASK>
      </DIDR0>
      <GIMSK>
        <IO_ADDR>$0C</IO_ADDR>
        <MEM_ADDR>$0C</MEM_ADDR>
        <INT0_MASK>0x01</INT0_MASK>
        <PCIE0_MASK>0x10</PCIE0_MASK>
        <PCIE1_MASK>0x20</PCIE1_MASK>
      </GIMSK>
      <GIFR>
        <IO_ADDR>$0B</IO_ADDR>
        <MEM_ADDR>$0B</MEM_ADDR>
        <INTF0_MASK>0x01</INTF0_MASK>
        <PCIF0_MASK>0x10</PCIF0_MASK>
        <PCIF1_MASK>0x20</PCIF1_MASK>
      </GIFR>
      <PCMSK1>
        <IO_ADDR>$0A</IO_ADDR>
        <MEM_ADDR>$0A</MEM_ADDR>
        <PCINT8_MASK>0x01</PCINT8_MASK>
        <PCINT9_MASK>0x02</PCINT9_MASK>
        <PCINT10_MASK>0x04</PCINT10_MASK>
        <PCINT11_MASK>0x08</PCINT11_MASK>
      </PCMSK1>
      <PCMSK0>
        <IO_ADDR>$09</IO_ADDR>
        <MEM_ADDR>$09</MEM_ADDR>
        <PCINT0_MASK>0x01</PCINT0_MASK>
        <PCINT1_MASK>0x02</PCINT1_MASK>
        <PCINT2_MASK>0x04</PCINT2_MASK>
        <PCINT3_MASK>0x08</PCINT3_MASK>
        <PCINT4_MASK>0x10</PCINT4_MASK>
        <PCINT5_MASK>0x20</PCINT5_MASK>
        <PCINT6_MASK>0x40</PCINT6_MASK>
        <PCINT7_MASK>0x80</PCINT7_MASK>
      </PCMSK0>
      <PORTCR>
        <IO_ADDR>$08</IO_ADDR>
        <MEM_ADDR>$08</MEM_ADDR>
        <BBMB_MASK>0x02</BBMB_MASK>
        <BBMA_MASK>0x01</BBMA_MASK>
      </PORTCR>
      <PUEB>
        <IO_ADDR>$07</IO_ADDR>
        <MEM_ADDR>$07</MEM_ADDR>
        <PUEB0_MASK>0x01</PUEB0_MASK>
        <PUEB1_MASK>0x02</PUEB1_MASK>
        <PUEB2_MASK>0x04</PUEB2_MASK>
        <PUEB3_MASK>0x08</PUEB3_MASK>
      </PUEB>
      <PORTB>
        <IO_ADDR>$06</IO_ADDR>
        <MEM_ADDR>$06</MEM_ADDR>
        <PORTB0_MASK>0x01</PORTB0_MASK>
        <PORTB1_MASK>0x02</PORTB1_MASK>
        <PORTB2_MASK>0x04</PORTB2_MASK>
        <PORTB3_MASK>0x08</PORTB3_MASK>
      </PORTB>
      <DDRB>
        <IO_ADDR>$05</IO_ADDR>
        <MEM_ADDR>$05</MEM_ADDR>
        <DDB0_MASK>0x01</DDB0_MASK>
        <DDB1_MASK>0x02</DDB1_MASK>
        <DDB2_MASK>0x04</DDB2_MASK>
        <DDB3_MASK>0x08</DDB3_MASK>
      </DDRB>
      <PINB>
        <IO_ADDR>$04</IO_ADDR>
        <MEM_ADDR>$04</MEM_ADDR>
        <PINB0_MASK>0x01</PINB0_MASK>
        <PINB1_MASK>0x02</PINB1_MASK>
        <PINB2_MASK>0x04</PINB2_MASK>
        <PINB3_MASK>0x08</PINB3_MASK>
      </PINB>
      <PUEA>
        <IO_ADDR>$03</IO_ADDR>
        <MEM_ADDR>$03</MEM_ADDR>
        <PUEA0_MASK>0x01</PUEA0_MASK>
        <PUEA1_MASK>0x02</PUEA1_MASK>
        <PUEA2_MASK>0x04</PUEA2_MASK>
        <PUEA3_MASK>0x08</PUEA3_MASK>
        <PUEA4_MASK>0x10</PUEA4_MASK>
        <PUEA5_MASK>0x20</PUEA5_MASK>
        <PUEA6_MASK>0x40</PUEA6_MASK>
        <PUEA7_MASK>0x80</PUEA7_MASK>
      </PUEA>
      <PORTA>
        <IO_ADDR>$02</IO_ADDR>
        <MEM_ADDR>$02</MEM_ADDR>
        <PORTA0_MASK>0x01</PORTA0_MASK>
        <PORTA1_MASK>0x02</PORTA1_MASK>
        <PORTA2_MASK>0x04</PORTA2_MASK>
        <PORTA3_MASK>0x08</PORTA3_MASK>
        <PORTA4_MASK>0x10</PORTA4_MASK>
        <PORTA5_MASK>0x20</PORTA5_MASK>
        <PORTA6_MASK>0x40</PORTA6_MASK>
        <PORTA7_MASK>0x80</PORTA7_MASK>
      </PORTA>
      <DDRA>
        <IO_ADDR>$01</IO_ADDR>
        <MEM_ADDR>$01</MEM_ADDR>
        <DDA0_MASK>0x01</DDA0_MASK>
        <DDA1_MASK>0x02</DDA1_MASK>
        <DDA2_MASK>0x04</DDA2_MASK>
        <DDA3_MASK>0x08</DDA3_MASK>
        <DDA4_MASK>0x10</DDA4_MASK>
        <DDA5_MASK>0x20</DDA5_MASK>
        <DDA6_MASK>0x40</DDA6_MASK>
        <DDA7_MASK>0x80</DDA7_MASK>
      </DDRA>
      <PINA>
        <IO_ADDR>$00</IO_ADDR>
        <MEM_ADDR>$00</MEM_ADDR>
        <PINA0_MASK>0x01</PINA0_MASK>
        <PINA1_MASK>0x02</PINA1_MASK>
        <PINA2_MASK>0x04</PINA2_MASK>
        <PINA3_MASK>0x08</PINA3_MASK>
        <PINA4_MASK>0x10</PINA4_MASK>
        <PINA5_MASK>0x20</PINA5_MASK>
        <PINA6_MASK>0x40</PINA6_MASK>
        <PINA7_MASK>0x80</PINA7_MASK>
      </PINA>
    </IO_MEMORY>
    <BOOT_CONFIG>
      <PAGESIZE>32</PAGESIZE>
    </BOOT_CONFIG>
    <NVM_MEMMAPPED>
      <FLASH_START>0x4000</FLASH_START>
      <LOCKBITS_0>0x3f00</LOCKBITS_0>
      <CONFIG_0>0x3f40</CONFIG_0>
      <CALIB_0>0x3f80</CALIB_0>
      <SIGN_0>0x3fc0</SIGN_0>
      <SIGN_1>0x3fc1</SIGN_1>
      <SIGN_2>0x3fc2</SIGN_2>
    </NVM_MEMMAPPED>
  </MEMORY>
  <PACKAGE>
    <PACKAGES>[SOIC:VQFN]</PACKAGES>
    <SOIC>
      <NMB_PIN>14</NMB_PIN>
      <PIN1>
        <NAME>[VCC]</NAME>
        <TEXT/>
      </PIN1>
      <PIN2>
        <NAME>[PCINT8:TPICLK:T0:CLKI]</NAME>
        <TEXT/>
      </PIN2>
      <PIN3>
        <NAME>[PCINT9:TPIDATA:MOSI:SDA:OC1A]</NAME>
        <TEXT/>
      </PIN3>
      <PIN4>
        <NAME>[PCINT11:RESET]</NAME>
        <TEXT/>
      </PIN4>
      <PIN5>
        <NAME>[PCINT10:INT0:MISO:OC1B:OC0A:CKOUT]</NAME>
        <TEXT/>
      </PIN5>
      <PIN6>
        <NAME>[PCINT7:SCL:SCK:T1:ICP1:OC0B:ADC7]</NAME>
        <TEXT/>
      </PIN6>
      <PIN7>
        <NAME>[PCINT6:SS:ADC6]</NAME>
        <TEXT/>
      </PIN7>
      <PIN8>
        <NAME>[ADC5:PCINT5]</NAME>
        <TEXT/>
      </PIN8>
      <PIN9>
        <NAME>[(ADC4:PCINT4]</NAME>
        <TEXT/>
      </PIN9>
      <PIN10>
        <NAME>[ADC3:PCINT3]</NAME>
        <TEXT/>
      </PIN10>
      <PIN11>
        <NAME>[ADC2:AIN1:PCINT2]</NAME>
        <TEXT/>
      </PIN11>
      <PIN12>
        <NAME>[ADC1:AIN0:PCINT1]</NAME>
        <TEXT/>
      </PIN12>
      <PIN13>
        <NAME>[ADC0:PCINT0]</NAME>
        <TEXT/>
      </PIN13>
      <PIN14>
        <NAME>[GND]</NAME>
        <TEXT/>
      </PIN14>
    </SOIC>
    <VQFN>
      <NMB_PIN>20</NMB_PIN>
      <PIN1>
        <NAME>[PCINT4:ADC4]</NAME>
        <TEXT/>
      </PIN1>
      <PIN2>
        <NAME>[PCINT3:ADC3]</NAME>
        <TEXT/>
      </PIN2>
      <PIN3>
        <NAME>[PCINT2:AIN1:ADC2]</NAME>
        <TEXT/>
      </PIN3>
      <PIN4>
        <NAME>[PCINT1:AIN0:ADC1]</NAME>
        <TEXT/>
      </PIN4>
      <PIN5>
        <NAME>[PCINT0:ADC0]</NAME>
        <TEXT/>
      </PIN5>
      <PIN6>
        <NAME>NC</NAME>
        <TEXT/>
      </PIN6>
      <PIN7>
        <NAME>NC</NAME>
        <TEXT/>
      </PIN7>
      <PIN8>
        <NAME>[GND]</NAME>
        <TEXT/>
      </PIN8>
      <PIN9>
        <NAME>[VCC]</NAME>
        <TEXT/>
      </PIN9>
      <PIN10>
        <NAME>NC</NAME>
        <TEXT/>
      </PIN10>
      <PIN11>
        <NAME>[CLKI:T0:TPICLK:PCINT8]</NAME>
        <TEXT/>
      </PIN11>
      <PIN12>
        <NAME>[OC1A:SDA:MOSI:TPIDATA:PCINT9]</NAME>
        <TEXT/>
      </PIN12>
      <PIN13>
        <NAME>[RESET:PCINT11]</NAME>
        <TEXT/>
      </PIN13>
      <PIN14>
        <NAME>[CKOUT:OC0A:OC1B:MISO:INT0:PCINT10]</NAME>
        <TEXT/>
      </PIN14>
      <PIN15>
        <NAME>(ADC7:OC0B:ICP1:T1:SCL:SCK:PCINT7]</NAME>
        <TEXT/>
      </PIN15>
      <PIN16>
        <NAME>[ADC6:SS:PCINT6]</NAME>
        <TEXT/>
      </PIN16>
      <PIN17>
        <NAME>[ADC5:PCINT5]</NAME>
        <TEXT/>
      </PIN17>
      <PIN18>
        <NAME>NC</NAME>
        <TEXT/>
      </PIN18>
      <PIN19>
        <NAME>NC</NAME>
        <TEXT/>
      </PIN19>
      <PIN20>
        <NAME>NC</NAME>
        <TEXT/>
      </PIN20>
    </VQFN>
  </PACKAGE>
  <PROGRAMMING>
    <TPIInterface/>
    <OscCal>
      <OCEntry>0x00,8.0 MHz</OCEntry>
    </OscCal>
    <FlashPageSize>128</FlashPageSize>
    <EepromPageSize>0</EepromPageSize>
  </PROGRAMMING>
  <IO_MODULE>
    <MODULE_LIST>[PORTB:WATCHDOG:AD_CONVERTER:ANALOG_COMPARATOR:CPU:EXTERNAL_INTERRUPT:TIMER_COUNTER_0:TWI:PORTA:TIMER_COUNTER_1:SPI]</MODULE_LIST>
    <PORTB>
      <LIST>[PORTCR:PUEB:PORTB:DDRB:PINB]</LIST>
      <LINK/>
      <ICON>io_port.bmp</ICON>
      <ID>AVRSimIOPort.SimIOPort</ID>
      <TEXT/>
      <PORTCR>
        <NAME>PORTCR</NAME>
        <DESCRIPTION>Port Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$08</IO_ADDR>
        <MEM_ADDR>$08</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT1>
          <NAME>BBMB</NAME>
          <DESCRIPTION>Break-Before-Make Mode Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
      </PORTCR>
      <PUEB>
        <NAME>PUEB</NAME>
        <DESCRIPTION>Pull-up Enable Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$07</IO_ADDR>
        <MEM_ADDR>$07</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT3>
          <NAME>PUEB3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PUEB2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PUEB1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PUEB0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PUEB>
      <DDRB>
        <NAME>DDRB</NAME>
        <DESCRIPTION>Data Direction Register, Port B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$05</IO_ADDR>
        <MEM_ADDR>$05</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT3>
          <NAME>DDB3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>DDB2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>DDB1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>DDB0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </DDRB>
      <PINB>
        <NAME>PINB</NAME>
        <DESCRIPTION>Port B Data register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$04</IO_ADDR>
        <MEM_ADDR>$04</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT3>
          <NAME>PINB3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PINB2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PINB1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PINB0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PINB>
      <PORTB>
        <NAME>PORTB</NAME>
        <DESCRIPTION>Input Pins, Port B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$06</IO_ADDR>
        <MEM_ADDR>$06</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT3>
          <NAME>PORTB3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PORTB2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PORTB1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PORTB0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PORTB>
    </PORTB>
    <WATCHDOG>
      <LIST>[WDTCSR]</LIST>
      <LINK/>
      <ICON>io_watch.bmp</ICON>
      <ID/>
      <TEXT/>
      <WDTCSR>
        <NAME>WDTCSR</NAME>
        <DESCRIPTION>Watchdog Timer Control and Status Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$31</IO_ADDR>
        <MEM_ADDR>$31</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>WDIF</NAME>
          <DESCRIPTION>Watchdog Timer Interrupt Flag</DESCRIPTION>
          <TEXT>This bit is set when a time-out occurs in the Watchdog Timer and the Watchdog Timer is configured for interrupt. WDTIF is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, WDTIF is cleared by writing a logic one to the flag. When the WDTIE is set, the Watchdog Time-out Interrupt is requested.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>WDIE</NAME>
          <DESCRIPTION>Watchdog Timer Interrupt Enable</DESCRIPTION>
          <TEXT>When this bit is written to one, the Watchdog interrupt request is enabled. If WDE is cleared in combination with this setting, the Watchdog Timer is in Interrupt Mode, and the corresponding interrupt is requested if time-out in the Watchdog Timer occurs. If WDE is set, the Watchdog Timer is in Interrupt and System Reset Mode. The first time-out in the Watchdog Timer will set WDTIF. Executing the corresponding interrupt vector will clear WDTIE and WDTIF automatically by hardware (the Watchdog goes to System Reset Mode). This is useful for keeping the Watchdog Timer security while using the interrupt. To stay in Interrupt and System Reset Mode, WDTIE must be set after each interrupt. This should however not be done within the interrupt service routine itself, as this might compromise the safety-function of the Watchdog System Reset mode. If the interrupt is not executed before the next time-out, a System Reset will be applied</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>WDP3</NAME>
          <DESCRIPTION>Watchdog Timer Prescaler Bit 3</DESCRIPTION>
          <TEXT>The WDP3..0 bits determine the Watchdog Timer prescaling when the Watchdog Timer is running.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT3>
          <NAME>WDE</NAME>
          <DESCRIPTION>Watch Dog Enable</DESCRIPTION>
          <TEXT>WDE is overridden by WDRF in MCUSR. This means that WDE is always set when WDRF is set. To clear WDE, WDRF must be cleared first. This feature ensures multiple resets during conditions causing failure, and a safe start-up after the failure.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>WDP2</NAME>
          <DESCRIPTION>Watch Dog Timer Prescaler bit 2</DESCRIPTION>
          <TEXT>The WDP3..0 bits determine the Watchdog Timer prescaling when the Watchdog Timer is running.</TEXT>
          <ENUM>WDOG_TIMER_PRESCALE_4BITS</ENUM>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>WDP1</NAME>
          <DESCRIPTION>Watch Dog Timer Prescaler bit 1</DESCRIPTION>
          <TEXT>The WDP3..0 bits determine the Watchdog Timer prescaling when the Watchdog Timer is running.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>WDP0</NAME>
          <DESCRIPTION>Watch Dog Timer Prescaler bit 0</DESCRIPTION>
          <TEXT>The WDP3..0 bits determine the Watchdog Timer prescaling when the Watchdog Timer is running.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </WDTCSR>
    </WATCHDOG>
    <AD_CONVERTER>
      <LIST>[ADMUX:ADCSRA:ADCH:ADCL:ADCSRB:DIDR0]</LIST>
      <LINK/>
      <RULES>((IF ADMUX.ADLAR = 1) LINK [ADCH(1:0):ADCL(7:0)]); (IF ADMUX.ADLAR = 0) LINK [ADCH(7:0):ADCL(7:6)]);</RULES>
      <ICON>io_analo.bmp</ICON>
      <ID/>
      <TEXT>AD Converter Feature list: 10-bit Resolution, 1 LSB Integral Non-linearity, &#xB1; 2 LSB Absolute Accuracy, 13&#x3BC;s Conversion Time, 15 kSPS at Maximum Resolution, Eight Multiplexed Single Ended Input Channels, Temperature Sensor Input Channel, Optional Left Adjustment for ADC Result Readout, 0 - VCC ADC Input Voltage Range, 1.1V ADC Reference Voltage, Free Running or Single Conversion Mode, ADC Start Conversion by Auto Triggering on Interrupt Sources, Interrupt on ADC Conversion Complete, Sleep Mode Noise Canceler</TEXT>
      <ADMUX>
        <NAME>ADMUX</NAME>
        <DESCRIPTION>The ADC multiplexer Selection Register</DESCRIPTION>
        <TEXT>These bits select the voltage reference for the ADC, as shown in Table 15-3. If these bits are changed during a conversion, the change will not go in effect until this conversion is complete (ADIF in ADCSR is set). If differential channels are used, the selected reference should not be closer to AV CC than indicated in Table 94 on page 200. The internal voltage reference options may not be used if an external reference voltage is being applied to the AREF pin.</TEXT>
        <IO_ADDR>$10</IO_ADDR>
        <MEM_ADDR>$10</MEM_ADDR>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT6>
          <NAME>REFS</NAME>
          <DESCRIPTION>Reference Selection Bit</DESCRIPTION>
          <TEXT>If this bit is changed during a conversion, the change will not go in effect until this conversion is complete (ADIF in ADCSR is set). Also note, that when these bits are changed, the next conversion will take 25 ADC clock cycles.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT3>
          <NAME>MUX3</NAME>
          <DESCRIPTION>Analog Channel and Gain Selection Bits</DESCRIPTION>
          <TEXT>The value of these bits selects which combination of analog inputs are connected to the ADC. These bits also select the gain for the differential channels. See Table 92 for details. If these bits are changed during a conversion, the change will not go in effect until this conversion is complete (ADIF in ADCSR is set).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>MUX2</NAME>
          <DESCRIPTION>Analog Channel and Gain Selection Bits</DESCRIPTION>
          <TEXT>The value of these bits selects which combination of analog inputs are connected to the ADC. These bits also select the gain for the differential channels. See Table 92 for details. If these bits are changed during a conversion, the change will not go in effect until this conversion is complete (ADIF in ADCSR is set).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>MUX1</NAME>
          <DESCRIPTION>Analog Channel and Gain Selection Bits</DESCRIPTION>
          <TEXT>The value of these bits selects which combination of analog inputs are connected to the ADC. These bits also select the gain for the differential channels. See Table 92 for details. If these bits are changed during a conversion, the change will not go in effect until this conversion is complete (ADIF in ADCSR is set).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>MUX0</NAME>
          <DESCRIPTION>Analog Channel and Gain Selection Bits</DESCRIPTION>
          <TEXT>The value of these bits selects which combination of analog inputs are connected to the ADC. These bits also select the gain for the differential channels. See Table 92 for details. If these bits are changed during a conversion, the change will not go in effect until this conversion is complete (ADIF in ADCSR is set).</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ADMUX>
      <ADCSRA>
        <NAME>ADCSRA</NAME>
        <DESCRIPTION>The ADC Control and Status register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$12</IO_ADDR>
        <MEM_ADDR>$12</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>ADEN</NAME>
          <DESCRIPTION>ADC Enable</DESCRIPTION>
          <TEXT>Writing a logical &#x2018;1&#x2019; to this bit enables the ADC. By clearing this bit to zero, the ADC is turned off. Turning the ADC off while a conversion is in progress, will terminate this conversion.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ADSC</NAME>
          <DESCRIPTION>ADC Start Conversion</DESCRIPTION>
          <TEXT>In Single Conversion Mode, a logical &#x2018;1&#x2019; must be written to this bit to start each conversion. In Free Running Mode, a logical &#x2018;1&#x2019; must be written to this bit to start the first conversion. The first time ADSC has been written after the ADC has been enabled, or if ADSC is written at the same time as the ADC is enabled, an extended conversion will result. This extended conversion performs initialization of the ADC. ADSC will read as one as long as a conversion is in progress. When the conversion is complete, it returns to zero. When a dummy conversion precedes a real conversion, ADSC will stay high until the real conversion completes. Writing a 0 to this bit has no effect</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ADATE</NAME>
          <DESCRIPTION>ADC Auto Trigger Enable</DESCRIPTION>
          <TEXT>When this bit is written to one,Auto Triggering of the ADC is enabled.The ADC will start a conversion on a positive edge of the selected trigger signal.The trigger source is selected by setting the ADC Trigger Select bits,ADTS in ADCSRB.     </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ADIF</NAME>
          <DESCRIPTION>ADC Interrupt Flag</DESCRIPTION>
          <TEXT>This bit is set (one) when an ADC conversion completes and the data registers are updated. The ADC Conversion Complete Interrupt is executed if the ADIE bit and the I-bit in SREG are set (one). ADIF is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, ADIF is cleared by writing a logical one to the flag. Beware that if doing a read-modify-write on ADCSR, a pending interrupt can be disabled. This also applies if the SBI and CBI instructions are used.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ADIE</NAME>
          <DESCRIPTION>ADC Interrupt Enable</DESCRIPTION>
          <TEXT>When this bit is set (one) and the I-bit in SREG is set (one), the ADC Conversion Complete Interrupt is activated.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ADPS2</NAME>
          <DESCRIPTION>ADC Prescaler Select Bits</DESCRIPTION>
          <TEXT>These bits determine the division factor between the XTAL frequency and the input clock to the ADC.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ADPS1</NAME>
          <DESCRIPTION>ADC Prescaler Select Bits</DESCRIPTION>
          <TEXT>These bits determine the division factor between the XTAL frequency and the input clock to the ADC.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ADPS0</NAME>
          <DESCRIPTION>ADC Prescaler Select Bits</DESCRIPTION>
          <TEXT>These bits determine the division factor between the XTAL frequency and the input clock to the ADC.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>ANALIG_ADC_PRESCALER</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ADCSRA>
      <ADCH>
        <NAME>ADCH</NAME>
        <DESCRIPTION>ADC Data Register High Byte</DESCRIPTION>
        <TEXT>When an ADC conversion is complete, the result is found in these two registers. If differential channels are used, the result is presented in two&#x2019;s complement form. The selected channel is differential if MUX4..0 are between &#x2018;01000&#x2019; and &#x2018;11101&#x2019;, otherwise the selected channel is single ended. When ADCL is read, the ADC Data Register is not updated until ADCH is read. Consequently, if the result is left adjusted and no more than 8 bit precision (7 bit + sign bit for differential input channels) is required, it is sufficient to read ADCH. Otherwise, ADCL must be read first, then ADCH. The ADLAR bit in ADMUX, and the MUX4..0 bits in ADMUX affect the way the result is read from the registers. If ADLAR is set, the result is left adjusted. If ADLAR is cleared (default), the result is right </TEXT>
        <IO_ADDR>$0F</IO_ADDR>
        <MEM_ADDR>$0F</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>ADCH7</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ADCH6</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ADCH5</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ADCH4</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ADCH3</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ADCH2</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ADCH1</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ADCH0</NAME>
          <DESCRIPTION>ADC Data Register High Byte Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ADCH>
      <ADCL>
        <NAME>ADCL</NAME>
        <DESCRIPTION>ADC Data Register Low Byte</DESCRIPTION>
        <TEXT>When an ADC conversion is complete, the result is found in these two registers. If differential channels are used, the result is presented in two&#x2019;s complement form. The selected channel is differential if MUX4..0 are between &#x2018;01000&#x2019; and &#x2018;11101&#x2019;, otherwise the selected channel is single ended. When ADCL is read, the ADC Data Register is not updated until ADCH is read. Consequently, if the result is left adjusted and no more than 8 bit precision (7 bit + sign bit for differential input channels) is required, it is sufficient to read ADCH. Otherwise, ADCL must be read first, then ADCH. The ADLAR bit in ADMUX, and the MUX4..0 bits in ADMUX affect the way the result is read from the registers. If ADLAR is set, the result is left adjusted. If ADLAR is cleared (default), the result is right</TEXT>
        <IO_ADDR>$0E</IO_ADDR>
        <MEM_ADDR>$0E</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>ADCL7</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ADCL6</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ADCL5</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ADCL4</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ADCL3</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ADCL2</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ADCL1</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ADCL0</NAME>
          <DESCRIPTION>ADC Data Register Low Byte Bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ADCL>
      <ADCSRB>
        <NAME>ADCSRB</NAME>
        <DESCRIPTION>ADC Control and Status Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$11</IO_ADDR>
        <MEM_ADDR>$11</MEM_ADDR>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT3><NAME>ADLAR</NAME><DESCRIPTION/>ADC Left Adjust Result
              <TEXT>The ADLAR bit affects the presentation of the ADC conversion result in the ADC Data Register. Write one to ADLAR to left adjust the result. Otherwise, the result is right adjusted. Changing the ADLAR bit will affect the ADC Data Register immediately, regardless of any ongoing conversions.</TEXT><ACCESS>R</ACCESS><INIT_VAL>0</INIT_VAL></BIT3>
        <BIT2>
          <NAME>ADTS2</NAME>
          <DESCRIPTION>ADC Auto Trigger Source 2</DESCRIPTION>
          <TEXT>If ADATE in ADCSRA is written to one,the value of these bits selects which source will trigger an ADC conversion.If ADATE is cleared,the ADTS2:0 settings will have no effect.A conversion will be triggered by the rising edge of the selected interrupt flag.Note that switching from a trigger source that is cleared to a trigger source that is set,will generate a positive edge on the trigger signal.If ADEN in ADCSRA is set,this will start a conversion.Switching to Free Running Mode (ADTS [2:0 ]=0)will not cause a trigger event,even if the ADC Interrupt Flag is set .   </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ADTS1</NAME>
          <DESCRIPTION>ADC Auto Trigger Source 1</DESCRIPTION>
          <TEXT>If ADATE in ADCSRA is written to one,the value of these bits selects which source will trigger an ADC conversion.If ADATE is cleared,the ADTS2:0 settings will have no effect.A conversion will be triggered by the rising edge of the selected interrupt flag.Note that switching from a trigger source that is cleared to a trigger source that is set,will generate a positive edge on the trigger signal.If ADEN in ADCSRA is set,this will start a conversion.Switching to Free Running Mode (ADTS [2:0 ]=0)will not cause a trigger event,even if the ADC Interrupt Flag is set .    </TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ADTS0</NAME>
          <DESCRIPTION>ADC Auto Trigger Source 0</DESCRIPTION>
          <TEXT>If ADATE in ADCSRA is written to one,the value of these bits selects which source will trigger an ADC conversion.If ADATE is cleared,the ADTS2:0 settings will have no effect.A conversion will be triggered by the rising edge of the selected interrupt flag.Note that switching from a trigger source that is cleared to a trigger source that is set,will generate a positive edge on the trigger signal.If ADEN in ADCSRA is set,this will start a conversion.Switching to Free Running Mode (ADTS [2:0 ]=0)will not cause a trigger event,even if the ADC Interrupt Flag is set .   </TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>ANALIG_ADC_AUTO_TRIGGER3</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ADCSRB>
      <DIDR0>
        <NAME>DIDR0</NAME>
        <DESCRIPTION>Digital Input Disable Register 0</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$0D</IO_ADDR>
        <MEM_ADDR>$0D</MEM_ADDR>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>ADC7D</NAME>
          <DESCRIPTION>ADC6 Digital input Disable</DESCRIPTION>
          <TEXT>When a bit is written logic one, the digital input buffer on the corresponding ADC pin is disabled. The corresponding PIN register bit will always read as zero when this bit is set. When an analog signal is applied to the ADC7..0 pin and the digital input from this pin is not needed, this bit should be written logic one to reduce power consumption in the digital input buffer</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ADC6D</NAME>
          <DESCRIPTION>ADC5 Digital input Disable</DESCRIPTION>
          <TEXT>When a bit is written logic one, the digital input buffer on the corresponding ADC pin is disabled. The corresponding PIN register bit will always read as zero when this bit is set. When an analog signal is applied to the ADC7..0 pin and the digital input from this pin is not needed, this bit should be written logic one to reduce power consumption in the digital input buffer</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ADC5D</NAME>
          <DESCRIPTION>ADC4 Digital input Disable</DESCRIPTION>
          <TEXT>When a bit is written logic one, the digital input buffer on the corresponding ADC pin is disabled. The corresponding PIN register bit will always read as zero when this bit is set. When an analog signal is applied to the ADC7..0 pin and the digital input from this pin is not needed, this bit should be written logic one to reduce power consumption in the digital input buffer</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ADC4D</NAME>
          <DESCRIPTION>ADC3 Digital input Disable</DESCRIPTION>
          <TEXT>When a bit is written logic one, the digital input buffer on the corresponding ADC pin is disabled. The corresponding PIN register bit will always read as zero when this bit is set. When an analog signal is applied to the ADC7..0 pin and the digital input from this pin is not needed, this bit should be written logic one to reduce power consumption in the digital input buffer</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ADC3D</NAME>
          <DESCRIPTION>AREF Digital Input Disable</DESCRIPTION>
          <TEXT>When a bit is written logic one, the digital input buffer on the corresponding ADC pin is disabled. The corresponding PIN register bit will always read as zero when this bit is set. When an analog signal is applied to the ADC7..0 pin and the digital input from this pin is not needed, this bit should be written logic one to reduce power consumption in the digital input buffer</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ADC2D</NAME>
          <DESCRIPTION>ADC2 Digital input Disable</DESCRIPTION>
          <TEXT>When a bit is written logic one, the digital input buffer on the corresponding ADC pin is disabled. The corresponding PIN register bit will always read as zero when this bit is set. When an analog signal is applied to the ADC7..0 pin and the digital input from this pin is not needed, this bit should be written logic one to reduce power consumption in the digital input buffer</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ADC1D</NAME>
          <DESCRIPTION>ADC1 Digital input Disable</DESCRIPTION>
          <TEXT>When a bit is written logic one, the digital input buffer on the corresponding ADC pin is disabled. The corresponding PIN register bit will always read as zero when this bit is set. When an analog signal is applied to the ADC7..0 pin and the digital input from this pin is not needed, this bit should be written logic one to reduce power consumption in the digital input buffer</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ADC0D</NAME>
          <DESCRIPTION>ADC0 Digital input Disable</DESCRIPTION>
          <TEXT>When a bit is written logic one, the digital input buffer on the corresponding ADC pin is disabled. The corresponding PIN register bit will always read as zero when this bit is set. When an analog signal is applied to the ADC7..0 pin and the digital input from this pin is not needed, this bit should be written logic one to reduce power consumption in the digital input buffer</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </DIDR0>
    </AD_CONVERTER>
    <ANALOG_COMPARATOR>
      <LIST>[ACSRA:ACSRB]</LIST>
      <LINK/>
      <ICON>io_analo.bmp</ICON>
      <ID>AlgComp_01</ID>
      <TEXT/>
      <ACSRB>
        <NAME>ACSRB</NAME>
        <DESCRIPTION>Analog Comparator Control And Status Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$13</IO_ADDR>
        <MEM_ADDR>$13</MEM_ADDR>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>HSEL</NAME>
          <DESCRIPTION>Hysteresis Select</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>HLEV</NAME>
          <DESCRIPTION>Hysteresis Level</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT2>
          <NAME>ACME</NAME>
          <DESCRIPTION>Analog Comparator Multiplexer Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
      </ACSRB>
      <ACSRA>
        <NAME>ACSRA</NAME>
        <DESCRIPTION>Analog Comparator Control And Status Register A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$14</IO_ADDR>
        <MEM_ADDR>$14</MEM_ADDR>
        <ICON>io_analo.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>ACD</NAME>
          <DESCRIPTION>Analog Comparator Disable</DESCRIPTION>
          <TEXT>When this bit is written logic one, the power to the analog comparator is switched off. This bit can be set at any time to turn off the analog comparator. This will reduce power consumption in active and idle mode. When changing the ACD bit, the Analog Comparator Interrupt must be disabled by clearing the ACIE bit in ACSR. Otherwise an interrupt can occur when the bit is changed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ACBG</NAME>
          <DESCRIPTION>Analog Comparator Bandgap Select</DESCRIPTION>
          <TEXT>When this bit is set, a fixed bandgap reference voltage replaces the positive input to the Analog Comparator. When this bit is cleared, AIN0 is applied to the positive input of the Analog Comparator. See &#x201C;Internal Voltage Reference&#x201D; on page 42.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ACO</NAME>
          <DESCRIPTION>Analog Compare Output</DESCRIPTION>
          <TEXT>The output of the analog comparator is synchronized and then directly connected to ACO. The synchronization introduces a delay of 1-2 clock cycles.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>NA</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ACI</NAME>
          <DESCRIPTION>Analog Comparator Interrupt Flag</DESCRIPTION>
          <TEXT>This bit is set by hardware when a comparator output event triggers the interrupt mode defined by ACIS1 and ACIS0. The Analog Comparator Interrupt routine is executed if the ACIE bit is set and the I-bit in SREG is set. ACI is cleared by hard-ware when executing the corresponding interrupt handling vector. Alternatively, ACI is cleared by writing a logic one to the flag.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ACIE</NAME>
          <DESCRIPTION>Analog Comparator Interrupt Enable</DESCRIPTION>
          <TEXT>When the ACIE bit is written logic one and the I-bit in the Status Register is set, the analog comparator interrupt is acti-vated. When written logic zero, the interrupt is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ACIC</NAME>
          <DESCRIPTION>Analog Comparator Input Capture Enable</DESCRIPTION>
          <TEXT>When written logic one, this bit enables the input capture function in Timer/Counter1 to be triggered by the Analog Comparator. The comparator output is then directly connected to the input capture front-end logic, making the comparator utilize the noise canceler and edge select features of the Timer/Counter1 Input Capture interrupt. When written logic zero, no connection between the Analog Comparator and the input capture function exists. To make the comparator trigger the Timer/Counter1 Input Capture inter-rupt, the ICIE1 bit in the Timer Interrupt Mask Register (TIMSK1) must be set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ACIS1</NAME>
          <DESCRIPTION>Analog Comparator Interrupt Mode Select bit 1</DESCRIPTION>
          <TEXT>These bits determine which comparator events that trigger the Analog Comparator interrupt.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ACIS0</NAME>
          <DESCRIPTION>Analog Comparator Interrupt Mode Select bit 0</DESCRIPTION>
          <TEXT>These bits determine which comparator events that trigger the Analog Comparator interrupt.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>ANALOG_COMP_INTERRUPT</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ACSRA>
    </ANALOG_COMPARATOR>
    <CPU>
      <LIST>[CCP:SPH:SPL:SREG:CLKMSR:CLKPSR:OSCCAL:PRR:RSTFLR:NVMCSR:NVMCMD:MCUCR]</LIST>
      <LINK>[SPH:SPL]</LINK>
      <ICON>io_cpu.bmp</ICON>
      <ID/>
      <TEXT/>
      <CCP>
        <NAME>CCP</NAME>
        <DESCRIPTION>Configuration Change Protection</DESCRIPTION>
        <TEXT>In order to enable changing the contents of an I/O register the CCP register must first be written with the correct signature. After CCP is written the protected I/O registers may be written to during the next four CPU instruction cycles. All interrupts are ignored during these cycles. After these cycles interrupts are automatically handled again by the CPU, and any pending interrupts will be executed according to their level and priority.When the protected I/O register signature is written, CCP[0] will read as one as long as the protected feature is enabled. CCP[7:1] will always read as zero.</TEXT>
        <IO_ADDR>$3C</IO_ADDR>
        <MEM_ADDR>$3C</MEM_ADDR>
        <ICON>io_sph.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>CCP7</NAME>
          <DESCRIPTION>Configuration Change Protection bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>CCP6</NAME>
          <DESCRIPTION>Configuration Change Protection bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>CCP5</NAME>
          <DESCRIPTION>Configuration Change Protection bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>CCP4</NAME>
          <DESCRIPTION>Configuration Change Protection bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>CCP3</NAME>
          <DESCRIPTION>Configuration Change Protection bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CCP2</NAME>
          <DESCRIPTION>Configuration Change Protection bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CCP1</NAME>
          <DESCRIPTION>Configuration Change Protection bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CCP0</NAME>
          <DESCRIPTION>Configuration Change Protection bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </CCP>
      <SPH>
        <NAME>SPH</NAME>
        <DESCRIPTION>Stack Pointer High</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$3E</IO_ADDR>
        <MEM_ADDR>$3E</MEM_ADDR>
        <ICON>io_sph.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>SP15</NAME>
          <DESCRIPTION>Stack pointer bit 15</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SP14</NAME>
          <DESCRIPTION>Stack pointer bit 14</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SP13</NAME>
          <DESCRIPTION>Stack pointer bit 13</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SP12</NAME>
          <DESCRIPTION>Stack pointer bit 12</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SP11</NAME>
          <DESCRIPTION>Stack pointer bit 11</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SP10</NAME>
          <DESCRIPTION>Stack pointer bit 10</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SP9</NAME>
          <DESCRIPTION>Stack pointer bit 9</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SP8</NAME>
          <DESCRIPTION>Stack pointer bit 8</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SPH>
      <SPL>
        <NAME>SPL</NAME>
        <DESCRIPTION>Stack Pointer Low</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$3D</IO_ADDR>
        <MEM_ADDR>$3D</MEM_ADDR>
        <ICON>io_sph.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>SP7</NAME>
          <DESCRIPTION>Stack pointer bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SP6</NAME>
          <DESCRIPTION>Stack pointer bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SP5</NAME>
          <DESCRIPTION>Stack pointer bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SP4</NAME>
          <DESCRIPTION>Stack pointer bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SP3</NAME>
          <DESCRIPTION>Stack pointer bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SP2</NAME>
          <DESCRIPTION>Stack pointer bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SP1</NAME>
          <DESCRIPTION>Stack pointer bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SP0</NAME>
          <DESCRIPTION>Stack pointer bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SPL>
      <SREG>
        <NAME>SREG</NAME>
        <DESCRIPTION>Status Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$3F</IO_ADDR>
        <MEM_ADDR>$3F</MEM_ADDR>
        <ICON>io_sreg.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>I</NAME>
          <DESCRIPTION>Global Interrupt Enable</DESCRIPTION>
          <TEXT>The global interrupt enable bit must be set (one) for the interrupts to be enabled. The individual interrupt enable control is then performed in separate control registers. If the global interrupt enable bit is cleared (zero), none of the interrupts are enabled independent of the individual interrupt enable settings. The I-bit is cleared by hardware after an interrupt has occurred, and is set by the RETI instruction to enable subsequent interrupts.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>T</NAME>
          <DESCRIPTION>Bit Copy Storage</DESCRIPTION>
          <TEXT>The bit copy instructions BLD (Bit LoaD) and BST (Bit STore) use the T bit as source and destination for the operated bit. A bit from a register in the register file can be copied into T by the BST instruction, and a bit in T can be copied into a bit in a register in the register file by the BLD instruction.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>H</NAME>
          <DESCRIPTION>Half Carry Flag</DESCRIPTION>
          <TEXT>The half carry flag H indicates a half carry in some arithmetic operations. See the Instruction Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>S</NAME>
          <DESCRIPTION>Sign Bit</DESCRIPTION>
          <TEXT>The S-bit is always an exclusive or between the negative flag N and the twos complement overflow flag V. See the Instruc-tion Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>V</NAME>
          <DESCRIPTION>Two's Complement Overflow Flag</DESCRIPTION>
          <TEXT>The twos complement overflow flag V supports twos complement arithmetics. See the Instruction Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>N</NAME>
          <DESCRIPTION>Negative Flag</DESCRIPTION>
          <TEXT>The negative flag N indicates a negative result after the different arithmetic and logic operations. See the Instruction Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>Z</NAME>
          <DESCRIPTION>Zero Flag</DESCRIPTION>
          <TEXT>The zero flag Z indicates a zero result after the different arithmetic and logic operations. See the Instruction Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>C</NAME>
          <DESCRIPTION>Carry Flag</DESCRIPTION>
          <TEXT>The carry flag C indicates a carry in an arithmetic or logic operation. See the Instruction Set Description for detailed information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SREG>
      <CLKMSR>
        <NAME>CLKMSR</NAME>
        <DESCRIPTION>Clock Main Settings Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$37</IO_ADDR>
        <MEM_ADDR>$37</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT1>
          <NAME>CLKMS1</NAME>
          <DESCRIPTION>Clock Main Select Bit 1</DESCRIPTION>
          <TEXT>These bits select the main clock source of the system. The bits can be written at run-time to switch the source of the main clock. The clock system ensures glitch free switching of the main clock source.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CLKMS0</NAME>
          <DESCRIPTION>Clock Main Select Bit 0</DESCRIPTION>
          <TEXT>These bits select the main clock source of the system. The bits can be written at run-time to switch the source of the main clock. The clock system ensures glitch free switching of the main clock source.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </CLKMSR>
      <CLKPSR>
        <NAME>CLKPSR</NAME>
        <DESCRIPTION>Clock Prescale Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$36</IO_ADDR>
        <MEM_ADDR>$36</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT3>
          <NAME>CLKPS3</NAME>
          <DESCRIPTION>Clock Prescaler Select Bit 3</DESCRIPTION>
          <TEXT>These bits define the division factor between the selected clock source and the internal system clock. These bits can be written run-time to vary the clock frequency to suit the application requirements. As the divider divides the master clock input to the MCU, the speed of all synchronous peripherals is reduced when a division factor is used.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CLKPS2</NAME>
          <DESCRIPTION>Clock Prescaler Select Bit 2</DESCRIPTION>
          <TEXT>These bits define the division factor between the selected clock source and the internal system clock. These bits can be written run-time to vary the clock frequency to suit the application requirements. As the divider divides the master clock input to the MCU, the speed of all synchronous peripherals is reduced when a division factor is used.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CLKPS1</NAME>
          <DESCRIPTION>Clock Prescaler Select Bit 1</DESCRIPTION>
          <TEXT>These bits define the division factor between the selected clock source and the internal system clock. These bits can be written run-time to vary the clock frequency to suit the application requirements. As the divider divides the master clock input to the MCU, the speed of all synchronous peripherals is reduced when a division factor is used.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CLKPS0</NAME>
          <DESCRIPTION>Clock Prescaler Select Bit 0</DESCRIPTION>
          <TEXT>These bits define the division factor between the selected clock source and the internal system clock. These bits can be written run-time to vary the clock frequency to suit the application requirements. As the divider divides the master clock input to the MCU, the speed of all synchronous peripherals is reduced when a division factor is used.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>CPU_CLK_PRESCALE_4_BITS_SMALL</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </CLKPSR>
      <OSCCAL>
        <NAME>OSCCAL</NAME>
        <DESCRIPTION>Oscillator Calibration Value</DESCRIPTION>
        <TEXT>The oscillator calibration register is used to trim the calibrated internal oscillator and remove process variations from the oscillator frequency. A pre-programmed calibration value is automatically written to this register during chip reset.The application software can write this register to change the oscillator frequency. Calibration outside the range given is not guaranteed. The CAL[7:0] bits are used to tune the frequency of the oscillator. A setting of 0x00 gives the lowest frequency, and a setting of 0xFF gives the highest frequency.</TEXT>
        <IO_ADDR>$39</IO_ADDR>
        <MEM_ADDR>$39</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>CAL7</NAME>
          <DESCRIPTION>Oscillator Calibration Value Bit7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>CAL6</NAME>
          <DESCRIPTION>Oscillator Calibration Value Bit6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>CAL5</NAME>
          <DESCRIPTION>Oscillator Calibration Value Bit5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>CAL4</NAME>
          <DESCRIPTION>Oscillator Calibration Value Bit4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>CAL3</NAME>
          <DESCRIPTION>Oscillator Calibration Value Bit3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CAL2</NAME>
          <DESCRIPTION>Oscillator Calibration Value Bit2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CAL1</NAME>
          <DESCRIPTION>Oscillator Calibration Value Bit1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CAL0</NAME>
          <DESCRIPTION>Oscillator Calibration Value Bit0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OSCCAL>
      <PRR>
        <NAME>PRR</NAME>
        <DESCRIPTION>Power Reduction Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$35</IO_ADDR>
        <MEM_ADDR>$35</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT4>
          <NAME>PRTWI</NAME>
          <DESCRIPTION>Power Reduction TWI</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PRSPI</NAME>
          <DESCRIPTION>Power Reduction Serial Peripheral Interface</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PRTIM1</NAME>
          <DESCRIPTION>Power Reduction Timer/Counter1</DESCRIPTION>
          <TEXT>Writing a logic one to this bit shuts down the Timer/Counter1 module. When the Timer/Counter1 is enabled, operation will continue like before the shutdown.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PRTIM0</NAME>
          <DESCRIPTION>Power Reduction Timer/Counter0</DESCRIPTION>
          <TEXT>Writing a logic one to this bit shuts down the Timer/Counter0 module. When the Timer/Counter0 is enabled, operation will continue like before the shutdown.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PRADC</NAME>
          <DESCRIPTION>Power Reduction ADC</DESCRIPTION>
          <TEXT>Writing a logic one to this bit shuts down the ADC. The ADC must be disabled before shut down. The analog comparator cannot use the ADC input MUX when the ADC is shut down.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PRR>
      <RSTFLR>
        <NAME>RSTFLR</NAME>
        <DESCRIPTION>Reset Flag Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$3B</IO_ADDR>
        <MEM_ADDR>$3B</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT3>
          <NAME>WDRF</NAME>
          <DESCRIPTION>Watchdog Reset Flag</DESCRIPTION>
          <TEXT>This bit is set if a Watchdog Reset occurs. The bit is reset by a Power-on Reset, or by writing a logic zero to the flag.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT1>
          <NAME>EXTRF</NAME>
          <DESCRIPTION>External Reset Flag</DESCRIPTION>
          <TEXT>This bit is set if an External Reset occurs. The bit is reset by a Power-on Reset, or by writing a logic zero to the flag.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PORF</NAME>
          <DESCRIPTION>Power-on Reset Flag</DESCRIPTION>
          <TEXT>This bit is set if a Power-on Reset occurs. The bit is reset only by writing a logic zero to the flag. To make use of the Reset Flags to identify a reset condition, the user should read and then reset the MCUSR as early as possible in the program. If the register is cleared before another reset occurs, the source of the reset can be found by examining the Reset Flags.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </RSTFLR>
      <NVMCSR>
        <NAME>NVMCSR</NAME>
        <DESCRIPTION>Non-Volatile Memory Control and Status Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$32</IO_ADDR>
        <MEM_ADDR>$32</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>NVMBSY</NAME>
          <DESCRIPTION>Non-Volatile Memory Busy</DESCRIPTION>
          <TEXT>This bit indicates the NVM Memory (Flash memory and Lock Bits) is busy, being programmed. This bit is set when a program operation is started, and it remains set until the operation has been completed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
      </NVMCSR>
      <NVMCMD>
        <NAME>NVMCMD</NAME>
        <DESCRIPTION>Non-Volatile Memory Command</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$33</IO_ADDR>
        <MEM_ADDR>$33</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT5>
          <NAME>NVMCMD5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>NVMCMD4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>NVMCMD3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>NVMCMD2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>NVMCMD1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>NVMCMD0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </NVMCMD>
      <MCUCR>
        <NAME>MCUCR</NAME>
        <DESCRIPTION>MCU Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$3A</IO_ADDR>
        <MEM_ADDR>$3A</MEM_ADDR>
        <ICON>io_cpu.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>ISC01</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ISC00</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT4>
          <NAME>BODS</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SM2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SM1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SM0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SE</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </MCUCR>
    </CPU>
    <EXTERNAL_INTERRUPT>
      <LIST>[PCMSK1:PCMSK0:GIFR:GIMSK]</LIST>
      <LINK/>
      <ICON>io_ext.bmp</ICON>
      <ID/>
      <TEXT/>
      <PCMSK1>
        <NAME>PCMSK1</NAME>
        <DESCRIPTION>Pin Change Mask Register 1</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$0A</IO_ADDR>
        <MEM_ADDR>$0A</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT3>
          <NAME>PCINT11</NAME>
          <DESCRIPTION>Pin Change Enable Mask 11</DESCRIPTION>
          <TEXT>Each PCINT11..8 bit selects whether pin change interrupt is enabled on the corresponding I/O pin. If PCINT11..8 is set and the PCIE1 bit in GIMSK is set, pin change interrupt is enabled on the corresponding I/O pin. If PCINT11..8 is cleared, pin change interrupt on the corresponding I/O pin is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PCINT10</NAME>
          <DESCRIPTION>Pin Change Enable Mask 10</DESCRIPTION>
          <TEXT>Each PCINT11..8 bit selects whether pin change interrupt is enabled on the corresponding I/O pin. If PCINT11..8 is set and the PCIE1 bit in GIMSK is set, pin change interrupt is enabled on the corresponding I/O pin. If PCINT11..8 is cleared, pin change interrupt on the corresponding I/O pin is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PCINT9</NAME>
          <DESCRIPTION>Pin Change Enable Mask 9</DESCRIPTION>
          <TEXT>Each PCINT11..8 bit selects whether pin change interrupt is enabled on the corresponding I/O pin. If PCINT11..8 is set and the PCIE1 bit in GIMSK is set, pin change interrupt is enabled on the corresponding I/O pin. If PCINT11..8 is cleared, pin change interrupt on the corresponding I/O pin is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PCINT8</NAME>
          <DESCRIPTION>Pin Change Enable Mask 8</DESCRIPTION>
          <TEXT>Each PCINT11..8 bit selects whether pin change interrupt is enabled on the corresponding I/O pin. If PCINT11..8 is set and the PCIE1 bit in GIMSK is set, pin change interrupt is enabled on the corresponding I/O pin. If PCINT11..8 is cleared, pin change interrupt on the corresponding I/O pin is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PCMSK1>
      <PCMSK0>
        <NAME>PCMSK0</NAME>
        <DESCRIPTION>Pin Change Mask Register 0</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$09</IO_ADDR>
        <MEM_ADDR>$09</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>PCINT7</NAME>
          <DESCRIPTION>Pin Change Enable Mask 7</DESCRIPTION>
          <TEXT>Each PCINT7..0 bit selects whether pin change interrupt is enabled on the corresponding I/O pin. If PCINT7..0 is set and the PCIE0 bit in GIMSK is set, pin change interrupt is enabled on the corresponding I/O pin. If PCINT7..0 is cleared, pin change interrupt on the corresponding I/O pin is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PCINT6</NAME>
          <DESCRIPTION>Pin Change Enable Mask 6</DESCRIPTION>
          <TEXT>Each PCINT7..0 bit selects whether pin change interrupt is enabled on the corresponding I/O pin. If PCINT7..0 is set and the PCIE0 bit in GIMSK is set, pin change interrupt is enabled on the corresponding I/O pin. If PCINT7..0 is cleared, pin change interrupt on the corresponding I/O pin is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PCINT5</NAME>
          <DESCRIPTION>Pin Change Enable Mask 5</DESCRIPTION>
          <TEXT>Each PCINT7..0 bit selects whether pin change interrupt is enabled on the corresponding I/O pin. If PCINT7..0 is set and the PCIE0 bit in GIMSK is set, pin change interrupt is enabled on the corresponding I/O pin. If PCINT7..0 is cleared, pin change interrupt on the corresponding I/O pin is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PCINT4</NAME>
          <DESCRIPTION>Pin Change Enable Mask 4</DESCRIPTION>
          <TEXT>Each PCINT7..0 bit selects whether pin change interrupt is enabled on the corresponding I/O pin. If PCINT7..0 is set and the PCIE0 bit in GIMSK is set, pin change interrupt is enabled on the corresponding I/O pin. If PCINT7..0 is cleared, pin change interrupt on the corresponding I/O pin is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PCINT3</NAME>
          <DESCRIPTION>Pin Change Enable Mask 3</DESCRIPTION>
          <TEXT>Each PCINT7..0 bit selects whether pin change interrupt is enabled on the corresponding I/O pin. If PCINT7..0 is set and the PCIE0 bit in GIMSK is set, pin change interrupt is enabled on the corresponding I/O pin. If PCINT7..0 is cleared, pin change interrupt on the corresponding I/O pin is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PCINT2</NAME>
          <DESCRIPTION>Pin Change Enable Mask 2</DESCRIPTION>
          <TEXT>Each PCINT7..0 bit selects whether pin change interrupt is enabled on the corresponding I/O pin. If PCINT7..0 is set and the PCIE0 bit in GIMSK is set, pin change interrupt is enabled on the corresponding I/O pin. If PCINT7..0 is cleared, pin change interrupt on the corresponding I/O pin is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PCINT1</NAME>
          <DESCRIPTION>Pin Change Enable Mask 1</DESCRIPTION>
          <TEXT>Each PCINT7..0 bit selects whether pin change interrupt is enabled on the corresponding I/O pin. If PCINT7..0 is set and the PCIE0 bit in GIMSK is set, pin change interrupt is enabled on the corresponding I/O pin. If PCINT7..0 is cleared, pin change interrupt on the corresponding I/O pin is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PCINT0</NAME>
          <DESCRIPTION>Pin Change Enable Mask 0</DESCRIPTION>
          <TEXT>Each PCINT7..0 bit selects whether pin change interrupt is enabled on the corresponding I/O pin. If PCINT7..0 is set and the PCIE0 bit in GIMSK is set, pin change interrupt is enabled on the corresponding I/O pin. If PCINT7..0 is cleared, pin change interrupt on the corresponding I/O pin is disabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PCMSK0>
      <GIFR>
        <NAME>GIFR</NAME>
        <DESCRIPTION>General Interrupt Flag Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$0B</IO_ADDR>
        <MEM_ADDR>$0B</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT5>
          <NAME>PCIF1</NAME>
          <DESCRIPTION>Pin Change Interrupt Flag 1</DESCRIPTION>
          <TEXT>When a logic change on any PCINT11..8 pin triggers an interrupt request, PCIF1 becomes set (one). If the I-bit in SREG and the PCIE1 bit in GIMSK are set (one), the MCU will jump to the corresponding Interrupt Vector. The flag is cleared when the interrupt routine is executed. Alternatively, the flag can be cleared by writing a logical one to it.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PCIF0</NAME>
          <DESCRIPTION>Pin Change Interrupt Flag 0</DESCRIPTION>
          <TEXT>When a logic change on any PCINT7..0 pin triggers an interrupt request, PCIF becomes set(one). If the I-bit in SREG and the PCIE0 bit in GIMSK are set (one), the MCU will jump to the corresponding Interrupt Vector. The flag is cleared when the interrupt routine is executed. Alternatively, the flag can be cleared by writing a logical one to it.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT0>
          <NAME>INTF0</NAME>
          <DESCRIPTION>External Interrupt Flag 0</DESCRIPTION>
          <TEXT>When an edge or logic change on the INT0 pin triggers an interrupt request, INTF0 becomes set (one). If the I-bit in SREG and the INT0 bit in GIMSK are set (one), the MCU will jump to the corresponding Interrupt Vector. The flag is cleared when the interrupt routine is executed. Alternatively, the flag can be cleared by writing a logical one to it. This flag is always cleared when INT0 is configured as a level interrupt.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </GIFR>
      <GIMSK>
        <NAME>GIMSK</NAME>
        <DESCRIPTION>General Interrupt Mask Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$0C</IO_ADDR>
        <MEM_ADDR>$0C</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT5>
          <NAME>PCIE1</NAME>
          <DESCRIPTION>Pin Change Interrupt Enable 1</DESCRIPTION>
          <TEXT>When the PCIE1 bit is set (one) and the I-bit in the Status Register (SREG) is set (one), pin change interrupt 1 is enabled. Any change on any enabled PCINT11..8 pin will cause an interrupt. The corresponding interrupt of Pin Change Interrupt Request is executed from the PCI1 Interrupt Vector. PCINT11..8 pins are enabled individually by the PCMSK1 Register.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PCIE0</NAME>
          <DESCRIPTION>Pin Change Interrupt Enable 0</DESCRIPTION>
          <TEXT>When the PCIE0 bit is set (one) and the I-bit in the Status Register (SREG) is set (one), pin change interrupt 0 is enabled. Any change on any enabled PCINT7..0 pin will cause an interrupt. The corresponding interrupt of Pin Change Interrupt Request is executed from the PCI0 Interrupt Vector. PCINT7..0 pins are enabled individually by the PCMSK0 Register.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT0>
          <NAME>INT0</NAME>
          <DESCRIPTION>External Interrupt Request 0 Enable</DESCRIPTION>
          <TEXT>When the INT0 bit is set (one) and the I-bit in the Status Register (SREG) is set (one), the external pin interrupt is enabled. The Interrupt Sense Control bits (ISC01 and ISC00) in the MCU Control Register (MCUCR) define whether the external interrupt is activated on rising and/or falling edge of the INT0 pin or level sensed. Activity on the pin will cause an interrupt request even if INT0 is configured as an output. The corresponding interrupt of External Interrupt Request 0 is executed from the INT0 Interrupt Vector.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </GIMSK>
    </EXTERNAL_INTERRUPT>
    <TIMER_COUNTER_0>
      <LIST>[TCCR0A:TCCR0B:TIMSK:TIFR:GTCCR:TCNT0:OCR0A:OCR0B]</LIST>
      <LINK>[TCNT0H:TCNT0L]</LINK>
      <ICON>io_timer.bmp</ICON>
      <ID/>
      <TEXT/>
      <TCCR0A>
        <NAME>TCCR0A</NAME>
        <DESCRIPTION>Timer/Counter 0 Control Register A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$19</IO_ADDR>
        <MEM_ADDR>$19</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>COM0A1</NAME>
          <DESCRIPTION>Compare Output Mode for Channel A bit 1</DESCRIPTION>
          <TEXT>The COM0A1:0 and COM0B1:0 control the behaviour of Output Compare pins OC0A and OC0B, respectively. If one or both COM0A1:0 bits are written to one, the OC0A output overrides the normal port functionality of the I/O pin it is connected to. Similarly, if one or both COM0B1:0 bit are written to one, the OC0B output overrides the normal port functionality of the I/O pin it is connected to. Note, however, that the Data Direction Register (DDR) bit corresponding to the OC0A or OC0B pin must be set in order to enable the output driver.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>COM0A0</NAME>
          <DESCRIPTION>Compare Output Mode for Channel A bit 0</DESCRIPTION>
          <TEXT>The COM0A1:0 and COM0B1:0 control the behaviour of Output Compare pins OC0A and OC0B, respectively. If one or both COM0A1:0 bits are written to one, the OC0A output overrides the normal port functionality of the I/O pin it is connected to. Similarly, if one or both COM0B1:0 bit are written to one, the OC0B output overrides the normal port functionality of the I/O pin it is connected to. Note, however, that the Data Direction Register (DDR) bit corresponding to the OC0A or OC0B pin must be set in order to enable the output driver.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>COM0B1</NAME>
          <DESCRIPTION>Compare Output Mode for Channel B bit 1</DESCRIPTION>
          <TEXT>The COM0A1:0 and COM0B1:0 control the behaviour of Output Compare pins OC0A and OC0B, respectively. If one or both COM0A1:0 bits are written to one, the OC0A output overrides the normal port functionality of the I/O pin it is connected to. Similarly, if one or both COM0B1:0 bit are written to one, the OC0B output overrides the normal port functionality of the I/O pin it is connected to. Note, however, that the Data Direction Register (DDR) bit corresponding to the OC0A or OC0B pin must be set in order to enable the output driver.</TEXT>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>COM0B0</NAME>
          <DESCRIPTION>Compare Output Mode for Channel B bit 0</DESCRIPTION>
          <TEXT>The COM0A1:0 and COM0B1:0 control the behaviour of Output Compare pins OC0A and OC0B, respectively. If one or both COM0A1:0 bits are written to one, the OC0A output overrides the normal port functionality of the I/O pin it is connected to. Similarly, if one or both COM0B1:0 bit are written to one, the OC0B output overrides the normal port functionality of the I/O pin it is connected to. Note, however, that the Data Direction Register (DDR) bit corresponding to the OC0A or OC0B pin must be set in order to enable the output drive</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT1>
          <NAME>WGM01</NAME>
          <DESCRIPTION>Waveform Generation Mode</DESCRIPTION>
          <TEXT>Combined with WGM03:2 bits of TCCR0B, these bits control the counting sequence of the counter, the source for maximum (TOP) counter value, and what type of waveform to generate. Modes of operation supported by the Timer/Counter unit are: Normal mode (counter), Clear Timer on Compare match (CTC) mode, and three types of Pulse Width Modulation(PWM) modes.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>WGM00</NAME>
          <DESCRIPTION>Waveform Generation Mode</DESCRIPTION>
          <TEXT>Combined with WGM03:2 bits of TCCR0B, these bits control the counting sequence of the counter, the source for maximum (TOP) counter value, and what type of waveform to generate. Modes of operation supported by the Timer/Counter unit are: Normal mode (counter), Clear Timer on Compare match (CTC) mode, and three types of Pulse Width Modulation(PWM) modes.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCCR0A>
      <TCCR0B>
        <NAME>TCCR0B</NAME>
        <DESCRIPTION>Timer/Counter 0 Control Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$18</IO_ADDR>
        <MEM_ADDR>$18</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>FOC0A</NAME>
          <DESCRIPTION>Force Output Compare A</DESCRIPTION>
          <TEXT>The FOC0A bit is only active when the WGM bits specify a non-PWM mode. However, for ensuring compatibility with future devices, this bit must be set to zero when TCCR0B is written when operating in PWM mode. When writing a logical one to the FOC0A bit,an immediate Compare Match is forced on the Waveform Generation unit. The OC0A output is changed according to its COM0A1:0 bits setting. Note that the FOC0A bit is implemented as a strobe. Therefore it is the value present in the COM0A1:0 bits that determines the effect of the forced compare.A FOC0A strobe will not generate any interrupt, nor will it clear the timer in CTC mode using OCR0A as TOP.The FOC0A bit always reads as zero.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>FOC0B</NAME>
          <DESCRIPTION>Force Output Compare B</DESCRIPTION>
          <TEXT>The FOC0B bit is only active when the WGM bits specify a non-PWM mode.However, for ensuring compatibility with future devices, this bit must be set to zero when TCCR0B is written when operating in PWM mode. When writing a logical one to the FOC0B bit,an immediate Compare Match is forced on the Waveform Generation unit. The OC0B output is changed according to its COM0B1:0 bits setting. Note that the FOC0B bit is implemented as a strobe. Therefore it is the value present in the COM0B1:0 bits that determines the effect of the forced compare.A FOC0B strobe will not generate any interrupt, nor will it clear the timer in CTC mode using OCR0B as TOP.</TEXT>
          <ACESS>RW</ACESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT3>
          <NAME>WGM02</NAME>
          <DESCRIPTION>Waveform Generation Mode</DESCRIPTION>
          <TEXT>See the description in the &#x201C;TCCR0A &#x2013; Timer/Counter Control Register A&#x201D; on page 72.</TEXT>
          <ACESS>RW</ACESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CS02</NAME>
          <DESCRIPTION>Clock Select</DESCRIPTION>
          <TEXT>The three Clock Select bits set the clock source to be used by the Timer/Counter.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CS01</NAME>
          <DESCRIPTION>Clock Select</DESCRIPTION>
          <TEXT>The three Clock Select bits set the clock source to be used by the Timer/Counter</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CS00</NAME>
          <DESCRIPTION>Clock Select</DESCRIPTION>
          <TEXT>The three Clock Select bits set the clock source to be used by the Timer/Counter</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>CLK_SEL_3BIT_EXT</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCCR0B>
      <TIMSK>
        <NAME>TIMSK</NAME>
        <DESCRIPTION>Timer Interrupt Mask Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$26</IO_ADDR>
        <MEM_ADDR>$26</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>ICIE1</NAME>
          <DESCRIPTION>Input Capture Interrupt Enable</DESCRIPTION>
          <TEXT>When this bit is written to one, and the I-flag in the Status Register is set (interrupts globally enabled), the Timer/Countern Input Capture interrupt is enabled. The corresponding Interrupt Vector (See &#x201C;Interrupts&#x201D; on page 66.) is executed when the ICF1 Flag, located in TIFR, is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT5>
          <NAME>OCIE1B</NAME>
          <DESCRIPTION>Output Compare B Match Interrupt Enable</DESCRIPTION>
          <TEXT>When this bit is written to one, and the I-flag in the Status Register is set (interrupts globally enabled), the Timer/Counter1 Output Compare B Match interrupt is enabled. The corresponding Interrupt Vector is executed when the OCF1B flag, located in TIFR, is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCIE1A</NAME>
          <DESCRIPTION>Output Compare A Match Interrupt Enable</DESCRIPTION>
          <TEXT>When this bit is written to one, and the I-flag in the Status Register is set (interrupts globally enabled), the Timer/Counter0 Output Compare A Match interrupt is enabled. The corresponding Interrupt Vector is executed when the OCF0A flag, located in TIFR0, is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TOIE1</NAME>
          <DESCRIPTION>Overflow Interrupt Enable</DESCRIPTION>
          <TEXT>When this bit is written to one, and the I-flag in the Status Register is set (interrupts globally enabled), the Timer/Counter1 Overflow interrupt is enabled. The corresponding Interrupt Vector is executed when the TOV1 flag, located in TIFR1, is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCIE0B</NAME>
          <DESCRIPTION>Timer/Counter Output Compare Match B Interrupt Enable</DESCRIPTION>
          <TEXT>When the OCIE0B bit is written to one, and the I-bit in the Status Register is set, the Timer/Counter Compare Match B interrupt is enabled. The corresponding interrupt is executed if a Compare Match in Timer/Counter occurs, i.e., when the OCF0B bit is set in the Timer/Counter Interrupt Flag Register &#x2013; TIFR.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCIE0A</NAME>
          <DESCRIPTION>Timer/Counter0 Output Compare Match A Interrupt Enable</DESCRIPTION>
          <TEXT>When the OCIE0A bit is written to one, and the I-bit in the Status Register is set, the Timer/Counter0 Compare Match A interrupt is enabled. The corresponding interrupt is executed if a Compare Match in Timer/Counter0 occurs, i.e., when the OCF0A bit is set in the Timer/Counter Interrupt Flag Register &#x2013; TIFR.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TOIE0</NAME>
          <DESCRIPTION>Timer/Counter0 Overflow Interrupt Enable</DESCRIPTION>
          <TEXT>When the TOIE0 bit is written to one, and the I-bit in the Status Register is set, the Timer/Counter0 Overflow interrupt is enabled. The corresponding interrupt is executed if an overflow in Timer/Counter0 occurs, i.e., when the TOV0 bit is set in the Timer/Counter Interrupt Flag Register &#x2013; TIFR.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TIMSK>
      <TIFR>
        <NAME>TIFR</NAME>
        <DESCRIPTION>Overflow Interrupt Enable</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$25</IO_ADDR>
        <MEM_ADDR>$25</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>ICF1</NAME>
          <DESCRIPTION>Input Capture Flag</DESCRIPTION>
          <TEXT>This flag is set when a capture event occurs on the ICP1 pin. When the Input Capture Register (ICR1) is set by the WGM13:0 to be used as the TOP value, the ICF1 flag is set when the counter reaches the TOP value.ICF1 is automatically cleared when the Input Capture Interrupt Vector is executed. Alternatively, ICF1 can be cleared by writing a logic one to its bit location.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT5>
          <NAME>OCF1B</NAME>
          <DESCRIPTION>Timer Output Compare Flag 1B</DESCRIPTION>
          <TEXT>This flag is set in the timer clock cycle after the counter (TCNT1) value matches the Output Compare Register B (OCR1B). Note that a Forced Output Compare (1B) strobe will not set the OCF1B flag. OCF1B is automatically cleared when the Output Compare Match B Interrupt Vector is executed.Alternatively, OCF1B can be cleared by writing a logic one to its bit location.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCF1A</NAME>
          <DESCRIPTION>Timer Output Compare Flag 1A</DESCRIPTION>
          <TEXT>This flag is set in the timer clock cycle after the counter (TCNT1) value matches the Output Compare Register A (OCR1A).Note that a Forced Output Compare (1A) strobe will not set the OCF1A flag.OCF1A is automatically cleared when the Output Compare Match A Interrupt Vector is executed. Alternatively, OCF1A can be cleared by writing a logic one to its bit location.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TOV1</NAME>
          <DESCRIPTION>Timer Overflow Flag</DESCRIPTION>
          <TEXT>The setting of this flag is dependent of the WGM13:0 bits setting. In Normal and CTC modes,the TOV1 flag is set when the timer overflows. See Table 12-5 on page 102 for the TOV1 flag behavior when using another WGM13:0 bit setting. TOV1 is automatically cleared when the Timer/Counter1 Overflow Interrupt Vector is executed. Alternatively, TOV1 can be cleared by writing a logic one to its bit location.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCF0B</NAME>
          <DESCRIPTION>Output Compare Flag 0 B</DESCRIPTION>
          <TEXT>The OCF0B bit is set when a Compare Match occurs between the Timer/Counter and the data in OCR0B &#x2013; Output Compare Register0 B. OCF0B is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, OCF0B is cleared by writing a logic one to the flag. When the I-bit in SREG, OCIE0B (Timer/Counter Compare B Match Interrupt Enable), and OCF0B are set, the Timer/Counter Compare Match Interrupt is executed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCF0A</NAME>
          <DESCRIPTION>Output Compare Flag 0 A</DESCRIPTION>
          <TEXT>The OCF0A bit is set when a Compare Match occurs between the Timer/Counter0 and the data in OCR0A &#x2013; Output Compare Register0. OCF0A is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, OCF0A is cleared by writing a logic one to the flag. When the I-bit in SREG, OCIE0A (Timer/Counter0 Compare Match Interrupt Enable), and OCF0A are set, the Timer/Counter0 Compare Match Interrupt is executed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TOV0</NAME>
          <DESCRIPTION>Timer/Counter0 Overflow Flag</DESCRIPTION>
          <TEXT>The bit TOV0 is set when an overflow occurs in Timer/Counter0. TOV0 is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, TOV0 is cleared by writing a logic one to the flag. When the SREG I-bit, TOIE0 (Timer/Counter0 Overflow Interrupt Enable), and TOV0 are set, the Timer/Counter0 Overflow interrupt is executed. The setting of this flag is dependent of the WGM02:0 bit setting. See Table 11-8 on page 75 and &#x201C;Waveform Generation Mode Bit Description&#x201D; on page 75.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TIFR>
      <GTCCR>
        <NAME>GTCCR</NAME>
        <DESCRIPTION>General Timer/Counter Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$27</IO_ADDR>
        <MEM_ADDR>$27</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>TSM</NAME>
          <DESCRIPTION>Timer Synchronization Mode</DESCRIPTION>
          <TEXT>Writing the TSM bit to one activates the Timer/Counter Synchronization mode. In this mode, the value that is written to the PSR bit is kept, hence keeping the Prescaler Reset signal asserted.This ensures that the Timer/Counter is halted and can be configured without the risk of advancing during configuration. When the TSM bit is written to zero, the PSR bit is cleared by hardware, and the Timer/Counter start counting.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT0>
          <NAME>PSR</NAME>
          <DESCRIPTION>Prescaler Reset</DESCRIPTION>
          <TEXT>When this bit is one, the Timer/Counter0 prescaler will be Reset. This bit is normally cleared immediately by hardware, except if the TSM bit is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </GTCCR>
      <TCNT0>
        <NAME>TCNT0</NAME>
        <DESCRIPTION>Timer/Counter0</DESCRIPTION>
        <TEXT>The Timer/Counter Register gives direct access, both for read and write operations, to the Timer/Counter unit 8-bit counter. Writing to the TCNT0 register blocks (removes) the compare match on the following timer clock. Modifying the counter (TCNT0) while the counter is running, introduces a risk of missing a compare match between TCNT0 the OCR0 register.</TEXT>
        <IO_ADDR>$17</IO_ADDR>
        <MEM_ADDR>$17</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TCNT0_7</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TCNT0_6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TCNT0_5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TCNT0_4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TCNT0_3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TCNT0_2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TCNT0_1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TCNT0_0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCNT0>
      <OCR0A>
        <NAME>OCR0A</NAME>
        <DESCRIPTION>Timer/Counter0 Output Compare Register</DESCRIPTION>
        <TEXT>The Output Compare Register contains an 8-bit value that is continuously compared with the counter value (TCNT0). A match can be used to generate an output compare interrupt, or to generate a waveform output on the OC0 pin.</TEXT>
        <IO_ADDR>$16</IO_ADDR>
        <MEM_ADDR>$16</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR0_7</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR0_6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR0_5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR0_4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR0_3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR0_2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR0_1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR0_0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCR0A>
      <OCR0B>
        <NAME>OCR0B</NAME>
        <DESCRIPTION>Timer/Counter0 Output Compare Register</DESCRIPTION>
        <TEXT>The Output Compare Register contains an 8-bit value that is continuously compared with the counter value (TCNT0). A match can be used to generate an output compare interrupt, or to generate a waveform output on the OC0 pin.</TEXT>
        <IO_ADDR>$15</IO_ADDR>
        <MEM_ADDR>$15</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR0B_7</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR0B_6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR0B_5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR0B_4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR0B_3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR0B_2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR0B_1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR0B_0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCR0B>
    </TIMER_COUNTER_0>
    <TWI>
      <LIST>[TWSCRA:TWSCRB:TWSSRA:TWSA:TWSD:TWSAM]</LIST>
      <LINK/>
      <ICON>io_com.bmp</ICON>
      <ID/>
      <TEXT>TWI: Simple yet powerful and flexible communications interface, only two bus lines needed. Both master and slave operation supported. Device can operate as transmitter or receiver. 7-bit address space allows up to 128 different slave addresses.  Multi-master arbitration support  Up to 400 kHz data transfer speed  Slew-rate limited output drivers  Noise suppression circuitry rejects spikes on bus lines  Fully programmable slave address with general call support  Address recognition causes wake-up when AVR is in sleep mode The Two-Wire Serial Interface (TWI) is ideally suited to typical microcontroller applications. The TWI protocol allows the systems designer to interconnect up to 128 different devices using only two bidirectional bus lines, one for clock (SCL) andone for data (SDA). The only external hardware needed to implement the bus is a single pull-up resistor for each of the TWI bus lines. All devices connected to the bus have individual addresses, and mechanisms for resolving bus contention are inherent in the TWI </TEXT>
      <TWSCRA>
        <NAME>TWSCRA</NAME>
        <DESCRIPTION>TWI Slave Control Register A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$2D</IO_ADDR>
        <MEM_ADDR>$2D</MEM_ADDR>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>TWSHE</NAME>
          <DESCRIPTION>TWI SDA Hold Time Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT5>
          <NAME>TWDIE</NAME>
          <DESCRIPTION>TWI Data Interrupt Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TWASIE</NAME>
          <DESCRIPTION>TWI Address/Stop Interrupt Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TWEN</NAME>
          <DESCRIPTION>Two-Wire Interface Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TWSIE</NAME>
          <DESCRIPTION>TWI Stop Interrupt Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TWPME</NAME>
          <DESCRIPTION>TWI Promiscuous Mode Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TWSME</NAME>
          <DESCRIPTION>TWI Smart Mode Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TWSCRA>
      <TWSCRB>
        <NAME>TWSCRB</NAME>
        <DESCRIPTION>TWI Slave Control Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$2C</IO_ADDR>
        <MEM_ADDR>$2C</MEM_ADDR>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT2>
          <NAME>TWAA</NAME>
          <DESCRIPTION>TWI Acknowledge Action</DESCRIPTION>
          <TEXT>This bit defines the slave's acknowledge behavior after an address or data byte has been received from the master. Depending on the TWSME bit in TWSCRA the Acknowledge Action is executed either when a valid command has been written to TWCMDn bits, or when the data register has been read.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TWCMD1</NAME>
          <DESCRIPTION/>
          <TEXT>Writing these bits triggers the slave operation as defined by Table 17-2. The type of operation depends on the TWI slave interrupt flags, TWDIF and TWASIF. The Acknowledge Action is only executed when the slave receives data bytes or address byte from the master.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TWCMD0</NAME>
          <DESCRIPTION/>
          <TEXT>Writing these bits triggers the slave operation as defined by Table 17-2. The type of operation depends on the TWI slave interrupt flags, TWDIF and TWASIF. The Acknowledge Action is only executed when the slave receives data bytes or address byte from the master.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TWSCRB>
      <TWSSRA>
        <NAME>TWSSRA</NAME>
        <DESCRIPTION>TWI Slave Status Register A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$2B</IO_ADDR>
        <MEM_ADDR>$2B</MEM_ADDR>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TWDIF</NAME>
          <DESCRIPTION>TWI Data Interrupt Flag.</DESCRIPTION>
          <TEXT>This flag is set when a data byte has been successfully received, i.e. no bus errors or collisions have occurred during the operation. When this flag is set the slave forces the SCL line low, stretching the TWI clock period. The SCL line is released by clearing the interrupt flags. Writing a one to this bit will clear the flag. This flag is also automatically cleared when writing a valid command to the TWCMDn bits in TWSCRB.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TWASIF</NAME>
          <DESCRIPTION>TWI Address/Stop Interrupt Flag</DESCRIPTION>
          <TEXT>This flag is set when the slave detects that a valid address has been received, or when a transmit collision has been detected. When this flag is set the slave forces the SCL line low, stretching the TWI clock period. The SCL line is released by clearing the interrupt flags. If TWASIE in TWSCRA is set a STOP condition on the bus will also set TWASIF.Writing a one to this bit will clear the flag. This flag is also automatically cleared when writing a valid command to the TWCMDn bits in TWSCRB.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5><NAME>TWCH</NAME><DESCRIPTION>TWI Clock Hold</DESCRIPTION><TEXT/>This bit is set when the slave is holding the SCL line low. This bit is read-only, and set when TWDIF or TWASIF is set. The bit can be cleared indirectly by clearing the interrupt flags and releasing the SCL line.<TEXT/><ACCESS>RW</ACCESS><INIT_VAL>0</INIT_VAL></BIT5>
        <BIT4><NAME>TWRA</NAME><DESCRIPTION>TWI Receive Acknowledge</DESCRIPTION><TEXT/>This bit contains the most recently received acknowledge bit from the master. This bit is read-only. When zero, the most recent acknowledge bit from the maser was ACK and, when one, the most recent acknowledge bit was NACK.<TEXT/><ACCESS>RW</ACCESS><INIT_VAL>0</INIT_VAL></BIT4>
        <BIT3><NAME>TWC</NAME><DESCRIPTION>TWI Collision</DESCRIPTION><TEXT/>This bit is set when the slave was not able to transfer a high data bit or a NACK bit. When a collision is detected, the slave will commence its normal operation, and disable data and acknowledge output. No low values are shifted out onto the SDA line.This bit is cleared by writing a one to it. The bit is also cleared automatically when a START or Repeated START condition is detected.<TEXT/><ACCESS>RW</ACCESS><INIT_VAL>0</INIT_VAL></BIT3>
        <BIT2><NAME>TWBE</NAME><DESCRIPTION>TWI Bus Error</DESCRIPTION><TEXT/>This bit is set when an illegal bus condition has occured during a transfer. An illegal bus condition occurs if a Repeated START or STOP condition is detected, and the number of bits from the previous START condition is not a multiple of nine.This bit is cleared by writing a one to it.<TEXT/><ACCESS>RW</ACCESS><INIT_VAL>0</INIT_VAL></BIT2>
        <BIT1><NAME>TWDIR</NAME><DESCRIPTION>TWI Read/Write Direction</DESCRIPTION><TEXT/>This bit indicates the direction bit from the last address packet received from a master. When this bit is one, a master read operation is in progress. When the bit is zero a master write operation is in progress.<TEXT/><ACCESS>RW</ACCESS><INIT_VAL>0</INIT_VAL></BIT1>
        <BIT0><NAME>TWAS</NAME><DESCRIPTION>TWI Address or Stop</DESCRIPTION><TEXT/>This bit indicates why the TWASIF bit was last set. If zero, a stop condition caused TWASIF to be set. If one, address detection caused TWASIF to be set.<TEXT/><ACCESS>RW</ACCESS><INIT_VAL>0</INIT_VAL></BIT0>
      </TWSSRA>
      <TWSA>
        <NAME>TWSA</NAME>
        <DESCRIPTION>TWI Slave Address Register</DESCRIPTION>
        <TEXT>The slave address register contains the TWI slave address used by the slave address match logic to determine if a master has addressed the slave. When using 7-bit or 10-bit address recognition mode, the high seven bits of the address register (TWSA[7:1]) represent the slave address. The least significant bit (TWSA[0]) is used for general call address recognition. Setting TWSA[0] enables general call address recognition logic.When using 10-bit addressing the address match logic only support hardware address recognition of the first byte of a 10-bit address. If TWSA[7:1] is set to "0b11110nn", 'nn' will represent bits 9 and 8 ot the slave address. The next byte received is then bits 7 to 0 in the 10-bit address, but this must be handled by software. When the address match logic detects that a valid address byte has been received, the TWASIF is set and the TWDIR flag is updated. If TWPME in TWSCRA is set, the address match logic responds to all addresses transmitted on the TWI bus. TWSA is not used in this mode.</TEXT>
        <IO_ADDR>$2A</IO_ADDR>
        <MEM_ADDR>$2A</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>TWSA7</NAME>
          <DESCRIPTION>TWI slave address bit</DESCRIPTION>
          <TEXT>The slave address register contains the TWI slave address used by the slave address match logic to determine if a master has addressed the slave. When using 7-bit or 10-bit address recognition mode, the high seven bits of the address register (TWSA[7:1]) represent the slave address. The least significant bit (TWSA[0]) is used for general call address recognition. Setting TWSA[0] enables general call address recognition logic.When using 10-bit addressing the address match logic only support hardware address recognition of the first byte of a 10-bit address. If TWSA[7:1] is set to "0b11110nn", 'nn' will represent bits 9 and 8 ot the slave address. The next byte received is then bits 7 to 0 in the 10-bit address, but this must be handled by software. When the address match logic detects that a valid address byte has been received, the TWASIF is set and the TWDIR flag is updated. If TWPME in TWSCRA is set, the address match logic responds to all addresses transmitted on the TWI bus. TWSA is not used in this mode.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TWSA6</NAME>
          <DESCRIPTION>TWI slave address bit</DESCRIPTION>
          <TEXT>The slave address register contains the TWI slave address used by the slave address match logic to determine if a master has addressed the slave. When using 7-bit or 10-bit address recognition mode, the high seven bits of the address register (TWSA[7:1]) represent the slave address. The least significant bit (TWSA[0]) is used for general call address recognition. Setting TWSA[0] enables general call address recognition logic.When using 10-bit addressing the address match logic only support hardware address recognition of the first byte of a 10-bit address. If TWSA[7:1] is set to "0b11110nn", 'nn' will represent bits 9 and 8 ot the slave address. The next byte received is then bits 7 to 0 in the 10-bit address, but this must be handled by software. When the address match logic detects that a valid address byte has been received, the TWASIF is set and the TWDIR flag is updated. If TWPME in TWSCRA is set, the address match logic responds to all addresses transmitted on the TWI bus. TWSA is not used in this mode.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TWSA5</NAME>
          <DESCRIPTION>TWI slave address bit</DESCRIPTION>
          <TEXT>The slave address register contains the TWI slave address used by the slave address match logic to determine if a master has addressed the slave. When using 7-bit or 10-bit address recognition mode, the high seven bits of the address register (TWSA[7:1]) represent the slave address. The least significant bit (TWSA[0]) is used for general call address recognition. Setting TWSA[0] enables general call address recognition logic.When using 10-bit addressing the address match logic only support hardware address recognition of the first byte of a 10-bit address. If TWSA[7:1] is set to "0b11110nn", 'nn' will represent bits 9 and 8 ot the slave address. The next byte received is then bits 7 to 0 in the 10-bit address, but this must be handled by software. When the address match logic detects that a valid address byte has been received, the TWASIF is set and the TWDIR flag is updated. If TWPME in TWSCRA is set, the address match logic responds to all addresses transmitted on the TWI bus. TWSA is not used in this mode.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TWSA4</NAME>
          <DESCRIPTION>TWI slave address bit</DESCRIPTION>
          <TEXT>The slave address register contains the TWI slave address used by the slave address match logic to determine if a master has addressed the slave. When using 7-bit or 10-bit address recognition mode, the high seven bits of the address register (TWSA[7:1]) represent the slave address. The least significant bit (TWSA[0]) is used for general call address recognition. Setting TWSA[0] enables general call address recognition logic.When using 10-bit addressing the address match logic only support hardware address recognition of the first byte of a 10-bit address. If TWSA[7:1] is set to "0b11110nn", 'nn' will represent bits 9 and 8 ot the slave address. The next byte received is then bits 7 to 0 in the 10-bit address, but this must be handled by software. When the address match logic detects that a valid address byte has been received, the TWASIF is set and the TWDIR flag is updated. If TWPME in TWSCRA is set, the address match logic responds to all addresses transmitted on the TWI bus. TWSA is not used in this mode.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TWSA3</NAME>
          <DESCRIPTION>TWI slave address bit</DESCRIPTION>
          <TEXT>The slave address register contains the TWI slave address used by the slave address match logic to determine if a master has addressed the slave. When using 7-bit or 10-bit address recognition mode, the high seven bits of the address register (TWSA[7:1]) represent the slave address. The least significant bit (TWSA[0]) is used for general call address recognition. Setting TWSA[0] enables general call address recognition logic.When using 10-bit addressing the address match logic only support hardware address recognition of the first byte of a 10-bit address. If TWSA[7:1] is set to "0b11110nn", 'nn' will represent bits 9 and 8 ot the slave address. The next byte received is then bits 7 to 0 in the 10-bit address, but this must be handled by software. When the address match logic detects that a valid address byte has been received, the TWASIF is set and the TWDIR flag is updated. If TWPME in TWSCRA is set, the address match logic responds to all addresses transmitted on the TWI bus. TWSA is not used in this mode.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TWSA2</NAME>
          <DESCRIPTION>TWI slave address bit</DESCRIPTION>
          <TEXT>The slave address register contains the TWI slave address used by the slave address match logic to determine if a master has addressed the slave. When using 7-bit or 10-bit address recognition mode, the high seven bits of the address register (TWSA[7:1]) represent the slave address. The least significant bit (TWSA[0]) is used for general call address recognition. Setting TWSA[0] enables general call address recognition logic.When using 10-bit addressing the address match logic only support hardware address recognition of the first byte of a 10-bit address. If TWSA[7:1] is set to "0b11110nn", 'nn' will represent bits 9 and 8 ot the slave address. The next byte received is then bits 7 to 0 in the 10-bit address, but this must be handled by software. When the address match logic detects that a valid address byte has been received, the TWASIF is set and the TWDIR flag is updated. If TWPME in TWSCRA is set, the address match logic responds to all addresses transmitted on the TWI bus. TWSA is not used in this mode.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TWSA1</NAME>
          <DESCRIPTION>TWI slave address bit</DESCRIPTION>
          <TEXT>The slave address register contains the TWI slave address used by the slave address match logic to determine if a master has addressed the slave. When using 7-bit or 10-bit address recognition mode, the high seven bits of the address register (TWSA[7:1]) represent the slave address. The least significant bit (TWSA[0]) is used for general call address recognition. Setting TWSA[0] enables general call address recognition logic.When using 10-bit addressing the address match logic only support hardware address recognition of the first byte of a 10-bit address. If TWSA[7:1] is set to "0b11110nn", 'nn' will represent bits 9 and 8 ot the slave address. The next byte received is then bits 7 to 0 in the 10-bit address, but this must be handled by software. When the address match logic detects that a valid address byte has been received, the TWASIF is set and the TWDIR flag is updated. If TWPME in TWSCRA is set, the address match logic responds to all addresses transmitted on the TWI bus. TWSA is not used in this mode.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TWSA0</NAME>
          <DESCRIPTION>TWI slave address bit</DESCRIPTION>
          <TEXT>The slave address register contains the TWI slave address used by the slave address match logic to determine if a master has addressed the slave. When using 7-bit or 10-bit address recognition mode, the high seven bits of the address register (TWSA[7:1]) represent the slave address. The least significant bit (TWSA[0]) is used for general call address recognition. Setting TWSA[0] enables general call address recognition logic.When using 10-bit addressing the address match logic only support hardware address recognition of the first byte of a 10-bit address. If TWSA[7:1] is set to "0b11110nn", 'nn' will represent bits 9 and 8 ot the slave address. The next byte received is then bits 7 to 0 in the 10-bit address, but this must be handled by software. When the address match logic detects that a valid address byte has been received, the TWASIF is set and the TWDIR flag is updated. If TWPME in TWSCRA is set, the address match logic responds to all addresses transmitted on the TWI bus. TWSA is not used in this mode.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TWSA>
      <TWSD>
        <NAME>TWSD</NAME>
        <DESCRIPTION>TWI Slave Data Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$28</IO_ADDR>
        <MEM_ADDR>$28</MEM_ADDR>
        <WRITE_INTRUSIVE/>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>TWSD7</NAME>
          <DESCRIPTION>TWI slave data bit</DESCRIPTION>
          <TEXT>The data register is used when transmitting and received data. During transfer, data is shifted from/to the TWSD register and to/from the bus. Therefore, the data register cannot be accessed during byte transfers. This is protected in hardware. The data register can only be accessed when the SCL line is held low by the slave, i.e. when TWCH is set. When a master reads data from a slave, the data to be sent must be written to the TWSD register. The byte transfer is started when the master starts to clock the data byte from the slave. It is followed by the slave receiving the acknowledge bit from the master. The TWDIF and the TWCH bits are then set. When a master writes data to a slave, the TWDIF and the TWCH flags are set when one byte has been received in the data register. If Smart Mode is enabled, reading the data register will trigger the bus operation, as set by the TWAA bit in TWSCRB. Accessing TWSD will clear the slave interrupt flags and the TWCH bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TWSD6</NAME>
          <DESCRIPTION>TWI slave data bit</DESCRIPTION>
          <TEXT>The data register is used when transmitting and received data. During transfer, data is shifted from/to the TWSD register and to/from the bus. Therefore, the data register cannot be accessed during byte transfers. This is protected in hardware. The data register can only be accessed when the SCL line is held low by the slave, i.e. when TWCH is set. When a master reads data from a slave, the data to be sent must be written to the TWSD register. The byte transfer is started when the master starts to clock the data byte from the slave. It is followed by the slave receiving the acknowledge bit from the master. The TWDIF and the TWCH bits are then set. When a master writes data to a slave, the TWDIF and the TWCH flags are set when one byte has been received in the data register. If Smart Mode is enabled, reading the data register will trigger the bus operation, as set by the TWAA bit in TWSCRB. Accessing TWSD will clear the slave interrupt flags and the TWCH bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TWSD5</NAME>
          <DESCRIPTION>TWI slave data bit</DESCRIPTION>
          <TEXT>The data register is used when transmitting and received data. During transfer, data is shifted from/to the TWSD register and to/from the bus. Therefore, the data register cannot be accessed during byte transfers. This is protected in hardware. The data register can only be accessed when the SCL line is held low by the slave, i.e. when TWCH is set. When a master reads data from a slave, the data to be sent must be written to the TWSD register. The byte transfer is started when the master starts to clock the data byte from the slave. It is followed by the slave receiving the acknowledge bit from the master. The TWDIF and the TWCH bits are then set. When a master writes data to a slave, the TWDIF and the TWCH flags are set when one byte has been received in the data register. If Smart Mode is enabled, reading the data register will trigger the bus operation, as set by the TWAA bit in TWSCRB. Accessing TWSD will clear the slave interrupt flags and the TWCH bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TWSD4</NAME>
          <DESCRIPTION>TWI slave data bit</DESCRIPTION>
          <TEXT>The data register is used when transmitting and received data. During transfer, data is shifted from/to the TWSD register and to/from the bus. Therefore, the data register cannot be accessed during byte transfers. This is protected in hardware. The data register can only be accessed when the SCL line is held low by the slave, i.e. when TWCH is set. When a master reads data from a slave, the data to be sent must be written to the TWSD register. The byte transfer is started when the master starts to clock the data byte from the slave. It is followed by the slave receiving the acknowledge bit from the master. The TWDIF and the TWCH bits are then set. When a master writes data to a slave, the TWDIF and the TWCH flags are set when one byte has been received in the data register. If Smart Mode is enabled, reading the data register will trigger the bus operation, as set by the TWAA bit in TWSCRB. Accessing TWSD will clear the slave interrupt flags and the TWCH bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TWSD3</NAME>
          <DESCRIPTION>TWI slave data bit</DESCRIPTION>
          <TEXT>The data register is used when transmitting and received data. During transfer, data is shifted from/to the TWSD register and to/from the bus. Therefore, the data register cannot be accessed during byte transfers. This is protected in hardware. The data register can only be accessed when the SCL line is held low by the slave, i.e. when TWCH is set. When a master reads data from a slave, the data to be sent must be written to the TWSD register. The byte transfer is started when the master starts to clock the data byte from the slave. It is followed by the slave receiving the acknowledge bit from the master. The TWDIF and the TWCH bits are then set. When a master writes data to a slave, the TWDIF and the TWCH flags are set when one byte has been received in the data register. If Smart Mode is enabled, reading the data register will trigger the bus operation, as set by the TWAA bit in TWSCRB. Accessing TWSD will clear the slave interrupt flags and the TWCH bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TWSD2</NAME>
          <DESCRIPTION>TWI slave data bit</DESCRIPTION>
          <TEXT>The data register is used when transmitting and received data. During transfer, data is shifted from/to the TWSD register and to/from the bus. Therefore, the data register cannot be accessed during byte transfers. This is protected in hardware. The data register can only be accessed when the SCL line is held low by the slave, i.e. when TWCH is set. When a master reads data from a slave, the data to be sent must be written to the TWSD register. The byte transfer is started when the master starts to clock the data byte from the slave. It is followed by the slave receiving the acknowledge bit from the master. The TWDIF and the TWCH bits are then set. When a master writes data to a slave, the TWDIF and the TWCH flags are set when one byte has been received in the data register. If Smart Mode is enabled, reading the data register will trigger the bus operation, as set by the TWAA bit in TWSCRB. Accessing TWSD will clear the slave interrupt flags and the TWCH bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TWSD1</NAME>
          <DESCRIPTION>TWI slave data bit</DESCRIPTION>
          <TEXT>The data register is used when transmitting and received data. During transfer, data is shifted from/to the TWSD register and to/from the bus. Therefore, the data register cannot be accessed during byte transfers. This is protected in hardware. The data register can only be accessed when the SCL line is held low by the slave, i.e. when TWCH is set. When a master reads data from a slave, the data to be sent must be written to the TWSD register. The byte transfer is started when the master starts to clock the data byte from the slave. It is followed by the slave receiving the acknowledge bit from the master. The TWDIF and the TWCH bits are then set. When a master writes data to a slave, the TWDIF and the TWCH flags are set when one byte has been received in the data register. If Smart Mode is enabled, reading the data register will trigger the bus operation, as set by the TWAA bit in TWSCRB. Accessing TWSD will clear the slave interrupt flags and the TWCH bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TWSD0</NAME>
          <DESCRIPTION>TWI slave data bit</DESCRIPTION>
          <TEXT>The data register is used when transmitting and received data. During transfer, data is shifted from/to the TWSD register and to/from the bus. Therefore, the data register cannot be accessed during byte transfers. This is protected in hardware. The data register can only be accessed when the SCL line is held low by the slave, i.e. when TWCH is set. When a master reads data from a slave, the data to be sent must be written to the TWSD register. The byte transfer is started when the master starts to clock the data byte from the slave. It is followed by the slave receiving the acknowledge bit from the master. The TWDIF and the TWCH bits are then set. When a master writes data to a slave, the TWDIF and the TWCH flags are set when one byte has been received in the data register. If Smart Mode is enabled, reading the data register will trigger the bus operation, as set by the TWAA bit in TWSCRB. Accessing TWSD will clear the slave interrupt flags and the TWCH bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TWSD>
      <TWSAM>
        <NAME>TWSAM</NAME>
        <DESCRIPTION>TWI Slave Address Mask Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$29</IO_ADDR>
        <MEM_ADDR>$29</MEM_ADDR>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TWSAM7</NAME>
          <DESCRIPTION>TWI Address Mask Bit 7</DESCRIPTION>
          <TEXT>These bits can act as a second address match register, or an address mask register, depending on the TWAE setting. If TWAE is set to zero, TWSAM can be loaded with a 7-bit slave address mask. Each bit in TWSAM can mask (disable) the corresponding address bit in the TWSA register. If the mask bit is one the address match between the incoming address bit and the corresponding bit in TWSA is ignored. In other words, masked bits will always match. If TWAE is set to one, TWSAM can be loaded with a second slave address in addition to the TWSA register. In this mode, the slave will match on 2 unique addresses, one in TWSA and the other in TWSAM.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TWSAM6</NAME>
          <DESCRIPTION>TWI Address Mask Bit 6</DESCRIPTION>
          <TEXT>These bits can act as a second address match register, or an address mask register, depending on the TWAE setting. If TWAE is set to zero, TWSAM can be loaded with a 7-bit slave address mask. Each bit in TWSAM can mask (disable) the corresponding address bit in the TWSA register. If the mask bit is one the address match between the incoming address bit and the corresponding bit in TWSA is ignored. In other words, masked bits will always match. If TWAE is set to one, TWSAM can be loaded with a second slave address in addition to the TWSA register. In this mode, the slave will match on 2 unique addresses, one in TWSA and the other in TWSAM.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TWSAM5</NAME>
          <DESCRIPTION>TWI Address Mask Bit 5</DESCRIPTION>
          <TEXT>These bits can act as a second address match register, or an address mask register, depending on the TWAE setting. If TWAE is set to zero, TWSAM can be loaded with a 7-bit slave address mask. Each bit in TWSAM can mask (disable) the corresponding address bit in the TWSA register. If the mask bit is one the address match between the incoming address bit and the corresponding bit in TWSA is ignored. In other words, masked bits will always match. If TWAE is set to one, TWSAM can be loaded with a second slave address in addition to the TWSA register. In this mode, the slave will match on 2 unique addresses, one in TWSA and the other in TWSAM.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TWSAM4</NAME>
          <DESCRIPTION>TWI Address Mask Bit 4</DESCRIPTION>
          <TEXT>These bits can act as a second address match register, or an address mask register, depending on the TWAE setting. If TWAE is set to zero, TWSAM can be loaded with a 7-bit slave address mask. Each bit in TWSAM can mask (disable) the corresponding address bit in the TWSA register. If the mask bit is one the address match between the incoming address bit and the corresponding bit in TWSA is ignored. In other words, masked bits will always match. If TWAE is set to one, TWSAM can be loaded with a second slave address in addition to the TWSA register. In this mode, the slave will match on 2 unique addresses, one in TWSA and the other in TWSAM.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TWSAM3</NAME>
          <DESCRIPTION>TWI Address Mask Bit 3</DESCRIPTION>
          <TEXT>These bits can act as a second address match register, or an address mask register, depending on the TWAE setting. If TWAE is set to zero, TWSAM can be loaded with a 7-bit slave address mask. Each bit in TWSAM can mask (disable) the corresponding address bit in the TWSA register. If the mask bit is one the address match between the incoming address bit and the corresponding bit in TWSA is ignored. In other words, masked bits will always match. If TWAE is set to one, TWSAM can be loaded with a second slave address in addition to the TWSA register. In this mode, the slave will match on 2 unique addresses, one in TWSA and the other in TWSAM.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TWSAM2</NAME>
          <DESCRIPTION>TWI Address Mask Bit 2</DESCRIPTION>
          <TEXT>These bits can act as a second address match register, or an address mask register, depending on the TWAE setting. If TWAE is set to zero, TWSAM can be loaded with a 7-bit slave address mask. Each bit in TWSAM can mask (disable) the corresponding address bit in the TWSA register. If the mask bit is one the address match between the incoming address bit and the corresponding bit in TWSA is ignored. In other words, masked bits will always match. If TWAE is set to one, TWSAM can be loaded with a second slave address in addition to the TWSA register. In this mode, the slave will match on 2 unique addresses, one in TWSA and the other in TWSAM.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TWSAM1</NAME>
          <DESCRIPTION>TWI Address Mask Bit 1</DESCRIPTION>
          <TEXT>These bits can act as a second address match register, or an address mask register, depending on the TWAE setting. If TWAE is set to zero, TWSAM can be loaded with a 7-bit slave address mask. Each bit in TWSAM can mask (disable) the corresponding address bit in the TWSA register. If the mask bit is one the address match between the incoming address bit and the corresponding bit in TWSA is ignored. In other words, masked bits will always match. If TWAE is set to one, TWSAM can be loaded with a second slave address in addition to the TWSA register. In this mode, the slave will match on 2 unique addresses, one in TWSA and the other in TWSAM.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TWAE</NAME>
          <DESCRIPTION>TWI Address Enable</DESCRIPTION>
          <TEXT>By default, this bit is zero and the TWSAM bits acts as an address mask to the TWSA register. If this bit is set to one, the slave address match logic responds to the two unique addresses in TWSA and TWSAM</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>1</INIT_VAL>
        </BIT0>
      </TWSAM>
    </TWI>
    <PORTA>
      <LIST>[PORTCR:PUEA:PORTA:DDRA:PINA]</LIST>
      <LINK/>
      <ICON>io_port.bmp</ICON>
      <ID>AVRSimIOPort.SimIOPort</ID>
      <TEXT/>
      <PORTCR>
        <NAME>PORTCR</NAME>
        <DESCRIPTION>Port Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$08</IO_ADDR>
        <MEM_ADDR>$08</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT0>
          <NAME>BBMA</NAME>
          <DESCRIPTION>Break-Before-Make Mode Enable</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PORTCR>
      <PUEA>
        <NAME>PUEA</NAME>
        <DESCRIPTION>Pull-up Enable Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$03</IO_ADDR>
        <MEM_ADDR>$03</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PUEA7</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PUEA6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PUEA5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PUEA4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PUEA3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PUEA2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PUEA1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PUEA0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PUEA>
      <PORTA>
        <NAME>PORTA</NAME>
        <DESCRIPTION>Port A Data Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$02</IO_ADDR>
        <MEM_ADDR>$02</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PORTA7</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PORTA6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PORTA5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PORTA4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PORTA3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PORTA2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PORTA1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PORTA0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PORTA>
      <DDRA>
        <NAME>DDRA</NAME>
        <DESCRIPTION>Data Direction Register, Port A</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$01</IO_ADDR>
        <MEM_ADDR>$01</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>DDA7</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>DDA6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>DDA5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>DDA4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>DDA3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>DDA2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>DDA1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>DDA0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </DDRA>
      <PINA>
        <NAME>PINA</NAME>
        <DESCRIPTION>Port A Input Pins</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$00</IO_ADDR>
        <MEM_ADDR>$00</MEM_ADDR>
        <ICON>io_port.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>PINA7</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>PINA6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>PINA5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>PINA4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>PINA3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>PINA2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>PINA1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>PINA0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </PINA>
    </PORTA>
    <TIMER_COUNTER_1>
      <LIST>[TCCR1A:TCCR1B:TCCR1C:TCNT1H:TCNT1L:OCR1AH:OCR1AL:OCR1BH:OCR1BL:ICR1H:ICR1L:TIMSK:TIFR:GTCCR]</LIST>
      <LINK>[OCR1AH:OCR1AL];[OCR1BH:OCR1BL];[ICR1H:ICR1L]</LINK>
      <ICON>io_timer.bmp</ICON>
      <ID/>
      <TEXT/>
      <TCCR1A>
        <NAME>TCCR1A</NAME>
        <DESCRIPTION>Timer/Counter1 Control Register A</DESCRIPTION>
        <TEXT>Bit 7:6 - COMnA1:0: Compare Output Mode for channel A  &#x2022; Bit 5:4 - COMnB1:0: Compare Output Mode for channel B  &#x2022; Bit 3:2 - COMnC1:0: Compare Output Mode for channel C The COMnA1:0, COMnB1:0, and COMnC1:0 control the output compare pins (OCnA, OCnB, and OCnC respectively) behavior. If one or both of the COMnA1:0 bits are written to one, the OCnA output overrides the normal port functionality of the I/O pin it is connected to. If one or both of the COMnB1:0 bits are written to one, the OCnB output overrides the normal port functionality of the I/O pin it is connected to. If one or both of the COMnC1:0 bits are written to one, the OCnC output overrides the normal port functionality of the I/O pin it is connected to. However, note that the Data Direction Register (DDR) bit corresponding to OCnA, OCnB or OCnC pin must be set in order to enable the output driver. When the OCnA, OCnB or OCnC is connected to the pin, the function of the COMnx1:0 bits are dependent of the WGMn3:0 bits setting. Table 57 shows the COMnx1 0 bit functionality when the WGMn3:0 bits are set to a normal or a CTC mode (non-PW</TEXT>
        <IO_ADDR>$24</IO_ADDR>
        <MEM_ADDR>$24</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>COM1A1</NAME>
          <DESCRIPTION>Compare Output Mode 1A, bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>COM1A0</NAME>
          <DESCRIPTION>Compare Ouput Mode 1A, bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>COM1B1</NAME>
          <DESCRIPTION>Compare Output Mode 1B, bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>COM1B0</NAME>
          <DESCRIPTION>Compare Output Mode 1B, bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT1>
          <NAME>WGM11</NAME>
          <ALIAS>PWM11</ALIAS>
          <DESCRIPTION>Waveform Generation Mode Bit 1</DESCRIPTION>
          <TEXT>Combined with the WGMn3:2 bits found in the TCCRnB register, these bits control the counting sequence of the counter, the source for maximum (TOP) counter value, and what type of waveform generation to be used, see Table 60. Modes of operation supported by the Timer/Counter unit are: Normal mode (counter), Clear Timer on Compare match (CTC) mode, and three types of Pulse Width Modulation (PWM) modes. (See &#x201C;Modes of Operation&#x201D; on page 101.)</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>WGM10</NAME>
          <ALIAS>PWM10</ALIAS>
          <DESCRIPTION>Waveform Generation Mode Bit 0</DESCRIPTION>
          <TEXT>Combined with the WGMn3:2 bits found in the TCCRnB register, these bits control the counting sequence of the counter, the source for maximum (TOP) counter value, and what type of waveform generation to be used, see Table 60. Modes of operation supported by the Timer/Counter unit are: Normal mode (counter), Clear Timer on Compare match (CTC) mode, and three types of Pulse Width Modulation (PWM) modes. (See &#x201C;Modes of Operation&#x201D; on page 101.)</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCCR1A>
      <TCCR1B>
        <NAME>TCCR1B</NAME>
        <DESCRIPTION>Timer/Counter1 Control Register B</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$23</IO_ADDR>
        <MEM_ADDR>$23</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>ICNC1</NAME>
          <DESCRIPTION>Input Capture 1 Noise Canceler</DESCRIPTION>
          <TEXT>When the ICNC1 bit is cleared (zero), the input capture trigger noise canceler function is disabled. The input capture is triggered at the first rising/falling edge sampled on the ICP - input capture pin - as specified. When the ICNC1 bit is set (one), four successive samples are measures on the ICP - input capture pin, and all samples must be high/low according to the input capture trigger specification in the ICES1 bit. The actual sampling frequency is XTAL clock frequency.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ICES1</NAME>
          <DESCRIPTION>Input Capture 1 Edge Select</DESCRIPTION>
          <TEXT>While the ICES1 bit is cleared (zero), the Timer/Counter1 contents are transferred to the Input Capture Register - ICR1 - on the falling edge of the input capture pin - ICP. While the ICES1 bit is set (one), the Timer/Counter1 contents are transferred to the Input Capture Register - ICR1 - on the rising edge of the input capture pin - ICP.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT4>
          <NAME>WGM13</NAME>
          <ALIAS>CTC11</ALIAS>
          <DESCRIPTION>Waveform Generation Mode</DESCRIPTION>
          <TEXT>See description found for TCCR1A</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>WGM12</NAME>
          <ALIAS>CTC10</ALIAS>
          <DESCRIPTION>Waveform Generation Mode</DESCRIPTION>
          <TEXT>See description found for TCCR1A</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CS12</NAME>
          <DESCRIPTION>Clock Select1 bit 2</DESCRIPTION>
          <TEXT>Select clock source</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>CS11</NAME>
          <DESCRIPTION>Clock Select 1 bit 1</DESCRIPTION>
          <TEXT>Select clock source</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>CS10</NAME>
          <DESCRIPTION>Clock Select bit 0</DESCRIPTION>
          <TEXT>Select clock source</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>CLK_SEL_3BIT_EXT</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCCR1B>
      <TCCR1C>
        <NAME>TCCR1C</NAME>
        <DESCRIPTION>Timer/Counter1 Control Register C</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$22</IO_ADDR>
        <MEM_ADDR>$22</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>FOC1A</NAME>
          <DESCRIPTION>Force Output Compare for channel A</DESCRIPTION>
          <TEXT>&#x2022; Bit 7- FOCnA: Force Output Compare for channel A  &#x2022; Bit 6- FOCnB: Force Output Compare for channel B  &#x2022; Bit 5- FOCnC: Force Output Compare for channel C The FOCnA/FOCnB//FOCnC bits are only active when the WGMn3:0 bits specifies a non-PWM mode. When writing a log-icalone to the FOCnA/FOCnB//FOCnC bit, an immediate compare match is forced on the waveform generation unit. The OCnA/OCnB/OCnC output is changed according to its COMnx1:0 bits setting. Note that the FOCnA/FOCnB/FOCnC bits are implemented as strobes. Therefore it is the value present in the COMnx1:0 bits that determine the effect of the forced compare. A FOCnA/FOCnB/FOCnC strobe will not generate any interrupt nor will it clear the timer in clear timer on compare match (CTC) mode using OCRnA as TOP. The FOCnA/FOCnB//FOCnB bits are always read as zero.</TEXT>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>FOC1B</NAME>
          <DESCRIPTION>Force Output Compare for channel B</DESCRIPTION>
          <TEXT>&#x2022; Bit 7- FOCnA: Force Output Compare for channel A  &#x2022; Bit 6- FOCnB: Force Output Compare for channel B  &#x2022; Bit 5- FOCnC: Force Output Compare for channel C The FOCnA/FOCnB//FOCnC bits are only active when the WGMn3:0 bits specifies a non-PWM mode. When writing a log-icalone to the FOCnA/FOCnB//FOCnC bit, an immediate compare match is forced on the waveform generation unit. The OCnA/OCnB/OCnC output is changed according to its COMnx1:0 bits setting. Note that the FOCnA/FOCnB/FOCnC bits are implemented as strobes. Therefore it is the value present in the COMnx1:0 bits that determine the effect of the forced compare. A FOCnA/FOCnB/FOCnC strobe will not generate any interrupt nor will it clear the timer in clear timer on compare match (CTC) mode using OCRnA as TOP. The FOCnA/FOCnB//FOCnB bits are always read as zero.</TEXT>
          <ACCESS>W</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
      </TCCR1C>
      <TCNT1H>
        <NAME>TCNT1H</NAME>
        <DESCRIPTION>Timer/Counter1 High</DESCRIPTION>
        <TEXT>The two Timer/Counter I/O locations (TCNT1H and TCNT1L, combined TCNT1) give direct access, both for read and for write operations, to the Timer/Counter unit 16-bit counter. To ensure that both the high and low bytes are read and written simultaneously when the CPU accesses these registers, the access is performed using an 8-bit temporary high byte register (TEMP). This temporary register is shared by all the other 16-bit registers. Modifying the counter (TCNT1) while the counter is running introduces a risk of missing a compare match between TCNT1 and one of the OCR1x Registers. Writing to the TCNT1 Register blocks (removes) the compare match on the following timer clock for all compare.</TEXT>
        <IO_ADDR>$21</IO_ADDR>
        <MEM_ADDR>$21</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TCNT1_15</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TCNT1_14</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TCNT1_13</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TCNT1_12</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TCNT1_11</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TCNT1_10</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TCNT1_9</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TCNT1_8</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCNT1H>
      <TCNT1L>
        <NAME>TCNT1L</NAME>
        <DESCRIPTION>Timer/Counter1 Low</DESCRIPTION>
        <TEXT>The two Timer/Counter I/O locations (TCNT1H and TCNT1L, combined TCNT1) give direct access, both for read and for write operations, to the Timer/Counter unit 16-bit counter. To ensure that both the high and low bytes are read and written simultaneously when the CPU accesses these registers, the access is performed using an 8-bit temporary high byte register (TEMP). This temporary register is shared by all the other 16-bit registers. Modifying the counter (TCNT1) while the counter is running introduces a risk of missing a compare match between TCNT1 and one of the OCR1x Registers. Writing to the TCNT1 Register blocks (removes) the compare match on the following timer clock for all compare.</TEXT>
        <IO_ADDR>$20</IO_ADDR>
        <MEM_ADDR>$20</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>TCNT1_7</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>TCNT1_6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>TCNT1_5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>TCNT1_4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TCNT1_3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>TCNT1_2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>TCNT1_1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TCNT1_0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TCNT1L>
      <OCR1AH>
        <NAME>OCR1AH</NAME>
        <DESCRIPTION>Timer/Counter 1 Output Compare Register A High</DESCRIPTION>
        <TEXT>The Output Compare Registers contain a 16-bit value that is continuously compared with the counter value (TCNT1). A match can be used to generate an Output Compare interrupt, or to generate a waveform output on the OC1x pin. The Output Compare Registers are 16-bit in size. To ensure that both the high and low bytes are written simultaneously when the CPU writes to these registers, the access is performed using an 8-bit temporary high byte register (TEMP). This temporary register is shared by all the other 16-bit registers.</TEXT>
        <IO_ADDR>$1F</IO_ADDR>
        <MEM_ADDR>$1F</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR1A15</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR1A14</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR1A13</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR1A12</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR1A11</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR1A10</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR1A9</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR1A8</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCR1AH>
      <OCR1AL>
        <NAME>OCR1AL</NAME>
        <DESCRIPTION>Timer/Counter 1 Output Compare Register A Low</DESCRIPTION>
        <TEXT>The Output Compare Registers contain a 16-bit value that is continuously compared with the counter value (TCNT1). A match can be used to generate an Output Compare interrupt, or to generate a waveform output on the OC1x pin. The Output Compare Registers are 16-bit in size. To ensure that both the high and low bytes are written simultaneously when the CPU writes to these registers, the access is performed using an 8-bit temporary high byte register (TEMP). This temporary register is shared by all the other 16-bit registers.</TEXT>
        <IO_ADDR>$1E</IO_ADDR>
        <MEM_ADDR>$1E</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR1A7</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR1A6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR1A5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR1A4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR1A3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR1A2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR1A1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR1A0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCR1AL>
      <OCR1BH>
        <NAME>OCR1BH</NAME>
        <DESCRIPTION>Timer/Counter1 Output Compare Register B High</DESCRIPTION>
        <TEXT>The Output Compare Registers contain a 16-bit value that is continuously compared with the counter value (TCNT1). A match can be used to generate an Output Compare interrupt, or to generate a waveform output on the OC1x pin. The Output Compare Registers are 16-bit in size. To ensure that both the high and low bytes are written simultaneously when the CPU writes to these registers, the access is performed using an 8-bit temporary high byte register (TEMP). This temporary register is shared by all the other 16-bit registers.</TEXT>
        <IO_ADDR>$1D</IO_ADDR>
        <MEM_ADDR>$1D</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR1B15</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR1B14</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR1B13</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR1B12</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR1B11</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR1B10</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR1B9</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR1B8</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCR1BH>
      <OCR1BL>
        <NAME>OCR1BL</NAME>
        <DESCRIPTION>Timer/Counter1 Output Compare Register B Low</DESCRIPTION>
        <TEXT>The Output Compare Registers contain a 16-bit value that is continuously compared with the counter value (TCNT1). A match can be used to generate an Output Compare interrupt, or to generate a waveform output on the OC1x pin. The Output Compare Registers are 16-bit in size. To ensure that both the high and low bytes are written simultaneously when the CPU writes to these registers, the access is performed using an 8-bit temporary high byte register (TEMP). This temporary register is shared by all the other 16-bit registers.</TEXT>
        <IO_ADDR>$1C</IO_ADDR>
        <MEM_ADDR>$1C</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>OCR1B7</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>OCR1B6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>OCR1B5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCR1B4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>OCR1B3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCR1B2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCR1B1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>OCR1B0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </OCR1BL>
      <ICR1H>
        <NAME>ICR1H</NAME>
        <DESCRIPTION>Input Capture Register High Byte</DESCRIPTION>
        <TEXT>The Input Capture is updated with the counter (TCNT1) value each time an event occurs on the ICP1 pin (or optionally on the Analog Comparator output for Timer/Counter1). The Input Capture can be used for defining the counter TOP value. The Input Capture Register is 16-bit in size. To ensure that both the high and low bytes are read simultaneously when the CPU accesses these registers, the access is performed using an 8-bit temporary high byte register (TEMP). This temporary register is shared by all the other 16-bit registers.</TEXT>
        <IO_ADDR>$1B</IO_ADDR>
        <MEM_ADDR>$1B</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>ICR1_15</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ICR1_14</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ICR1_13</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ICR1_12</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ICR1_11</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ICR1_10</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ICR1_9</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ICR1_8</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ICR1H>
      <ICR1L>
        <NAME>ICR1L</NAME>
        <DESCRIPTION>Input Capture Register Low Byte</DESCRIPTION>
        <TEXT>The Input Capture is updated with the counter (TCNT1) value each time an event occurs on the ICP1 pin (or optionally on the Analog Comparator output for Timer/Counter1). The Input Capture can be used for defining the counter TOP value. The Input Capture Register is 16-bit in size. To ensure that both the high and low bytes are read simultaneously when the CPU accesses these registers, the access is performed using an 8-bit temporary high byte register (TEMP). This temporary register is shared by all the other 16-bit registers.</TEXT>
        <IO_ADDR>$1A</IO_ADDR>
        <MEM_ADDR>$1A</MEM_ADDR>
        <ICON>io_timer.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>ICR1_7</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>ICR1_6</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>ICR1_5</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>ICR1_4</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>ICR1_3</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>ICR1_2</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>ICR1_1</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>ICR1_0</NAME>
          <DESCRIPTION/>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </ICR1L>
      <TIMSK>
        <NAME>TIMSK</NAME>
        <DESCRIPTION>Timer Interrupt Mask Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$26</IO_ADDR>
        <MEM_ADDR>$26</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>ICIE1</NAME>
          <DESCRIPTION>Input Capture Interrupt Enable</DESCRIPTION>
          <TEXT>When this bit is written to one, and the I-flag in the Status Register is set (interrupts globally enabled), the Timer/Countern Input Capture interrupt is enabled. The corresponding Interrupt Vector (See &#x201C;Interrupts&#x201D; on page 66.) is executed when the ICF1 Flag, located in TIFR, is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT5>
          <NAME>OCIE1B</NAME>
          <DESCRIPTION>Output Compare B Match Interrupt Enable</DESCRIPTION>
          <TEXT>When this bit is written to one, and the I-flag in the Status Register is set (interrupts globally enabled), the Timer/Counter1 Output Compare B Match interrupt is enabled. The corresponding Interrupt Vector is executed when the OCF1B flag, located in TIFR, is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCIE1A</NAME>
          <DESCRIPTION>Output Compare A Match Interrupt Enable</DESCRIPTION>
          <TEXT>When this bit is written to one, and the I-flag in the Status Register is set (interrupts globally enabled), the Timer/Counter0 Output Compare A Match interrupt is enabled. The corresponding Interrupt Vector is executed when the OCF0A flag, located in TIFR0, is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TOIE1</NAME>
          <DESCRIPTION>Overflow Interrupt Enable</DESCRIPTION>
          <TEXT>When this bit is written to one, and the I-flag in the Status Register is set (interrupts globally enabled), the Timer/Counter1 Overflow interrupt is enabled. The corresponding Interrupt Vector is executed when the TOV1 flag, located in TIFR1, is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCIE0B</NAME>
          <DESCRIPTION>Timer/Counter Output Compare Match B Interrupt Enable</DESCRIPTION>
          <TEXT>When the OCIE0B bit is written to one, and the I-bit in the Status Register is set, the Timer/Counter Compare Match B interrupt is enabled. The corresponding interrupt is executed if a Compare Match in Timer/Counter occurs, i.e., when the OCF0B bit is set in the Timer/Counter Interrupt Flag Register &#x2013; TIFR.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCIE0A</NAME>
          <DESCRIPTION>Timer/Counter0 Output Compare Match A Interrupt Enable</DESCRIPTION>
          <TEXT>When the OCIE0A bit is written to one, and the I-bit in the Status Register is set, the Timer/Counter0 Compare Match A interrupt is enabled. The corresponding interrupt is executed if a Compare Match in Timer/Counter0 occurs, i.e., when the OCF0A bit is set in the Timer/Counter Interrupt Flag Register &#x2013; TIFR.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TOIE0</NAME>
          <DESCRIPTION>Timer/Counter0 Overflow Interrupt Enable</DESCRIPTION>
          <TEXT>When the TOIE0 bit is written to one, and the I-bit in the Status Register is set, the Timer/Counter0 Overflow interrupt is enabled. The corresponding interrupt is executed if an overflow in Timer/Counter0 occurs, i.e., when the TOV0 bit is set in the Timer/Counter Interrupt Flag Register &#x2013; TIFR.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TIMSK>
      <TIFR>
        <NAME>TIFR</NAME>
        <DESCRIPTION>Overflow Interrupt Enable</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$25</IO_ADDR>
        <MEM_ADDR>$25</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>ICF1</NAME>
          <DESCRIPTION>Input Capture Flag</DESCRIPTION>
          <TEXT>This flag is set when a capture event occurs on the ICP1 pin. When the Input Capture Register (ICR1) is set by the WGM13:0 to be used as the TOP value, the ICF1 flag is set when the counter reaches the TOP value.ICF1 is automatically cleared when the Input Capture Interrupt Vector is executed. Alternatively, ICF1 can be cleared by writing a logic one to its bit location.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT5>
          <NAME>OCF1B</NAME>
          <DESCRIPTION>Timer Output Compare Flag 1B</DESCRIPTION>
          <TEXT>This flag is set in the timer clock cycle after the counter (TCNT1) value matches the Output Compare Register B (OCR1B). Note that a Forced Output Compare (1B) strobe will not set the OCF1B flag. OCF1B is automatically cleared when the Output Compare Match B Interrupt Vector is executed.Alternatively, OCF1B can be cleared by writing a logic one to its bit location.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>OCF1A</NAME>
          <DESCRIPTION>Timer Output Compare Flag 1A</DESCRIPTION>
          <TEXT>This flag is set in the timer clock cycle after the counter (TCNT1) value matches the Output Compare Register A (OCR1A).Note that a Forced Output Compare (1A) strobe will not set the OCF1A flag.OCF1A is automatically cleared when the Output Compare Match A Interrupt Vector is executed. Alternatively, OCF1A can be cleared by writing a logic one to its bit location.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>TOV1</NAME>
          <DESCRIPTION>Timer Overflow Flag</DESCRIPTION>
          <TEXT>The setting of this flag is dependent of the WGM13:0 bits setting. In Normal and CTC modes,the TOV1 flag is set when the timer overflows. See Table 12-5 on page 102 for the TOV1 flag behavior when using another WGM13:0 bit setting. TOV1 is automatically cleared when the Timer/Counter1 Overflow Interrupt Vector is executed. Alternatively, TOV1 can be cleared by writing a logic one to its bit location.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>OCF0B</NAME>
          <DESCRIPTION>Output Compare Flag 0 B</DESCRIPTION>
          <TEXT>The OCF0B bit is set when a Compare Match occurs between the Timer/Counter and the data in OCR0B &#x2013; Output Compare Register0 B. OCF0B is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, OCF0B is cleared by writing a logic one to the flag. When the I-bit in SREG, OCIE0B (Timer/Counter Compare B Match Interrupt Enable), and OCF0B are set, the Timer/Counter Compare Match Interrupt is executed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>OCF0A</NAME>
          <DESCRIPTION>Output Compare Flag 0 A</DESCRIPTION>
          <TEXT>The OCF0A bit is set when a Compare Match occurs between the Timer/Counter0 and the data in OCR0A &#x2013; Output Compare Register0. OCF0A is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, OCF0A is cleared by writing a logic one to the flag. When the I-bit in SREG, OCIE0A (Timer/Counter0 Compare Match Interrupt Enable), and OCF0A are set, the Timer/Counter0 Compare Match Interrupt is executed.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>TOV0</NAME>
          <DESCRIPTION>Timer/Counter0 Overflow Flag</DESCRIPTION>
          <TEXT>The bit TOV0 is set when an overflow occurs in Timer/Counter0. TOV0 is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, TOV0 is cleared by writing a logic one to the flag. When the SREG I-bit, TOIE0 (Timer/Counter0 Overflow Interrupt Enable), and TOV0 are set, the Timer/Counter0 Overflow interrupt is executed. The setting of this flag is dependent of the WGM02:0 bit setting. See Table 11-8 on page 75 and &#x201C;Waveform Generation Mode Bit Description&#x201D; on page 75.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </TIFR>
      <GTCCR>
        <NAME>GTCCR</NAME>
        <DESCRIPTION>General Timer/Counter Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$27</IO_ADDR>
        <MEM_ADDR>$27</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>TSM</NAME>
          <DESCRIPTION>Timer Synchronization Mode</DESCRIPTION>
          <TEXT>Writing the TSM bit to one activates the Timer/Counter Synchronization mode. In this mode, the value that is written to the PSR bit is kept, hence keeping the Prescaler Reset signal asserted.This ensures that the Timer/Counter is halted and can be configured without the risk of advancing during configuration. When the TSM bit is written to zero, the PSR bit is cleared by hardware, and the Timer/Counter start counting.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT0>
          <NAME>PSR</NAME>
          <DESCRIPTION>Prescaler Reset</DESCRIPTION>
          <TEXT>When this bit is one, the Timer/Counter0 prescaler will be Reset. This bit is normally cleared immediately by hardware, except if the TSM bit is set.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </GTCCR>
    </TIMER_COUNTER_1>
    <SPI>
      <LIST>[SPDR:SPSR:SPCR]</LIST>
      <LINK/>
      <ICON>io_com.bmp</ICON>
      <ID/>
      <TEXT>The Serial Peripheral Interface(SPI) allows high-speed synchronous data transfer between the AT90S4414/8515 and peripheral devices or between several AVR devices. The AT90S4414/8515 SPI features include the following: &#x2022; Full-duplex, 3-wire Synchronous Data Transfer &#x2022; Master or Slave Operation &#x2022; LSB First or MSB First Data Transfer &#x2022; Four Programmable Bit Rates &#x2022; End of Transmission Interrupt Flag &#x2022; Write Collision Flag Protection &#x2022; Wakeup from Idle Mode (Slave Mode Only)</TEXT>
      <SPCR>
        <NAME>SPCR</NAME>
        <DESCRIPTION>SPI Control Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$30</IO_ADDR>
        <MEM_ADDR>$30</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SPIE</NAME>
          <DESCRIPTION>SPI Interrupt Enable</DESCRIPTION>
          <TEXT>This bit causes the SPI interrupt to be executed if SPIF bit in the SPSR register is set and the global interrupts are enabled.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SPE</NAME>
          <DESCRIPTION>SPI Enable</DESCRIPTION>
          <TEXT>When the SPE bit is set (one), the SPI is enabled. This bit must be set to enable any SPI operations.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>DORD</NAME>
          <DESCRIPTION>Data Order</DESCRIPTION>
          <TEXT>When the DORD bit is set (one), the LSB of the data word is transmitted first. When the DORD bit is cleared (zero), the MSB of the data word is transmitted first.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>MSTR</NAME>
          <DESCRIPTION>Master/Slave Select</DESCRIPTION>
          <TEXT>This bit selects Master SPI mode when set (one), and Slave SPI mode when cleared (zero). If SS is configured as an input and is driven low while MSTR is set, MSTR will be cleared, and SPIF in SPSR will become set. The user will then have to set MSTR to re-enable SPI master mode.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>CPOL</NAME>
          <DESCRIPTION>Clock polarity</DESCRIPTION>
          <TEXT>When this bit is set (one), SCK is high when idle. When CPOL is cleared (zero), SCK is low when idle. Refer to Figure 36 and Figure 37 for additional information.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>CPHA</NAME>
          <DESCRIPTION>Clock Phase</DESCRIPTION>
          <TEXT>Refer to Figure 36 or Figure 37 for the functionality of this bit.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SPR1</NAME>
          <DESCRIPTION>SPI Clock Rate Select 1</DESCRIPTION>
          <TEXT>These two bits control the SCK rate of the device configured as a master. SPR1 and SPR0 have no effect on the slave.</TEXT>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SPR0</NAME>
          <DESCRIPTION>SPI Clock Rate Select 0</DESCRIPTION>
          <TEXT>These two bits control the SCK rate of the device configured as a master. SPR1 and SPR0 have no effect on the slave.</TEXT>
          <ACCESS>RW</ACCESS>
          <ENUM>COMM_SCK_RATE</ENUM>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SPCR>
      <SPSR>
        <NAME>SPSR</NAME>
        <DESCRIPTION>SPI Status Register</DESCRIPTION>
        <TEXT/>
        <IO_ADDR>$2F</IO_ADDR>
        <MEM_ADDR>$2F</MEM_ADDR>
        <ICON>io_flag.bmp</ICON>
        <DISPLAY_BITS>Y</DISPLAY_BITS>
        <BIT7>
          <NAME>SPIF</NAME>
          <DESCRIPTION>SPI Interrupt Flag</DESCRIPTION>
          <TEXT>When a serial transfer is complete, the SPIF bit is set (one) and an interrupt is generated if SPIE in SPCR is set (one) and global interrupts are enabled. If SS is an input and is driven low when the SPI is in master mode, this will also set the SPIF flag. SPIF is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, the SPIF bit is cleared by first reading the SPI status register when SPIF is set (one), then accessing the SPI Data Register (SPDR).</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>WCOL</NAME>
          <DESCRIPTION>Write Collision Flag</DESCRIPTION>
          <TEXT>The WCOL bit is set if the SPI data register (SPDR) is written during a data transfer. The WCOL bit (and the SPIF bit) are cleared (zero) by first reading the SPI Status Register when WCOL is set (one), and then accessing the SPI Data Register.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT6>
        <BIT0>
          <NAME>SPI2X</NAME>
          <DESCRIPTION>Double SPI Speed Bit</DESCRIPTION>
          <TEXT>When this bit is written logic one the SPI speed (SCK Frequency) will be doubled when the SPI is in Master mode (see Table 16-5). This means that the minimum SCK period will be two CPU clock periods. When the SPI is configured as Slave, the SPI is only guaranteed to work at fosc/4 or lower. The SPI interface is also used for program memory and EEPROM downloading or uploading.</TEXT>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SPSR>
      <SPDR>
        <NAME>SPDR</NAME>
        <DESCRIPTION>SPI Data Register</DESCRIPTION>
        <TEXT>The SPI Data Register is a read/write register used for data transfer between the register file and the SPI Shift register. Writing to the register initiates data transmission. Reading the register causes the Shift Register Receive buffer to be read.</TEXT>
        <IO_ADDR>$2E</IO_ADDR>
        <MEM_ADDR>$2E</MEM_ADDR>
        <ICON>io_com.bmp</ICON>
        <DISPLAY_BITS>N</DISPLAY_BITS>
        <BIT7>
          <NAME>SPDR7</NAME>
          <DESCRIPTION>SPI Data Register bit 7</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT7>
        <BIT6>
          <NAME>SPDR6</NAME>
          <DESCRIPTION>SPI Data Register bit 6</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT6>
        <BIT5>
          <NAME>SPDR5</NAME>
          <DESCRIPTION>SPI Data Register bit 5</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT5>
        <BIT4>
          <NAME>SPDR4</NAME>
          <DESCRIPTION>SPI Data Register bit 4</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT4>
        <BIT3>
          <NAME>SPDR3</NAME>
          <DESCRIPTION>SPI Data Register bit 3</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT3>
        <BIT2>
          <NAME>SPDR2</NAME>
          <DESCRIPTION>SPI Data Register bit 2</DESCRIPTION>
          <TEXT/>
          <ACCESS>RW</ACCESS>
          <INIT_VAL>X</INIT_VAL>
        </BIT2>
        <BIT1>
          <NAME>SPDR1</NAME>
          <DESCRIPTION>SPI Data Register bit 1</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT1>
        <BIT0>
          <NAME>SPDR0</NAME>
          <DESCRIPTION>SPI Data Register bit 0</DESCRIPTION>
          <TEXT/>
          <ACCESS>R</ACCESS>
          <INIT_VAL>0</INIT_VAL>
        </BIT0>
      </SPDR>
    </SPI>
  </IO_MODULE>
  <ICE_SETTINGS>
    <MODULE_LIST>[STK600:SIMULATOR2:AVRISPmkII]</MODULE_LIST>
    <STK600>
		</STK600>
    <SIMULATOR2>
      <MODEL>libATtiny20.dll</MODEL>
    </SIMULATOR2>
    <AVRISPmkII/>
  </ICE_SETTINGS>
  <V2>
    <templates>
      <module class="FUSE">
        <registers name="FUSE" memspace="FUSE">
          <reg size="1" name="BYTE0" offset="0x00">
            <bitfield name="BODLEVEL" mask="0x70" text="Brown-out Detector trigger level" icon="" enum="ENUM_BODLEVEL"/>
            <bitfield name="CKOUT" mask="0x04" text="Output external clock" icon=""/>
            <bitfield name="WDTON" mask="0x02" text="Watch dog timer always on" icon=""/>
            <bitfield name="RSTDISBL" mask="0x01" text="Disable external reset" icon=""/>
          </reg>
        </registers>
        <enumerator name="ENUM_BODLEVEL">
          <enum val="0x07" text="Brown-out detection disabled; [BODLEVEL=111]" constname="DISABLED"/>
          <enum val="0x06" text="Brown-out detection at VCC=1.8 V" constname="1V8"/>
          <enum val="0x05" text="Brown-out detection at VCC=2.7 V" constname="2V7"/>
          <enum val="0x04" text="Brown-out detection at VCC=4.3 V" constname="4V3"/>
        </enumerator>
      </module>
      <module class="LOCKBIT">
        <registers name="LOCKBIT" memspace="LOCKBIT">
          <reg size="1" name="LOCKBIT" offset="0x00">
            <bitfield name="LB" mask="0x03" text="Memory Lock" icon="" enum="ENUM_LB"/>
          </reg>
        </registers>
        <enumerator name="ENUM_LB">
          <enum val="0x00" text="Further programming and verification disabled" constname="PROG_VER_DISABLED"/>
          <enum val="0x02" text="Further programming disabled" constname="PROG_DISABLED"/>
          <enum val="0x03" text="No memory lock features enabled" constname="NO_LOCK"/>
        </enumerator>
      </module>
      <module class="PORTB" text="">
        <registers name="PORTB" memspace="DATAMEM" text="" icon="io_port.bmp">
          <reg size="1" name="PORTCR" offset="0x08" text="Port Control Register" icon="io_flag.bmp">
            <bitfield name="BBMB" mask="0x02" text="Break-Before-Make Mode Enable" icon=""/>
          </reg>
          <reg size="1" name="PUEB" offset="0x07" text="Pull-up Enable Control Register" icon="io_flag.bmp" mask="0x0F"/>
          <reg size="1" name="DDRB" offset="0x05" text="Data Direction Register, Port B" icon="io_flag.bmp" mask="0x0F"/>
          <reg size="1" name="PINB" offset="0x04" text="Port B Data register" icon="io_port.bmp" mask="0x0F"/>
          <reg size="1" name="PORTB" offset="0x06" text="Input Pins, Port B" icon="io_port.bmp" mask="0x0F"/>
        </registers>
      </module>
      <module class="WATCHDOG" text="">
        <registers name="WATCHDOG" memspace="DATAMEM" text="" icon="io_watch.bmp">
          <reg size="1" name="WDTCSR" offset="0x31" text="Watchdog Timer Control and Status Register" icon="io_flag.bmp">
            <bitfield name="WDIF" mask="0x80" text="Watchdog Timer Interrupt Flag" icon=""/>
            <bitfield name="WDIE" mask="0x40" text="Watchdog Timer Interrupt Enable" icon=""/>
            <bitfield name="WDP" mask="0x27" text="Watchdog Timer Prescaler Bits" icon="" enum="WDOG_TIMER_PRESCALE_4BITS"/>
            <bitfield name="WDE" mask="0x08" text="Watch Dog Enable" icon=""/>
          </reg>
        </registers>
        <enumerator name="WDOG_TIMER_PRESCALE_4BITS">
          <enum val="0x00" text="Oscillator Cycles 2K"/>
          <enum val="0x01" text="Oscillator Cycles 4K"/>
          <enum val="0x02" text="Oscillator Cycles 8K"/>
          <enum val="0x03" text="Oscillator Cycles 16K"/>
          <enum val="0x04" text="Oscillator Cycles 32K"/>
          <enum val="0x05" text="Oscillator Cycles 64K"/>
          <enum val="0x06" text="Oscillator Cycles 128K"/>
          <enum val="0x07" text="Oscillator Cycles 256K"/>
          <enum val="0x08" text="Oscillator Cycles 512K"/>
          <enum val="0x09" text="Oscillator Cycles 1024K"/>
        </enumerator>
      </module>
      <module class="AD_CONVERTER" text="">
        <registers name="AD_CONVERTER" memspace="DATAMEM" text="" icon="io_analo.bmp">
          <reg size="1" name="ADMUX" offset="0x10" text="The ADC multiplexer Selection Register" icon="io_analo.bmp">
            <bitfield name="REFS" mask="0x40" text="Reference Selection Bit" icon=""/>
            <bitfield name="MUX" mask="0x0F" text="Analog Channel and Gain Selection Bits" icon=""/>
          </reg>
          <reg size="1" name="ADCSRA" offset="0x12" text="The ADC Control and Status register" icon="io_flag.bmp">
            <bitfield name="ADEN" mask="0x80" text="ADC Enable" icon=""/>
            <bitfield name="ADSC" mask="0x40" text="ADC Start Conversion" icon=""/>
            <bitfield name="ADATE" mask="0x20" text="ADC Auto Trigger Enable" icon=""/>
            <bitfield name="ADIF" mask="0x10" text="ADC Interrupt Flag" icon=""/>
            <bitfield name="ADIE" mask="0x08" text="ADC Interrupt Enable" icon=""/>
            <bitfield name="ADPS" mask="0x07" text="ADC Prescaler Select Bits" icon="" enum="ANALIG_ADC_PRESCALER"/>
          </reg>
          <reg size="2" name="ADC" offset="0x0E" text="ADC Data Register  Bytes" icon="io_analo.bmp" mask="0xFFFF"/>
          <reg size="1" name="ADCSRB" offset="0x11" text="ADC Control and Status Register B" icon="io_analo.bmp">
            <bitfield name="ADLAR" mask="0x08" text="" icon=""/>
            <bitfield name="ADTS" mask="0x07" text="ADC Auto Trigger Sources" icon="" enum="ANALIG_ADC_AUTO_TRIGGER3"/>
          </reg>
          <reg size="1" name="DIDR0" offset="0x0D" text="Digital Input Disable Register 0" icon="io_analo.bmp">
            <bitfield name="ADC7D" mask="0x80" text="ADC6 Digital input Disable" icon=""/>
            <bitfield name="ADC6D" mask="0x40" text="ADC5 Digital input Disable" icon=""/>
            <bitfield name="ADC5D" mask="0x20" text="ADC4 Digital input Disable" icon=""/>
            <bitfield name="ADC4D" mask="0x10" text="ADC3 Digital input Disable" icon=""/>
            <bitfield name="ADC3D" mask="0x08" text="AREF Digital Input Disable" icon=""/>
            <bitfield name="ADC2D" mask="0x04" text="ADC2 Digital input Disable" icon=""/>
            <bitfield name="ADC1D" mask="0x02" text="ADC1 Digital input Disable" icon=""/>
            <bitfield name="ADC0D" mask="0x01" text="ADC0 Digital input Disable" icon=""/>
          </reg>
        </registers>
        <enumerator name="ANALIG_ADC_PRESCALER">
          <enum val="0x00" text="2"/>
          <enum val="0x01" text="2"/>
          <enum val="0x02" text="4"/>
          <enum val="0x03" text="8"/>
          <enum val="0x04" text="16"/>
          <enum val="0x05" text="32"/>
          <enum val="0x06" text="64"/>
          <enum val="0x07" text="128"/>
        </enumerator>
        <enumerator name="ANALIG_ADC_AUTO_TRIGGER3">
          <enum val="0x00" text="Free Running mode"/>
          <enum val="0x01" text="Analog Comparator"/>
          <enum val="0x02" text="External Interrupt Request 0"/>
          <enum val="0x03" text="Timer/Counter0 Compare Match A"/>
          <enum val="0x04" text="Timer/Counter0 Overflow"/>
          <enum val="0x05" text="Timer/Counter1 Compare Match B"/>
          <enum val="0x06" text="Timer/Counter1 Overflow"/>
          <enum val="0x07" text="Watchdog Interrupt Request"/>
        </enumerator>
      </module>
      <module class="ANALOG_COMPARATOR" text="">
        <registers name="ANALOG_COMPARATOR" memspace="DATAMEM" text="" icon="io_analo.bmp">
          <reg size="1" name="ACSRB" offset="0x13" text="Analog Comparator Control And Status Register B" icon="io_analo.bmp">
            <bitfield name="HSEL" mask="0x80" text="Hysteresis Select" icon=""/>
            <bitfield name="HLEV" mask="0x40" text="Hysteresis Level" icon=""/>
            <bitfield name="ACME" mask="0x04" text="Analog Comparator Multiplexer Enable" icon=""/>
          </reg>
          <reg size="1" name="ACSRA" offset="0x14" text="Analog Comparator Control And Status Register A" icon="io_analo.bmp">
            <bitfield name="ACD" mask="0x80" text="Analog Comparator Disable" icon=""/>
            <bitfield name="ACBG" mask="0x40" text="Analog Comparator Bandgap Select" icon=""/>
            <bitfield name="ACO" mask="0x20" text="Analog Compare Output" icon=""/>
            <bitfield name="ACI" mask="0x10" text="Analog Comparator Interrupt Flag" icon=""/>
            <bitfield name="ACIE" mask="0x08" text="Analog Comparator Interrupt Enable" icon=""/>
            <bitfield name="ACIC" mask="0x04" text="Analog Comparator Input Capture Enable" icon=""/>
            <bitfield name="ACIS" mask="0x03" text="Analog Comparator Interrupt Mode Select bits" icon="" enum="ANALOG_COMP_INTERRUPT"/>
          </reg>
        </registers>
        <enumerator name="ANALOG_COMP_INTERRUPT">
          <enum val="0x00" text="Interrupt on Toggle"/>
          <enum val="0x01" text="Reserved"/>
          <enum val="0x02" text="Interrupt on Falling Edge"/>
          <enum val="0x03" text="Interrupt on Rising Edge"/>
        </enumerator>
      </module>
      <module class="CPU" text="">
        <registers name="CPU" memspace="DATAMEM" text="" icon="io_cpu.bmp">
          <reg size="1" name="CCP" offset="0x3C" text="Configuration Change Protection" icon="io_sph.bmp" mask="0xFF"/>
          <reg size="2" name="SP" offset="0x3D" text="Stack Pointer " icon="io_sph.bmp" mask="0xFFFF"/>
          <reg size="1" name="SREG" offset="0x3F" text="Status Register" icon="io_sreg.bmp">
            <bitfield name="I" mask="0x80" text="Global Interrupt Enable" icon=""/>
            <bitfield name="T" mask="0x40" text="Bit Copy Storage" icon=""/>
            <bitfield name="H" mask="0x20" text="Half Carry Flag" icon=""/>
            <bitfield name="S" mask="0x10" text="Sign Bit" icon=""/>
            <bitfield name="V" mask="0x08" text="Two's Complement Overflow Flag" icon=""/>
            <bitfield name="N" mask="0x04" text="Negative Flag" icon=""/>
            <bitfield name="Z" mask="0x02" text="Zero Flag" icon=""/>
            <bitfield name="C" mask="0x01" text="Carry Flag" icon=""/>
          </reg>
          <reg size="1" name="CLKMSR" offset="0x37" text="Clock Main Settings Register" icon="io_flag.bmp">
            <bitfield name="CLKMS" mask="0x03" text="Clock Main Select Bits" icon=""/>
          </reg>
          <reg size="1" name="CLKPSR" offset="0x36" text="Clock Prescale Register" icon="io_flag.bmp">
            <bitfield name="CLKPS" mask="0x0F" text="Clock Prescaler Select Bits" icon="" enum="CPU_CLK_PRESCALE_4_BITS_SMALL"/>
          </reg>
          <reg size="1" name="OSCCAL" offset="0x39" text="Oscillator Calibration Value" icon="io_cpu.bmp" mask="0xFF"/>
          <reg size="1" name="PRR" offset="0x35" text="Power Reduction Register" icon="io_cpu.bmp">
            <bitfield name="PRTWI" mask="0x10" text="Power Reduction TWI" icon=""/>
            <bitfield name="PRSPI" mask="0x08" text="Power Reduction Serial Peripheral Interface" icon=""/>
            <bitfield name="PRTIM1" mask="0x04" text="Power Reduction Timer/Counter1" icon=""/>
            <bitfield name="PRTIM0" mask="0x02" text="Power Reduction Timer/Counter0" icon=""/>
            <bitfield name="PRADC" mask="0x01" text="Power Reduction ADC" icon=""/>
          </reg>
          <reg size="1" name="RSTFLR" offset="0x3B" text="Reset Flag Register" icon="io_cpu.bmp">
            <bitfield name="WDRF" mask="0x08" text="Watchdog Reset Flag" icon=""/>
            <bitfield name="EXTRF" mask="0x02" text="External Reset Flag" icon=""/>
            <bitfield name="PORF" mask="0x01" text="Power-on Reset Flag" icon=""/>
          </reg>
          <reg size="1" name="NVMCSR" offset="0x32" text="Non-Volatile Memory Control and Status Register" icon="io_cpu.bmp">
            <bitfield name="NVMBSY" mask="0x80" text="Non-Volatile Memory Busy" icon=""/>
          </reg>
          <reg size="1" name="NVMCMD" offset="0x33" text="Non-Volatile Memory Command" icon="io_cpu.bmp" mask="0x3F"/>
          <reg size="1" name="MCUCR" offset="0x3A" text="MCU Control Register" icon="io_cpu.bmp" mask="0xDF"/>
        </registers>
        <enumerator name="CPU_CLK_PRESCALE_4_BITS_SMALL">
          <enum val="0x00" text="1"/>
          <enum val="0x01" text="2"/>
          <enum val="0x02" text="4"/>
          <enum val="0x03" text="8"/>
          <enum val="0x04" text="16"/>
          <enum val="0x05" text="32"/>
          <enum val="0x06" text="64"/>
          <enum val="0x07" text="128"/>
          <enum val="0x08" text="256"/>
        </enumerator>
      </module>
      <module class="EXTERNAL_INTERRUPT" text="">
        <registers name="EXTERNAL_INTERRUPT" memspace="DATAMEM" text="" icon="io_ext.bmp">
          <reg size="1" name="PCMSK1" offset="0x0A" text="Pin Change Mask Register 1" icon="io_flag.bmp">
            <bitfield name="PCINT" mask="0x0F" text="Pin Change Enable Masks" icon="" lsb="8"/>
          </reg>
          <reg size="1" name="PCMSK0" offset="0x09" text="Pin Change Mask Register 0" icon="io_flag.bmp">
            <bitfield name="PCINT" mask="0xFF" text="Pin Change Enable Masks" icon=""/>
          </reg>
          <reg size="1" name="GIFR" offset="0x0B" text="General Interrupt Flag Register" icon="io_flag.bmp">
            <bitfield name="PCIF" mask="0x30" text="Pin Change Interrupt Flags" icon=""/>
            <bitfield name="INTF0" mask="0x01" text="External Interrupt Flag 0" icon=""/>
          </reg>
          <reg size="1" name="GIMSK" offset="0x0C" text="General Interrupt Mask Register" icon="io_flag.bmp">
            <bitfield name="PCIE" mask="0x30" text="Pin Change Interrupt Enables" icon=""/>
            <bitfield name="INT0" mask="0x01" text="External Interrupt Request 0 Enable" icon=""/>
          </reg>
        </registers>
      </module>
      <module class="TIMER_COUNTER_0" text="">
        <registers name="TIMER_COUNTER_0" memspace="DATAMEM" text="" icon="io_timer.bmp">
          <reg size="1" name="TCCR0A" offset="0x19" text="Timer/Counter 0 Control Register A" icon="io_flag.bmp">
            <bitfield name="COM0A" mask="0xC0" text="Compare Output Mode for Channel A bits" icon=""/>
            <bitfield name="COM0B" mask="0x30" text="Compare Output Mode for Channel B bits" icon=""/>
            <bitfield name="WGM0" mask="0x03" text="Waveform Generation Mode" icon=""/>
          </reg>
          <reg size="1" name="TCCR0B" offset="0x18" text="Timer/Counter 0 Control Register B" icon="io_flag.bmp">
            <bitfield name="FOC0A" mask="0x80" text="Force Output Compare A" icon=""/>
            <bitfield name="FOC0B" mask="0x40" text="Force Output Compare B" icon=""/>
            <bitfield name="WGM02" mask="0x08" text="Waveform Generation Mode" icon=""/>
            <bitfield name="CS0" mask="0x07" text="Clock Select" icon="" enum="CLK_SEL_3BIT_EXT"/>
          </reg>
          <reg size="1" name="TIMSK" offset="0x26" text="Timer Interrupt Mask Register" icon="io_flag.bmp">
            <bitfield name="ICIE1" mask="0x80" text="Input Capture Interrupt Enable" icon=""/>
            <bitfield name="OCIE1B" mask="0x20" text="Output Compare B Match Interrupt Enable" icon=""/>
            <bitfield name="OCIE1A" mask="0x10" text="Output Compare A Match Interrupt Enable" icon=""/>
            <bitfield name="TOIE" mask="0x09" text="Overflow Interrupt Enable" icon=""/>
            <bitfield name="OCIE0B" mask="0x04" text="Timer/Counter Output Compare Match B Interrupt Enable" icon=""/>
            <bitfield name="OCIE0A" mask="0x02" text="Timer/Counter0 Output Compare Match A Interrupt Enable" icon=""/>
          </reg>
          <reg size="1" name="TIFR" offset="0x25" text="Overflow Interrupt Enable" icon="io_flag.bmp">
            <bitfield name="ICF1" mask="0x80" text="Input Capture Flag" icon=""/>
            <bitfield name="OCF1B" mask="0x20" text="Timer Output Compare Flag 1B" icon=""/>
            <bitfield name="OCF1A" mask="0x10" text="Timer Output Compare Flag 1A" icon=""/>
            <bitfield name="TOV" mask="0x09" text="Timer Overflow Flag" icon=""/>
            <bitfield name="OCF0B" mask="0x04" text="Output Compare Flag 0 B" icon=""/>
            <bitfield name="OCF0A" mask="0x02" text="Output Compare Flag 0 A" icon=""/>
          </reg>
          <reg size="1" name="GTCCR" offset="0x27" text="General Timer/Counter Control Register" icon="io_flag.bmp">
            <bitfield name="TSM" mask="0x80" text="Timer Synchronization Mode" icon=""/>
            <bitfield name="PSR" mask="0x01" text="Prescaler Reset" icon=""/>
          </reg>
          <reg size="1" name="TCNT0" offset="0x17" text="Timer/Counter0" icon="io_timer.bmp" mask="0xFF"/>
          <reg size="1" name="OCR0A" offset="0x16" text="Timer/Counter0 Output Compare Register" icon="io_timer.bmp" mask="0xFF"/>
          <reg size="1" name="OCR0B" offset="0x15" text="Timer/Counter0 Output Compare Register" icon="io_timer.bmp" mask="0xFF"/>
        </registers>
        <enumerator name="CLK_SEL_3BIT_EXT">
          <enum val="0x00" text="No Clock Source (Stopped)"/>
          <enum val="0x01" text="Running, No Prescaling"/>
          <enum val="0x02" text="Running, CLK/8"/>
          <enum val="0x03" text="Running, CLK/64"/>
          <enum val="0x04" text="Running, CLK/256"/>
          <enum val="0x05" text="Running, CLK/1024"/>
          <enum val="0x06" text="Running, ExtClk Tx Falling Edge"/>
          <enum val="0x07" text="Running, ExtClk Tx Rising Edge"/>
        </enumerator>
      </module>
      <module class="TWI" text="">
        <registers name="TWI" memspace="DATAMEM" text="" icon="io_com.bmp">
          <reg size="1" name="TWSCRA" offset="0x2D" text="TWI Slave Control Register A" icon="io_com.bmp">
            <bitfield name="TWSHE" mask="0x80" text="TWI SDA Hold Time Enable" icon=""/>
            <bitfield name="TWDIE" mask="0x20" text="TWI Data Interrupt Enable" icon=""/>
            <bitfield name="TWASIE" mask="0x10" text="TWI Address/Stop Interrupt Enable" icon=""/>
            <bitfield name="TWEN" mask="0x08" text="Two-Wire Interface Enable" icon=""/>
            <bitfield name="TWSIE" mask="0x04" text="TWI Stop Interrupt Enable" icon=""/>
            <bitfield name="TWPME" mask="0x02" text="TWI Promiscuous Mode Enable" icon=""/>
            <bitfield name="TWSME" mask="0x01" text="TWI Smart Mode Enable" icon=""/>
          </reg>
          <reg size="1" name="TWSCRB" offset="0x2C" text="TWI Slave Control Register B" icon="io_com.bmp">
            <bitfield name="TWAA" mask="0x04" text="TWI Acknowledge Action" icon=""/>
            <bitfield name="TWCMD" mask="0x03" text="" icon=""/>
          </reg>
          <reg size="1" name="TWSSRA" offset="0x2B" text="TWI Slave Status Register A" icon="io_com.bmp" mask="0xFF"/>
          <reg size="1" name="TWSA" offset="0x2A" text="TWI Slave Address Register" icon="io_flag.bmp">
            <bitfield name="TWSA" mask="0xFF" text="TWI slave address bit" icon=""/>
          </reg>
          <reg size="1" name="TWSD" offset="0x28" text="TWI Slave Data Register" icon="io_flag.bmp">
            <bitfield name="TWSD" mask="0xFF" text="TWI slave data bit" icon=""/>
          </reg>
          <reg size="1" name="TWSAM" offset="0x29" text="TWI Slave Address Mask Register" icon="io_com.bmp" mask="0xFF"/>
        </registers>
      </module>
      <module class="PORTA" text="">
        <registers name="PORTA" memspace="IOMEM" text="" icon="io_port.bmp">
          <reg size="1" name="PORTCR" offset="0x08" text="Port Control Register" icon="io_flag.bmp">
            <bitfield name="BBMA" mask="0x01" text="Break-Before-Make Mode Enable" icon=""/>
          </reg>
          <reg size="1" name="PUEA" offset="0x03" text="Pull-up Enable Control Register" icon="io_flag.bmp" mask="0xFF"/>
          <reg size="1" name="PORTA" offset="0x02" text="Port A Data Register" icon="io_port.bmp" mask="0xFF"/>
          <reg size="1" name="DDRA" offset="0x01" text="Data Direction Register, Port A" icon="io_flag.bmp" mask="0xFF"/>
          <reg size="1" name="PINA" offset="0x00" text="Port A Input Pins" icon="io_port.bmp" mask="0xFF"/>
        </registers>
      </module>
      <module class="TIMER_COUNTER_1" text="">
        <registers name="TIMER_COUNTER_1" memspace="DATAMEM" text="" icon="io_timer.bmp">
          <reg size="1" name="TCCR1A" offset="0x24" text="Timer/Counter1 Control Register A" icon="io_flag.bmp">
            <bitfield name="COM1A" mask="0xC0" text="Compare Output Mode 1A, bits" icon=""/>
            <bitfield name="COM1B" mask="0x30" text="Compare Output Mode 1B, bits" icon=""/>
            <bitfield name="WGM1" mask="0x03" text="Waveform Generation Mode Bits" icon=""/>
          </reg>
          <reg size="1" name="TCCR1B" offset="0x23" text="Timer/Counter1 Control Register B" icon="io_flag.bmp">
            <bitfield name="ICNC1" mask="0x80" text="Input Capture 1 Noise Canceler" icon=""/>
            <bitfield name="ICES1" mask="0x40" text="Input Capture 1 Edge Select" icon=""/>
            <bitfield name="WGM1" mask="0x18" text="Waveform Generation Mode" icon="" lsb="2"/>
            <bitfield name="CS1" mask="0x07" text="Clock Select1 bits" icon="" enum="CLK_SEL_3BIT_EXT"/>
          </reg>
          <reg size="1" name="TCCR1C" offset="0x22" text="Timer/Counter1 Control Register C" icon="io_flag.bmp">
            <bitfield name="FOC1A" mask="0x80" text="Force Output Compare for channel A" icon=""/>
            <bitfield name="FOC1B" mask="0x40" text="Force Output Compare for channel B" icon=""/>
          </reg>
          <reg size="2" name="TCNT1" offset="0x20" text="Timer/Counter1 " icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="2" name="OCR1A" offset="0x1E" text="Timer/Counter 1 Output Compare Register A " icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="2" name="OCR1B" offset="0x1C" text="Timer/Counter1 Output Compare Register B " icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="2" name="ICR1" offset="0x1A" text="Input Capture Register  Bytes" icon="io_timer.bmp" mask="0xFFFF"/>
          <reg size="1" name="TIMSK" offset="0x26" text="Timer Interrupt Mask Register" icon="io_flag.bmp">
            <bitfield name="ICIE1" mask="0x80" text="Input Capture Interrupt Enable" icon=""/>
            <bitfield name="OCIE1B" mask="0x20" text="Output Compare B Match Interrupt Enable" icon=""/>
            <bitfield name="OCIE1A" mask="0x10" text="Output Compare A Match Interrupt Enable" icon=""/>
            <bitfield name="TOIE" mask="0x09" text="Overflow Interrupt Enable" icon=""/>
            <bitfield name="OCIE0B" mask="0x04" text="Timer/Counter Output Compare Match B Interrupt Enable" icon=""/>
            <bitfield name="OCIE0A" mask="0x02" text="Timer/Counter0 Output Compare Match A Interrupt Enable" icon=""/>
          </reg>
          <reg size="1" name="TIFR" offset="0x25" text="Overflow Interrupt Enable" icon="io_flag.bmp">
            <bitfield name="ICF1" mask="0x80" text="Input Capture Flag" icon=""/>
            <bitfield name="OCF1B" mask="0x20" text="Timer Output Compare Flag 1B" icon=""/>
            <bitfield name="OCF1A" mask="0x10" text="Timer Output Compare Flag 1A" icon=""/>
            <bitfield name="TOV" mask="0x09" text="Timer Overflow Flag" icon=""/>
            <bitfield name="OCF0B" mask="0x04" text="Output Compare Flag 0 B" icon=""/>
            <bitfield name="OCF0A" mask="0x02" text="Output Compare Flag 0 A" icon=""/>
          </reg>
          <reg size="1" name="GTCCR" offset="0x27" text="General Timer/Counter Control Register" icon="io_flag.bmp">
            <bitfield name="TSM" mask="0x80" text="Timer Synchronization Mode" icon=""/>
            <bitfield name="PSR" mask="0x01" text="Prescaler Reset" icon=""/>
          </reg>
        </registers>
        <enumerator name="CLK_SEL_3BIT_EXT">
          <enum val="0x00" text="No Clock Source (Stopped)"/>
          <enum val="0x01" text="Running, No Prescaling"/>
          <enum val="0x02" text="Running, CLK/8"/>
          <enum val="0x03" text="Running, CLK/64"/>
          <enum val="0x04" text="Running, CLK/256"/>
          <enum val="0x05" text="Running, CLK/1024"/>
          <enum val="0x06" text="Running, ExtClk Tx Falling Edge"/>
          <enum val="0x07" text="Running, ExtClk Tx Rising Edge"/>
        </enumerator>
      </module>
      <module class="SPI" text="">
        <registers name="SPI" memspace="DATAMEM" text="" icon="io_com.bmp">
          <reg size="1" name="SPCR" offset="0x30" text="SPI Control Register" icon="io_flag.bmp">
            <bitfield name="SPIE" mask="0x80" text="SPI Interrupt Enable" icon=""/>
            <bitfield name="SPE" mask="0x40" text="SPI Enable" icon=""/>
            <bitfield name="DORD" mask="0x20" text="Data Order" icon=""/>
            <bitfield name="MSTR" mask="0x10" text="Master/Slave Select" icon=""/>
            <bitfield name="CPOL" mask="0x08" text="Clock polarity" icon=""/>
            <bitfield name="CPHA" mask="0x04" text="Clock Phase" icon=""/>
            <bitfield name="SPR" mask="0x03" text="SPI Clock Rate Selects" icon="" enum="COMM_SCK_RATE"/>
          </reg>
          <reg size="1" name="SPSR" offset="0x2F" text="SPI Status Register" icon="io_flag.bmp">
            <bitfield name="SPIF" mask="0x80" text="SPI Interrupt Flag" icon=""/>
            <bitfield name="WCOL" mask="0x40" text="Write Collision Flag" icon=""/>
            <bitfield name="SPI2X" mask="0x01" text="Double SPI Speed Bit" icon=""/>
          </reg>
          <reg size="1" name="SPDR" offset="0x2E" text="SPI Data Register" icon="io_com.bmp" mask="0xFF"/>
        </registers>
        <enumerator name="COMM_SCK_RATE">
          <enum val="0x00" text="fcl/4"/>
          <enum val="0x01" text="fcl/16"/>
          <enum val="0x02" text="fcl/64"/>
          <enum val="0x03" text="fcl/128"/>
        </enumerator>
      </module>
    </templates>
    <modules>
      <module implements="PORTB" name="PORTB">
        <registers implements="PORTB" name="PORTB" offset="0x00" text=""/>
      </module>
      <module implements="WATCHDOG" name="WATCHDOG">
        <registers implements="WATCHDOG" name="WATCHDOG" offset="0x00" text=""/>
      </module>
      <module implements="AD_CONVERTER" name="AD_CONVERTER">
        <registers implements="AD_CONVERTER" name="AD_CONVERTER" offset="0x00" text=""/>
      </module>
      <module implements="ANALOG_COMPARATOR" name="ANALOG_COMPARATOR">
        <registers implements="ANALOG_COMPARATOR" name="ANALOG_COMPARATOR" offset="0x00" text=""/>
      </module>
      <module implements="CPU" name="CPU">
        <registers implements="CPU" name="CPU" offset="0x00" text=""/>
      </module>
      <module implements="EXTERNAL_INTERRUPT" name="EXTERNAL_INTERRUPT">
        <registers implements="EXTERNAL_INTERRUPT" name="EXTERNAL_INTERRUPT" offset="0x00" text=""/>
      </module>
      <module implements="TIMER_COUNTER_0" name="TIMER_COUNTER_0">
        <registers implements="TIMER_COUNTER_0" name="TIMER_COUNTER_0" offset="0x00" text=""/>
      </module>
      <module implements="TWI" name="TWI">
        <registers implements="TWI" name="TWI" offset="0x00" text=""/>
      </module>
      <module implements="PORTA" name="PORTA">
        <registers implements="PORTA" name="PORTA" offset="0x00" text=""/>
      </module>
      <module implements="TIMER_COUNTER_1" name="TIMER_COUNTER_1">
        <registers implements="TIMER_COUNTER_1" name="TIMER_COUNTER_1" offset="0x00" text=""/>
      </module>
      <module implements="SPI" name="SPI">
        <registers implements="SPI" name="SPI" offset="0x00" text=""/>
      </module>
    </modules>
    <fuses>
      <fuse implements="FUSE" name="FUSE">
        <registers implements="FUSE" name="FUSE"/>
      </fuse>
    </fuses>
    <lockbits>
      <lockbit implements="LOCKBIT" name="LOCKBIT">
        <registers implements="LOCKBIT" name="LOCKBIT"/>
      </lockbit>
    </lockbits>
  </V2>
</AVRPART>
